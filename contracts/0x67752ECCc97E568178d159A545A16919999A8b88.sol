contract main {




// =====================  Runtime code  =====================


#
#  - sub_3ede50c6(?)
#  - beforeTokenTransfer(address arg1, address arg2, uint256 arg3)
#  - withdrawInstantlyFrom(address arg1, uint256 arg2, address arg3, uint256 arg4)
#  - sub_cfa24007(?)
#
const VERSION = ''


array of address stor1;
address owner;
uint256 stor101;
address reserveRegistryAddress;
array of struct stor152;
address prizeStrategyAddress;
uint256 maxExitFeeMantissa;
uint256 reserveTotalSupply;
uint256 liquidityCap;
uint256 awardBalance;
mapping of struct creditPlanOf;
mapping of struct stor159;
address yieldSourceAddress;
uint256 stor160;

function awardBalance() payable {
    return awardBalance
}

function liquidityCap() payable {
    return liquidityCap
}

function owner() payable {
    return owner
}

function reserveRegistry() payable {
    return reserveRegistryAddress
}

function prizeStrategy() payable {
    return prizeStrategyAddress
}

function maxExitFeeMantissa() payable {
    return maxExitFeeMantissa
}

function yieldSource() payable {
    return address(yieldSourceAddress)
}

function creditPlanOf(address arg1) payable {
    require calldata.size - 4 >= 32
    return creditPlanOf[address(arg1)].field_0, creditPlanOf[address(arg1)].field_128
}

function reserveTotalSupply() payable {
    return reserveTotalSupply
}

function _fallback() payable {
    revert
}

function canAwardExternal(address arg1) payable {
    require calldata.size - 4 >= 32
    return arg1 != address(yieldSourceAddress)
}

function renounceOwnership() payable {
    if owner != msg.sender:
        revert with 0, 'wOwnable: caller is not the owne'
    emit OwnershipTransferred(owner, 0);
    owner = 0
}

function setLiquidityCap(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'wOwnable: caller is not the owne'
    liquidityCap = arg1
    emit LiquidityCapSet(arg1);
}

function token() payable {
    require ext_code.size(address(yieldSourceAddress))
    staticcall address(yieldSourceAddress).0xc89039c5 with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    return ext_call.return_data[12 len 20]
}

function balance() payable {
    require ext_code.size(address(yieldSourceAddress))
    call address(yieldSourceAddress).0xb99152d0 with:
         gas gas_remaining wei
        args this.address
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    return ext_call.return_data[0]
}

function transferOwnership(address arg1) payable {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'wOwnable: caller is not the owne'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    38,
                    0x654f776e61626c653a206e6577206f776e657220697320746865207a65726f20616464726573,
                    mem[202 len 26]
    emit OwnershipTransferred(owner, arg1);
    owner = arg1
}

function sub_78b3d327(?) payable {
    require calldata.size - 4 >= 32
    if stor152.length:
        mem[128] = address(stor152.field_0)
        idx = 128
        s = 0
        while (32 * stor152.length) + 96 > idx:
            mem[idx + 32] = stor152[s].field_256
            idx = idx + 32
            s = s + 1
            continue 
    idx = 0
    while idx < stor152.length:
        require idx < stor152.length
        if mem[(32 * idx) + 140 len 20] != arg1:
            idx = idx + 1
            continue 
        return 1
    return 0
}

function sub_2f7627e3(?) payable {
    require calldata.size - 4 >= 64
    if owner != msg.sender:
        revert with 0, 'wOwnable: caller is not the owne'
    require ext_code.size(arg1)
    staticcall arg1.0x70a08231 with:
            gas gas_remaining wei
           args this.address
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if ext_call.return_data[0] > 0:
        require ext_code.size(arg1)
        call arg1.delegate(address arg1) with:
             gas gas_remaining wei
            args arg2
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
}

function setCreditPlanOf(address arg1, uint128 arg2, uint128 arg3) payable {
    require calldata.size - 4 >= 96
    if stor152.length:
        mem[128] = address(stor152.field_0)
        idx = 128
        s = 0
        while (32 * stor152.length) + 96 > idx:
            mem[idx + 32] = stor152[s].field_256
            idx = idx + 32
            s = s + 1
            continue 
    idx = 0
    while idx < stor152.length:
        require idx < stor152.length
        if mem[(32 * idx) + 140 len 20] != arg1:
            idx = idx + 1
            continue 
        if owner != msg.sender:
            revert with 0, 'wOwnable: caller is not the owne'
        creditPlanOf[address(arg1)].field_0 = arg3
        creditPlanOf[address(arg1)].field_128 = arg2
        emit CreditPlanSet(address(arg1), arg3 << 128, arg2);
    revert with 0, 'mPrizePool/unknown-token'
}

function tokens() payable {
    if not stor152.length:
        mem[(32 * stor152.length) + 128] = 32
        mem[(32 * stor152.length) + 160] = stor152.length
        mem[(32 * stor152.length) + 192 len floor32(stor152.length)] = mem[128 len floor32(stor152.length)]
        return memory
          from (32 * stor152.length) + 128
           len (96 * stor152.length) + 64
    mem[128] = address(stor152.field_0)
    idx = 128
    s = 0
    while (32 * stor152.length) + 96 > idx:
        mem[idx + 32] = stor152[s].field_256
        idx = idx + 32
        s = s + 1
        continue 
    mem[(32 * stor152.length) + 192 len floor32(stor152.length)] = mem[128 len floor32(stor152.length)]
    return Array(len=stor152.length, data=mem[128 len floor32(stor152.length)], mem[(32 * stor152.length) + floor32(stor152.length) + 192 len (32 * stor152.length) - floor32(stor152.length)]), 
}

function estimateCreditAccrualTime(address arg1, uint256 arg2, uint256 arg3) payable {
    require calldata.size - 4 >= 96
    if not creditPlanOf[address(arg1)].field_128:
        return 0
    if arg2 * creditPlanOf[address(arg1)].field_128 / creditPlanOf[address(arg1)].field_128 != arg2:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    33,
                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                    mem[197 len 31]
    if not arg2 * creditPlanOf[address(arg1)].field_128 / 10^18:
        return 0
    if arg2 * creditPlanOf[address(arg1)].field_128 / 10^18 <= 0:
        revert with 0, 'SafeMath: division by zero'
    require arg2 * creditPlanOf[address(arg1)].field_128 / 10^18
    return (arg3 / arg2 * creditPlanOf[address(arg1)].field_128 / 10^18)
}

function calculateReserveFee(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    require ext_code.size(reserveRegistryAddress)
    staticcall reserveRegistryAddress.0xf5e3542b with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if not ext_call.return_data[12 len 20]:
        return 0
    require ext_code.size(address(ext_call.return_data[0]))
    staticcall address(ext_call.return_data[0]).reserveRateMantissa(address arg1) with:
            gas gas_remaining wei
           args this.address
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if not ext_call.return_data[0]:
        return 0
    if arg1 * ext_call.return_data[0] / ext_call.return_data[0] != arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    33,
                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                    mem[197 len 31]
    return (arg1 * ext_call.return_data[0] / 10^18)
}

function accountedBalance() payable {
    if not stor152.length:
        idx = 0
        s = reserveTotalSupply
        while idx < stor152.length:
            require idx < stor152.length
            require ext_code.size(mem[(32 * idx) + 140 len 20])
            staticcall mem[(32 * idx) + 140 len 20].0x18160ddd with:
                    gas gas_remaining wei
            mem[(32 * stor152.length) + 128] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if ext_call.return_data[0] + s < s:
                revert with 0, 'SafeMath: addition overflow'
            idx = idx + 1
            s = ext_call.return_data[0] + s
            continue 
        return (reserveTotalSupply + (_21 * stor152.length))
    mem[128] = address(stor152.field_0)
    idx = 128
    s = 0
    while (32 * stor152.length) + 96 > idx:
        mem[idx + 32] = stor152[s].field_256
        idx = idx + 32
        s = s + 1
        continue 
    idx = 0
    s = reserveTotalSupply
    while idx < stor152.length:
        require idx < stor152.length
        require ext_code.size(mem[(32 * idx) + 140 len 20])
        staticcall mem[(32 * idx) + 140 len 20].0x18160ddd with:
                gas gas_remaining wei
        mem[(32 * stor152.length) + 128] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        _42 = ext_call.return_data[0]
        if ext_call.return_data[0] + s < s:
            revert with 0, 'SafeMath: addition overflow'
        idx = idx + 1
        s = ext_call.return_data[0] + s
        continue 
    return (reserveTotalSupply + (_42 * stor152.length))
}

function awardExternalERC20(address arg1, address arg2, uint256 arg3) payable {
    require calldata.size - 4 >= 96
    if prizeStrategyAddress != msg.sender:
        revert with 0, 'PrizePool/only-prizeStrategy'
    if arg2 == address(yieldSourceAddress):
        revert with 0, 'PrizePool/invalid-external-token'
    if arg3:
        if eth.balance(this.address) < 0:
            revert with 0, 32, 38, 0x6f416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[366 len 26]
        if not ext_code.size(arg2):
            revert with 0, 'Address: call to non-contract'
        mem[260 len 64] = unknown_0xa9059cbb(?????), address(arg1) << 64, 0, Mask(224, 32, arg3) >> 32
        mem[324 len 0] = 0
        call arg2 with:
             gas gas_remaining wei
            args Mask(224, 32, arg3) << 224, mem[324 len 4]
        if not return_data.size:
            if not ext_call.success:
                revert with unknown_0xa9059cbb(?????), address(arg1) << 64, 0, arg3
            if not unknown_0xa9059cbb(?????), address(arg1) << 64:
                revert with 0, 32, 42, 0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565, mem[370 len 22]
        else:
            mem[292 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if not ext_call.success:
                if return_data.size:
                    revert with ext_call.return_data[0 len return_data.size]
                revert with 0, 'SafeERC20: low-level call failed'
            if return_data.size:
                require return_data.size >= 32
                if not mem[292]:
                    revert with 0, 
                                32,
                                42,
                                0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                mem[ceil32(return_data.size) + 371 len 22]
        emit AwardedExternalERC20(arg3, arg1, arg2);
}

function transferExternalERC20(address arg1, address arg2, uint256 arg3) payable {
    require calldata.size - 4 >= 96
    if prizeStrategyAddress != msg.sender:
        revert with 0, 'PrizePool/only-prizeStrategy'
    if arg2 == address(yieldSourceAddress):
        revert with 0, 'PrizePool/invalid-external-token'
    if arg3:
        if eth.balance(this.address) < 0:
            revert with 0, 32, 38, 0x6f416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[366 len 26]
        if not ext_code.size(arg2):
            revert with 0, 'Address: call to non-contract'
        mem[260 len 64] = unknown_0xa9059cbb(?????), address(arg1) << 64, 0, Mask(224, 32, arg3) >> 32
        mem[324 len 0] = 0
        call arg2 with:
             gas gas_remaining wei
            args Mask(224, 32, arg3) << 224, mem[324 len 4]
        if not return_data.size:
            if not ext_call.success:
                revert with unknown_0xa9059cbb(?????), address(arg1) << 64, 0, arg3
            if not unknown_0xa9059cbb(?????), address(arg1) << 64:
                revert with 0, 32, 42, 0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565, mem[370 len 22]
        else:
            mem[292 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if not ext_call.success:
                if return_data.size:
                    revert with ext_call.return_data[0 len return_data.size]
                revert with 0, 'SafeERC20: low-level call failed'
            if return_data.size:
                require return_data.size >= 32
                if not mem[292]:
                    revert with 0, 
                                32,
                                42,
                                0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                mem[ceil32(return_data.size) + 371 len 22]
        emit TransferredExternalERC20(arg3, arg1, arg2);
}

function withdrawReserve(address arg1) payable {
    require calldata.size - 4 >= 32
    require ext_code.size(reserveRegistryAddress)
    staticcall reserveRegistryAddress.0xf5e3542b with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if ext_call.return_data[12 len 20] != msg.sender:
        revert with 0, 'PrizePool/only-reserve'
    reserveTotalSupply = 0
    require ext_code.size(address(yieldSourceAddress))
    call address(yieldSourceAddress).redeemToken(uint256 arg1) with:
         gas gas_remaining wei
        args reserveTotalSupply
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_code.size(address(yieldSourceAddress))
    staticcall address(yieldSourceAddress).0xc89039c5 with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if eth.balance(this.address) < 0:
        revert with 0, 32, 38, 0x6f416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[366 len 26]
    if not ext_code.size(address(ext_call.return_data[0])):
        revert with 0, 'Address: call to non-contract'
    mem[260 len 64] = unknown_0xa9059cbb(?????), address(arg1) << 64, 0, ext_call.return_data[0 len 28]
    mem[324 len 0] = 0
    call address(ext_call.return_data[0]) with:
         gas gas_remaining wei
        args Mask(480, -256, ext_call.return_data[0 len 28]) << 256, mem[324 len 4]
    if not return_data.size:
        if not ext_call.success:
            revert with unknown_0xa9059cbb(?????), address(arg1) << 64, 0, ext_call.return_data[0]
        if not unknown_0xa9059cbb(?????), address(arg1) << 64:
            revert with 0, 32, 42, 0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565, mem[370 len 22]
    else:
        mem[292 len return_data.size] = ext_call.return_data[0 len return_data.size]
        if not ext_call.success:
            if return_data.size:
                revert with ext_call.return_data[0 len return_data.size]
            revert with 0, 'SafeERC20: low-level call failed'
        if return_data.size:
            require return_data.size >= 32
            if not mem[292]:
                revert with 0, 
                            32,
                            42,
                            0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                            mem[ceil32(return_data.size) + 371 len 22]
    emit ReserveWithdrawal(reserveTotalSupply, arg1);
    return ext_call.return_data[0]
}

function setPrizeStrategy(address arg1) payable {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'wOwnable: caller is not the owne'
    if not arg1:
        revert with 0, 'PrizePool/prizeStrategy-not-zero'
    staticcall arg1 with:
         funct Mask(32, 224, supportsInterface(bytes4 arg1), 0x1ffc9a70000000000000000000000000000000000000000) >> 224
            gas 30000 wei
           args Mask(224, 0, supportsInterface(bytes4 arg1), 0x1ffc9a70000000000000000000000000000000000000000), mem[196 len 4]
    if not return_data.size:
        if not ext_call.success:
            revert with 0, 'PrizePool/prizeStrategy-invalid'
        if not supportsInterface(bytes4 arg1), 0x1ffc9a70000000000000000000000000000000000000000:
            revert with 0, 'PrizePool/prizeStrategy-invalid'
        staticcall arg1 with:
                gas 30000 wei
               args 0xffffffff000000000000000000000000000000000000000000000000, mem[264 len 4]
        if not return_data.size:
            if ext_call.success:
                if supportsInterface(bytes4 arg1), 0x1ffc9a70000000000000000000000000000000000000000:
                    revert with 0, 'PrizePool/prizeStrategy-invalid'
            staticcall arg1 with:
                 funct Mask(32, 224, supportsInterface(bytes4 arg1), 0xff5e34e70000000000000000000000000000000000000000) >> 224
                    gas 30000 wei
                   args Mask(224, 0, supportsInterface(bytes4 arg1), 0xff5e34e70000000000000000000000000000000000000000), mem[332 len 4]
            if not return_data.size:
                if not ext_call.success:
                    revert with 0, 'PrizePool/prizeStrategy-invalid'
                if not supportsInterface(bytes4 arg1), 0x1ffc9a70000000000000000000000000000000000000000:
                    revert with 0, 'PrizePool/prizeStrategy-invalid'
            else:
                mem[332 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if return_data.size < 32:
                    revert with 0, 'PrizePool/prizeStrategy-invalid'
                require return_data.size >= 32
                if not ext_call.success:
                    revert with 0, 'PrizePool/prizeStrategy-invalid'
                if not mem[332 len 28], Mask(32, 32, supportsInterface(bytes4 arg1), 0xff5e34e70000000000000000000000000000000000000000) >> 32:
                    revert with 0, 'PrizePool/prizeStrategy-invalid'
        else:
            mem[264 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if return_data.size >= 32:
                require return_data.size >= 32
                if ext_call.success:
                    if mem[264 len 28], 0:
                        revert with 0, 'PrizePool/prizeStrategy-invalid'
            staticcall arg1 with:
                 funct Mask(32, 224, supportsInterface(bytes4 arg1), 0xff5e34e70000000000000000000000000000000000000000) >> 224
                    gas 30000 wei
                   args Mask(224, 0, supportsInterface(bytes4 arg1), 0xff5e34e70000000000000000000000000000000000000000), mem[ceil32(return_data.size) + 333 len 4]
            if not return_data.size:
                if not ext_call.success:
                    revert with 0, 'PrizePool/prizeStrategy-invalid'
                if not supportsInterface(bytes4 arg1), 0x1ffc9a70000000000000000000000000000000000000000:
                    revert with 0, 'PrizePool/prizeStrategy-invalid'
            else:
                mem[ceil32(return_data.size) + 333 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if return_data.size < 32:
                    revert with 0, 'PrizePool/prizeStrategy-invalid'
                require return_data.size >= 32
                if not ext_call.success:
                    revert with 0, 'PrizePool/prizeStrategy-invalid'
                if not mem[ceil32(return_data.size) + 333 len 28], Mask(32, 32, supportsInterface(bytes4 arg1), 0xff5e34e70000000000000000000000000000000000000000) >> 32:
                    revert with 0, 'PrizePool/prizeStrategy-invalid'
    else:
        mem[196 len return_data.size] = ext_call.return_data[0 len return_data.size]
        if return_data.size < 32:
            revert with 0, 'PrizePool/prizeStrategy-invalid'
        require return_data.size >= 32
        if not ext_call.success:
            revert with 0, 'PrizePool/prizeStrategy-invalid'
        if not mem[196 len 28], Mask(32, 32, supportsInterface(bytes4 arg1), 0x1ffc9a70000000000000000000000000000000000000000) >> 32:
            revert with 0, 'PrizePool/prizeStrategy-invalid'
        staticcall arg1 with:
                gas 30000 wei
               args 0xffffffff000000000000000000000000000000000000000000000000, mem[ceil32(return_data.size) + 265 len 4]
        if not return_data.size:
            if ext_call.success:
                if supportsInterface(bytes4 arg1), 0x1ffc9a70000000000000000000000000000000000000000:
                    revert with 0, 'PrizePool/prizeStrategy-invalid'
            staticcall arg1 with:
                    gas 30000 wei
                   args 0xff5e34e7000000000000000000000000000000000000000000000000, mem[ceil32(return_data.size) + 333 len 4]
            if not return_data.size:
                if not ext_call.success:
                    revert with 0, 'PrizePool/prizeStrategy-invalid'
                if not supportsInterface(bytes4 arg1), 0x1ffc9a70000000000000000000000000000000000000000:
                    revert with 0, 'PrizePool/prizeStrategy-invalid'
            else:
                mem[ceil32(return_data.size) + 333 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if return_data.size < 32:
                    revert with 0, 'PrizePool/prizeStrategy-invalid'
                require return_data.size >= 32
                if not ext_call.success:
                    revert with 0, 'PrizePool/prizeStrategy-invalid'
                if not mem[ceil32(return_data.size) + 333 len 28], 0:
                    revert with 0, 'PrizePool/prizeStrategy-invalid'
        else:
            mem[ceil32(return_data.size) + 265 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if return_data.size >= 32:
                require return_data.size >= 32
                if ext_call.success:
                    if mem[ceil32(return_data.size) + 265 len 28], 0:
                        revert with 0, 'PrizePool/prizeStrategy-invalid'
            staticcall arg1 with:
                    gas 30000 wei
                   args 0xff5e34e7000000000000000000000000000000000000000000000000, mem[(2 * ceil32(return_data.size)) + 334 len 4]
            if not return_data.size:
                if not ext_call.success:
                    revert with 0, 'PrizePool/prizeStrategy-invalid'
                if not supportsInterface(bytes4 arg1), 0x1ffc9a70000000000000000000000000000000000000000:
                    revert with 0, 'PrizePool/prizeStrategy-invalid'
            else:
                mem[(2 * ceil32(return_data.size)) + 334 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if return_data.size < 32:
                    revert with 0, 'PrizePool/prizeStrategy-invalid'
                require return_data.size >= 32
                if not ext_call.success:
                    revert with 0, 'PrizePool/prizeStrategy-invalid'
                if not mem[(2 * ceil32(return_data.size)) + 334 len 28], 0:
                    revert with 0, 'PrizePool/prizeStrategy-invalid'
    prizeStrategyAddress = arg1
    emit PrizeStrategySet(arg1);
}

function captureAwardBalance() payable {
    if stor101 == 2:
        revert with 0, 'ReentrancyGuard: reentrant call'
    stor101 = 2
    if not stor152.length:
        idx = 0
        s = reserveTotalSupply
        while idx < stor152.length:
            require idx < stor152.length
            require ext_code.size(mem[(32 * idx) + 140 len 20])
            staticcall mem[(32 * idx) + 140 len 20].0x18160ddd with:
                    gas gas_remaining wei
            mem[(32 * stor152.length) + 128] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if ext_call.return_data[0] + s < s:
                revert with 0, 'SafeMath: addition overflow'
            idx = idx + 1
            s = ext_call.return_data[0] + s
            continue 
        require ext_code.size(address(yieldSourceAddress))
        call address(yieldSourceAddress).0xb99152d0 with:
             gas gas_remaining wei
            args this.address
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if ext_call.return_data[0] <= reserveTotalSupply + (_122 * stor152.length):
            if 0 > awardBalance:
                if awardBalance > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                if -awardBalance:
                    require ext_code.size(reserveRegistryAddress)
                    staticcall reserveRegistryAddress.0xf5e3542b with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if not ext_call.return_data[12 len 20]:
                        if 0 < awardBalance:
                            revert with 0, 'SafeMath: addition overflow'
                        awardBalance = 0
                        emit AwardCaptured(-awardBalance);
                    else:
                        require ext_code.size(address(ext_call.return_data[0]))
                        staticcall address(ext_call.return_data[0]).reserveRateMantissa(address arg1) with:
                                gas gas_remaining wei
                               args this.address
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if not ext_call.return_data[0]:
                            if 0 < awardBalance:
                                revert with 0, 'SafeMath: addition overflow'
                            awardBalance = 0
                            emit AwardCaptured(-awardBalance);
                        else:
                            if -1 * awardBalance * ext_call.return_data[0] / ext_call.return_data[0] != -awardBalance:
                                revert with 0, 
                                            32,
                                            33,
                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[(32 * stor152.length) + 229 len 31]
                            if not -1 * awardBalance * ext_call.return_data[0] / 10^18:
                                if 0 < awardBalance:
                                    revert with 0, 'SafeMath: addition overflow'
                                awardBalance = 0
                                emit AwardCaptured(-awardBalance);
                            else:
                                if (-1 * awardBalance * ext_call.return_data[0] / 10^18) + reserveTotalSupply < reserveTotalSupply:
                                    revert with 0, 'SafeMath: addition overflow'
                                reserveTotalSupply += -1 * awardBalance * ext_call.return_data[0] / 10^18
                                if -1 * awardBalance * ext_call.return_data[0] / 10^18 > -awardBalance:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                emit ReserveFeeCaptured((-1 * awardBalance * ext_call.return_data[0] / 10^18));
                                if --1 * awardBalance * ext_call.return_data[0] / 10^18 < awardBalance:
                                    revert with 0, 'SafeMath: addition overflow'
                                awardBalance = --1 * awardBalance * ext_call.return_data[0] / 10^18
                                emit AwardCaptured((-awardBalance - (-1 * awardBalance * ext_call.return_data[0] / 10^18)));
        else:
            if reserveTotalSupply + (_122 * stor152.length) > ext_call.return_data[0]:
                revert with 0, 'SafeMath: subtraction overflow'
            if ext_call.return_data[0] - reserveTotalSupply - (_122 * stor152.length) > awardBalance:
                if awardBalance > ext_call.return_data[0] - reserveTotalSupply - (_122 * stor152.length):
                    revert with 0, 'SafeMath: subtraction overflow'
                if ext_call.return_data[0] - reserveTotalSupply - (_122 * stor152.length) - awardBalance:
                    require ext_code.size(reserveRegistryAddress)
                    staticcall reserveRegistryAddress.0xf5e3542b with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if not ext_call.return_data[12 len 20]:
                        if ext_call.return_data[0] - reserveTotalSupply - (_122 * stor152.length) < awardBalance:
                            revert with 0, 'SafeMath: addition overflow'
                        awardBalance = ext_call.return_data[0] - reserveTotalSupply - (_122 * stor152.length)
                        emit AwardCaptured((ext_call.return_data[0] - reserveTotalSupply - (_122 * stor152.length) - awardBalance));
                    else:
                        require ext_code.size(address(ext_call.return_data[0]))
                        staticcall address(ext_call.return_data[0]).reserveRateMantissa(address arg1) with:
                                gas gas_remaining wei
                               args this.address
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if not ext_call.return_data[0]:
                            if ext_call.return_data[0] - reserveTotalSupply - (_122 * stor152.length) < awardBalance:
                                revert with 0, 'SafeMath: addition overflow'
                            awardBalance = ext_call.return_data[0] - reserveTotalSupply - (_122 * stor152.length)
                            emit AwardCaptured((ext_call.return_data[0] - reserveTotalSupply - (_122 * stor152.length) - awardBalance));
                        else:
                            if (ext_call.return_data[0] * ext_call.return_data[0]) - (reserveTotalSupply * ext_call.return_data[0]) - (_122 * stor152.length * ext_call.return_data[0]) - (awardBalance * ext_call.return_data[0]) / ext_call.return_data[0] != ext_call.return_data[0] - reserveTotalSupply - (_122 * stor152.length) - awardBalance:
                                revert with 0, 
                                            32,
                                            33,
                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[(32 * stor152.length) + 229 len 31]
                            if not (ext_call.return_data[0] * ext_call.return_data[0]) - (reserveTotalSupply * ext_call.return_data[0]) - (_122 * stor152.length * ext_call.return_data[0]) - (awardBalance * ext_call.return_data[0]) / 10^18:
                                if ext_call.return_data[0] - reserveTotalSupply - (_122 * stor152.length) < awardBalance:
                                    revert with 0, 'SafeMath: addition overflow'
                                awardBalance = ext_call.return_data[0] - reserveTotalSupply - (_122 * stor152.length)
                                emit AwardCaptured((ext_call.return_data[0] - reserveTotalSupply - (_122 * stor152.length) - awardBalance));
                            else:
                                if ((ext_call.return_data[0] * ext_call.return_data[0]) - (reserveTotalSupply * ext_call.return_data[0]) - (_122 * stor152.length * ext_call.return_data[0]) - (awardBalance * ext_call.return_data[0]) / 10^18) + reserveTotalSupply < reserveTotalSupply:
                                    revert with 0, 'SafeMath: addition overflow'
                                reserveTotalSupply += (ext_call.return_data[0] * ext_call.return_data[0]) - (reserveTotalSupply * ext_call.return_data[0]) - (_122 * stor152.length * ext_call.return_data[0]) - (awardBalance * ext_call.return_data[0]) / 10^18
                                if (ext_call.return_data[0] * ext_call.return_data[0]) - (reserveTotalSupply * ext_call.return_data[0]) - (_122 * stor152.length * ext_call.return_data[0]) - (awardBalance * ext_call.return_data[0]) / 10^18 > ext_call.return_data[0] - reserveTotalSupply - (_122 * stor152.length) - awardBalance:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                emit ReserveFeeCaptured(((ext_call.return_data[0] * ext_call.return_data[0]) - (reserveTotalSupply * ext_call.return_data[0]) - (_122 * stor152.length * ext_call.return_data[0]) - (awardBalance * ext_call.return_data[0]) / 10^18));
                                if ext_call.return_data[0] - reserveTotalSupply - (_122 * stor152.length) - ((ext_call.return_data[0] * ext_call.return_data[0]) - (reserveTotalSupply * ext_call.return_data[0]) - (_122 * stor152.length * ext_call.return_data[0]) - (awardBalance * ext_call.return_data[0]) / 10^18) < awardBalance:
                                    revert with 0, 'SafeMath: addition overflow'
                                awardBalance = ext_call.return_data[0] - reserveTotalSupply - (_122 * stor152.length) - ((ext_call.return_data[0] * ext_call.return_data[0]) - (reserveTotalSupply * ext_call.return_data[0]) - (_122 * stor152.length * ext_call.return_data[0]) - (awardBalance * ext_call.return_data[0]) / 10^18)
                                emit AwardCaptured((ext_call.return_data[0] - reserveTotalSupply - (_122 * stor152.length) - awardBalance - ((ext_call.return_data[0] * ext_call.return_data[0]) - (reserveTotalSupply * ext_call.return_data[0]) - (_122 * stor152.length * ext_call.return_data[0]) - (awardBalance * ext_call.return_data[0]) / 10^18)));
    else:
        mem[128] = address(stor152.field_0)
        idx = 128
        s = 0
        while (32 * stor152.length) + 96 > idx:
            mem[idx + 32] = stor152[s].field_256
            idx = idx + 32
            s = s + 1
            continue 
        idx = 0
        s = reserveTotalSupply
        while idx < stor152.length:
            require idx < stor152.length
            require ext_code.size(mem[(32 * idx) + 140 len 20])
            staticcall mem[(32 * idx) + 140 len 20].0x18160ddd with:
                    gas gas_remaining wei
            mem[(32 * stor152.length) + 128] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            _339 = ext_call.return_data[0]
            if ext_call.return_data[0] + s < s:
                revert with 0, 'SafeMath: addition overflow'
            idx = idx + 1
            s = ext_call.return_data[0] + s
            continue 
        require ext_code.size(address(yieldSourceAddress))
        call address(yieldSourceAddress).0xb99152d0 with:
             gas gas_remaining wei
            args this.address
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if ext_call.return_data[0] <= reserveTotalSupply + (_339 * stor152.length):
            if 0 > awardBalance:
                if awardBalance > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                if -awardBalance:
                    require ext_code.size(reserveRegistryAddress)
                    staticcall reserveRegistryAddress.0xf5e3542b with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if not address(ext_call.return_data[0]):
                        if 0 < awardBalance:
                            revert with 0, 'SafeMath: addition overflow'
                        awardBalance = 0
                        emit AwardCaptured(-awardBalance);
                    else:
                        require ext_code.size(address(ext_call.return_data[0]))
                        staticcall address(ext_call.return_data[0]).reserveRateMantissa(address arg1) with:
                                gas gas_remaining wei
                               args this.address
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if not ext_call.return_data[0]:
                            if 0 < awardBalance:
                                revert with 0, 'SafeMath: addition overflow'
                            awardBalance = 0
                            emit AwardCaptured(-awardBalance);
                        else:
                            if -1 * awardBalance * ext_call.return_data[0] / ext_call.return_data[0] != -awardBalance:
                                revert with 0, 
                                            32,
                                            33,
                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[(32 * stor152.length) + 229 len 31]
                            if not -1 * awardBalance * ext_call.return_data[0] / 10^18:
                                if 0 < awardBalance:
                                    revert with 0, 'SafeMath: addition overflow'
                                awardBalance = 0
                                emit AwardCaptured(-awardBalance);
                            else:
                                if (-1 * awardBalance * ext_call.return_data[0] / 10^18) + reserveTotalSupply < reserveTotalSupply:
                                    revert with 0, 'SafeMath: addition overflow'
                                reserveTotalSupply += -1 * awardBalance * ext_call.return_data[0] / 10^18
                                if -1 * awardBalance * ext_call.return_data[0] / 10^18 > -awardBalance:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                emit ReserveFeeCaptured((-1 * awardBalance * ext_call.return_data[0] / 10^18));
                                if --1 * awardBalance * ext_call.return_data[0] / 10^18 < awardBalance:
                                    revert with 0, 'SafeMath: addition overflow'
                                awardBalance = --1 * awardBalance * ext_call.return_data[0] / 10^18
                                emit AwardCaptured((-awardBalance - (-1 * awardBalance * ext_call.return_data[0] / 10^18)));
        else:
            if reserveTotalSupply + (_339 * stor152.length) > ext_call.return_data[0]:
                revert with 0, 'SafeMath: subtraction overflow'
            if ext_call.return_data[0] - reserveTotalSupply - (_339 * stor152.length) > awardBalance:
                if awardBalance > ext_call.return_data[0] - reserveTotalSupply - (_339 * stor152.length):
                    revert with 0, 'SafeMath: subtraction overflow'
                if ext_call.return_data[0] - reserveTotalSupply - (_339 * stor152.length) - awardBalance:
                    require ext_code.size(reserveRegistryAddress)
                    staticcall reserveRegistryAddress.0xf5e3542b with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if not address(ext_call.return_data[0]):
                        if ext_call.return_data[0] - reserveTotalSupply - (_339 * stor152.length) < awardBalance:
                            revert with 0, 'SafeMath: addition overflow'
                        awardBalance = ext_call.return_data[0] - reserveTotalSupply - (_339 * stor152.length)
                        emit AwardCaptured((ext_call.return_data[0] - reserveTotalSupply - (_339 * stor152.length) - awardBalance));
                    else:
                        require ext_code.size(address(ext_call.return_data[0]))
                        staticcall address(ext_call.return_data[0]).reserveRateMantissa(address arg1) with:
                                gas gas_remaining wei
                               args this.address
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if not ext_call.return_data[0]:
                            if ext_call.return_data[0] - reserveTotalSupply - (_339 * stor152.length) < awardBalance:
                                revert with 0, 'SafeMath: addition overflow'
                            awardBalance = ext_call.return_data[0] - reserveTotalSupply - (_339 * stor152.length)
                            emit AwardCaptured((ext_call.return_data[0] - reserveTotalSupply - (_339 * stor152.length) - awardBalance));
                        else:
                            if (ext_call.return_data[0] * ext_call.return_data[0]) - (reserveTotalSupply * ext_call.return_data[0]) - (_339 * stor152.length * ext_call.return_data[0]) - (awardBalance * ext_call.return_data[0]) / ext_call.return_data[0] != ext_call.return_data[0] - reserveTotalSupply - (_339 * stor152.length) - awardBalance:
                                revert with 0, 
                                            32,
                                            33,
                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[(32 * stor152.length) + 229 len 31]
                            if not (ext_call.return_data[0] * ext_call.return_data[0]) - (reserveTotalSupply * ext_call.return_data[0]) - (_339 * stor152.length * ext_call.return_data[0]) - (awardBalance * ext_call.return_data[0]) / 10^18:
                                if ext_call.return_data[0] - reserveTotalSupply - (_339 * stor152.length) < awardBalance:
                                    revert with 0, 'SafeMath: addition overflow'
                                awardBalance = ext_call.return_data[0] - reserveTotalSupply - (_339 * stor152.length)
                                emit AwardCaptured((ext_call.return_data[0] - reserveTotalSupply - (_339 * stor152.length) - awardBalance));
                            else:
                                if ((ext_call.return_data[0] * ext_call.return_data[0]) - (reserveTotalSupply * ext_call.return_data[0]) - (_339 * stor152.length * ext_call.return_data[0]) - (awardBalance * ext_call.return_data[0]) / 10^18) + reserveTotalSupply < reserveTotalSupply:
                                    revert with 0, 'SafeMath: addition overflow'
                                reserveTotalSupply += (ext_call.return_data[0] * ext_call.return_data[0]) - (reserveTotalSupply * ext_call.return_data[0]) - (_339 * stor152.length * ext_call.return_data[0]) - (awardBalance * ext_call.return_data[0]) / 10^18
                                if (ext_call.return_data[0] * ext_call.return_data[0]) - (reserveTotalSupply * ext_call.return_data[0]) - (_339 * stor152.length * ext_call.return_data[0]) - (awardBalance * ext_call.return_data[0]) / 10^18 > ext_call.return_data[0] - reserveTotalSupply - (_339 * stor152.length) - awardBalance:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                emit ReserveFeeCaptured(((ext_call.return_data[0] * ext_call.return_data[0]) - (reserveTotalSupply * ext_call.return_data[0]) - (_339 * stor152.length * ext_call.return_data[0]) - (awardBalance * ext_call.return_data[0]) / 10^18));
                                if ext_call.return_data[0] - reserveTotalSupply - (_339 * stor152.length) - ((ext_call.return_data[0] * ext_call.return_data[0]) - (reserveTotalSupply * ext_call.return_data[0]) - (_339 * stor152.length * ext_call.return_data[0]) - (awardBalance * ext_call.return_data[0]) / 10^18) < awardBalance:
                                    revert with 0, 'SafeMath: addition overflow'
                                awardBalance = ext_call.return_data[0] - reserveTotalSupply - (_339 * stor152.length) - ((ext_call.return_data[0] * ext_call.return_data[0]) - (reserveTotalSupply * ext_call.return_data[0]) - (_339 * stor152.length * ext_call.return_data[0]) - (awardBalance * ext_call.return_data[0]) / 10^18)
                                emit AwardCaptured((ext_call.return_data[0] - reserveTotalSupply - (_339 * stor152.length) - awardBalance - ((ext_call.return_data[0] * ext_call.return_data[0]) - (reserveTotalSupply * ext_call.return_data[0]) - (_339 * stor152.length * ext_call.return_data[0]) - (awardBalance * ext_call.return_data[0]) / 10^18)));
    stor101 = 1
    return awardBalance
}

function balanceOfCredit(address arg1, address arg2) payable {
    require calldata.size - 4 >= 64
    if stor152.length:
        mem[128] = address(stor152.field_0)
        idx = 128
        s = 0
        while (32 * stor152.length) + 96 > idx:
            mem[idx + 32] = stor152[s].field_256
            idx = idx + 32
            s = s + 1
            continue 
    idx = 0
    while idx < stor152.length:
        require idx < stor152.length
        if mem[(32 * idx) + 140 len 20] != arg2:
            idx = idx + 1
            continue 
        require ext_code.size(arg2)
        staticcall arg2.0x70a08231 with:
                gas gas_remaining wei
               args arg1
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if not stor159[address(arg2)][address(arg1)].field_224:
            if block.timestamp >= 4294967296:
                revert with 0, 
                            32,
                            38,
                            0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                            mem[(32 * stor152.length) + 330 len 26]
            stor159[address(arg2)][address(arg1)].field_0 = 0
            stor159[address(arg2)][address(arg1)].field_192 = uint32(block.timestamp)
            stor159[address(arg2)][address(arg1)].field_224 = 1
            stor159[address(arg2)][address(arg1)].field_256 = 0
            if stor159[address(arg2)][address(arg1)].field_0 < 0:
                if stor159[address(arg2)][address(arg1)].field_0 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                emit CreditMinted(-stor159[address(arg2)][address(arg1)].field_0, arg1, arg2);
            else:
                if 0 < stor159[address(arg2)][address(arg1)].field_0:
                    if 0 > stor159[address(arg2)][address(arg1)].field_0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    emit CreditBurned(stor159[address(arg2)][address(arg1)].field_0, arg1, arg2);
        else:
            if not stor159[address(arg2)][address(arg1)].field_224:
                if stor159[address(arg2)][address(arg1)].field_0 < stor159[address(arg2)][address(arg1)].field_0:
                    revert with 0, 'SafeMath: addition overflow'
                if not creditPlanOf[address(arg2)].field_0:
                    if stor159[address(arg2)][address(arg1)].field_0 > 0:
                        if block.timestamp >= 4294967296:
                            revert with 0, 
                                        32,
                                        38,
                                        0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                        mem[(32 * stor152.length) + 394 len 26]
                        stor159[address(arg2)][address(arg1)].field_0 = 0
                        stor159[address(arg2)][address(arg1)].field_192 = uint32(block.timestamp)
                        stor159[address(arg2)][address(arg1)].field_224 = 1
                        stor159[address(arg2)][address(arg1)].field_256 = 0
                        if stor159[address(arg2)][address(arg1)].field_0 < 0:
                            if stor159[address(arg2)][address(arg1)].field_0 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            emit CreditMinted(-stor159[address(arg2)][address(arg1)].field_0, arg1, arg2);
                        else:
                            if 0 < stor159[address(arg2)][address(arg1)].field_0:
                                if 0 > stor159[address(arg2)][address(arg1)].field_0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                emit CreditBurned(stor159[address(arg2)][address(arg1)].field_0, arg1, arg2);
                    else:
                        if stor159[address(arg2)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                            revert with 0, 
                                        32,
                                        39,
                                        0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                        mem[(32 * stor152.length) + 395 len 25]
                        if block.timestamp >= 4294967296:
                            revert with 0, 
                                        32,
                                        38,
                                        0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                        mem[(32 * stor152.length) + 394 len 26]
                        stor159[address(arg2)][address(arg1)].field_0 = stor159[address(arg2)][address(arg1)].field_0
                        stor159[address(arg2)][address(arg1)].field_128 = 0
                        stor159[address(arg2)][address(arg1)].field_192 = uint32(block.timestamp)
                        stor159[address(arg2)][address(arg1)].field_224 = 1
                        if stor159[address(arg2)][address(arg1)].field_0 < stor159[address(arg2)][address(arg1)].field_0:
                            if stor159[address(arg2)][address(arg1)].field_0 > stor159[address(arg2)][address(arg1)].field_0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            emit CreditMinted(0, arg1, arg2);
                        else:
                            if stor159[address(arg2)][address(arg1)].field_0 < stor159[address(arg2)][address(arg1)].field_0:
                                if stor159[address(arg2)][address(arg1)].field_0 > stor159[address(arg2)][address(arg1)].field_0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                emit CreditBurned(0, arg1, arg2);
                else:
                    if ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / creditPlanOf[address(arg2)].field_0 != ext_call.return_data[0]:
                        revert with 0, 
                                    32,
                                    33,
                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[(32 * stor152.length) + 229 len 31]
                    if stor159[address(arg2)][address(arg1)].field_0 <= ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18:
                        if stor159[address(arg2)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                            revert with 0, 
                                        32,
                                        39,
                                        0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                        mem[(32 * stor152.length) + 395 len 25]
                        if block.timestamp >= 4294967296:
                            revert with 0, 
                                        32,
                                        38,
                                        0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                        mem[(32 * stor152.length) + 394 len 26]
                        stor159[address(arg2)][address(arg1)].field_0 = stor159[address(arg2)][address(arg1)].field_0
                        stor159[address(arg2)][address(arg1)].field_128 = 0
                        stor159[address(arg2)][address(arg1)].field_192 = uint32(block.timestamp)
                        stor159[address(arg2)][address(arg1)].field_224 = 1
                        if stor159[address(arg2)][address(arg1)].field_0 < stor159[address(arg2)][address(arg1)].field_0:
                            if stor159[address(arg2)][address(arg1)].field_0 > stor159[address(arg2)][address(arg1)].field_0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            emit CreditMinted(0, arg1, arg2);
                        else:
                            if stor159[address(arg2)][address(arg1)].field_0 < stor159[address(arg2)][address(arg1)].field_0:
                                if stor159[address(arg2)][address(arg1)].field_0 > stor159[address(arg2)][address(arg1)].field_0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                emit CreditBurned(0, arg1, arg2);
                    else:
                        if ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18 >= 0x100000000000000000000000000000000:
                            revert with 0, 
                                        32,
                                        39,
                                        0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                        mem[(32 * stor152.length) + 395 len 25]
                        if block.timestamp >= 4294967296:
                            revert with 0, 
                                        32,
                                        38,
                                        0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                        mem[(32 * stor152.length) + 394 len 26]
                        stor159[address(arg2)][address(arg1)].field_0 = uint128(ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18)
                        stor159[address(arg2)][address(arg1)].field_128 = 0
                        stor159[address(arg2)][address(arg1)].field_192 = uint32(block.timestamp)
                        stor159[address(arg2)][address(arg1)].field_224 = 1
                        if stor159[address(arg2)][address(arg1)].field_0 < ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18:
                            if stor159[address(arg2)][address(arg1)].field_0 > ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18:
                                revert with 0, 'SafeMath: subtraction overflow'
                            emit CreditMinted(((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18) - stor159[address(arg2)][address(arg1)].field_0), arg1, arg2);
                        else:
                            if ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18 < stor159[address(arg2)][address(arg1)].field_0:
                                if ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18 > stor159[address(arg2)][address(arg1)].field_0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                emit CreditBurned((stor159[address(arg2)][address(arg1)].field_0 - (ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18)), arg1, arg2);
            else:
                if stor159[address(arg2)][address(arg1)].field_192 > block.timestamp:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not block.timestamp - stor159[address(arg2)][address(arg1)].field_192:
                    if stor159[address(arg2)][address(arg1)].field_0 < stor159[address(arg2)][address(arg1)].field_0:
                        revert with 0, 'SafeMath: addition overflow'
                    if not creditPlanOf[address(arg2)].field_0:
                        if stor159[address(arg2)][address(arg1)].field_0 > 0:
                            if block.timestamp >= 4294967296:
                                revert with 0, 
                                            32,
                                            38,
                                            0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                            mem[(32 * stor152.length) + 458 len 26]
                            stor159[address(arg2)][address(arg1)].field_0 = 0
                            stor159[address(arg2)][address(arg1)].field_192 = uint32(block.timestamp)
                            stor159[address(arg2)][address(arg1)].field_224 = 1
                            stor159[address(arg2)][address(arg1)].field_256 = 0
                            if stor159[address(arg2)][address(arg1)].field_0 < 0:
                                if stor159[address(arg2)][address(arg1)].field_0 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                emit CreditMinted(-stor159[address(arg2)][address(arg1)].field_0, arg1, arg2);
                            else:
                                if 0 < stor159[address(arg2)][address(arg1)].field_0:
                                    if 0 > stor159[address(arg2)][address(arg1)].field_0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    emit CreditBurned(stor159[address(arg2)][address(arg1)].field_0, arg1, arg2);
                        else:
                            if stor159[address(arg2)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                revert with 0, 
                                            32,
                                            39,
                                            0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                            mem[(32 * stor152.length) + 459 len 25]
                            if block.timestamp >= 4294967296:
                                revert with 0, 
                                            32,
                                            38,
                                            0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                            mem[(32 * stor152.length) + 458 len 26]
                            stor159[address(arg2)][address(arg1)].field_0 = stor159[address(arg2)][address(arg1)].field_0
                            stor159[address(arg2)][address(arg1)].field_128 = 0
                            stor159[address(arg2)][address(arg1)].field_192 = uint32(block.timestamp)
                            stor159[address(arg2)][address(arg1)].field_224 = 1
                            if stor159[address(arg2)][address(arg1)].field_0 < stor159[address(arg2)][address(arg1)].field_0:
                                if stor159[address(arg2)][address(arg1)].field_0 > stor159[address(arg2)][address(arg1)].field_0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                emit CreditMinted(0, arg1, arg2);
                            else:
                                if stor159[address(arg2)][address(arg1)].field_0 < stor159[address(arg2)][address(arg1)].field_0:
                                    if stor159[address(arg2)][address(arg1)].field_0 > stor159[address(arg2)][address(arg1)].field_0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    emit CreditBurned(0, arg1, arg2);
                    else:
                        if ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / creditPlanOf[address(arg2)].field_0 != ext_call.return_data[0]:
                            revert with 0, 
                                        32,
                                        33,
                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[(32 * stor152.length) + 293 len 31]
                        if stor159[address(arg2)][address(arg1)].field_0 <= ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18:
                            if stor159[address(arg2)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                revert with 0, 
                                            32,
                                            39,
                                            0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                            mem[(32 * stor152.length) + 459 len 25]
                            if block.timestamp >= 4294967296:
                                revert with 0, 
                                            32,
                                            38,
                                            0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                            mem[(32 * stor152.length) + 458 len 26]
                            stor159[address(arg2)][address(arg1)].field_0 = stor159[address(arg2)][address(arg1)].field_0
                            stor159[address(arg2)][address(arg1)].field_128 = 0
                            stor159[address(arg2)][address(arg1)].field_192 = uint32(block.timestamp)
                            stor159[address(arg2)][address(arg1)].field_224 = 1
                            if stor159[address(arg2)][address(arg1)].field_0 < stor159[address(arg2)][address(arg1)].field_0:
                                if stor159[address(arg2)][address(arg1)].field_0 > stor159[address(arg2)][address(arg1)].field_0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                emit CreditMinted(0, arg1, arg2);
                            else:
                                if stor159[address(arg2)][address(arg1)].field_0 < stor159[address(arg2)][address(arg1)].field_0:
                                    if stor159[address(arg2)][address(arg1)].field_0 > stor159[address(arg2)][address(arg1)].field_0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    emit CreditBurned(0, arg1, arg2);
                        else:
                            if ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18 >= 0x100000000000000000000000000000000:
                                revert with 0, 
                                            32,
                                            39,
                                            0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                            mem[(32 * stor152.length) + 459 len 25]
                            if block.timestamp >= 4294967296:
                                revert with 0, 
                                            32,
                                            38,
                                            0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                            mem[(32 * stor152.length) + 458 len 26]
                            stor159[address(arg2)][address(arg1)].field_0 = uint128(ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18)
                            stor159[address(arg2)][address(arg1)].field_128 = 0
                            stor159[address(arg2)][address(arg1)].field_192 = uint32(block.timestamp)
                            stor159[address(arg2)][address(arg1)].field_224 = 1
                            if stor159[address(arg2)][address(arg1)].field_0 < ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18:
                                if stor159[address(arg2)][address(arg1)].field_0 > ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                emit CreditMinted(((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18) - stor159[address(arg2)][address(arg1)].field_0), arg1, arg2);
                            else:
                                if ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18 < stor159[address(arg2)][address(arg1)].field_0:
                                    if ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18 > stor159[address(arg2)][address(arg1)].field_0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    emit CreditBurned((stor159[address(arg2)][address(arg1)].field_0 - (ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18)), arg1, arg2);
                else:
                    if (block.timestamp * creditPlanOf[address(arg2)].field_128) - (stor159[address(arg2)][address(arg1)].field_192 * creditPlanOf[address(arg2)].field_128) / block.timestamp - stor159[address(arg2)][address(arg1)].field_192 != creditPlanOf[address(arg2)].field_128:
                        revert with 0, 
                                    32,
                                    33,
                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[(32 * stor152.length) + 229 len 31]
                    if not (block.timestamp * creditPlanOf[address(arg2)].field_128) - (stor159[address(arg2)][address(arg1)].field_192 * creditPlanOf[address(arg2)].field_128):
                        if stor159[address(arg2)][address(arg1)].field_0 < stor159[address(arg2)][address(arg1)].field_0:
                            revert with 0, 'SafeMath: addition overflow'
                        if not creditPlanOf[address(arg2)].field_0:
                            if stor159[address(arg2)][address(arg1)].field_0 > 0:
                                if block.timestamp >= 4294967296:
                                    revert with 0, 
                                                32,
                                                38,
                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                mem[(32 * stor152.length) + 458 len 26]
                                stor159[address(arg2)][address(arg1)].field_0 = 0
                                stor159[address(arg2)][address(arg1)].field_192 = uint32(block.timestamp)
                                stor159[address(arg2)][address(arg1)].field_224 = 1
                                stor159[address(arg2)][address(arg1)].field_256 = 0
                                if stor159[address(arg2)][address(arg1)].field_0 < 0:
                                    if stor159[address(arg2)][address(arg1)].field_0 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    emit CreditMinted(-stor159[address(arg2)][address(arg1)].field_0, arg1, arg2);
                                else:
                                    if 0 < stor159[address(arg2)][address(arg1)].field_0:
                                        if 0 > stor159[address(arg2)][address(arg1)].field_0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        emit CreditBurned(stor159[address(arg2)][address(arg1)].field_0, arg1, arg2);
                            else:
                                if stor159[address(arg2)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                    revert with 0, 
                                                32,
                                                39,
                                                0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                mem[(32 * stor152.length) + 459 len 25]
                                if block.timestamp >= 4294967296:
                                    revert with 0, 
                                                32,
                                                38,
                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                mem[(32 * stor152.length) + 458 len 26]
                                stor159[address(arg2)][address(arg1)].field_0 = stor159[address(arg2)][address(arg1)].field_0
                                stor159[address(arg2)][address(arg1)].field_128 = 0
                                stor159[address(arg2)][address(arg1)].field_192 = uint32(block.timestamp)
                                stor159[address(arg2)][address(arg1)].field_224 = 1
                                if stor159[address(arg2)][address(arg1)].field_0 < stor159[address(arg2)][address(arg1)].field_0:
                                    if stor159[address(arg2)][address(arg1)].field_0 > stor159[address(arg2)][address(arg1)].field_0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    emit CreditMinted(0, arg1, arg2);
                                else:
                                    if stor159[address(arg2)][address(arg1)].field_0 < stor159[address(arg2)][address(arg1)].field_0:
                                        if stor159[address(arg2)][address(arg1)].field_0 > stor159[address(arg2)][address(arg1)].field_0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        emit CreditBurned(0, arg1, arg2);
                        else:
                            if ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / creditPlanOf[address(arg2)].field_0 != ext_call.return_data[0]:
                                revert with 0, 
                                            32,
                                            33,
                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[(32 * stor152.length) + 293 len 31]
                            if stor159[address(arg2)][address(arg1)].field_0 <= ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18:
                                if stor159[address(arg2)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                    revert with 0, 
                                                32,
                                                39,
                                                0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                mem[(32 * stor152.length) + 459 len 25]
                                if block.timestamp >= 4294967296:
                                    revert with 0, 
                                                32,
                                                38,
                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                mem[(32 * stor152.length) + 458 len 26]
                                stor159[address(arg2)][address(arg1)].field_0 = stor159[address(arg2)][address(arg1)].field_0
                                stor159[address(arg2)][address(arg1)].field_128 = 0
                                stor159[address(arg2)][address(arg1)].field_192 = uint32(block.timestamp)
                                stor159[address(arg2)][address(arg1)].field_224 = 1
                                if stor159[address(arg2)][address(arg1)].field_0 < stor159[address(arg2)][address(arg1)].field_0:
                                    if stor159[address(arg2)][address(arg1)].field_0 > stor159[address(arg2)][address(arg1)].field_0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    emit CreditMinted(0, arg1, arg2);
                                else:
                                    if stor159[address(arg2)][address(arg1)].field_0 < stor159[address(arg2)][address(arg1)].field_0:
                                        if stor159[address(arg2)][address(arg1)].field_0 > stor159[address(arg2)][address(arg1)].field_0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        emit CreditBurned(0, arg1, arg2);
                            else:
                                if ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18 >= 0x100000000000000000000000000000000:
                                    revert with 0, 
                                                32,
                                                39,
                                                0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                mem[(32 * stor152.length) + 459 len 25]
                                if block.timestamp >= 4294967296:
                                    revert with 0, 
                                                32,
                                                38,
                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                mem[(32 * stor152.length) + 458 len 26]
                                stor159[address(arg2)][address(arg1)].field_0 = uint128(ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18)
                                stor159[address(arg2)][address(arg1)].field_128 = 0
                                stor159[address(arg2)][address(arg1)].field_192 = uint32(block.timestamp)
                                stor159[address(arg2)][address(arg1)].field_224 = 1
                                if stor159[address(arg2)][address(arg1)].field_0 < ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    if stor159[address(arg2)][address(arg1)].field_0 > ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    emit CreditMinted(((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18) - stor159[address(arg2)][address(arg1)].field_0), arg1, arg2);
                                else:
                                    if ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18 < stor159[address(arg2)][address(arg1)].field_0:
                                        if ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18 > stor159[address(arg2)][address(arg1)].field_0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        emit CreditBurned((stor159[address(arg2)][address(arg1)].field_0 - (ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18)), arg1, arg2);
                    else:
                        if (block.timestamp * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) - (stor159[address(arg2)][address(arg1)].field_192 * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) / (block.timestamp * creditPlanOf[address(arg2)].field_128) - (stor159[address(arg2)][address(arg1)].field_192 * creditPlanOf[address(arg2)].field_128) != ext_call.return_data[0]:
                            revert with 0, 
                                        32,
                                        33,
                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[(32 * stor152.length) + 229 len 31]
                        if ((block.timestamp * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) - (stor159[address(arg2)][address(arg1)].field_192 * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg2)][address(arg1)].field_0 < stor159[address(arg2)][address(arg1)].field_0:
                            revert with 0, 'SafeMath: addition overflow'
                        if not creditPlanOf[address(arg2)].field_0:
                            if ((block.timestamp * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) - (stor159[address(arg2)][address(arg1)].field_192 * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg2)][address(arg1)].field_0 > 0:
                                if block.timestamp >= 4294967296:
                                    revert with 0, 
                                                32,
                                                38,
                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                mem[(32 * stor152.length) + 458 len 26]
                                stor159[address(arg2)][address(arg1)].field_0 = 0
                                stor159[address(arg2)][address(arg1)].field_192 = uint32(block.timestamp)
                                stor159[address(arg2)][address(arg1)].field_224 = 1
                                stor159[address(arg2)][address(arg1)].field_256 = 0
                                if stor159[address(arg2)][address(arg1)].field_0 < 0:
                                    if stor159[address(arg2)][address(arg1)].field_0 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    emit CreditMinted(-stor159[address(arg2)][address(arg1)].field_0, arg1, arg2);
                                else:
                                    if 0 < stor159[address(arg2)][address(arg1)].field_0:
                                        if 0 > stor159[address(arg2)][address(arg1)].field_0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        emit CreditBurned(stor159[address(arg2)][address(arg1)].field_0, arg1, arg2);
                            else:
                                if ((block.timestamp * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) - (stor159[address(arg2)][address(arg1)].field_192 * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg2)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                    revert with 0, 
                                                32,
                                                39,
                                                0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                mem[(32 * stor152.length) + 459 len 25]
                                if block.timestamp >= 4294967296:
                                    revert with 0, 
                                                32,
                                                38,
                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                mem[(32 * stor152.length) + 458 len 26]
                                stor159[address(arg2)][address(arg1)].field_0 = uint128(((block.timestamp * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) - (stor159[address(arg2)][address(arg1)].field_192 * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg2)][address(arg1)].field_0)
                                stor159[address(arg2)][address(arg1)].field_128 = 0
                                stor159[address(arg2)][address(arg1)].field_192 = uint32(block.timestamp)
                                stor159[address(arg2)][address(arg1)].field_224 = 1
                                if stor159[address(arg2)][address(arg1)].field_0 < ((block.timestamp * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) - (stor159[address(arg2)][address(arg1)].field_192 * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg2)][address(arg1)].field_0:
                                    if stor159[address(arg2)][address(arg1)].field_0 > ((block.timestamp * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) - (stor159[address(arg2)][address(arg1)].field_192 * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg2)][address(arg1)].field_0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    emit CreditMinted(((block.timestamp * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) - (stor159[address(arg2)][address(arg1)].field_192 * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) / 10^18), arg1, arg2);
                                else:
                                    if ((block.timestamp * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) - (stor159[address(arg2)][address(arg1)].field_192 * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg2)][address(arg1)].field_0 < stor159[address(arg2)][address(arg1)].field_0:
                                        if ((block.timestamp * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) - (stor159[address(arg2)][address(arg1)].field_192 * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg2)][address(arg1)].field_0 > stor159[address(arg2)][address(arg1)].field_0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        emit CreditBurned(-((block.timestamp * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) - (stor159[address(arg2)][address(arg1)].field_192 * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) / 10^18), arg1, arg2);
                        else:
                            if ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / creditPlanOf[address(arg2)].field_0 != ext_call.return_data[0]:
                                revert with 0, 
                                            32,
                                            33,
                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[(32 * stor152.length) + 293 len 31]
                            if ((block.timestamp * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) - (stor159[address(arg2)][address(arg1)].field_192 * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg2)][address(arg1)].field_0 <= ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18:
                                if ((block.timestamp * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) - (stor159[address(arg2)][address(arg1)].field_192 * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg2)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                    revert with 0, 
                                                32,
                                                39,
                                                0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                mem[(32 * stor152.length) + 459 len 25]
                                if block.timestamp >= 4294967296:
                                    revert with 0, 
                                                32,
                                                38,
                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                mem[(32 * stor152.length) + 458 len 26]
                                stor159[address(arg2)][address(arg1)].field_0 = uint128(((block.timestamp * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) - (stor159[address(arg2)][address(arg1)].field_192 * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg2)][address(arg1)].field_0)
                                stor159[address(arg2)][address(arg1)].field_128 = 0
                                stor159[address(arg2)][address(arg1)].field_192 = uint32(block.timestamp)
                                stor159[address(arg2)][address(arg1)].field_224 = 1
                                if stor159[address(arg2)][address(arg1)].field_0 < ((block.timestamp * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) - (stor159[address(arg2)][address(arg1)].field_192 * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg2)][address(arg1)].field_0:
                                    if stor159[address(arg2)][address(arg1)].field_0 > ((block.timestamp * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) - (stor159[address(arg2)][address(arg1)].field_192 * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg2)][address(arg1)].field_0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    emit CreditMinted(((block.timestamp * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) - (stor159[address(arg2)][address(arg1)].field_192 * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) / 10^18), arg1, arg2);
                                else:
                                    if ((block.timestamp * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) - (stor159[address(arg2)][address(arg1)].field_192 * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg2)][address(arg1)].field_0 < stor159[address(arg2)][address(arg1)].field_0:
                                        if ((block.timestamp * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) - (stor159[address(arg2)][address(arg1)].field_192 * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg2)][address(arg1)].field_0 > stor159[address(arg2)][address(arg1)].field_0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        emit CreditBurned(-((block.timestamp * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) - (stor159[address(arg2)][address(arg1)].field_192 * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) / 10^18), arg1, arg2);
                            else:
                                if ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18 >= 0x100000000000000000000000000000000:
                                    revert with 0, 
                                                32,
                                                39,
                                                0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                mem[(32 * stor152.length) + 459 len 25]
                                if block.timestamp >= 4294967296:
                                    revert with 0, 
                                                32,
                                                38,
                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                mem[(32 * stor152.length) + 458 len 26]
                                stor159[address(arg2)][address(arg1)].field_0 = uint128(ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18)
                                stor159[address(arg2)][address(arg1)].field_128 = 0
                                stor159[address(arg2)][address(arg1)].field_192 = uint32(block.timestamp)
                                stor159[address(arg2)][address(arg1)].field_224 = 1
                                if stor159[address(arg2)][address(arg1)].field_0 < ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    if stor159[address(arg2)][address(arg1)].field_0 > ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    emit CreditMinted(((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18) - stor159[address(arg2)][address(arg1)].field_0), arg1, arg2);
                                else:
                                    if ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18 < stor159[address(arg2)][address(arg1)].field_0:
                                        if ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18 > stor159[address(arg2)][address(arg1)].field_0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        emit CreditBurned((stor159[address(arg2)][address(arg1)].field_0 - (ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18)), arg1, arg2);
        return stor159[address(arg2)][address(arg1)].field_0
    revert with 0, 'mPrizePool/unknown-token'
}

function calculateEarlyExitFee(address arg1, address arg2, uint256 arg3) payable {
    require calldata.size - 4 >= 96
    require ext_code.size(arg2)
    staticcall arg2.0x70a08231 with:
            gas gas_remaining wei
           args arg1
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if ext_call.return_data[0] < arg3:
        revert with 0, 'PrizePool/insuff-funds'
    if not stor159[address(arg2)][address(arg1)].field_224:
        if block.timestamp >= 4294967296:
            revert with 0, 32, 38, 0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400, mem[298 len 26]
        stor159[address(arg2)][address(arg1)].field_0 = 0
        stor159[address(arg2)][address(arg1)].field_192 = uint32(block.timestamp)
        stor159[address(arg2)][address(arg1)].field_224 = 1
        stor159[address(arg2)][address(arg1)].field_256 = 0
        if stor159[address(arg2)][address(arg1)].field_0 < 0:
            if stor159[address(arg2)][address(arg1)].field_0 > 0:
                revert with 0, 'SafeMath: subtraction overflow'
            emit CreditMinted(-stor159[address(arg2)][address(arg1)].field_0, arg1, arg2);
        else:
            if 0 < stor159[address(arg2)][address(arg1)].field_0:
                if 0 > stor159[address(arg2)][address(arg1)].field_0:
                    revert with 0, 'SafeMath: subtraction overflow'
                emit CreditBurned(stor159[address(arg2)][address(arg1)].field_0, arg1, arg2);
        if arg3 > ext_call.return_data[0]:
            revert with 0, 'SafeMath: subtraction overflow'
        if not creditPlanOf[address(arg2)].field_0:
            if not maxExitFeeMantissa:
                if 0 > stor159[address(arg2)][address(arg1)].field_0:
                    if not creditPlanOf[address(arg2)].field_0:
                        if not maxExitFeeMantissa:
                            return 0
                        if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[485 len 31]
                        if 0 <= arg3 * maxExitFeeMantissa / 10^18:
                            return 0
                    else:
                        if arg3 * creditPlanOf[address(arg2)].field_0 / creditPlanOf[address(arg2)].field_0 != arg3:
                            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[421 len 31]
                        if not maxExitFeeMantissa:
                            if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > 0:
                                return 0
                            if 0 <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                return arg3 * creditPlanOf[address(arg2)].field_0 / 10^18, 0
                            if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                        if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[485 len 31]
                        if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 <= arg3 * maxExitFeeMantissa / 10^18:
                            if 0 <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                return arg3 * creditPlanOf[address(arg2)].field_0 / 10^18, 0
                            if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                        if 0 <= arg3 * maxExitFeeMantissa / 10^18:
                            return arg3 * maxExitFeeMantissa / 10^18, 0
                    ('gt', 0, ('div', ('mul', ('param', 'arg3'), ('stor', ('name', 'maxExitFeeMantissa', 154))), 1000000000000000000))
                else:
                    if 0 > stor159[address(arg2)][address(arg1)].field_0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not creditPlanOf[address(arg2)].field_0:
                        if not maxExitFeeMantissa:
                            if stor159[address(arg2)][address(arg1)].field_0 > 0:
                                return 0
                            return -stor159[address(arg2)][address(arg1)].field_0, stor159[address(arg2)][address(arg1)].field_0
                        if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[485 len 31]
                        if 0 <= arg3 * maxExitFeeMantissa / 10^18:
                            if stor159[address(arg2)][address(arg1)].field_0 > 0:
                                return 0
                            return -stor159[address(arg2)][address(arg1)].field_0, stor159[address(arg2)][address(arg1)].field_0
                    else:
                        if arg3 * creditPlanOf[address(arg2)].field_0 / creditPlanOf[address(arg2)].field_0 != arg3:
                            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[421 len 31]
                        if not maxExitFeeMantissa:
                            if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > 0:
                                if stor159[address(arg2)][address(arg1)].field_0 > 0:
                                    return 0
                                return -stor159[address(arg2)][address(arg1)].field_0, stor159[address(arg2)][address(arg1)].field_0
                            if stor159[address(arg2)][address(arg1)].field_0 <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                return (arg3 * creditPlanOf[address(arg2)].field_0 / 10^18) - stor159[address(arg2)][address(arg1)].field_0, 
                                       stor159[address(arg2)][address(arg1)].field_0
                            if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                        if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[485 len 31]
                        if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 <= arg3 * maxExitFeeMantissa / 10^18:
                            if stor159[address(arg2)][address(arg1)].field_0 <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                return (arg3 * creditPlanOf[address(arg2)].field_0 / 10^18) - stor159[address(arg2)][address(arg1)].field_0, 
                                       stor159[address(arg2)][address(arg1)].field_0
                            if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                    if stor159[address(arg2)][address(arg1)].field_0 <= arg3 * maxExitFeeMantissa / 10^18:
                        return (arg3 * maxExitFeeMantissa / 10^18) - stor159[address(arg2)][address(arg1)].field_0, 
                               stor159[address(arg2)][address(arg1)].field_0
            else:
                if (ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / maxExitFeeMantissa != ext_call.return_data[0] - arg3:
                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[357 len 31]
                if 0 <= (ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18:
                    if 0 > stor159[address(arg2)][address(arg1)].field_0:
                        if not creditPlanOf[address(arg2)].field_0:
                            if not maxExitFeeMantissa:
                                return 0
                            if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[485 len 31]
                            if 0 <= arg3 * maxExitFeeMantissa / 10^18:
                                return 0
                        else:
                            if arg3 * creditPlanOf[address(arg2)].field_0 / creditPlanOf[address(arg2)].field_0 != arg3:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[421 len 31]
                            if not maxExitFeeMantissa:
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > 0:
                                    return 0
                                if 0 <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    return arg3 * creditPlanOf[address(arg2)].field_0 / 10^18, 0
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                            if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[485 len 31]
                            if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 <= arg3 * maxExitFeeMantissa / 10^18:
                                if 0 <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    return arg3 * creditPlanOf[address(arg2)].field_0 / 10^18, 0
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                            if 0 <= arg3 * maxExitFeeMantissa / 10^18:
                                return arg3 * maxExitFeeMantissa / 10^18, 0
                        ('gt', 0, ('div', ('mul', ('param', 'arg3'), ('stor', ('name', 'maxExitFeeMantissa', 154))), 1000000000000000000))
                    else:
                        if 0 > stor159[address(arg2)][address(arg1)].field_0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if not creditPlanOf[address(arg2)].field_0:
                            if not maxExitFeeMantissa:
                                if stor159[address(arg2)][address(arg1)].field_0 > 0:
                                    return 0
                                return -stor159[address(arg2)][address(arg1)].field_0, stor159[address(arg2)][address(arg1)].field_0
                            if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[485 len 31]
                            if 0 <= arg3 * maxExitFeeMantissa / 10^18:
                                if stor159[address(arg2)][address(arg1)].field_0 > 0:
                                    return 0
                                return -stor159[address(arg2)][address(arg1)].field_0, stor159[address(arg2)][address(arg1)].field_0
                        else:
                            if arg3 * creditPlanOf[address(arg2)].field_0 / creditPlanOf[address(arg2)].field_0 != arg3:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[421 len 31]
                            if not maxExitFeeMantissa:
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > 0:
                                    if stor159[address(arg2)][address(arg1)].field_0 > 0:
                                        return 0
                                    return -stor159[address(arg2)][address(arg1)].field_0, stor159[address(arg2)][address(arg1)].field_0
                                if stor159[address(arg2)][address(arg1)].field_0 <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    return (arg3 * creditPlanOf[address(arg2)].field_0 / 10^18) - stor159[address(arg2)][address(arg1)].field_0, 
                                           stor159[address(arg2)][address(arg1)].field_0
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                            if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[485 len 31]
                            if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 <= arg3 * maxExitFeeMantissa / 10^18:
                                if stor159[address(arg2)][address(arg1)].field_0 <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    return (arg3 * creditPlanOf[address(arg2)].field_0 / 10^18) - stor159[address(arg2)][address(arg1)].field_0, 
                                           stor159[address(arg2)][address(arg1)].field_0
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                        if stor159[address(arg2)][address(arg1)].field_0 <= arg3 * maxExitFeeMantissa / 10^18:
                            return (arg3 * maxExitFeeMantissa / 10^18) - stor159[address(arg2)][address(arg1)].field_0, 
                                   stor159[address(arg2)][address(arg1)].field_0
                else:
                    if (ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18 > stor159[address(arg2)][address(arg1)].field_0:
                        if not creditPlanOf[address(arg2)].field_0:
                            if not maxExitFeeMantissa:
                                return 0
                            if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[485 len 31]
                            if 0 <= arg3 * maxExitFeeMantissa / 10^18:
                                return 0
                        else:
                            if arg3 * creditPlanOf[address(arg2)].field_0 / creditPlanOf[address(arg2)].field_0 != arg3:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[421 len 31]
                            if not maxExitFeeMantissa:
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > 0:
                                    return 0
                                if 0 <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    return arg3 * creditPlanOf[address(arg2)].field_0 / 10^18, 0
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                            if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[485 len 31]
                            if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 <= arg3 * maxExitFeeMantissa / 10^18:
                                if 0 <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    return arg3 * creditPlanOf[address(arg2)].field_0 / 10^18, 0
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                            if 0 <= arg3 * maxExitFeeMantissa / 10^18:
                                return arg3 * maxExitFeeMantissa / 10^18, 0
                        ('gt', 0, ('div', ('mul', ('param', 'arg3'), ('stor', ('name', 'maxExitFeeMantissa', 154))), 1000000000000000000))
                    else:
                        if (ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18 > stor159[address(arg2)][address(arg1)].field_0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if not creditPlanOf[address(arg2)].field_0:
                            if not maxExitFeeMantissa:
                                if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18) > 0:
                                    return 0
                                return -stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18), 
                                       stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18)
                            if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[485 len 31]
                            if 0 <= arg3 * maxExitFeeMantissa / 10^18:
                                if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18) > 0:
                                    return 0
                                return -stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18), 
                                       stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18)
                        else:
                            if arg3 * creditPlanOf[address(arg2)].field_0 / creditPlanOf[address(arg2)].field_0 != arg3:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[421 len 31]
                            if not maxExitFeeMantissa:
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > 0:
                                    if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18) > 0:
                                        return 0
                                    return -stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18), 
                                           stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18)
                                if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18) <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    return (arg3 * creditPlanOf[address(arg2)].field_0 / 10^18) - stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18), 
                                           stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18)
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                            if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[485 len 31]
                            if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 <= arg3 * maxExitFeeMantissa / 10^18:
                                if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18) <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    return (arg3 * creditPlanOf[address(arg2)].field_0 / 10^18) - stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18), 
                                           stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18)
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                        if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18) <= arg3 * maxExitFeeMantissa / 10^18:
                            return (arg3 * maxExitFeeMantissa / 10^18) - stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18), 
                                   stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18)
        else:
            if (ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / creditPlanOf[address(arg2)].field_0 != ext_call.return_data[0] - arg3:
                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[293 len 31]
            if not maxExitFeeMantissa:
                if (ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18 <= 0:
                    if (ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18 > stor159[address(arg2)][address(arg1)].field_0:
                        if not creditPlanOf[address(arg2)].field_0:
                            if not maxExitFeeMantissa:
                                return 0
                            if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[485 len 31]
                            if 0 <= arg3 * maxExitFeeMantissa / 10^18:
                                return 0
                        else:
                            if arg3 * creditPlanOf[address(arg2)].field_0 / creditPlanOf[address(arg2)].field_0 != arg3:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[421 len 31]
                            if not maxExitFeeMantissa:
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > 0:
                                    return 0
                                if 0 <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    return arg3 * creditPlanOf[address(arg2)].field_0 / 10^18, 0
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                            if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[485 len 31]
                            if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 <= arg3 * maxExitFeeMantissa / 10^18:
                                if 0 <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    return arg3 * creditPlanOf[address(arg2)].field_0 / 10^18, 0
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                            if 0 <= arg3 * maxExitFeeMantissa / 10^18:
                                return arg3 * maxExitFeeMantissa / 10^18, 0
                        ('gt', 0, ('div', ('mul', ('param', 'arg3'), ('stor', ('name', 'maxExitFeeMantissa', 154))), 1000000000000000000))
                    else:
                        if (ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18 > stor159[address(arg2)][address(arg1)].field_0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if not creditPlanOf[address(arg2)].field_0:
                            if not maxExitFeeMantissa:
                                if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18) > 0:
                                    return 0
                                return -stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18), 
                                       stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18)
                            if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[485 len 31]
                            if 0 <= arg3 * maxExitFeeMantissa / 10^18:
                                if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18) > 0:
                                    return 0
                                return -stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18), 
                                       stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18)
                        else:
                            if arg3 * creditPlanOf[address(arg2)].field_0 / creditPlanOf[address(arg2)].field_0 != arg3:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[421 len 31]
                            if not maxExitFeeMantissa:
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > 0:
                                    if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18) > 0:
                                        return 0
                                    return -stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18), 
                                           stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18)
                                if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18) <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    return (arg3 * creditPlanOf[address(arg2)].field_0 / 10^18) - stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18), 
                                           stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18)
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                            if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[485 len 31]
                            if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 <= arg3 * maxExitFeeMantissa / 10^18:
                                if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18) <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    return (arg3 * creditPlanOf[address(arg2)].field_0 / 10^18) - stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18), 
                                           stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18)
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                        if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18) <= arg3 * maxExitFeeMantissa / 10^18:
                            return (arg3 * maxExitFeeMantissa / 10^18) - stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18), 
                                   stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18)
                else:
                    if 0 > stor159[address(arg2)][address(arg1)].field_0:
                        if not creditPlanOf[address(arg2)].field_0:
                            if not maxExitFeeMantissa:
                                return 0
                            if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[485 len 31]
                            if 0 <= arg3 * maxExitFeeMantissa / 10^18:
                                return 0
                        else:
                            if arg3 * creditPlanOf[address(arg2)].field_0 / creditPlanOf[address(arg2)].field_0 != arg3:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[421 len 31]
                            if not maxExitFeeMantissa:
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > 0:
                                    return 0
                                if 0 <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    return arg3 * creditPlanOf[address(arg2)].field_0 / 10^18, 0
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                            if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[485 len 31]
                            if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 <= arg3 * maxExitFeeMantissa / 10^18:
                                if 0 <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    return arg3 * creditPlanOf[address(arg2)].field_0 / 10^18, 0
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                            if 0 <= arg3 * maxExitFeeMantissa / 10^18:
                                return arg3 * maxExitFeeMantissa / 10^18, 0
                        ('gt', 0, ('div', ('mul', ('param', 'arg3'), ('stor', ('name', 'maxExitFeeMantissa', 154))), 1000000000000000000))
                    else:
                        if 0 > stor159[address(arg2)][address(arg1)].field_0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if not creditPlanOf[address(arg2)].field_0:
                            if not maxExitFeeMantissa:
                                if stor159[address(arg2)][address(arg1)].field_0 > 0:
                                    return 0
                                return -stor159[address(arg2)][address(arg1)].field_0, stor159[address(arg2)][address(arg1)].field_0
                            if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[485 len 31]
                            if 0 <= arg3 * maxExitFeeMantissa / 10^18:
                                if stor159[address(arg2)][address(arg1)].field_0 > 0:
                                    return 0
                                return -stor159[address(arg2)][address(arg1)].field_0, stor159[address(arg2)][address(arg1)].field_0
                        else:
                            if arg3 * creditPlanOf[address(arg2)].field_0 / creditPlanOf[address(arg2)].field_0 != arg3:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[421 len 31]
                            if not maxExitFeeMantissa:
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > 0:
                                    if stor159[address(arg2)][address(arg1)].field_0 > 0:
                                        return 0
                                    return -stor159[address(arg2)][address(arg1)].field_0, stor159[address(arg2)][address(arg1)].field_0
                                if stor159[address(arg2)][address(arg1)].field_0 <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    return (arg3 * creditPlanOf[address(arg2)].field_0 / 10^18) - stor159[address(arg2)][address(arg1)].field_0, 
                                           stor159[address(arg2)][address(arg1)].field_0
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                            if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[485 len 31]
                            if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 <= arg3 * maxExitFeeMantissa / 10^18:
                                if stor159[address(arg2)][address(arg1)].field_0 <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    return (arg3 * creditPlanOf[address(arg2)].field_0 / 10^18) - stor159[address(arg2)][address(arg1)].field_0, 
                                           stor159[address(arg2)][address(arg1)].field_0
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                        if stor159[address(arg2)][address(arg1)].field_0 <= arg3 * maxExitFeeMantissa / 10^18:
                            return (arg3 * maxExitFeeMantissa / 10^18) - stor159[address(arg2)][address(arg1)].field_0, 
                                   stor159[address(arg2)][address(arg1)].field_0
            else:
                if (ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / maxExitFeeMantissa != ext_call.return_data[0] - arg3:
                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[357 len 31]
                if (ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18 <= (ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18:
                    if (ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18 > stor159[address(arg2)][address(arg1)].field_0:
                        if not creditPlanOf[address(arg2)].field_0:
                            if not maxExitFeeMantissa:
                                return 0
                            if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[485 len 31]
                            if 0 <= arg3 * maxExitFeeMantissa / 10^18:
                                return 0
                        else:
                            if arg3 * creditPlanOf[address(arg2)].field_0 / creditPlanOf[address(arg2)].field_0 != arg3:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[421 len 31]
                            if not maxExitFeeMantissa:
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > 0:
                                    return 0
                                if 0 <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    return arg3 * creditPlanOf[address(arg2)].field_0 / 10^18, 0
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                            if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[485 len 31]
                            if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 <= arg3 * maxExitFeeMantissa / 10^18:
                                if 0 <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    return arg3 * creditPlanOf[address(arg2)].field_0 / 10^18, 0
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                            if 0 <= arg3 * maxExitFeeMantissa / 10^18:
                                return arg3 * maxExitFeeMantissa / 10^18, 0
                        ('gt', 0, ('div', ('mul', ('param', 'arg3'), ('stor', ('name', 'maxExitFeeMantissa', 154))), 1000000000000000000))
                    else:
                        if (ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18 > stor159[address(arg2)][address(arg1)].field_0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if not creditPlanOf[address(arg2)].field_0:
                            if not maxExitFeeMantissa:
                                if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18) > 0:
                                    return 0
                                return -stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18), 
                                       stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18)
                            if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[485 len 31]
                            if 0 <= arg3 * maxExitFeeMantissa / 10^18:
                                if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18) > 0:
                                    return 0
                                return -stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18), 
                                       stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18)
                        else:
                            if arg3 * creditPlanOf[address(arg2)].field_0 / creditPlanOf[address(arg2)].field_0 != arg3:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[421 len 31]
                            if not maxExitFeeMantissa:
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > 0:
                                    if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18) > 0:
                                        return 0
                                    return -stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18), 
                                           stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18)
                                if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18) <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    return (arg3 * creditPlanOf[address(arg2)].field_0 / 10^18) - stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18), 
                                           stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18)
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                            if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[485 len 31]
                            if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 <= arg3 * maxExitFeeMantissa / 10^18:
                                if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18) <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    return (arg3 * creditPlanOf[address(arg2)].field_0 / 10^18) - stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18), 
                                           stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18)
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                        if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18) <= arg3 * maxExitFeeMantissa / 10^18:
                            return (arg3 * maxExitFeeMantissa / 10^18) - stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18), 
                                   stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18)
                else:
                    if (ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18 > stor159[address(arg2)][address(arg1)].field_0:
                        if not creditPlanOf[address(arg2)].field_0:
                            if not maxExitFeeMantissa:
                                return 0
                            if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[485 len 31]
                            if 0 <= arg3 * maxExitFeeMantissa / 10^18:
                                return 0
                        else:
                            if arg3 * creditPlanOf[address(arg2)].field_0 / creditPlanOf[address(arg2)].field_0 != arg3:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[421 len 31]
                            if not maxExitFeeMantissa:
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > 0:
                                    return 0
                                if 0 <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    return arg3 * creditPlanOf[address(arg2)].field_0 / 10^18, 0
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                            if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[485 len 31]
                            if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 <= arg3 * maxExitFeeMantissa / 10^18:
                                if 0 <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    return arg3 * creditPlanOf[address(arg2)].field_0 / 10^18, 0
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                            if 0 <= arg3 * maxExitFeeMantissa / 10^18:
                                return arg3 * maxExitFeeMantissa / 10^18, 0
                        ('gt', 0, ('div', ('mul', ('param', 'arg3'), ('stor', ('name', 'maxExitFeeMantissa', 154))), 1000000000000000000))
                    else:
                        if (ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18 > stor159[address(arg2)][address(arg1)].field_0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if not creditPlanOf[address(arg2)].field_0:
                            if not maxExitFeeMantissa:
                                if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18) > 0:
                                    return 0
                                return -stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18), 
                                       stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18)
                            if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[485 len 31]
                            if 0 <= arg3 * maxExitFeeMantissa / 10^18:
                                if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18) > 0:
                                    return 0
                                return -stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18), 
                                       stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18)
                        else:
                            if arg3 * creditPlanOf[address(arg2)].field_0 / creditPlanOf[address(arg2)].field_0 != arg3:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[421 len 31]
                            if not maxExitFeeMantissa:
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > 0:
                                    if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18) > 0:
                                        return 0
                                    return -stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18), 
                                           stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18)
                                if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18) <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    return (arg3 * creditPlanOf[address(arg2)].field_0 / 10^18) - stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18), 
                                           stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18)
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                            if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[485 len 31]
                            if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 <= arg3 * maxExitFeeMantissa / 10^18:
                                if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18) <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    return (arg3 * creditPlanOf[address(arg2)].field_0 / 10^18) - stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18), 
                                           stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18)
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                        if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18) <= arg3 * maxExitFeeMantissa / 10^18:
                            return (arg3 * maxExitFeeMantissa / 10^18) - stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18), 
                                   stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18)
    else:
        if not stor159[address(arg2)][address(arg1)].field_224:
            if stor159[address(arg2)][address(arg1)].field_0 < stor159[address(arg2)][address(arg1)].field_0:
                revert with 0, 'SafeMath: addition overflow'
            if not creditPlanOf[address(arg2)].field_0:
                if stor159[address(arg2)][address(arg1)].field_0 > 0:
                    if block.timestamp >= 4294967296:
                        revert with 0, 32, 38, 0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400, mem[362 len 26]
                    stor159[address(arg2)][address(arg1)].field_0 = 0
                    stor159[address(arg2)][address(arg1)].field_192 = uint32(block.timestamp)
                    stor159[address(arg2)][address(arg1)].field_224 = 1
                    stor159[address(arg2)][address(arg1)].field_256 = 0
                    if stor159[address(arg2)][address(arg1)].field_0 < 0:
                        if stor159[address(arg2)][address(arg1)].field_0 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        emit CreditMinted(-stor159[address(arg2)][address(arg1)].field_0, arg1, arg2);
                    else:
                        if 0 < stor159[address(arg2)][address(arg1)].field_0:
                            if 0 > stor159[address(arg2)][address(arg1)].field_0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            emit CreditBurned(stor159[address(arg2)][address(arg1)].field_0, arg1, arg2);
                else:
                    if stor159[address(arg2)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                        revert with 0, 32, 39, 0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974, mem[363 len 25]
                    if block.timestamp >= 4294967296:
                        revert with 0, 32, 38, 0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400, mem[362 len 26]
                    stor159[address(arg2)][address(arg1)].field_0 = stor159[address(arg2)][address(arg1)].field_0
                    stor159[address(arg2)][address(arg1)].field_128 = 0
                    stor159[address(arg2)][address(arg1)].field_192 = uint32(block.timestamp)
                    stor159[address(arg2)][address(arg1)].field_224 = 1
                    if stor159[address(arg2)][address(arg1)].field_0 < stor159[address(arg2)][address(arg1)].field_0:
                        if stor159[address(arg2)][address(arg1)].field_0 > stor159[address(arg2)][address(arg1)].field_0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        emit CreditMinted(0, arg1, arg2);
                    else:
                        if stor159[address(arg2)][address(arg1)].field_0 < stor159[address(arg2)][address(arg1)].field_0:
                            if stor159[address(arg2)][address(arg1)].field_0 > stor159[address(arg2)][address(arg1)].field_0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            emit CreditBurned(0, arg1, arg2);
            else:
                if ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / creditPlanOf[address(arg2)].field_0 != ext_call.return_data[0]:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if stor159[address(arg2)][address(arg1)].field_0 <= ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18:
                    if stor159[address(arg2)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                        revert with 0, 32, 39, 0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974, mem[363 len 25]
                    if block.timestamp >= 4294967296:
                        revert with 0, 32, 38, 0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400, mem[362 len 26]
                    stor159[address(arg2)][address(arg1)].field_0 = stor159[address(arg2)][address(arg1)].field_0
                    stor159[address(arg2)][address(arg1)].field_128 = 0
                    stor159[address(arg2)][address(arg1)].field_192 = uint32(block.timestamp)
                    stor159[address(arg2)][address(arg1)].field_224 = 1
                    if stor159[address(arg2)][address(arg1)].field_0 < stor159[address(arg2)][address(arg1)].field_0:
                        if stor159[address(arg2)][address(arg1)].field_0 > stor159[address(arg2)][address(arg1)].field_0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        emit CreditMinted(0, arg1, arg2);
                    else:
                        if stor159[address(arg2)][address(arg1)].field_0 < stor159[address(arg2)][address(arg1)].field_0:
                            if stor159[address(arg2)][address(arg1)].field_0 > stor159[address(arg2)][address(arg1)].field_0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            emit CreditBurned(0, arg1, arg2);
                else:
                    if ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18 >= 0x100000000000000000000000000000000:
                        revert with 0, 32, 39, 0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974, mem[363 len 25]
                    if block.timestamp >= 4294967296:
                        revert with 0, 32, 38, 0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400, mem[362 len 26]
                    stor159[address(arg2)][address(arg1)].field_0 = uint128(ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18)
                    stor159[address(arg2)][address(arg1)].field_128 = 0
                    stor159[address(arg2)][address(arg1)].field_192 = uint32(block.timestamp)
                    stor159[address(arg2)][address(arg1)].field_224 = 1
                    if stor159[address(arg2)][address(arg1)].field_0 < ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18:
                        if stor159[address(arg2)][address(arg1)].field_0 > ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18:
                            revert with 0, 'SafeMath: subtraction overflow'
                        emit CreditMinted(((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18) - stor159[address(arg2)][address(arg1)].field_0), arg1, arg2);
                    else:
                        if ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18 < stor159[address(arg2)][address(arg1)].field_0:
                            if ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18 > stor159[address(arg2)][address(arg1)].field_0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            emit CreditBurned((stor159[address(arg2)][address(arg1)].field_0 - (ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18)), arg1, arg2);
            if arg3 > ext_call.return_data[0]:
                revert with 0, 'SafeMath: subtraction overflow'
            if not creditPlanOf[address(arg2)].field_0:
                if not maxExitFeeMantissa:
                    if 0 > stor159[address(arg2)][address(arg1)].field_0:
                        if not creditPlanOf[address(arg2)].field_0:
                            if not maxExitFeeMantissa:
                                return 0
                            if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[549 len 31]
                            if 0 <= arg3 * maxExitFeeMantissa / 10^18:
                                return 0
                        else:
                            if arg3 * creditPlanOf[address(arg2)].field_0 / creditPlanOf[address(arg2)].field_0 != arg3:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[485 len 31]
                            if not maxExitFeeMantissa:
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > 0:
                                    return 0
                                if 0 <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    return arg3 * creditPlanOf[address(arg2)].field_0 / 10^18, 0
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                            if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[549 len 31]
                            if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 <= arg3 * maxExitFeeMantissa / 10^18:
                                if 0 <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    return arg3 * creditPlanOf[address(arg2)].field_0 / 10^18, 0
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                            if 0 <= arg3 * maxExitFeeMantissa / 10^18:
                                return arg3 * maxExitFeeMantissa / 10^18, 0
                        ('gt', 0, ('div', ('mul', ('param', 'arg3'), ('stor', ('name', 'maxExitFeeMantissa', 154))), 1000000000000000000))
                    else:
                        if 0 > stor159[address(arg2)][address(arg1)].field_0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if not creditPlanOf[address(arg2)].field_0:
                            if not maxExitFeeMantissa:
                                if stor159[address(arg2)][address(arg1)].field_0 > 0:
                                    return 0
                                return -stor159[address(arg2)][address(arg1)].field_0, stor159[address(arg2)][address(arg1)].field_0
                            if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[549 len 31]
                            if 0 <= arg3 * maxExitFeeMantissa / 10^18:
                                if stor159[address(arg2)][address(arg1)].field_0 > 0:
                                    return 0
                                return -stor159[address(arg2)][address(arg1)].field_0, stor159[address(arg2)][address(arg1)].field_0
                        else:
                            if arg3 * creditPlanOf[address(arg2)].field_0 / creditPlanOf[address(arg2)].field_0 != arg3:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[485 len 31]
                            if not maxExitFeeMantissa:
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > 0:
                                    if stor159[address(arg2)][address(arg1)].field_0 > 0:
                                        return 0
                                    return -stor159[address(arg2)][address(arg1)].field_0, stor159[address(arg2)][address(arg1)].field_0
                                if stor159[address(arg2)][address(arg1)].field_0 <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    return (arg3 * creditPlanOf[address(arg2)].field_0 / 10^18) - stor159[address(arg2)][address(arg1)].field_0, 
                                           stor159[address(arg2)][address(arg1)].field_0
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                            if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[549 len 31]
                            if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 <= arg3 * maxExitFeeMantissa / 10^18:
                                if stor159[address(arg2)][address(arg1)].field_0 <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    return (arg3 * creditPlanOf[address(arg2)].field_0 / 10^18) - stor159[address(arg2)][address(arg1)].field_0, 
                                           stor159[address(arg2)][address(arg1)].field_0
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                        if stor159[address(arg2)][address(arg1)].field_0 <= arg3 * maxExitFeeMantissa / 10^18:
                            return (arg3 * maxExitFeeMantissa / 10^18) - stor159[address(arg2)][address(arg1)].field_0, 
                                   stor159[address(arg2)][address(arg1)].field_0
                else:
                    if (ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / maxExitFeeMantissa != ext_call.return_data[0] - arg3:
                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[421 len 31]
                    if 0 <= (ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18:
                        if 0 > stor159[address(arg2)][address(arg1)].field_0:
                            if not creditPlanOf[address(arg2)].field_0:
                                if not maxExitFeeMantissa:
                                    return 0
                                if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[549 len 31]
                                if 0 <= arg3 * maxExitFeeMantissa / 10^18:
                                    return 0
                            else:
                                if arg3 * creditPlanOf[address(arg2)].field_0 / creditPlanOf[address(arg2)].field_0 != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[485 len 31]
                                if not maxExitFeeMantissa:
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > 0:
                                        return 0
                                    if 0 <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        return arg3 * creditPlanOf[address(arg2)].field_0 / 10^18, 0
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                                if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[549 len 31]
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 <= arg3 * maxExitFeeMantissa / 10^18:
                                    if 0 <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        return arg3 * creditPlanOf[address(arg2)].field_0 / 10^18, 0
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                                if 0 <= arg3 * maxExitFeeMantissa / 10^18:
                                    return arg3 * maxExitFeeMantissa / 10^18, 0
                            ('gt', 0, ('div', ('mul', ('param', 'arg3'), ('stor', ('name', 'maxExitFeeMantissa', 154))), 1000000000000000000))
                        else:
                            if 0 > stor159[address(arg2)][address(arg1)].field_0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if not creditPlanOf[address(arg2)].field_0:
                                if not maxExitFeeMantissa:
                                    if stor159[address(arg2)][address(arg1)].field_0 > 0:
                                        return 0
                                    return -stor159[address(arg2)][address(arg1)].field_0, stor159[address(arg2)][address(arg1)].field_0
                                if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[549 len 31]
                                if 0 <= arg3 * maxExitFeeMantissa / 10^18:
                                    if stor159[address(arg2)][address(arg1)].field_0 > 0:
                                        return 0
                                    return -stor159[address(arg2)][address(arg1)].field_0, stor159[address(arg2)][address(arg1)].field_0
                            else:
                                if arg3 * creditPlanOf[address(arg2)].field_0 / creditPlanOf[address(arg2)].field_0 != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[485 len 31]
                                if not maxExitFeeMantissa:
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > 0:
                                        if stor159[address(arg2)][address(arg1)].field_0 > 0:
                                            return 0
                                        return -stor159[address(arg2)][address(arg1)].field_0, stor159[address(arg2)][address(arg1)].field_0
                                    if stor159[address(arg2)][address(arg1)].field_0 <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        return (arg3 * creditPlanOf[address(arg2)].field_0 / 10^18) - stor159[address(arg2)][address(arg1)].field_0, 
                                               stor159[address(arg2)][address(arg1)].field_0
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                                if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[549 len 31]
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 <= arg3 * maxExitFeeMantissa / 10^18:
                                    if stor159[address(arg2)][address(arg1)].field_0 <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        return (arg3 * creditPlanOf[address(arg2)].field_0 / 10^18) - stor159[address(arg2)][address(arg1)].field_0, 
                                               stor159[address(arg2)][address(arg1)].field_0
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                            if stor159[address(arg2)][address(arg1)].field_0 <= arg3 * maxExitFeeMantissa / 10^18:
                                return (arg3 * maxExitFeeMantissa / 10^18) - stor159[address(arg2)][address(arg1)].field_0, 
                                       stor159[address(arg2)][address(arg1)].field_0
                    else:
                        if (ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18 > stor159[address(arg2)][address(arg1)].field_0:
                            if not creditPlanOf[address(arg2)].field_0:
                                if not maxExitFeeMantissa:
                                    return 0
                                if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[549 len 31]
                                if 0 <= arg3 * maxExitFeeMantissa / 10^18:
                                    return 0
                            else:
                                if arg3 * creditPlanOf[address(arg2)].field_0 / creditPlanOf[address(arg2)].field_0 != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[485 len 31]
                                if not maxExitFeeMantissa:
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > 0:
                                        return 0
                                    if 0 <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        return arg3 * creditPlanOf[address(arg2)].field_0 / 10^18, 0
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                                if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[549 len 31]
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 <= arg3 * maxExitFeeMantissa / 10^18:
                                    if 0 <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        return arg3 * creditPlanOf[address(arg2)].field_0 / 10^18, 0
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                                if 0 <= arg3 * maxExitFeeMantissa / 10^18:
                                    return arg3 * maxExitFeeMantissa / 10^18, 0
                            ('gt', 0, ('div', ('mul', ('param', 'arg3'), ('stor', ('name', 'maxExitFeeMantissa', 154))), 1000000000000000000))
                        else:
                            if (ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18 > stor159[address(arg2)][address(arg1)].field_0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if not creditPlanOf[address(arg2)].field_0:
                                if not maxExitFeeMantissa:
                                    if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18) > 0:
                                        return 0
                                    return -stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18), 
                                           stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18)
                                if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[549 len 31]
                                if 0 <= arg3 * maxExitFeeMantissa / 10^18:
                                    if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18) > 0:
                                        return 0
                                    return -stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18), 
                                           stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18)
                            else:
                                if arg3 * creditPlanOf[address(arg2)].field_0 / creditPlanOf[address(arg2)].field_0 != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[485 len 31]
                                if not maxExitFeeMantissa:
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > 0:
                                        if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18) > 0:
                                            return 0
                                        return -stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18), 
                                               stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18)
                                    if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18) <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        return (arg3 * creditPlanOf[address(arg2)].field_0 / 10^18) - stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18), 
                                               stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18)
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                                if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[549 len 31]
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 <= arg3 * maxExitFeeMantissa / 10^18:
                                    if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18) <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        return (arg3 * creditPlanOf[address(arg2)].field_0 / 10^18) - stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18), 
                                               stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18)
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                            if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18) <= arg3 * maxExitFeeMantissa / 10^18:
                                return (arg3 * maxExitFeeMantissa / 10^18) - stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18), 
                                       stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18)
            else:
                if (ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / creditPlanOf[address(arg2)].field_0 != ext_call.return_data[0] - arg3:
                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[357 len 31]
                if not maxExitFeeMantissa:
                    if (ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18 <= 0:
                        if (ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18 > stor159[address(arg2)][address(arg1)].field_0:
                            if not creditPlanOf[address(arg2)].field_0:
                                if not maxExitFeeMantissa:
                                    return 0
                                if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[549 len 31]
                                if 0 <= arg3 * maxExitFeeMantissa / 10^18:
                                    return 0
                            else:
                                if arg3 * creditPlanOf[address(arg2)].field_0 / creditPlanOf[address(arg2)].field_0 != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[485 len 31]
                                if not maxExitFeeMantissa:
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > 0:
                                        return 0
                                    if 0 <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        return arg3 * creditPlanOf[address(arg2)].field_0 / 10^18, 0
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                                if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[549 len 31]
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 <= arg3 * maxExitFeeMantissa / 10^18:
                                    if 0 <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        return arg3 * creditPlanOf[address(arg2)].field_0 / 10^18, 0
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                                if 0 <= arg3 * maxExitFeeMantissa / 10^18:
                                    return arg3 * maxExitFeeMantissa / 10^18, 0
                            ('gt', 0, ('div', ('mul', ('param', 'arg3'), ('stor', ('name', 'maxExitFeeMantissa', 154))), 1000000000000000000))
                        else:
                            if (ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18 > stor159[address(arg2)][address(arg1)].field_0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if not creditPlanOf[address(arg2)].field_0:
                                if not maxExitFeeMantissa:
                                    if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18) > 0:
                                        return 0
                                    return -stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18), 
                                           stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18)
                                if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[549 len 31]
                                if 0 <= arg3 * maxExitFeeMantissa / 10^18:
                                    if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18) > 0:
                                        return 0
                                    return -stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18), 
                                           stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18)
                            else:
                                if arg3 * creditPlanOf[address(arg2)].field_0 / creditPlanOf[address(arg2)].field_0 != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[485 len 31]
                                if not maxExitFeeMantissa:
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > 0:
                                        if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18) > 0:
                                            return 0
                                        return -stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18), 
                                               stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18)
                                    if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18) <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        return (arg3 * creditPlanOf[address(arg2)].field_0 / 10^18) - stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18), 
                                               stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18)
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                                if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[549 len 31]
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 <= arg3 * maxExitFeeMantissa / 10^18:
                                    if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18) <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        return (arg3 * creditPlanOf[address(arg2)].field_0 / 10^18) - stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18), 
                                               stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18)
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                            if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18) <= arg3 * maxExitFeeMantissa / 10^18:
                                return (arg3 * maxExitFeeMantissa / 10^18) - stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18), 
                                       stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18)
                    else:
                        if 0 > stor159[address(arg2)][address(arg1)].field_0:
                            if not creditPlanOf[address(arg2)].field_0:
                                if not maxExitFeeMantissa:
                                    return 0
                                if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[549 len 31]
                                if 0 <= arg3 * maxExitFeeMantissa / 10^18:
                                    return 0
                            else:
                                if arg3 * creditPlanOf[address(arg2)].field_0 / creditPlanOf[address(arg2)].field_0 != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[485 len 31]
                                if not maxExitFeeMantissa:
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > 0:
                                        return 0
                                    if 0 <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        return arg3 * creditPlanOf[address(arg2)].field_0 / 10^18, 0
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                                if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[549 len 31]
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 <= arg3 * maxExitFeeMantissa / 10^18:
                                    if 0 <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        return arg3 * creditPlanOf[address(arg2)].field_0 / 10^18, 0
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                                if 0 <= arg3 * maxExitFeeMantissa / 10^18:
                                    return arg3 * maxExitFeeMantissa / 10^18, 0
                            ('gt', 0, ('div', ('mul', ('param', 'arg3'), ('stor', ('name', 'maxExitFeeMantissa', 154))), 1000000000000000000))
                        else:
                            if 0 > stor159[address(arg2)][address(arg1)].field_0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if not creditPlanOf[address(arg2)].field_0:
                                if not maxExitFeeMantissa:
                                    if stor159[address(arg2)][address(arg1)].field_0 > 0:
                                        return 0
                                    return -stor159[address(arg2)][address(arg1)].field_0, stor159[address(arg2)][address(arg1)].field_0
                                if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[549 len 31]
                                if 0 <= arg3 * maxExitFeeMantissa / 10^18:
                                    if stor159[address(arg2)][address(arg1)].field_0 > 0:
                                        return 0
                                    return -stor159[address(arg2)][address(arg1)].field_0, stor159[address(arg2)][address(arg1)].field_0
                            else:
                                if arg3 * creditPlanOf[address(arg2)].field_0 / creditPlanOf[address(arg2)].field_0 != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[485 len 31]
                                if not maxExitFeeMantissa:
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > 0:
                                        if stor159[address(arg2)][address(arg1)].field_0 > 0:
                                            return 0
                                        return -stor159[address(arg2)][address(arg1)].field_0, stor159[address(arg2)][address(arg1)].field_0
                                    if stor159[address(arg2)][address(arg1)].field_0 <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        return (arg3 * creditPlanOf[address(arg2)].field_0 / 10^18) - stor159[address(arg2)][address(arg1)].field_0, 
                                               stor159[address(arg2)][address(arg1)].field_0
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                                if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[549 len 31]
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 <= arg3 * maxExitFeeMantissa / 10^18:
                                    if stor159[address(arg2)][address(arg1)].field_0 <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        return (arg3 * creditPlanOf[address(arg2)].field_0 / 10^18) - stor159[address(arg2)][address(arg1)].field_0, 
                                               stor159[address(arg2)][address(arg1)].field_0
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                            if stor159[address(arg2)][address(arg1)].field_0 <= arg3 * maxExitFeeMantissa / 10^18:
                                return (arg3 * maxExitFeeMantissa / 10^18) - stor159[address(arg2)][address(arg1)].field_0, 
                                       stor159[address(arg2)][address(arg1)].field_0
                else:
                    if (ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / maxExitFeeMantissa != ext_call.return_data[0] - arg3:
                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[421 len 31]
                    if (ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18 <= (ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18:
                        if (ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18 > stor159[address(arg2)][address(arg1)].field_0:
                            if not creditPlanOf[address(arg2)].field_0:
                                if not maxExitFeeMantissa:
                                    return 0
                                if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[549 len 31]
                                if 0 <= arg3 * maxExitFeeMantissa / 10^18:
                                    return 0
                            else:
                                if arg3 * creditPlanOf[address(arg2)].field_0 / creditPlanOf[address(arg2)].field_0 != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[485 len 31]
                                if not maxExitFeeMantissa:
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > 0:
                                        return 0
                                    if 0 <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        return arg3 * creditPlanOf[address(arg2)].field_0 / 10^18, 0
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                                if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[549 len 31]
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 <= arg3 * maxExitFeeMantissa / 10^18:
                                    if 0 <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        return arg3 * creditPlanOf[address(arg2)].field_0 / 10^18, 0
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                                if 0 <= arg3 * maxExitFeeMantissa / 10^18:
                                    return arg3 * maxExitFeeMantissa / 10^18, 0
                            ('gt', 0, ('div', ('mul', ('param', 'arg3'), ('stor', ('name', 'maxExitFeeMantissa', 154))), 1000000000000000000))
                        else:
                            if (ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18 > stor159[address(arg2)][address(arg1)].field_0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if not creditPlanOf[address(arg2)].field_0:
                                if not maxExitFeeMantissa:
                                    if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18) > 0:
                                        return 0
                                    return -stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18), 
                                           stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18)
                                if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[549 len 31]
                                if 0 <= arg3 * maxExitFeeMantissa / 10^18:
                                    if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18) > 0:
                                        return 0
                                    return -stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18), 
                                           stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18)
                            else:
                                if arg3 * creditPlanOf[address(arg2)].field_0 / creditPlanOf[address(arg2)].field_0 != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[485 len 31]
                                if not maxExitFeeMantissa:
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > 0:
                                        if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18) > 0:
                                            return 0
                                        return -stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18), 
                                               stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18)
                                    if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18) <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        return (arg3 * creditPlanOf[address(arg2)].field_0 / 10^18) - stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18), 
                                               stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18)
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                                if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[549 len 31]
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 <= arg3 * maxExitFeeMantissa / 10^18:
                                    if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18) <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        return (arg3 * creditPlanOf[address(arg2)].field_0 / 10^18) - stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18), 
                                               stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18)
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                            if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18) <= arg3 * maxExitFeeMantissa / 10^18:
                                return (arg3 * maxExitFeeMantissa / 10^18) - stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18), 
                                       stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18)
                    else:
                        if (ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18 > stor159[address(arg2)][address(arg1)].field_0:
                            if not creditPlanOf[address(arg2)].field_0:
                                if not maxExitFeeMantissa:
                                    return 0
                                if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[549 len 31]
                                if 0 <= arg3 * maxExitFeeMantissa / 10^18:
                                    return 0
                            else:
                                if arg3 * creditPlanOf[address(arg2)].field_0 / creditPlanOf[address(arg2)].field_0 != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[485 len 31]
                                if not maxExitFeeMantissa:
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > 0:
                                        return 0
                                    if 0 <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        return arg3 * creditPlanOf[address(arg2)].field_0 / 10^18, 0
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                                if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[549 len 31]
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 <= arg3 * maxExitFeeMantissa / 10^18:
                                    if 0 <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        return arg3 * creditPlanOf[address(arg2)].field_0 / 10^18, 0
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                                if 0 <= arg3 * maxExitFeeMantissa / 10^18:
                                    return arg3 * maxExitFeeMantissa / 10^18, 0
                            ('gt', 0, ('div', ('mul', ('param', 'arg3'), ('stor', ('name', 'maxExitFeeMantissa', 154))), 1000000000000000000))
                        else:
                            if (ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18 > stor159[address(arg2)][address(arg1)].field_0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if not creditPlanOf[address(arg2)].field_0:
                                if not maxExitFeeMantissa:
                                    if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18) > 0:
                                        return 0
                                    return -stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18), 
                                           stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18)
                                if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[549 len 31]
                                if 0 <= arg3 * maxExitFeeMantissa / 10^18:
                                    if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18) > 0:
                                        return 0
                                    return -stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18), 
                                           stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18)
                            else:
                                if arg3 * creditPlanOf[address(arg2)].field_0 / creditPlanOf[address(arg2)].field_0 != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[485 len 31]
                                if not maxExitFeeMantissa:
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > 0:
                                        if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18) > 0:
                                            return 0
                                        return -stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18), 
                                               stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18)
                                    if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18) <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        return (arg3 * creditPlanOf[address(arg2)].field_0 / 10^18) - stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18), 
                                               stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18)
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                                if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[549 len 31]
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 <= arg3 * maxExitFeeMantissa / 10^18:
                                    if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18) <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        return (arg3 * creditPlanOf[address(arg2)].field_0 / 10^18) - stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18), 
                                               stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18)
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                            if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18) <= arg3 * maxExitFeeMantissa / 10^18:
                                return (arg3 * maxExitFeeMantissa / 10^18) - stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18), 
                                       stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18)
        else:
            if stor159[address(arg2)][address(arg1)].field_192 > block.timestamp:
                revert with 0, 'SafeMath: subtraction overflow'
            if not block.timestamp - stor159[address(arg2)][address(arg1)].field_192:
                if stor159[address(arg2)][address(arg1)].field_0 < stor159[address(arg2)][address(arg1)].field_0:
                    revert with 0, 'SafeMath: addition overflow'
                if not creditPlanOf[address(arg2)].field_0:
                    if stor159[address(arg2)][address(arg1)].field_0 > 0:
                        if block.timestamp >= 4294967296:
                            revert with 0, 32, 38, 0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400, mem[426 len 26]
                        stor159[address(arg2)][address(arg1)].field_0 = 0
                        stor159[address(arg2)][address(arg1)].field_192 = uint32(block.timestamp)
                        stor159[address(arg2)][address(arg1)].field_224 = 1
                        stor159[address(arg2)][address(arg1)].field_256 = 0
                        if stor159[address(arg2)][address(arg1)].field_0 < 0:
                            if stor159[address(arg2)][address(arg1)].field_0 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            emit CreditMinted(-stor159[address(arg2)][address(arg1)].field_0, arg1, arg2);
                        else:
                            if 0 < stor159[address(arg2)][address(arg1)].field_0:
                                if 0 > stor159[address(arg2)][address(arg1)].field_0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                emit CreditBurned(stor159[address(arg2)][address(arg1)].field_0, arg1, arg2);
                    else:
                        if stor159[address(arg2)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                            revert with 0, 32, 39, 0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974, mem[427 len 25]
                        if block.timestamp >= 4294967296:
                            revert with 0, 32, 38, 0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400, mem[426 len 26]
                        stor159[address(arg2)][address(arg1)].field_0 = stor159[address(arg2)][address(arg1)].field_0
                        stor159[address(arg2)][address(arg1)].field_128 = 0
                        stor159[address(arg2)][address(arg1)].field_192 = uint32(block.timestamp)
                        stor159[address(arg2)][address(arg1)].field_224 = 1
                        if stor159[address(arg2)][address(arg1)].field_0 < stor159[address(arg2)][address(arg1)].field_0:
                            if stor159[address(arg2)][address(arg1)].field_0 > stor159[address(arg2)][address(arg1)].field_0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            emit CreditMinted(0, arg1, arg2);
                        else:
                            if stor159[address(arg2)][address(arg1)].field_0 < stor159[address(arg2)][address(arg1)].field_0:
                                if stor159[address(arg2)][address(arg1)].field_0 > stor159[address(arg2)][address(arg1)].field_0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                emit CreditBurned(0, arg1, arg2);
                else:
                    if ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / creditPlanOf[address(arg2)].field_0 != ext_call.return_data[0]:
                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                    if stor159[address(arg2)][address(arg1)].field_0 <= ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18:
                        if stor159[address(arg2)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                            revert with 0, 32, 39, 0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974, mem[427 len 25]
                        if block.timestamp >= 4294967296:
                            revert with 0, 32, 38, 0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400, mem[426 len 26]
                        stor159[address(arg2)][address(arg1)].field_0 = stor159[address(arg2)][address(arg1)].field_0
                        stor159[address(arg2)][address(arg1)].field_128 = 0
                        stor159[address(arg2)][address(arg1)].field_192 = uint32(block.timestamp)
                        stor159[address(arg2)][address(arg1)].field_224 = 1
                        if stor159[address(arg2)][address(arg1)].field_0 < stor159[address(arg2)][address(arg1)].field_0:
                            if stor159[address(arg2)][address(arg1)].field_0 > stor159[address(arg2)][address(arg1)].field_0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            emit CreditMinted(0, arg1, arg2);
                        else:
                            if stor159[address(arg2)][address(arg1)].field_0 < stor159[address(arg2)][address(arg1)].field_0:
                                if stor159[address(arg2)][address(arg1)].field_0 > stor159[address(arg2)][address(arg1)].field_0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                emit CreditBurned(0, arg1, arg2);
                    else:
                        if ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18 >= 0x100000000000000000000000000000000:
                            revert with 0, 32, 39, 0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974, mem[427 len 25]
                        if block.timestamp >= 4294967296:
                            revert with 0, 32, 38, 0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400, mem[426 len 26]
                        stor159[address(arg2)][address(arg1)].field_0 = uint128(ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18)
                        stor159[address(arg2)][address(arg1)].field_128 = 0
                        stor159[address(arg2)][address(arg1)].field_192 = uint32(block.timestamp)
                        stor159[address(arg2)][address(arg1)].field_224 = 1
                        if stor159[address(arg2)][address(arg1)].field_0 < ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18:
                            if stor159[address(arg2)][address(arg1)].field_0 > ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18:
                                revert with 0, 'SafeMath: subtraction overflow'
                            emit CreditMinted(((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18) - stor159[address(arg2)][address(arg1)].field_0), arg1, arg2);
                        else:
                            if ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18 < stor159[address(arg2)][address(arg1)].field_0:
                                if ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18 > stor159[address(arg2)][address(arg1)].field_0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                emit CreditBurned((stor159[address(arg2)][address(arg1)].field_0 - (ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18)), arg1, arg2);
            else:
                if (block.timestamp * creditPlanOf[address(arg2)].field_128) - (stor159[address(arg2)][address(arg1)].field_192 * creditPlanOf[address(arg2)].field_128) / block.timestamp - stor159[address(arg2)][address(arg1)].field_192 != creditPlanOf[address(arg2)].field_128:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if not (block.timestamp * creditPlanOf[address(arg2)].field_128) - (stor159[address(arg2)][address(arg1)].field_192 * creditPlanOf[address(arg2)].field_128):
                    if stor159[address(arg2)][address(arg1)].field_0 < stor159[address(arg2)][address(arg1)].field_0:
                        revert with 0, 'SafeMath: addition overflow'
                    if not creditPlanOf[address(arg2)].field_0:
                        if stor159[address(arg2)][address(arg1)].field_0 > 0:
                            if block.timestamp >= 4294967296:
                                revert with 0, 32, 38, 0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400, mem[426 len 26]
                            stor159[address(arg2)][address(arg1)].field_0 = 0
                            stor159[address(arg2)][address(arg1)].field_192 = uint32(block.timestamp)
                            stor159[address(arg2)][address(arg1)].field_224 = 1
                            stor159[address(arg2)][address(arg1)].field_256 = 0
                            if stor159[address(arg2)][address(arg1)].field_0 < 0:
                                if stor159[address(arg2)][address(arg1)].field_0 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                emit CreditMinted(-stor159[address(arg2)][address(arg1)].field_0, arg1, arg2);
                            else:
                                if 0 < stor159[address(arg2)][address(arg1)].field_0:
                                    if 0 > stor159[address(arg2)][address(arg1)].field_0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    emit CreditBurned(stor159[address(arg2)][address(arg1)].field_0, arg1, arg2);
                        else:
                            if stor159[address(arg2)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                revert with 0, 32, 39, 0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974, mem[427 len 25]
                            if block.timestamp >= 4294967296:
                                revert with 0, 32, 38, 0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400, mem[426 len 26]
                            stor159[address(arg2)][address(arg1)].field_0 = stor159[address(arg2)][address(arg1)].field_0
                            stor159[address(arg2)][address(arg1)].field_128 = 0
                            stor159[address(arg2)][address(arg1)].field_192 = uint32(block.timestamp)
                            stor159[address(arg2)][address(arg1)].field_224 = 1
                            if stor159[address(arg2)][address(arg1)].field_0 < stor159[address(arg2)][address(arg1)].field_0:
                                if stor159[address(arg2)][address(arg1)].field_0 > stor159[address(arg2)][address(arg1)].field_0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                emit CreditMinted(0, arg1, arg2);
                            else:
                                if stor159[address(arg2)][address(arg1)].field_0 < stor159[address(arg2)][address(arg1)].field_0:
                                    if stor159[address(arg2)][address(arg1)].field_0 > stor159[address(arg2)][address(arg1)].field_0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    emit CreditBurned(0, arg1, arg2);
                    else:
                        if ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / creditPlanOf[address(arg2)].field_0 != ext_call.return_data[0]:
                            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                        if stor159[address(arg2)][address(arg1)].field_0 <= ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18:
                            if stor159[address(arg2)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                revert with 0, 32, 39, 0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974, mem[427 len 25]
                            if block.timestamp >= 4294967296:
                                revert with 0, 32, 38, 0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400, mem[426 len 26]
                            stor159[address(arg2)][address(arg1)].field_0 = stor159[address(arg2)][address(arg1)].field_0
                            stor159[address(arg2)][address(arg1)].field_128 = 0
                            stor159[address(arg2)][address(arg1)].field_192 = uint32(block.timestamp)
                            stor159[address(arg2)][address(arg1)].field_224 = 1
                            if stor159[address(arg2)][address(arg1)].field_0 < stor159[address(arg2)][address(arg1)].field_0:
                                if stor159[address(arg2)][address(arg1)].field_0 > stor159[address(arg2)][address(arg1)].field_0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                emit CreditMinted(0, arg1, arg2);
                            else:
                                if stor159[address(arg2)][address(arg1)].field_0 < stor159[address(arg2)][address(arg1)].field_0:
                                    if stor159[address(arg2)][address(arg1)].field_0 > stor159[address(arg2)][address(arg1)].field_0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    emit CreditBurned(0, arg1, arg2);
                        else:
                            if ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18 >= 0x100000000000000000000000000000000:
                                revert with 0, 32, 39, 0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974, mem[427 len 25]
                            if block.timestamp >= 4294967296:
                                revert with 0, 32, 38, 0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400, mem[426 len 26]
                            stor159[address(arg2)][address(arg1)].field_0 = uint128(ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18)
                            stor159[address(arg2)][address(arg1)].field_128 = 0
                            stor159[address(arg2)][address(arg1)].field_192 = uint32(block.timestamp)
                            stor159[address(arg2)][address(arg1)].field_224 = 1
                            if stor159[address(arg2)][address(arg1)].field_0 < ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18:
                                if stor159[address(arg2)][address(arg1)].field_0 > ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                emit CreditMinted(((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18) - stor159[address(arg2)][address(arg1)].field_0), arg1, arg2);
                            else:
                                if ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18 < stor159[address(arg2)][address(arg1)].field_0:
                                    if ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18 > stor159[address(arg2)][address(arg1)].field_0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    emit CreditBurned((stor159[address(arg2)][address(arg1)].field_0 - (ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18)), arg1, arg2);
                else:
                    if (block.timestamp * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) - (stor159[address(arg2)][address(arg1)].field_192 * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) / (block.timestamp * creditPlanOf[address(arg2)].field_128) - (stor159[address(arg2)][address(arg1)].field_192 * creditPlanOf[address(arg2)].field_128) != ext_call.return_data[0]:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if ((block.timestamp * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) - (stor159[address(arg2)][address(arg1)].field_192 * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg2)][address(arg1)].field_0 < stor159[address(arg2)][address(arg1)].field_0:
                        revert with 0, 'SafeMath: addition overflow'
                    if not creditPlanOf[address(arg2)].field_0:
                        if ((block.timestamp * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) - (stor159[address(arg2)][address(arg1)].field_192 * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg2)][address(arg1)].field_0 > 0:
                            if block.timestamp >= 4294967296:
                                revert with 0, 32, 38, 0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400, mem[426 len 26]
                            stor159[address(arg2)][address(arg1)].field_0 = 0
                            stor159[address(arg2)][address(arg1)].field_192 = uint32(block.timestamp)
                            stor159[address(arg2)][address(arg1)].field_224 = 1
                            stor159[address(arg2)][address(arg1)].field_256 = 0
                            if stor159[address(arg2)][address(arg1)].field_0 < 0:
                                if stor159[address(arg2)][address(arg1)].field_0 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                emit CreditMinted(-stor159[address(arg2)][address(arg1)].field_0, arg1, arg2);
                            else:
                                if 0 < stor159[address(arg2)][address(arg1)].field_0:
                                    if 0 > stor159[address(arg2)][address(arg1)].field_0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    emit CreditBurned(stor159[address(arg2)][address(arg1)].field_0, arg1, arg2);
                        else:
                            if ((block.timestamp * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) - (stor159[address(arg2)][address(arg1)].field_192 * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg2)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                revert with 0, 32, 39, 0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974, mem[427 len 25]
                            if block.timestamp >= 4294967296:
                                revert with 0, 32, 38, 0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400, mem[426 len 26]
                            stor159[address(arg2)][address(arg1)].field_0 = uint128(((block.timestamp * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) - (stor159[address(arg2)][address(arg1)].field_192 * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg2)][address(arg1)].field_0)
                            stor159[address(arg2)][address(arg1)].field_128 = 0
                            stor159[address(arg2)][address(arg1)].field_192 = uint32(block.timestamp)
                            stor159[address(arg2)][address(arg1)].field_224 = 1
                            if stor159[address(arg2)][address(arg1)].field_0 < ((block.timestamp * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) - (stor159[address(arg2)][address(arg1)].field_192 * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg2)][address(arg1)].field_0:
                                if stor159[address(arg2)][address(arg1)].field_0 > ((block.timestamp * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) - (stor159[address(arg2)][address(arg1)].field_192 * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg2)][address(arg1)].field_0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                emit CreditMinted(((block.timestamp * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) - (stor159[address(arg2)][address(arg1)].field_192 * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) / 10^18), arg1, arg2);
                            else:
                                if ((block.timestamp * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) - (stor159[address(arg2)][address(arg1)].field_192 * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg2)][address(arg1)].field_0 < stor159[address(arg2)][address(arg1)].field_0:
                                    if ((block.timestamp * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) - (stor159[address(arg2)][address(arg1)].field_192 * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg2)][address(arg1)].field_0 > stor159[address(arg2)][address(arg1)].field_0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    emit CreditBurned(-((block.timestamp * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) - (stor159[address(arg2)][address(arg1)].field_192 * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) / 10^18), arg1, arg2);
                    else:
                        if ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / creditPlanOf[address(arg2)].field_0 != ext_call.return_data[0]:
                            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                        if ((block.timestamp * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) - (stor159[address(arg2)][address(arg1)].field_192 * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg2)][address(arg1)].field_0 <= ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18:
                            if ((block.timestamp * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) - (stor159[address(arg2)][address(arg1)].field_192 * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg2)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                revert with 0, 32, 39, 0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974, mem[427 len 25]
                            if block.timestamp >= 4294967296:
                                revert with 0, 32, 38, 0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400, mem[426 len 26]
                            stor159[address(arg2)][address(arg1)].field_0 = uint128(((block.timestamp * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) - (stor159[address(arg2)][address(arg1)].field_192 * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg2)][address(arg1)].field_0)
                            stor159[address(arg2)][address(arg1)].field_128 = 0
                            stor159[address(arg2)][address(arg1)].field_192 = uint32(block.timestamp)
                            stor159[address(arg2)][address(arg1)].field_224 = 1
                            if stor159[address(arg2)][address(arg1)].field_0 < ((block.timestamp * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) - (stor159[address(arg2)][address(arg1)].field_192 * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg2)][address(arg1)].field_0:
                                if stor159[address(arg2)][address(arg1)].field_0 > ((block.timestamp * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) - (stor159[address(arg2)][address(arg1)].field_192 * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg2)][address(arg1)].field_0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                emit CreditMinted(((block.timestamp * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) - (stor159[address(arg2)][address(arg1)].field_192 * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) / 10^18), arg1, arg2);
                            else:
                                if ((block.timestamp * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) - (stor159[address(arg2)][address(arg1)].field_192 * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg2)][address(arg1)].field_0 < stor159[address(arg2)][address(arg1)].field_0:
                                    if ((block.timestamp * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) - (stor159[address(arg2)][address(arg1)].field_192 * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg2)][address(arg1)].field_0 > stor159[address(arg2)][address(arg1)].field_0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    emit CreditBurned(-((block.timestamp * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) - (stor159[address(arg2)][address(arg1)].field_192 * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) / 10^18), arg1, arg2);
                        else:
                            if ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18 >= 0x100000000000000000000000000000000:
                                revert with 0, 32, 39, 0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974, mem[427 len 25]
                            if block.timestamp >= 4294967296:
                                revert with 0, 32, 38, 0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400, mem[426 len 26]
                            stor159[address(arg2)][address(arg1)].field_0 = uint128(ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18)
                            stor159[address(arg2)][address(arg1)].field_128 = 0
                            stor159[address(arg2)][address(arg1)].field_192 = uint32(block.timestamp)
                            stor159[address(arg2)][address(arg1)].field_224 = 1
                            if stor159[address(arg2)][address(arg1)].field_0 < ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18:
                                if stor159[address(arg2)][address(arg1)].field_0 > ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                emit CreditMinted(((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18) - stor159[address(arg2)][address(arg1)].field_0), arg1, arg2);
                            else:
                                if ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18 < stor159[address(arg2)][address(arg1)].field_0:
                                    if ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18 > stor159[address(arg2)][address(arg1)].field_0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    emit CreditBurned((stor159[address(arg2)][address(arg1)].field_0 - (ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18)), arg1, arg2);
            if arg3 > ext_call.return_data[0]:
                revert with 0, 'SafeMath: subtraction overflow'
            if not creditPlanOf[address(arg2)].field_0:
                if not maxExitFeeMantissa:
                    if 0 > stor159[address(arg2)][address(arg1)].field_0:
                        if not creditPlanOf[address(arg2)].field_0:
                            if not maxExitFeeMantissa:
                                return 0
                            if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[613 len 31]
                            if 0 <= arg3 * maxExitFeeMantissa / 10^18:
                                return 0
                        else:
                            if arg3 * creditPlanOf[address(arg2)].field_0 / creditPlanOf[address(arg2)].field_0 != arg3:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[549 len 31]
                            if not maxExitFeeMantissa:
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > 0:
                                    return 0
                                if 0 <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    return arg3 * creditPlanOf[address(arg2)].field_0 / 10^18, 0
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                            if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[613 len 31]
                            if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 <= arg3 * maxExitFeeMantissa / 10^18:
                                if 0 <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    return arg3 * creditPlanOf[address(arg2)].field_0 / 10^18, 0
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                            if 0 <= arg3 * maxExitFeeMantissa / 10^18:
                                return arg3 * maxExitFeeMantissa / 10^18, 0
                        ('gt', 0, ('div', ('mul', ('param', 'arg3'), ('stor', ('name', 'maxExitFeeMantissa', 154))), 1000000000000000000))
                    else:
                        if 0 > stor159[address(arg2)][address(arg1)].field_0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if not creditPlanOf[address(arg2)].field_0:
                            if not maxExitFeeMantissa:
                                if stor159[address(arg2)][address(arg1)].field_0 > 0:
                                    return 0
                                return -stor159[address(arg2)][address(arg1)].field_0, stor159[address(arg2)][address(arg1)].field_0
                            if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[613 len 31]
                            if 0 <= arg3 * maxExitFeeMantissa / 10^18:
                                if stor159[address(arg2)][address(arg1)].field_0 > 0:
                                    return 0
                                return -stor159[address(arg2)][address(arg1)].field_0, stor159[address(arg2)][address(arg1)].field_0
                        else:
                            if arg3 * creditPlanOf[address(arg2)].field_0 / creditPlanOf[address(arg2)].field_0 != arg3:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[549 len 31]
                            if not maxExitFeeMantissa:
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > 0:
                                    if stor159[address(arg2)][address(arg1)].field_0 > 0:
                                        return 0
                                    return -stor159[address(arg2)][address(arg1)].field_0, stor159[address(arg2)][address(arg1)].field_0
                                if stor159[address(arg2)][address(arg1)].field_0 <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    return (arg3 * creditPlanOf[address(arg2)].field_0 / 10^18) - stor159[address(arg2)][address(arg1)].field_0, 
                                           stor159[address(arg2)][address(arg1)].field_0
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                            if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[613 len 31]
                            if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 <= arg3 * maxExitFeeMantissa / 10^18:
                                if stor159[address(arg2)][address(arg1)].field_0 <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    return (arg3 * creditPlanOf[address(arg2)].field_0 / 10^18) - stor159[address(arg2)][address(arg1)].field_0, 
                                           stor159[address(arg2)][address(arg1)].field_0
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                        if stor159[address(arg2)][address(arg1)].field_0 <= arg3 * maxExitFeeMantissa / 10^18:
                            return (arg3 * maxExitFeeMantissa / 10^18) - stor159[address(arg2)][address(arg1)].field_0, 
                                   stor159[address(arg2)][address(arg1)].field_0
                else:
                    if (ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / maxExitFeeMantissa != ext_call.return_data[0] - arg3:
                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[485 len 31]
                    if 0 <= (ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18:
                        if 0 > stor159[address(arg2)][address(arg1)].field_0:
                            if not creditPlanOf[address(arg2)].field_0:
                                if not maxExitFeeMantissa:
                                    return 0
                                if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[613 len 31]
                                if 0 <= arg3 * maxExitFeeMantissa / 10^18:
                                    return 0
                            else:
                                if arg3 * creditPlanOf[address(arg2)].field_0 / creditPlanOf[address(arg2)].field_0 != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[549 len 31]
                                if not maxExitFeeMantissa:
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > 0:
                                        return 0
                                    if 0 <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        return arg3 * creditPlanOf[address(arg2)].field_0 / 10^18, 0
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                                if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[613 len 31]
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 <= arg3 * maxExitFeeMantissa / 10^18:
                                    if 0 <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        return arg3 * creditPlanOf[address(arg2)].field_0 / 10^18, 0
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                                if 0 <= arg3 * maxExitFeeMantissa / 10^18:
                                    return arg3 * maxExitFeeMantissa / 10^18, 0
                            ('gt', 0, ('div', ('mul', ('param', 'arg3'), ('stor', ('name', 'maxExitFeeMantissa', 154))), 1000000000000000000))
                        else:
                            if 0 > stor159[address(arg2)][address(arg1)].field_0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if not creditPlanOf[address(arg2)].field_0:
                                if not maxExitFeeMantissa:
                                    if stor159[address(arg2)][address(arg1)].field_0 > 0:
                                        return 0
                                    return -stor159[address(arg2)][address(arg1)].field_0, stor159[address(arg2)][address(arg1)].field_0
                                if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[613 len 31]
                                if 0 <= arg3 * maxExitFeeMantissa / 10^18:
                                    if stor159[address(arg2)][address(arg1)].field_0 > 0:
                                        return 0
                                    return -stor159[address(arg2)][address(arg1)].field_0, stor159[address(arg2)][address(arg1)].field_0
                            else:
                                if arg3 * creditPlanOf[address(arg2)].field_0 / creditPlanOf[address(arg2)].field_0 != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[549 len 31]
                                if not maxExitFeeMantissa:
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > 0:
                                        if stor159[address(arg2)][address(arg1)].field_0 > 0:
                                            return 0
                                        return -stor159[address(arg2)][address(arg1)].field_0, stor159[address(arg2)][address(arg1)].field_0
                                    if stor159[address(arg2)][address(arg1)].field_0 <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        return (arg3 * creditPlanOf[address(arg2)].field_0 / 10^18) - stor159[address(arg2)][address(arg1)].field_0, 
                                               stor159[address(arg2)][address(arg1)].field_0
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                                if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[613 len 31]
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 <= arg3 * maxExitFeeMantissa / 10^18:
                                    if stor159[address(arg2)][address(arg1)].field_0 <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        return (arg3 * creditPlanOf[address(arg2)].field_0 / 10^18) - stor159[address(arg2)][address(arg1)].field_0, 
                                               stor159[address(arg2)][address(arg1)].field_0
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                            if stor159[address(arg2)][address(arg1)].field_0 <= arg3 * maxExitFeeMantissa / 10^18:
                                return (arg3 * maxExitFeeMantissa / 10^18) - stor159[address(arg2)][address(arg1)].field_0, 
                                       stor159[address(arg2)][address(arg1)].field_0
                    else:
                        if (ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18 > stor159[address(arg2)][address(arg1)].field_0:
                            if not creditPlanOf[address(arg2)].field_0:
                                if not maxExitFeeMantissa:
                                    return 0
                                if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[613 len 31]
                                if 0 <= arg3 * maxExitFeeMantissa / 10^18:
                                    return 0
                            else:
                                if arg3 * creditPlanOf[address(arg2)].field_0 / creditPlanOf[address(arg2)].field_0 != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[549 len 31]
                                if not maxExitFeeMantissa:
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > 0:
                                        return 0
                                    if 0 <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        return arg3 * creditPlanOf[address(arg2)].field_0 / 10^18, 0
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                                if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[613 len 31]
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 <= arg3 * maxExitFeeMantissa / 10^18:
                                    if 0 <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        return arg3 * creditPlanOf[address(arg2)].field_0 / 10^18, 0
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                                if 0 <= arg3 * maxExitFeeMantissa / 10^18:
                                    return arg3 * maxExitFeeMantissa / 10^18, 0
                            ('gt', 0, ('div', ('mul', ('param', 'arg3'), ('stor', ('name', 'maxExitFeeMantissa', 154))), 1000000000000000000))
                        else:
                            if (ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18 > stor159[address(arg2)][address(arg1)].field_0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if not creditPlanOf[address(arg2)].field_0:
                                if not maxExitFeeMantissa:
                                    if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18) > 0:
                                        return 0
                                    return -stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18), 
                                           stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18)
                                if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[613 len 31]
                                if 0 <= arg3 * maxExitFeeMantissa / 10^18:
                                    if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18) > 0:
                                        return 0
                                    return -stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18), 
                                           stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18)
                            else:
                                if arg3 * creditPlanOf[address(arg2)].field_0 / creditPlanOf[address(arg2)].field_0 != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[549 len 31]
                                if not maxExitFeeMantissa:
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > 0:
                                        if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18) > 0:
                                            return 0
                                        return -stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18), 
                                               stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18)
                                    if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18) <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        return (arg3 * creditPlanOf[address(arg2)].field_0 / 10^18) - stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18), 
                                               stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18)
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                                if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[613 len 31]
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 <= arg3 * maxExitFeeMantissa / 10^18:
                                    if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18) <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        return (arg3 * creditPlanOf[address(arg2)].field_0 / 10^18) - stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18), 
                                               stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18)
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                            if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18) <= arg3 * maxExitFeeMantissa / 10^18:
                                return (arg3 * maxExitFeeMantissa / 10^18) - stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18), 
                                       stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18)
            else:
                if (ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / creditPlanOf[address(arg2)].field_0 != ext_call.return_data[0] - arg3:
                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[421 len 31]
                if not maxExitFeeMantissa:
                    if (ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18 <= 0:
                        if (ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18 > stor159[address(arg2)][address(arg1)].field_0:
                            if not creditPlanOf[address(arg2)].field_0:
                                if not maxExitFeeMantissa:
                                    return 0
                                if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[613 len 31]
                                if 0 <= arg3 * maxExitFeeMantissa / 10^18:
                                    return 0
                            else:
                                if arg3 * creditPlanOf[address(arg2)].field_0 / creditPlanOf[address(arg2)].field_0 != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[549 len 31]
                                if not maxExitFeeMantissa:
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > 0:
                                        return 0
                                    if 0 <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        return arg3 * creditPlanOf[address(arg2)].field_0 / 10^18, 0
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                                if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[613 len 31]
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 <= arg3 * maxExitFeeMantissa / 10^18:
                                    if 0 <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        return arg3 * creditPlanOf[address(arg2)].field_0 / 10^18, 0
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                                if 0 <= arg3 * maxExitFeeMantissa / 10^18:
                                    return arg3 * maxExitFeeMantissa / 10^18, 0
                            ('gt', 0, ('div', ('mul', ('param', 'arg3'), ('stor', ('name', 'maxExitFeeMantissa', 154))), 1000000000000000000))
                        else:
                            if (ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18 > stor159[address(arg2)][address(arg1)].field_0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if not creditPlanOf[address(arg2)].field_0:
                                if not maxExitFeeMantissa:
                                    if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18) > 0:
                                        return 0
                                    return -stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18), 
                                           stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18)
                                if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[613 len 31]
                                if 0 <= arg3 * maxExitFeeMantissa / 10^18:
                                    if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18) > 0:
                                        return 0
                                    return -stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18), 
                                           stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18)
                            else:
                                if arg3 * creditPlanOf[address(arg2)].field_0 / creditPlanOf[address(arg2)].field_0 != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[549 len 31]
                                if not maxExitFeeMantissa:
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > 0:
                                        if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18) > 0:
                                            return 0
                                        return -stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18), 
                                               stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18)
                                    if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18) <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        return (arg3 * creditPlanOf[address(arg2)].field_0 / 10^18) - stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18), 
                                               stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18)
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                                if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[613 len 31]
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 <= arg3 * maxExitFeeMantissa / 10^18:
                                    if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18) <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        return (arg3 * creditPlanOf[address(arg2)].field_0 / 10^18) - stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18), 
                                               stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18)
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                            if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18) <= arg3 * maxExitFeeMantissa / 10^18:
                                return (arg3 * maxExitFeeMantissa / 10^18) - stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18), 
                                       stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18)
                    else:
                        if 0 > stor159[address(arg2)][address(arg1)].field_0:
                            if not creditPlanOf[address(arg2)].field_0:
                                if not maxExitFeeMantissa:
                                    return 0
                                if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[613 len 31]
                                if 0 <= arg3 * maxExitFeeMantissa / 10^18:
                                    return 0
                            else:
                                if arg3 * creditPlanOf[address(arg2)].field_0 / creditPlanOf[address(arg2)].field_0 != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[549 len 31]
                                if not maxExitFeeMantissa:
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > 0:
                                        return 0
                                    if 0 <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        return arg3 * creditPlanOf[address(arg2)].field_0 / 10^18, 0
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                                if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[613 len 31]
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 <= arg3 * maxExitFeeMantissa / 10^18:
                                    if 0 <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        return arg3 * creditPlanOf[address(arg2)].field_0 / 10^18, 0
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                                if 0 <= arg3 * maxExitFeeMantissa / 10^18:
                                    return arg3 * maxExitFeeMantissa / 10^18, 0
                            ('gt', 0, ('div', ('mul', ('param', 'arg3'), ('stor', ('name', 'maxExitFeeMantissa', 154))), 1000000000000000000))
                        else:
                            if 0 > stor159[address(arg2)][address(arg1)].field_0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if not creditPlanOf[address(arg2)].field_0:
                                if not maxExitFeeMantissa:
                                    if stor159[address(arg2)][address(arg1)].field_0 > 0:
                                        return 0
                                    return -stor159[address(arg2)][address(arg1)].field_0, stor159[address(arg2)][address(arg1)].field_0
                                if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[613 len 31]
                                if 0 <= arg3 * maxExitFeeMantissa / 10^18:
                                    if stor159[address(arg2)][address(arg1)].field_0 > 0:
                                        return 0
                                    return -stor159[address(arg2)][address(arg1)].field_0, stor159[address(arg2)][address(arg1)].field_0
                            else:
                                if arg3 * creditPlanOf[address(arg2)].field_0 / creditPlanOf[address(arg2)].field_0 != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[549 len 31]
                                if not maxExitFeeMantissa:
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > 0:
                                        if stor159[address(arg2)][address(arg1)].field_0 > 0:
                                            return 0
                                        return -stor159[address(arg2)][address(arg1)].field_0, stor159[address(arg2)][address(arg1)].field_0
                                    if stor159[address(arg2)][address(arg1)].field_0 <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        return (arg3 * creditPlanOf[address(arg2)].field_0 / 10^18) - stor159[address(arg2)][address(arg1)].field_0, 
                                               stor159[address(arg2)][address(arg1)].field_0
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                                if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[613 len 31]
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 <= arg3 * maxExitFeeMantissa / 10^18:
                                    if stor159[address(arg2)][address(arg1)].field_0 <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        return (arg3 * creditPlanOf[address(arg2)].field_0 / 10^18) - stor159[address(arg2)][address(arg1)].field_0, 
                                               stor159[address(arg2)][address(arg1)].field_0
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                            if stor159[address(arg2)][address(arg1)].field_0 <= arg3 * maxExitFeeMantissa / 10^18:
                                return (arg3 * maxExitFeeMantissa / 10^18) - stor159[address(arg2)][address(arg1)].field_0, 
                                       stor159[address(arg2)][address(arg1)].field_0
                else:
                    if (ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / maxExitFeeMantissa != ext_call.return_data[0] - arg3:
                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[485 len 31]
                    if (ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18 <= (ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18:
                        if (ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18 > stor159[address(arg2)][address(arg1)].field_0:
                            if not creditPlanOf[address(arg2)].field_0:
                                if not maxExitFeeMantissa:
                                    return 0
                                if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[613 len 31]
                                if 0 <= arg3 * maxExitFeeMantissa / 10^18:
                                    return 0
                            else:
                                if arg3 * creditPlanOf[address(arg2)].field_0 / creditPlanOf[address(arg2)].field_0 != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[549 len 31]
                                if not maxExitFeeMantissa:
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > 0:
                                        return 0
                                    if 0 <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        return arg3 * creditPlanOf[address(arg2)].field_0 / 10^18, 0
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                                if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[613 len 31]
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 <= arg3 * maxExitFeeMantissa / 10^18:
                                    if 0 <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        return arg3 * creditPlanOf[address(arg2)].field_0 / 10^18, 0
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                                if 0 <= arg3 * maxExitFeeMantissa / 10^18:
                                    return arg3 * maxExitFeeMantissa / 10^18, 0
                            ('gt', 0, ('div', ('mul', ('param', 'arg3'), ('stor', ('name', 'maxExitFeeMantissa', 154))), 1000000000000000000))
                        else:
                            if (ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18 > stor159[address(arg2)][address(arg1)].field_0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if not creditPlanOf[address(arg2)].field_0:
                                if not maxExitFeeMantissa:
                                    if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18) > 0:
                                        return 0
                                    return -stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18), 
                                           stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18)
                                if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[613 len 31]
                                if 0 <= arg3 * maxExitFeeMantissa / 10^18:
                                    if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18) > 0:
                                        return 0
                                    return -stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18), 
                                           stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18)
                            else:
                                if arg3 * creditPlanOf[address(arg2)].field_0 / creditPlanOf[address(arg2)].field_0 != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[549 len 31]
                                if not maxExitFeeMantissa:
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > 0:
                                        if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18) > 0:
                                            return 0
                                        return -stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18), 
                                               stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18)
                                    if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18) <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        return (arg3 * creditPlanOf[address(arg2)].field_0 / 10^18) - stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18), 
                                               stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18)
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                                if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[613 len 31]
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 <= arg3 * maxExitFeeMantissa / 10^18:
                                    if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18) <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        return (arg3 * creditPlanOf[address(arg2)].field_0 / 10^18) - stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18), 
                                               stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18)
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                            if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18) <= arg3 * maxExitFeeMantissa / 10^18:
                                return (arg3 * maxExitFeeMantissa / 10^18) - stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18), 
                                       stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18)
                    else:
                        if (ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18 > stor159[address(arg2)][address(arg1)].field_0:
                            if not creditPlanOf[address(arg2)].field_0:
                                if not maxExitFeeMantissa:
                                    return 0
                                if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[613 len 31]
                                if 0 <= arg3 * maxExitFeeMantissa / 10^18:
                                    return 0
                            else:
                                if arg3 * creditPlanOf[address(arg2)].field_0 / creditPlanOf[address(arg2)].field_0 != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[549 len 31]
                                if not maxExitFeeMantissa:
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > 0:
                                        return 0
                                    if 0 <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        return arg3 * creditPlanOf[address(arg2)].field_0 / 10^18, 0
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                                if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[613 len 31]
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 <= arg3 * maxExitFeeMantissa / 10^18:
                                    if 0 <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        return arg3 * creditPlanOf[address(arg2)].field_0 / 10^18, 0
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                                if 0 <= arg3 * maxExitFeeMantissa / 10^18:
                                    return arg3 * maxExitFeeMantissa / 10^18, 0
                            ('gt', 0, ('div', ('mul', ('param', 'arg3'), ('stor', ('name', 'maxExitFeeMantissa', 154))), 1000000000000000000))
                        else:
                            if (ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18 > stor159[address(arg2)][address(arg1)].field_0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if not creditPlanOf[address(arg2)].field_0:
                                if not maxExitFeeMantissa:
                                    if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18) > 0:
                                        return 0
                                    return -stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18), 
                                           stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18)
                                if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[613 len 31]
                                if 0 <= arg3 * maxExitFeeMantissa / 10^18:
                                    if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18) > 0:
                                        return 0
                                    return -stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18), 
                                           stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18)
                            else:
                                if arg3 * creditPlanOf[address(arg2)].field_0 / creditPlanOf[address(arg2)].field_0 != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[549 len 31]
                                if not maxExitFeeMantissa:
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > 0:
                                        if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18) > 0:
                                            return 0
                                        return -stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18), 
                                               stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18)
                                    if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18) <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        return (arg3 * creditPlanOf[address(arg2)].field_0 / 10^18) - stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18), 
                                               stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18)
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                                if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[613 len 31]
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 <= arg3 * maxExitFeeMantissa / 10^18:
                                    if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18) <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        return (arg3 * creditPlanOf[address(arg2)].field_0 / 10^18) - stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18), 
                                               stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18)
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                            if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18) <= arg3 * maxExitFeeMantissa / 10^18:
                                return (arg3 * maxExitFeeMantissa / 10^18) - stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18), 
                                       stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18)
    if arg3 * maxExitFeeMantissa / 10^18 > arg3 * maxExitFeeMantissa / 10^18:
        revert with 0, 'SafeMath: subtraction overflow'
    return 0, arg3 * maxExitFeeMantissa / 10^18
}

function depositTo(address arg1, uint256 arg2, address arg3, address arg4) payable {
    require calldata.size - 4 >= 128
    if stor101 == 2:
        revert with 0, 'ReentrancyGuard: reentrant call'
    stor101 = 2
    mem[64] = (32 * stor152.length) + 128
    mem[96] = stor152.length
    if not stor152.length:
        idx = 0
        while idx < stor152.length:
            require idx < stor152.length
            if mem[(32 * idx) + 140 len 20] != arg3:
                idx = idx + 1
                continue 
            mem[(32 * stor152.length) + 128] = stor152.length
            if not stor152.length:
                idx = 0
                s = reserveTotalSupply
                while idx < stor152.length:
                    require idx < mem[(32 * stor152.length) + 128]
                    require ext_code.size(mem[(32 * idx) + (32 * stor152.length) + 172 len 20])
                    staticcall mem[(32 * idx) + (32 * stor152.length) + 172 len 20].0x18160ddd with:
                            gas gas_remaining wei
                    mem[(64 * stor152.length) + 160] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if ext_call.return_data[0] + s < s:
                        revert with 0, 'SafeMath: addition overflow'
                    idx = idx + 1
                    s = ext_call.return_data[0] + s
                    continue 
                if arg2 < 0:
                    revert with 0, 'SafeMath: addition overflow'
                if arg2 + reserveTotalSupply + (_2598 * stor152.length) > liquidityCap:
                    revert with 0, 'PrizePool/exceeds-liquidity-cap'
                if prizeStrategyAddress:
                    require ext_code.size(prizeStrategyAddress)
                    call prizeStrategyAddress.beforeTokenMint(address arg1, uint256 arg2, address arg3, address arg4) with:
                         gas gas_remaining wei
                        args address(arg1), arg2, address(arg3), arg4
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require ext_code.size(arg3)
                    call arg3.0x5d7b0758 with:
                         gas gas_remaining wei
                        args address(arg1), arg2
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require ext_code.size(address(yieldSourceAddress))
                    staticcall address(yieldSourceAddress).0xc89039c5 with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    mem[(64 * stor152.length) + 196] = msg.sender
                    mem[(64 * stor152.length) + 228] = this.address
                    mem[(64 * stor152.length) + 260] = arg2
                    mem[(64 * stor152.length) + 160] = 100
                    mem[(64 * stor152.length) + 192] = 0x23b872dd00000000000000000000000000000000000000000000000000000000 or Mask(224, 32, msg.sender) >> 32
                    mem[64] = (64 * stor152.length) + 356
                    mem[(64 * stor152.length) + 292] = 32
                    mem[(64 * stor152.length) + 324] = 'SafeERC20: low-level call failed'
                    if eth.balance(this.address) < 0:
                        revert with 0, 
                                    32,
                                    38,
                                    0x6f416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c,
                                    mem[(64 * stor152.length) + 462 len 26]
                    if not ext_code.size(address(ext_call.return_data[0])):
                        revert with 0, 'Address: call to non-contract'
                    s = (64 * stor152.length) + 192
                    t = mem[64]
                    idx = mem[(64 * stor152.length) + 160]
                    while idx >= 32:
                        mem[t] = mem[s]
                        s = s + 32
                        t = t + 32
                        idx = idx - 32
                        continue 
                    mem[mem[64] + floor32(mem[(64 * stor152.length) + 160])] = mem[(64 * stor152.length) + floor32(mem[(64 * stor152.length) + 160]) + -(mem[(64 * stor152.length) + 160] % 32) + 224 len mem[(64 * stor152.length) + 160] % 32] or Mask(8 * -(mem[(64 * stor152.length) + 160] % 32) + 32, -(8 * -(mem[(64 * stor152.length) + 160] % 32) + 32) + 256, mem[mem[64] + floor32(mem[(64 * stor152.length) + 160])])
                    call address(ext_call.return_data[0]).mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len (64 * stor152.length) + -mem[64] + 452]
                    if return_data.size:
                        _5165 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size) + 1
                        mem[_5165] = return_data.size
                        mem[_5165 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size:
                                revert with ext_call.return_data[0 len return_data.size]
                            _5194 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = mem[(64 * stor152.length) + 292]
                            _5196 = mem[(64 * stor152.length) + 292]
                            if not mem[(64 * stor152.length) + 292]:
                                if not mem[(64 * stor152.length) + 292] % 32:
                                    revert with 0, 32, mem[mem[64] + 36 len mem[(64 * stor152.length) + 292] + 32]
                                mem[floor32(mem[(64 * stor152.length) + 292]) + mem[64] + 68] = mem[floor32(mem[(64 * stor152.length) + 292]) + mem[64] + -(mem[(64 * stor152.length) + 292] % 32) + 100 len mem[(64 * stor152.length) + 292] % 32]
                            else:
                                mem[mem[64] + 68] = mem[(64 * stor152.length) + 324]
                                idx = 32
                                while idx < _5196:
                                    mem[idx + mem[64] + 68] = mem[idx + (64 * stor152.length) + 324]
                                    idx = idx + 32
                                    continue 
                                if not _5196 % 32:
                                    revert with memory
                                      from mem[64]
                                       len _5196 + _5194 + -mem[64] + 68
                                mem[floor32(_5196) + _5194 + 68] = mem[floor32(_5196) + _5194 + -(_5196 % 32) + 100 len _5196 % 32]
                            revert with memory
                              from mem[64]
                               len floor32(_5196) + _5194 + -mem[64] + 100
                        if not return_data.size:
                            require ext_code.size(address(yieldSourceAddress))
                            staticcall address(yieldSourceAddress).0xc89039c5 with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if not arg2:
                                _5331 = mem[64]
                                mem[mem[64] + 36] = address(yieldSourceAddress)
                                mem[mem[64] + 68] = arg2
                                _5332 = mem[64]
                                mem[mem[64]] = 68
                                mem[64] = mem[64] + 100
                                mem[_5332 + 32] = 0x95ea7b300000000000000000000000000000000000000000000000000000000 or mem[_5332 + 36 len 28]
                                mem[64] = _5331 + 164
                                mem[_5331 + 100] = 32
                                mem[_5331 + 132] = 'SafeERC20: low-level call failed'
                                if eth.balance(this.address) < 0:
                                    revert with 0, 32, 38, 0x6f416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_5331 + 270 len 26]
                                if not ext_code.size(address(ext_call.return_data[0])):
                                    revert with 0, 'Address: call to non-contract'
                                _5475 = mem[_5332]
                                s = _5332 + 32
                                t = mem[64]
                                idx = mem[_5332]
                                while idx >= 32:
                                    mem[t] = mem[s]
                                    s = s + 32
                                    t = t + 32
                                    idx = idx - 32
                                    continue 
                                mem[mem[64] + floor32(mem[_5332])] = mem[_5332 + floor32(mem[_5332]) + -(mem[_5332] % 32) + 64 len mem[_5332] % 32] or Mask(8 * -(mem[_5332] % 32) + 32, -(8 * -(mem[_5332] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_5332])])
                                call address(ext_call.return_data[0]).mem[mem[64] len 4] with:
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len _5475 + _5331 + -mem[64] + 160]
                                if not return_data.size:
                                    if ext_call.success:
                                        if mem[96]:
                                            require mem[96] >= 32
                                            if not mem[128]:
                                                revert with 0, 
                                                            32,
                                                            42,
                                                            0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                            mem[mem[64] + 110 len 22]
                                        require ext_code.size(address(yieldSourceAddress))
                                        call address(yieldSourceAddress).0x87a6eeef with:
                                             gas gas_remaining wei
                                            args arg2, this.address
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        emit Deposited(arg2, arg4, msg.sender, arg1, arg3);
                                        stor101 = 1
                                    if mem[96]:
                                        revert with memory
                                          from 128
                                           len mem[96]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = mem[_5331 + 100]
                                    _9200 = mem[_5331 + 100]
                                    if not mem[_5331 + 100]:
                                        if not mem[_5331 + 100] % 32:
                                            revert with 0, 32, mem[mem[64] + 36 len mem[_5331 + 100] + 32]
                                        mem[floor32(mem[_5331 + 100]) + mem[64] + 68] = mem[floor32(mem[_5331 + 100]) + mem[64] + -(mem[_5331 + 100] % 32) + 100 len mem[_5331 + 100] % 32]
                                    else:
                                        mem[mem[64] + 68] = mem[_5331 + 132]
                                        idx = 32
                                        while idx < _9200:
                                            mem[idx + mem[64] + 68] = mem[idx + _5331 + 132]
                                            idx = idx + 32
                                            continue 
                                        if not _9200 % 32:
                                            revert with 0, 32, mem[mem[64] + 36 len _9200 + 32]
                                        mem[floor32(_9200) + mem[64] + 68] = mem[floor32(_9200) + mem[64] + -(_9200 % 32) + 100 len _9200 % 32]
                                    revert with 0, 32, mem[mem[64] + 36 len floor32(_9200) + 64]
                                _9048 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size) + 1
                                mem[_9048] = return_data.size
                                mem[_9048 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if ext_call.success:
                                    if return_data.size:
                                        require return_data.size >= 32
                                        if not mem[_9048 + 32]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[mem[64] + 110 len 22]
                                    require ext_code.size(address(yieldSourceAddress))
                                    call address(yieldSourceAddress).0x87a6eeef with:
                                         gas gas_remaining wei
                                        args arg2, this.address
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    emit Deposited(arg2, arg4, msg.sender, arg1, arg3);
                                    stor101 = 1
                                if return_data.size:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = mem[_5331 + 100]
                                _9204 = mem[_5331 + 100]
                                if not mem[_5331 + 100]:
                                    if not mem[_5331 + 100] % 32:
                                        revert with 0, 32, mem[mem[64] + 36 len mem[_5331 + 100] + 32]
                                    mem[floor32(mem[_5331 + 100]) + mem[64] + 68] = mem[floor32(mem[_5331 + 100]) + mem[64] + -(mem[_5331 + 100] % 32) + 100 len mem[_5331 + 100] % 32]
                                else:
                                    mem[mem[64] + 68] = mem[_5331 + 132]
                                    idx = 32
                                    while idx < _9204:
                                        mem[idx + mem[64] + 68] = mem[idx + _5331 + 132]
                                        idx = idx + 32
                                        continue 
                                    if not _9204 % 32:
                                        revert with 0, 32, mem[mem[64] + 36 len _9204 + 32]
                                    mem[floor32(_9204) + mem[64] + 68] = mem[floor32(_9204) + mem[64] + -(_9204 % 32) + 100 len _9204 % 32]
                                revert with 0, 32, mem[mem[64] + 36 len floor32(_9204) + 64]
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(address(ext_call.return_data[0]))
                            staticcall address(ext_call.return_data[0]).0xdd62ed3e with:
                                    gas gas_remaining wei
                                   args this.address, address(yieldSourceAddress)
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if ext_call.return_data[0]:
                                revert with 0, 
                                            32,
                                            54,
                                            0x735361666545524332303a20617070726f76652066726f6d206e6f6e2d7a65726f20746f206e6f6e2d7a65726f20616c6c6f77616e63,
                                            mem[mem[64] + 122 len 10]
                            _5415 = mem[64]
                            mem[mem[64] + 36] = address(yieldSourceAddress)
                            mem[mem[64] + 68] = arg2
                            _5416 = mem[64]
                            mem[mem[64]] = 68
                            mem[64] = mem[64] + 100
                            mem[_5416 + 32] = 0x95ea7b300000000000000000000000000000000000000000000000000000000 or mem[_5416 + 36 len 28]
                            mem[64] = _5415 + 164
                            mem[_5415 + 100] = 32
                            mem[_5415 + 132] = 'SafeERC20: low-level call failed'
                            if eth.balance(this.address) < 0:
                                revert with 0, 32, 38, 0x6f416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_5415 + 270 len 26]
                            if not ext_code.size(address(ext_call.return_data[0])):
                                revert with 0, 'Address: call to non-contract'
                            _5580 = mem[_5416]
                            s = _5416 + 32
                            t = _5415 + 164
                            idx = mem[_5416]
                            while idx >= 32:
                                mem[t] = mem[s]
                                s = s + 32
                                t = t + 32
                                idx = idx - 32
                                continue 
                            mem[_5415 + floor32(mem[_5416]) + 164] = mem[_5416 + -(mem[_5416] % 32) + floor32(mem[_5416]) + 64 len mem[_5416] % 32] or Mask(8 * -(mem[_5416] % 32) + 32, -(8 * -(mem[_5416] % 32) + 32) + 256, mem[_5415 + floor32(mem[_5416]) + 164])
                            call address(ext_call.return_data[0]).mem[_5415 + 164 len 4] with:
                                 gas gas_remaining wei
                                args mem[_5415 + 168 len _5580 - 4]
                            if not return_data.size:
                                if not ext_call.success:
                                    if mem[96]:
                                        revert with memory
                                          from 128
                                           len mem[96]
                                    mem[_5415 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[_5415 + 168] = 32
                                    idx = 32
                                    while idx < 32:
                                        mem[idx + _5415 + 232] = mem[idx + _5415 + 132]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 32, 32, mem[_5415 + 132]
                                if mem[96]:
                                    require mem[96] >= 32
                                    if not mem[128]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[_5415 + 274 len 22]
                            else:
                                mem[_5415 + 164] = return_data.size
                                mem[_5415 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    if return_data.size:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_5415 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[_5415 + ceil32(return_data.size) + 169] = 32
                                    idx = 32
                                    while idx < 32:
                                        mem[idx + _5415 + ceil32(return_data.size) + 233] = mem[idx + _5415 + 132]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 32, 32, mem[_5415 + 132]
                                if return_data.size:
                                    require return_data.size >= 32
                                    if not mem[_5415 + 196]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[_5415 + ceil32(return_data.size) + 275 len 22]
                        else:
                            require return_data.size >= 32
                            if not mem[_5165 + 32]:
                                revert with 0, 
                                            32,
                                            42,
                                            0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                            mem[mem[64] + 110 len 22]
                            require ext_code.size(address(yieldSourceAddress))
                            staticcall address(yieldSourceAddress).0xc89039c5 with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if not arg2:
                                _5373 = mem[64]
                                mem[mem[64] + 36] = address(yieldSourceAddress)
                                mem[mem[64] + 68] = arg2
                                _5374 = mem[64]
                                mem[mem[64]] = 68
                                mem[64] = mem[64] + 100
                                mem[_5374 + 32] = 0x95ea7b300000000000000000000000000000000000000000000000000000000 or mem[_5374 + 36 len 28]
                                mem[64] = _5373 + 164
                                mem[_5373 + 100] = 32
                                mem[_5373 + 132] = 'SafeERC20: low-level call failed'
                                if eth.balance(this.address) < 0:
                                    revert with 0, 32, 38, 0x6f416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_5373 + 270 len 26]
                                if not ext_code.size(address(ext_call.return_data[0])):
                                    revert with 0, 'Address: call to non-contract'
                                _5525 = mem[_5374]
                                s = _5374 + 32
                                t = _5373 + 164
                                idx = mem[_5374]
                                while idx >= 32:
                                    mem[t] = mem[s]
                                    s = s + 32
                                    t = t + 32
                                    idx = idx - 32
                                    continue 
                                mem[_5373 + floor32(mem[_5374]) + 164] = mem[_5374 + -(mem[_5374] % 32) + floor32(mem[_5374]) + 64 len mem[_5374] % 32] or Mask(8 * -(mem[_5374] % 32) + 32, -(8 * -(mem[_5374] % 32) + 32) + 256, mem[_5373 + floor32(mem[_5374]) + 164])
                                call address(ext_call.return_data[0]).mem[_5373 + 164 len 4] with:
                                     gas gas_remaining wei
                                    args mem[_5373 + 168 len _5525 - 4]
                                if not return_data.size:
                                    if not ext_call.success:
                                        if mem[96]:
                                            revert with memory
                                              from 128
                                               len mem[96]
                                        mem[_5373 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[_5373 + 168] = 32
                                        idx = 32
                                        while idx < 32:
                                            mem[idx + _5373 + 232] = mem[idx + _5373 + 132]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 32, 32, mem[_5373 + 132]
                                    if mem[96]:
                                        require mem[96] >= 32
                                        if not mem[128]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[_5373 + 274 len 22]
                                else:
                                    mem[_5373 + 164] = return_data.size
                                    mem[_5373 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    if not ext_call.success:
                                        if return_data.size:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[_5373 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[_5373 + ceil32(return_data.size) + 169] = 32
                                        idx = 32
                                        while idx < 32:
                                            mem[idx + _5373 + ceil32(return_data.size) + 233] = mem[idx + _5373 + 132]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 32, 32, mem[_5373 + 132]
                                    if return_data.size:
                                        require return_data.size >= 32
                                        if not mem[_5373 + 196]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[_5373 + ceil32(return_data.size) + 275 len 22]
                            else:
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(address(ext_call.return_data[0]))
                                staticcall address(ext_call.return_data[0]).0xdd62ed3e with:
                                        gas gas_remaining wei
                                       args this.address, address(yieldSourceAddress)
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if ext_call.return_data[0]:
                                    revert with 0, 
                                                32,
                                                54,
                                                0x735361666545524332303a20617070726f76652066726f6d206e6f6e2d7a65726f20746f206e6f6e2d7a65726f20616c6c6f77616e63,
                                                mem[mem[64] + 122 len 10]
                                _5453 = mem[64]
                                mem[mem[64] + 36] = address(yieldSourceAddress)
                                mem[mem[64] + 68] = arg2
                                _5454 = mem[64]
                                mem[mem[64]] = 68
                                mem[64] = mem[64] + 100
                                mem[_5454 + 32] = 0x95ea7b300000000000000000000000000000000000000000000000000000000 or mem[_5454 + 36 len 28]
                                mem[64] = _5453 + 164
                                mem[_5453 + 100] = 32
                                mem[_5453 + 132] = 'SafeERC20: low-level call failed'
                                if eth.balance(this.address) < 0:
                                    revert with 0, 32, 38, 0x6f416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_5453 + 270 len 26]
                                if not ext_code.size(address(ext_call.return_data[0])):
                                    revert with 0, 'Address: call to non-contract'
                                _5635 = mem[_5454]
                                s = _5454 + 32
                                t = _5453 + 164
                                idx = mem[_5454]
                                while idx >= 32:
                                    mem[t] = mem[s]
                                    s = s + 32
                                    t = t + 32
                                    idx = idx - 32
                                    continue 
                                mem[_5453 + floor32(mem[_5454]) + 164] = mem[_5454 + -(mem[_5454] % 32) + floor32(mem[_5454]) + 64 len mem[_5454] % 32] or Mask(8 * -(mem[_5454] % 32) + 32, -(8 * -(mem[_5454] % 32) + 32) + 256, mem[_5453 + floor32(mem[_5454]) + 164])
                                call address(ext_call.return_data[0]).mem[_5453 + 164 len 4] with:
                                     gas gas_remaining wei
                                    args mem[_5453 + 168 len _5635 - 4]
                                if not return_data.size:
                                    if not ext_call.success:
                                        if mem[96]:
                                            revert with memory
                                              from 128
                                               len mem[96]
                                        mem[_5453 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[_5453 + 168] = 32
                                        idx = 32
                                        while idx < 32:
                                            mem[idx + _5453 + 232] = mem[idx + _5453 + 132]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 32, 32, mem[_5453 + 132]
                                    if mem[96]:
                                        require mem[96] >= 32
                                        if not mem[128]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[_5453 + 274 len 22]
                                else:
                                    mem[_5453 + 164] = return_data.size
                                    mem[_5453 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    if not ext_call.success:
                                        if return_data.size:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[_5453 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[_5453 + ceil32(return_data.size) + 169] = 32
                                        idx = 32
                                        while idx < 32:
                                            mem[idx + _5453 + ceil32(return_data.size) + 233] = mem[idx + _5453 + 132]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 32, 32, mem[_5453 + 132]
                                    if return_data.size:
                                        require return_data.size >= 32
                                        if not mem[_5453 + 196]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[_5453 + ceil32(return_data.size) + 275 len 22]
                        require ext_code.size(address(yieldSourceAddress))
                        call address(yieldSourceAddress).0x87a6eeef with:
                             gas gas_remaining wei
                            args arg2, this.address
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        emit Deposited(arg2, arg4, msg.sender, arg1, arg3);
                        stor101 = 1
                    if not ext_call.success:
                        if mem[96]:
                            revert with memory
                              from 128
                               len mem[96]
                        _5190 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = mem[(64 * stor152.length) + 292]
                        _5192 = mem[(64 * stor152.length) + 292]
                        if not mem[(64 * stor152.length) + 292]:
                            if not mem[(64 * stor152.length) + 292] % 32:
                                revert with 0, 32, mem[mem[64] + 36 len mem[(64 * stor152.length) + 292] + 32]
                            mem[floor32(mem[(64 * stor152.length) + 292]) + mem[64] + 68] = mem[floor32(mem[(64 * stor152.length) + 292]) + mem[64] + -(mem[(64 * stor152.length) + 292] % 32) + 100 len mem[(64 * stor152.length) + 292] % 32]
                        else:
                            mem[mem[64] + 68] = mem[(64 * stor152.length) + 324]
                            idx = 32
                            while idx < _5192:
                                mem[idx + mem[64] + 68] = mem[idx + (64 * stor152.length) + 324]
                                idx = idx + 32
                                continue 
                            if not _5192 % 32:
                                revert with memory
                                  from mem[64]
                                   len _5192 + _5190 + -mem[64] + 68
                            mem[floor32(_5192) + _5190 + 68] = mem[floor32(_5192) + _5190 + -(_5192 % 32) + 100 len _5192 % 32]
                        revert with memory
                          from mem[64]
                           len floor32(_5192) + _5190 + -mem[64] + 100
                    if not mem[96]:
                        require ext_code.size(address(yieldSourceAddress))
                        staticcall address(yieldSourceAddress).0xc89039c5 with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if not arg2:
                            _5328 = mem[64]
                            mem[mem[64] + 36] = address(yieldSourceAddress)
                            mem[mem[64] + 68] = arg2
                            _5329 = mem[64]
                            mem[mem[64]] = 68
                            mem[64] = mem[64] + 100
                            mem[_5329 + 32] = 0x95ea7b300000000000000000000000000000000000000000000000000000000 or mem[_5329 + 36 len 28]
                            mem[64] = _5328 + 164
                            mem[_5328 + 100] = 32
                            mem[_5328 + 132] = 'SafeERC20: low-level call failed'
                            if eth.balance(this.address) < 0:
                                revert with 0, 32, 38, 0x6f416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_5328 + 270 len 26]
                            if not ext_code.size(address(ext_call.return_data[0])):
                                revert with 0, 'Address: call to non-contract'
                            _5470 = mem[_5329]
                            s = _5329 + 32
                            t = mem[64]
                            idx = mem[_5329]
                            while idx >= 32:
                                mem[t] = mem[s]
                                s = s + 32
                                t = t + 32
                                idx = idx - 32
                                continue 
                            mem[mem[64] + floor32(mem[_5329])] = mem[_5329 + floor32(mem[_5329]) + -(mem[_5329] % 32) + 64 len mem[_5329] % 32] or Mask(8 * -(mem[_5329] % 32) + 32, -(8 * -(mem[_5329] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_5329])])
                            call address(ext_call.return_data[0]).mem[mem[64] len 4] with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len _5470 + _5328 + -mem[64] + 160]
                            if not return_data.size:
                                if ext_call.success:
                                    if mem[96]:
                                        require mem[96] >= 32
                                        if not mem[128]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[mem[64] + 110 len 22]
                                    require ext_code.size(address(yieldSourceAddress))
                                    call address(yieldSourceAddress).0x87a6eeef with:
                                         gas gas_remaining wei
                                        args arg2, this.address
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    emit Deposited(arg2, arg4, msg.sender, arg1, arg3);
                                    stor101 = 1
                                if mem[96]:
                                    revert with memory
                                      from 128
                                       len mem[96]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = mem[_5328 + 100]
                                _9168 = mem[_5328 + 100]
                                if not mem[_5328 + 100]:
                                    if not mem[_5328 + 100] % 32:
                                        revert with 0, 32, mem[mem[64] + 36 len mem[_5328 + 100] + 32]
                                    mem[floor32(mem[_5328 + 100]) + mem[64] + 68] = mem[floor32(mem[_5328 + 100]) + mem[64] + -(mem[_5328 + 100] % 32) + 100 len mem[_5328 + 100] % 32]
                                else:
                                    mem[mem[64] + 68] = mem[_5328 + 132]
                                    idx = 32
                                    while idx < _9168:
                                        mem[idx + mem[64] + 68] = mem[idx + _5328 + 132]
                                        idx = idx + 32
                                        continue 
                                    if not _9168 % 32:
                                        revert with 0, 32, mem[mem[64] + 36 len _9168 + 32]
                                    mem[floor32(_9168) + mem[64] + 68] = mem[floor32(_9168) + mem[64] + -(_9168 % 32) + 100 len _9168 % 32]
                                revert with 0, 32, mem[mem[64] + 36 len floor32(_9168) + 64]
                            _9042 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                            mem[_9042] = return_data.size
                            mem[_9042 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if ext_call.success:
                                if return_data.size:
                                    require return_data.size >= 32
                                    if not mem[_9042 + 32]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[mem[64] + 110 len 22]
                                require ext_code.size(address(yieldSourceAddress))
                                call address(yieldSourceAddress).0x87a6eeef with:
                                     gas gas_remaining wei
                                    args arg2, this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                emit Deposited(arg2, arg4, msg.sender, arg1, arg3);
                                stor101 = 1
                            if return_data.size:
                                revert with ext_call.return_data[0 len return_data.size]
                            _9170 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = mem[_5328 + 100]
                            _9172 = mem[_5328 + 100]
                            if not mem[_5328 + 100]:
                                if not mem[_5328 + 100] % 32:
                                    revert with 0, 32, mem[mem[64] + 36 len mem[_5328 + 100] + 32]
                                mem[floor32(mem[_5328 + 100]) + mem[64] + 68] = mem[floor32(mem[_5328 + 100]) + mem[64] + -(mem[_5328 + 100] % 32) + 100 len mem[_5328 + 100] % 32]
                                revert with 0, 32, mem[mem[64] + 36 len floor32(_9172) + 64]
                            mem[mem[64] + 68] = mem[_5328 + 132]
                            idx = 32
                            while idx < _9172:
                                mem[idx + mem[64] + 68] = mem[idx + _5328 + 132]
                                idx = idx + 32
                                continue 
                            if not _9172 % 32:
                                revert with memory
                                  from mem[64]
                                   len _9172 + _9170 + -mem[64] + 68
                            mem[floor32(_9172) + _9170 + 68] = mem[floor32(_9172) + _9170 + -(_9172 % 32) + 100 len _9172 % 32]
                            revert with memory
                              from mem[64]
                               len floor32(_9172) + _9170 + -mem[64] + 100
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(ext_call.return_data[0]))
                        staticcall address(ext_call.return_data[0]).0xdd62ed3e with:
                                gas gas_remaining wei
                               args this.address, address(yieldSourceAddress)
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if ext_call.return_data[0]:
                            revert with 0, 
                                        32,
                                        54,
                                        0x735361666545524332303a20617070726f76652066726f6d206e6f6e2d7a65726f20746f206e6f6e2d7a65726f20616c6c6f77616e63,
                                        mem[mem[64] + 122 len 10]
                        _5407 = mem[64]
                        mem[mem[64] + 36] = address(yieldSourceAddress)
                        mem[mem[64] + 68] = arg2
                        _5408 = mem[64]
                        mem[mem[64]] = 68
                        mem[64] = mem[64] + 100
                        mem[_5408 + 32] = 0x95ea7b300000000000000000000000000000000000000000000000000000000 or mem[_5408 + 36 len 28]
                        mem[64] = _5407 + 164
                        mem[_5407 + 100] = 32
                        mem[_5407 + 132] = 'SafeERC20: low-level call failed'
                        if eth.balance(this.address) < 0:
                            revert with 0, 32, 38, 0x6f416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_5407 + 270 len 26]
                        if not ext_code.size(address(ext_call.return_data[0])):
                            revert with 0, 'Address: call to non-contract'
                        _5572 = mem[_5408]
                        s = _5408 + 32
                        t = mem[64]
                        idx = mem[_5408]
                        while idx >= 32:
                            mem[t] = mem[s]
                            s = s + 32
                            t = t + 32
                            idx = idx - 32
                            continue 
                        mem[mem[64] + floor32(mem[_5408])] = mem[_5408 + floor32(mem[_5408]) + -(mem[_5408] % 32) + 64 len mem[_5408] % 32] or Mask(8 * -(mem[_5408] % 32) + 32, -(8 * -(mem[_5408] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_5408])])
                        call address(ext_call.return_data[0]).mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len _5572 + _5407 + -mem[64] + 160]
                        if not return_data.size:
                            if ext_call.success:
                                if mem[96]:
                                    require mem[96] >= 32
                                    if not mem[128]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[mem[64] + 110 len 22]
                                require ext_code.size(address(yieldSourceAddress))
                                call address(yieldSourceAddress).0x87a6eeef with:
                                     gas gas_remaining wei
                                    args arg2, this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                emit Deposited(arg2, arg4, msg.sender, arg1, arg3);
                                stor101 = 1
                            if mem[96]:
                                revert with memory
                                  from 128
                                   len mem[96]
                            _9174 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = mem[_5407 + 100]
                            _9176 = mem[_5407 + 100]
                            if not mem[_5407 + 100]:
                                if not mem[_5407 + 100] % 32:
                                    revert with 0, 32, mem[mem[64] + 36 len mem[_5407 + 100] + 32]
                                mem[floor32(mem[_5407 + 100]) + mem[64] + 68] = mem[floor32(mem[_5407 + 100]) + mem[64] + -(mem[_5407 + 100] % 32) + 100 len mem[_5407 + 100] % 32]
                            else:
                                mem[mem[64] + 68] = mem[_5407 + 132]
                                idx = 32
                                while idx < _9176:
                                    mem[idx + mem[64] + 68] = mem[idx + _5407 + 132]
                                    idx = idx + 32
                                    continue 
                                if not _9176 % 32:
                                    revert with memory
                                      from mem[64]
                                       len _9176 + _9174 + -mem[64] + 68
                                mem[floor32(_9176) + _9174 + 68] = mem[floor32(_9176) + _9174 + -(_9176 % 32) + 100 len _9176 % 32]
                            revert with memory
                              from mem[64]
                               len floor32(_9176) + _9174 + -mem[64] + 100
                        _9043 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size) + 1
                        mem[_9043] = return_data.size
                        mem[_9043 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if ext_call.success:
                            if return_data.size:
                                require return_data.size >= 32
                                if not mem[_9043 + 32]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[mem[64] + 110 len 22]
                            require ext_code.size(address(yieldSourceAddress))
                            call address(yieldSourceAddress).0x87a6eeef with:
                                 gas gas_remaining wei
                                args arg2, this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            emit Deposited(arg2, arg4, msg.sender, arg1, arg3);
                            stor101 = 1
                        if return_data.size:
                            revert with ext_call.return_data[0 len return_data.size]
                        _9178 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = mem[_5407 + 100]
                        _9180 = mem[_5407 + 100]
                        if not mem[_5407 + 100]:
                            if not mem[_5407 + 100] % 32:
                                revert with 0, 32, mem[mem[64] + 36 len mem[_5407 + 100] + 32]
                            mem[floor32(mem[_5407 + 100]) + mem[64] + 68] = mem[floor32(mem[_5407 + 100]) + mem[64] + -(mem[_5407 + 100] % 32) + 100 len mem[_5407 + 100] % 32]
                        else:
                            mem[mem[64] + 68] = mem[_5407 + 132]
                            idx = 32
                            while idx < _9180:
                                mem[idx + mem[64] + 68] = mem[idx + _5407 + 132]
                                idx = idx + 32
                                continue 
                            if not _9180 % 32:
                                revert with memory
                                  from mem[64]
                                   len _9180 + _9178 + -mem[64] + 68
                            mem[floor32(_9180) + _9178 + 68] = mem[floor32(_9180) + _9178 + -(_9180 % 32) + 100 len _9180 % 32]
                        revert with memory
                          from mem[64]
                           len floor32(_9180) + _9178 + -mem[64] + 100
                    require mem[96] >= 32
                    if not mem[128]:
                        revert with 0, 
                                    32,
                                    42,
                                    0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                    mem[mem[64] + 110 len 22]
                    require ext_code.size(address(yieldSourceAddress))
                    staticcall address(yieldSourceAddress).0xc89039c5 with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if not arg2:
                        _5369 = mem[64]
                        mem[mem[64] + 36] = address(yieldSourceAddress)
                        mem[mem[64] + 68] = arg2
                        _5370 = mem[64]
                        mem[mem[64]] = 68
                        mem[64] = mem[64] + 100
                        mem[_5370 + 32] = 0x95ea7b300000000000000000000000000000000000000000000000000000000 or mem[_5370 + 36 len 28]
                        mem[64] = _5369 + 164
                        mem[_5369 + 100] = 32
                        mem[_5369 + 132] = 'SafeERC20: low-level call failed'
                        if eth.balance(this.address) < 0:
                            revert with 0, 32, 38, 0x6f416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_5369 + 270 len 26]
                        if not ext_code.size(address(ext_call.return_data[0])):
                            revert with 0, 'Address: call to non-contract'
                        _5517 = mem[_5370]
                        s = _5370 + 32
                        t = _5369 + 164
                        idx = mem[_5370]
                        while idx >= 32:
                            mem[t] = mem[s]
                            s = s + 32
                            t = t + 32
                            idx = idx - 32
                            continue 
                        mem[_5369 + floor32(mem[_5370]) + 164] = mem[_5370 + -(mem[_5370] % 32) + floor32(mem[_5370]) + 64 len mem[_5370] % 32] or Mask(8 * -(mem[_5370] % 32) + 32, -(8 * -(mem[_5370] % 32) + 32) + 256, mem[_5369 + floor32(mem[_5370]) + 164])
                        call address(ext_call.return_data[0]).mem[_5369 + 164 len 4] with:
                             gas gas_remaining wei
                            args mem[_5369 + 168 len _5517 - 4]
                        if not return_data.size:
                            if not ext_call.success:
                                if mem[96]:
                                    revert with memory
                                      from 128
                                       len mem[96]
                                mem[_5369 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[_5369 + 168] = 32
                                idx = 32
                                while idx < 32:
                                    mem[idx + _5369 + 232] = mem[idx + _5369 + 132]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 32, 32, mem[_5369 + 132]
                            if mem[96]:
                                require mem[96] >= 32
                                if not mem[128]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[_5369 + 274 len 22]
                        else:
                            mem[_5369 + 164] = return_data.size
                            mem[_5369 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                if return_data.size:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[_5369 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[_5369 + ceil32(return_data.size) + 169] = 32
                                idx = 32
                                while idx < 32:
                                    mem[idx + _5369 + ceil32(return_data.size) + 233] = mem[idx + _5369 + 132]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 32, 32, mem[_5369 + 132]
                            if return_data.size:
                                require return_data.size >= 32
                                if not mem[_5369 + 196]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[_5369 + ceil32(return_data.size) + 275 len 22]
                        require ext_code.size(address(yieldSourceAddress))
                        call address(yieldSourceAddress).0x87a6eeef with:
                             gas gas_remaining wei
                            args arg2, this.address
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        emit Deposited(arg2, arg4, msg.sender, arg1, arg3);
                        stor101 = 1
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(ext_call.return_data[0]))
                    staticcall address(ext_call.return_data[0]).0xdd62ed3e with:
                            gas gas_remaining wei
                           args this.address, address(yieldSourceAddress)
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if ext_call.return_data[0]:
                        revert with 0, 
                                    32,
                                    54,
                                    0x735361666545524332303a20617070726f76652066726f6d206e6f6e2d7a65726f20746f206e6f6e2d7a65726f20616c6c6f77616e63,
                                    mem[mem[64] + 122 len 10]
                    _5446 = mem[64]
                    mem[mem[64] + 36] = address(yieldSourceAddress)
                    mem[mem[64] + 68] = arg2
                    _5447 = mem[64]
                    mem[mem[64]] = 68
                    mem[64] = mem[64] + 100
                    mem[_5447 + 32] = 0x95ea7b300000000000000000000000000000000000000000000000000000000 or mem[_5447 + 36 len 28]
                    mem[64] = _5446 + 164
                    mem[_5446 + 100] = 32
                    mem[_5446 + 132] = 'SafeERC20: low-level call failed'
                    if eth.balance(this.address) < 0:
                        revert with 0, 32, 38, 0x6f416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_5446 + 270 len 26]
                    if not ext_code.size(address(ext_call.return_data[0])):
                        revert with 0, 'Address: call to non-contract'
                    _5625 = mem[_5447]
                    s = _5447 + 32
                    t = mem[64]
                    idx = mem[_5447]
                    while idx >= 32:
                        mem[t] = mem[s]
                        s = s + 32
                        t = t + 32
                        idx = idx - 32
                        continue 
                    mem[mem[64] + floor32(mem[_5447])] = mem[_5447 + floor32(mem[_5447]) + -(mem[_5447] % 32) + 64 len mem[_5447] % 32] or Mask(8 * -(mem[_5447] % 32) + 32, -(8 * -(mem[_5447] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_5447])])
                    call address(ext_call.return_data[0]).mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len _5625 + _5446 + -mem[64] + 160]
                    if not return_data.size:
                        if ext_call.success:
                            if mem[96]:
                                require mem[96] >= 32
                                if not mem[128]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[mem[64] + 110 len 22]
                            require ext_code.size(address(yieldSourceAddress))
                            call address(yieldSourceAddress).0x87a6eeef with:
                                 gas gas_remaining wei
                                args arg2, this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            emit Deposited(arg2, arg4, msg.sender, arg1, arg3);
                            stor101 = 1
                        if mem[96]:
                            revert with memory
                              from 128
                               len mem[96]
                        _9190 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = mem[_5446 + 100]
                        _9192 = mem[_5446 + 100]
                        if not mem[_5446 + 100]:
                            if not mem[_5446 + 100] % 32:
                                revert with 0, 32, mem[mem[64] + 36 len mem[_5446 + 100] + 32]
                            mem[floor32(mem[_5446 + 100]) + mem[64] + 68] = mem[floor32(mem[_5446 + 100]) + mem[64] + -(mem[_5446 + 100] % 32) + 100 len mem[_5446 + 100] % 32]
                        else:
                            mem[mem[64] + 68] = mem[_5446 + 132]
                            idx = 32
                            while idx < _9192:
                                mem[idx + mem[64] + 68] = mem[idx + _5446 + 132]
                                idx = idx + 32
                                continue 
                            if not _9192 % 32:
                                revert with memory
                                  from mem[64]
                                   len _9192 + _9190 + -mem[64] + 68
                            mem[floor32(_9192) + _9190 + 68] = mem[floor32(_9192) + _9190 + -(_9192 % 32) + 100 len _9192 % 32]
                        revert with memory
                          from mem[64]
                           len floor32(_9192) + _9190 + -mem[64] + 100
                    _9045 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size) + 1
                    mem[_9045] = return_data.size
                    mem[_9045 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if ext_call.success:
                        if return_data.size:
                            require return_data.size >= 32
                            if not mem[_9045 + 32]:
                                revert with 0, 
                                            32,
                                            42,
                                            0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                            mem[mem[64] + 110 len 22]
                        require ext_code.size(address(yieldSourceAddress))
                        call address(yieldSourceAddress).0x87a6eeef with:
                             gas gas_remaining wei
                            args arg2, this.address
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        emit Deposited(arg2, arg4, msg.sender, arg1, arg3);
                        stor101 = 1
                    if return_data.size:
                        revert with ext_call.return_data[0 len return_data.size]
                    _9194 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = mem[_5446 + 100]
                    _9196 = mem[_5446 + 100]
                    if not mem[_5446 + 100]:
                        if not mem[_5446 + 100] % 32:
                            revert with 0, 32, mem[mem[64] + 36 len mem[_5446 + 100] + 32]
                        mem[floor32(mem[_5446 + 100]) + mem[64] + 68] = mem[floor32(mem[_5446 + 100]) + mem[64] + -(mem[_5446 + 100] % 32) + 100 len mem[_5446 + 100] % 32]
                    else:
                        mem[mem[64] + 68] = mem[_5446 + 132]
                        idx = 32
                        while idx < _9196:
                            mem[idx + mem[64] + 68] = mem[idx + _5446 + 132]
                            idx = idx + 32
                            continue 
                        if not _9196 % 32:
                            revert with memory
                              from mem[64]
                               len _9196 + _9194 + -mem[64] + 68
                        mem[floor32(_9196) + _9194 + 68] = mem[floor32(_9196) + _9194 + -(_9196 % 32) + 100 len _9196 % 32]
                    revert with memory
                      from mem[64]
                       len floor32(_9196) + _9194 + -mem[64] + 100
                require ext_code.size(arg3)
                call arg3.0x5d7b0758 with:
                     gas gas_remaining wei
                    args address(arg1), arg2
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require ext_code.size(address(yieldSourceAddress))
                staticcall address(yieldSourceAddress).0xc89039c5 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                mem[(64 * stor152.length) + 196] = msg.sender
                mem[(64 * stor152.length) + 228] = this.address
                mem[(64 * stor152.length) + 260] = arg2
                mem[(64 * stor152.length) + 160] = 100
                mem[(64 * stor152.length) + 192] = 0x23b872dd00000000000000000000000000000000000000000000000000000000 or Mask(224, 32, msg.sender) >> 32
                mem[64] = (64 * stor152.length) + 356
                mem[(64 * stor152.length) + 292] = 32
                mem[(64 * stor152.length) + 324] = 'SafeERC20: low-level call failed'
                if eth.balance(this.address) < 0:
                    revert with 0, 
                                32,
                                38,
                                0x6f416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c,
                                mem[(64 * stor152.length) + 462 len 26]
                if not ext_code.size(address(ext_call.return_data[0])):
                    revert with 0, 'Address: call to non-contract'
                s = (64 * stor152.length) + 192
                t = mem[64]
                idx = mem[(64 * stor152.length) + 160]
                while idx >= 32:
                    mem[t] = mem[s]
                    s = s + 32
                    t = t + 32
                    idx = idx - 32
                    continue 
                mem[mem[64] + floor32(mem[(64 * stor152.length) + 160])] = mem[(64 * stor152.length) + floor32(mem[(64 * stor152.length) + 160]) + -(mem[(64 * stor152.length) + 160] % 32) + 224 len mem[(64 * stor152.length) + 160] % 32] or Mask(8 * -(mem[(64 * stor152.length) + 160] % 32) + 32, -(8 * -(mem[(64 * stor152.length) + 160] % 32) + 32) + 256, mem[mem[64] + floor32(mem[(64 * stor152.length) + 160])])
                call address(ext_call.return_data[0]).mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len (64 * stor152.length) + -mem[64] + 452]
                if not return_data.size:
                    if not ext_call.success:
                        if mem[96]:
                            revert with memory
                              from 128
                               len mem[96]
                        _5182 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = mem[(64 * stor152.length) + 292]
                        _5184 = mem[(64 * stor152.length) + 292]
                        if not mem[(64 * stor152.length) + 292]:
                            if not mem[(64 * stor152.length) + 292] % 32:
                                revert with 0, 32, mem[mem[64] + 36 len mem[(64 * stor152.length) + 292] + 32]
                            mem[floor32(mem[(64 * stor152.length) + 292]) + mem[64] + 68] = mem[floor32(mem[(64 * stor152.length) + 292]) + mem[64] + -(mem[(64 * stor152.length) + 292] % 32) + 100 len mem[(64 * stor152.length) + 292] % 32]
                        else:
                            mem[mem[64] + 68] = mem[(64 * stor152.length) + 324]
                            idx = 32
                            while idx < _5184:
                                mem[idx + mem[64] + 68] = mem[idx + (64 * stor152.length) + 324]
                                idx = idx + 32
                                continue 
                            if not _5184 % 32:
                                revert with memory
                                  from mem[64]
                                   len _5184 + _5182 + -mem[64] + 68
                            mem[floor32(_5184) + _5182 + 68] = mem[floor32(_5184) + _5182 + -(_5184 % 32) + 100 len _5184 % 32]
                        revert with memory
                          from mem[64]
                           len floor32(_5184) + _5182 + -mem[64] + 100
                    if mem[96]:
                        require mem[96] >= 32
                        if not mem[128]:
                            revert with 0, 
                                        32,
                                        42,
                                        0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                        mem[mem[64] + 110 len 22]
                        require ext_code.size(address(yieldSourceAddress))
                        staticcall address(yieldSourceAddress).0xc89039c5 with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if not arg2:
                            _5361 = mem[64]
                            mem[mem[64] + 36] = address(yieldSourceAddress)
                            mem[mem[64] + 68] = arg2
                            _5362 = mem[64]
                            mem[mem[64]] = 68
                            mem[64] = mem[64] + 100
                            mem[_5362 + 32] = 0x95ea7b300000000000000000000000000000000000000000000000000000000 or mem[_5362 + 36 len 28]
                            mem[64] = _5361 + 164
                            mem[_5361 + 100] = 32
                            mem[_5361 + 132] = 'SafeERC20: low-level call failed'
                            if eth.balance(this.address) < 0:
                                revert with 0, 32, 38, 0x6f416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_5361 + 270 len 26]
                            if not ext_code.size(address(ext_call.return_data[0])):
                                revert with 0, 'Address: call to non-contract'
                            _5501 = mem[_5362]
                            s = _5362 + 32
                            t = _5361 + 164
                            idx = mem[_5362]
                            while idx >= 32:
                                mem[t] = mem[s]
                                s = s + 32
                                t = t + 32
                                idx = idx - 32
                                continue 
                            mem[_5361 + floor32(mem[_5362]) + 164] = mem[_5362 + -(mem[_5362] % 32) + floor32(mem[_5362]) + 64 len mem[_5362] % 32] or Mask(8 * -(mem[_5362] % 32) + 32, -(8 * -(mem[_5362] % 32) + 32) + 256, mem[_5361 + floor32(mem[_5362]) + 164])
                            call address(ext_call.return_data[0]).mem[_5361 + 164 len 4] with:
                                 gas gas_remaining wei
                                args mem[_5361 + 168 len _5501 - 4]
                            if not return_data.size:
                                if not ext_call.success:
                                    if mem[96]:
                                        revert with memory
                                          from 128
                                           len mem[96]
                                    mem[_5361 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[_5361 + 168] = 32
                                    idx = 32
                                    while idx < 32:
                                        mem[idx + _5361 + 232] = mem[idx + _5361 + 132]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 32, 32, mem[_5361 + 132]
                                if mem[96]:
                                    require mem[96] >= 32
                                    if not mem[128]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[_5361 + 274 len 22]
                            else:
                                mem[_5361 + 164] = return_data.size
                                mem[_5361 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    if return_data.size:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_5361 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[_5361 + ceil32(return_data.size) + 169] = 32
                                    idx = 32
                                    while idx < 32:
                                        mem[idx + _5361 + ceil32(return_data.size) + 233] = mem[idx + _5361 + 132]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 32, 32, mem[_5361 + 132]
                                if return_data.size:
                                    require return_data.size >= 32
                                    if not mem[_5361 + 196]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[_5361 + ceil32(return_data.size) + 275 len 22]
                        else:
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(address(ext_call.return_data[0]))
                            staticcall address(ext_call.return_data[0]).0xdd62ed3e with:
                                    gas gas_remaining wei
                                   args this.address, address(yieldSourceAddress)
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if ext_call.return_data[0]:
                                revert with 0, 
                                            32,
                                            54,
                                            0x735361666545524332303a20617070726f76652066726f6d206e6f6e2d7a65726f20746f206e6f6e2d7a65726f20616c6c6f77616e63,
                                            mem[mem[64] + 122 len 10]
                            _5432 = mem[64]
                            mem[mem[64] + 36] = address(yieldSourceAddress)
                            mem[mem[64] + 68] = arg2
                            _5433 = mem[64]
                            mem[mem[64]] = 68
                            mem[64] = mem[64] + 100
                            mem[_5433 + 32] = 0x95ea7b300000000000000000000000000000000000000000000000000000000 or mem[_5433 + 36 len 28]
                            mem[64] = _5432 + 164
                            mem[_5432 + 100] = 32
                            mem[_5432 + 132] = 'SafeERC20: low-level call failed'
                            if eth.balance(this.address) < 0:
                                revert with 0, 32, 38, 0x6f416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_5432 + 270 len 26]
                            if not ext_code.size(address(ext_call.return_data[0])):
                                revert with 0, 'Address: call to non-contract'
                            _5605 = mem[_5433]
                            s = _5433 + 32
                            t = _5432 + 164
                            idx = mem[_5433]
                            while idx >= 32:
                                mem[t] = mem[s]
                                s = s + 32
                                t = t + 32
                                idx = idx - 32
                                continue 
                            mem[_5432 + floor32(mem[_5433]) + 164] = mem[_5433 + -(mem[_5433] % 32) + floor32(mem[_5433]) + 64 len mem[_5433] % 32] or Mask(8 * -(mem[_5433] % 32) + 32, -(8 * -(mem[_5433] % 32) + 32) + 256, mem[_5432 + floor32(mem[_5433]) + 164])
                            call address(ext_call.return_data[0]).mem[_5432 + 164 len 4] with:
                                 gas gas_remaining wei
                                args mem[_5432 + 168 len _5605 - 4]
                            if not return_data.size:
                                if not ext_call.success:
                                    if mem[96]:
                                        revert with memory
                                          from 128
                                           len mem[96]
                                    mem[_5432 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[_5432 + 168] = 32
                                    idx = 32
                                    while idx < 32:
                                        mem[idx + _5432 + 232] = mem[idx + _5432 + 132]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 32, 32, mem[_5432 + 132]
                                if mem[96]:
                                    require mem[96] >= 32
                                    if not mem[128]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[_5432 + 274 len 22]
                            else:
                                mem[_5432 + 164] = return_data.size
                                mem[_5432 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    if return_data.size:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_5432 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[_5432 + ceil32(return_data.size) + 169] = 32
                                    idx = 32
                                    while idx < 32:
                                        mem[idx + _5432 + ceil32(return_data.size) + 233] = mem[idx + _5432 + 132]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 32, 32, mem[_5432 + 132]
                                if return_data.size:
                                    require return_data.size >= 32
                                    if not mem[_5432 + 196]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[_5432 + ceil32(return_data.size) + 275 len 22]
                        require ext_code.size(address(yieldSourceAddress))
                        call address(yieldSourceAddress).0x87a6eeef with:
                             gas gas_remaining wei
                            args arg2, this.address
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        emit Deposited(arg2, arg4, msg.sender, arg1, arg3);
                        stor101 = 1
                    require ext_code.size(address(yieldSourceAddress))
                    staticcall address(yieldSourceAddress).0xc89039c5 with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if not arg2:
                        _5322 = mem[64]
                        mem[mem[64] + 36] = address(yieldSourceAddress)
                        mem[mem[64] + 68] = arg2
                        _5323 = mem[64]
                        mem[mem[64]] = 68
                        mem[64] = mem[64] + 100
                        mem[_5323 + 32] = 0x95ea7b300000000000000000000000000000000000000000000000000000000 or mem[_5323 + 36 len 28]
                        mem[64] = _5322 + 164
                        mem[_5322 + 100] = 32
                        mem[_5322 + 132] = 'SafeERC20: low-level call failed'
                        if eth.balance(this.address) < 0:
                            revert with 0, 32, 38, 0x6f416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_5322 + 270 len 26]
                        if not ext_code.size(address(ext_call.return_data[0])):
                            revert with 0, 'Address: call to non-contract'
                        _5460 = mem[_5323]
                        s = _5323 + 32
                        t = _5322 + 164
                        idx = mem[_5323]
                        while idx >= 32:
                            mem[t] = mem[s]
                            s = s + 32
                            t = t + 32
                            idx = idx - 32
                            continue 
                        mem[_5322 + floor32(mem[_5323]) + 164] = mem[_5323 + -(mem[_5323] % 32) + floor32(mem[_5323]) + 64 len mem[_5323] % 32] or Mask(8 * -(mem[_5323] % 32) + 32, -(8 * -(mem[_5323] % 32) + 32) + 256, mem[_5322 + floor32(mem[_5323]) + 164])
                        call address(ext_call.return_data[0]).mem[_5322 + 164 len 4] with:
                             gas gas_remaining wei
                            args mem[_5322 + 168 len _5460 - 4]
                        if not return_data.size:
                            if not ext_call.success:
                                if mem[96]:
                                    revert with memory
                                      from 128
                                       len mem[96]
                                mem[_5322 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[_5322 + 168] = 32
                                idx = 32
                                while idx < 32:
                                    mem[idx + _5322 + 232] = mem[idx + _5322 + 132]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 32, 32, mem[_5322 + 132]
                            if mem[96]:
                                require mem[96] >= 32
                                if not mem[128]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[_5322 + 274 len 22]
                        else:
                            mem[_5322 + 164] = return_data.size
                            mem[_5322 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                if return_data.size:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[_5322 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[_5322 + ceil32(return_data.size) + 169] = 32
                                idx = 32
                                while idx < 32:
                                    mem[idx + _5322 + ceil32(return_data.size) + 233] = mem[idx + _5322 + 132]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 32, 32, mem[_5322 + 132]
                            if return_data.size:
                                require return_data.size >= 32
                                if not mem[_5322 + 196]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[_5322 + ceil32(return_data.size) + 275 len 22]
                        require ext_code.size(address(yieldSourceAddress))
                        call address(yieldSourceAddress).0x87a6eeef with:
                             gas gas_remaining wei
                            args arg2, this.address
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        emit Deposited(arg2, arg4, msg.sender, arg1, arg3);
                        stor101 = 1
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(ext_call.return_data[0]))
                    staticcall address(ext_call.return_data[0]).0xdd62ed3e with:
                            gas gas_remaining wei
                           args this.address, address(yieldSourceAddress)
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if ext_call.return_data[0]:
                        revert with 0, 
                                    32,
                                    54,
                                    0x735361666545524332303a20617070726f76652066726f6d206e6f6e2d7a65726f20746f206e6f6e2d7a65726f20616c6c6f77616e63,
                                    mem[mem[64] + 122 len 10]
                    _5391 = mem[64]
                    mem[mem[64] + 36] = address(yieldSourceAddress)
                    mem[mem[64] + 68] = arg2
                    _5392 = mem[64]
                    mem[mem[64]] = 68
                    mem[64] = mem[64] + 100
                    mem[_5392 + 32] = 0x95ea7b300000000000000000000000000000000000000000000000000000000 or mem[_5392 + 36 len 28]
                    mem[64] = _5391 + 164
                    mem[_5391 + 100] = 32
                    mem[_5391 + 132] = 'SafeERC20: low-level call failed'
                    if eth.balance(this.address) < 0:
                        revert with 0, 32, 38, 0x6f416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_5391 + 270 len 26]
                    if not ext_code.size(address(ext_call.return_data[0])):
                        revert with 0, 'Address: call to non-contract'
                    _5556 = mem[_5392]
                    s = _5392 + 32
                    t = mem[64]
                    idx = mem[_5392]
                    while idx >= 32:
                        mem[t] = mem[s]
                        s = s + 32
                        t = t + 32
                        idx = idx - 32
                        continue 
                    mem[mem[64] + floor32(mem[_5392])] = mem[_5392 + floor32(mem[_5392]) + -(mem[_5392] % 32) + 64 len mem[_5392] % 32] or Mask(8 * -(mem[_5392] % 32) + 32, -(8 * -(mem[_5392] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_5392])])
                    call address(ext_call.return_data[0]).mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len _5556 + _5391 + -mem[64] + 160]
                    if not return_data.size:
                        if ext_call.success:
                            if mem[96]:
                                require mem[96] >= 32
                                if not mem[128]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[mem[64] + 110 len 22]
                            require ext_code.size(address(yieldSourceAddress))
                            call address(yieldSourceAddress).0x87a6eeef with:
                                 gas gas_remaining wei
                                args arg2, this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            emit Deposited(arg2, arg4, msg.sender, arg1, arg3);
                            stor101 = 1
                        if mem[96]:
                            revert with memory
                              from 128
                               len mem[96]
                        _9110 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = mem[_5391 + 100]
                        _9112 = mem[_5391 + 100]
                        if not mem[_5391 + 100]:
                            if not mem[_5391 + 100] % 32:
                                revert with 0, 32, mem[mem[64] + 36 len mem[_5391 + 100] + 32]
                            mem[floor32(mem[_5391 + 100]) + mem[64] + 68] = mem[floor32(mem[_5391 + 100]) + mem[64] + -(mem[_5391 + 100] % 32) + 100 len mem[_5391 + 100] % 32]
                            revert with 0, 32, mem[mem[64] + 36 len floor32(_9112) + 64]
                        mem[mem[64] + 68] = mem[_5391 + 132]
                        idx = 32
                        while idx < _9112:
                            mem[idx + mem[64] + 68] = mem[idx + _5391 + 132]
                            idx = idx + 32
                            continue 
                        if not _9112 % 32:
                            revert with memory
                              from mem[64]
                               len _9112 + _9110 + -mem[64] + 68
                        mem[floor32(_9112) + _9110 + 68] = mem[floor32(_9112) + _9110 + -(_9112 % 32) + 100 len _9112 % 32]
                        revert with memory
                          from mem[64]
                           len floor32(_9112) + _9110 + -mem[64] + 100
                    _9031 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size) + 1
                    mem[_9031] = return_data.size
                    mem[_9031 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if ext_call.success:
                        if return_data.size:
                            require return_data.size >= 32
                            if not mem[_9031 + 32]:
                                revert with 0, 
                                            32,
                                            42,
                                            0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                            mem[mem[64] + 110 len 22]
                        require ext_code.size(address(yieldSourceAddress))
                        call address(yieldSourceAddress).0x87a6eeef with:
                             gas gas_remaining wei
                            args arg2, this.address
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        emit Deposited(arg2, arg4, msg.sender, arg1, arg3);
                        stor101 = 1
                    if return_data.size:
                        revert with ext_call.return_data[0 len return_data.size]
                    _9114 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = mem[_5391 + 100]
                    _9116 = mem[_5391 + 100]
                    if not mem[_5391 + 100]:
                        if not mem[_5391 + 100] % 32:
                            revert with 0, 32, mem[mem[64] + 36 len mem[_5391 + 100] + 32]
                        mem[floor32(mem[_5391 + 100]) + mem[64] + 68] = mem[floor32(mem[_5391 + 100]) + mem[64] + -(mem[_5391 + 100] % 32) + 100 len mem[_5391 + 100] % 32]
                        revert with 0, 32, mem[mem[64] + 36 len floor32(_9116) + 64]
                    mem[mem[64] + 68] = mem[_5391 + 132]
                    idx = 32
                    while idx < _9116:
                        mem[idx + mem[64] + 68] = mem[idx + _5391 + 132]
                        idx = idx + 32
                        continue 
                    if not _9116 % 32:
                        revert with memory
                          from mem[64]
                           len _9116 + _9114 + -mem[64] + 68
                    mem[floor32(_9116) + _9114 + 68] = mem[floor32(_9116) + _9114 + -(_9116 % 32) + 100 len _9116 % 32]
                    revert with memory
                      from mem[64]
                       len floor32(_9116) + _9114 + -mem[64] + 100
                _5164 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size) + 1
                mem[_5164] = return_data.size
                mem[_5164 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not ext_call.success:
                    if return_data.size:
                        revert with ext_call.return_data[0 len return_data.size]
                    _5186 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = mem[(64 * stor152.length) + 292]
                    _5188 = mem[(64 * stor152.length) + 292]
                    if not mem[(64 * stor152.length) + 292]:
                        if not mem[(64 * stor152.length) + 292] % 32:
                            revert with 0, 32, mem[mem[64] + 36 len mem[(64 * stor152.length) + 292] + 32]
                        mem[floor32(mem[(64 * stor152.length) + 292]) + mem[64] + 68] = mem[floor32(mem[(64 * stor152.length) + 292]) + mem[64] + -(mem[(64 * stor152.length) + 292] % 32) + 100 len mem[(64 * stor152.length) + 292] % 32]
                    else:
                        mem[mem[64] + 68] = mem[(64 * stor152.length) + 324]
                        idx = 32
                        while idx < _5188:
                            mem[idx + mem[64] + 68] = mem[idx + (64 * stor152.length) + 324]
                            idx = idx + 32
                            continue 
                        if not _5188 % 32:
                            revert with memory
                              from mem[64]
                               len _5188 + _5186 + -mem[64] + 68
                        mem[floor32(_5188) + _5186 + 68] = mem[floor32(_5188) + _5186 + -(_5188 % 32) + 100 len _5188 % 32]
                    revert with memory
                      from mem[64]
                       len floor32(_5188) + _5186 + -mem[64] + 100
                if not return_data.size:
                    require ext_code.size(address(yieldSourceAddress))
                    staticcall address(yieldSourceAddress).0xc89039c5 with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if not arg2:
                        _5325 = mem[64]
                        mem[mem[64] + 36] = address(yieldSourceAddress)
                        mem[mem[64] + 68] = arg2
                        _5326 = mem[64]
                        mem[mem[64]] = 68
                        mem[64] = mem[64] + 100
                        mem[_5326 + 32] = 0x95ea7b300000000000000000000000000000000000000000000000000000000 or mem[_5326 + 36 len 28]
                        mem[64] = _5325 + 164
                        mem[_5325 + 100] = 32
                        mem[_5325 + 132] = 'SafeERC20: low-level call failed'
                        if eth.balance(this.address) < 0:
                            revert with 0, 32, 38, 0x6f416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_5325 + 270 len 26]
                        if not ext_code.size(address(ext_call.return_data[0])):
                            revert with 0, 'Address: call to non-contract'
                        _5465 = mem[_5326]
                        s = _5326 + 32
                        t = mem[64]
                        idx = mem[_5326]
                        while idx >= 32:
                            mem[t] = mem[s]
                            s = s + 32
                            t = t + 32
                            idx = idx - 32
                            continue 
                        mem[mem[64] + floor32(mem[_5326])] = mem[_5326 + floor32(mem[_5326]) + -(mem[_5326] % 32) + 64 len mem[_5326] % 32] or Mask(8 * -(mem[_5326] % 32) + 32, -(8 * -(mem[_5326] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_5326])])
                        call address(ext_call.return_data[0]).mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len _5465 + _5325 + -mem[64] + 160]
                        if not return_data.size:
                            if ext_call.success:
                                if mem[96]:
                                    require mem[96] >= 32
                                    if not mem[128]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[mem[64] + 110 len 22]
                                require ext_code.size(address(yieldSourceAddress))
                                call address(yieldSourceAddress).0x87a6eeef with:
                                     gas gas_remaining wei
                                    args arg2, this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                emit Deposited(arg2, arg4, msg.sender, arg1, arg3);
                                stor101 = 1
                            if mem[96]:
                                revert with memory
                                  from 128
                                   len mem[96]
                            _9134 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = mem[_5325 + 100]
                            _9136 = mem[_5325 + 100]
                            if not mem[_5325 + 100]:
                                if not mem[_5325 + 100] % 32:
                                    revert with 0, 32, mem[mem[64] + 36 len mem[_5325 + 100] + 32]
                                mem[floor32(mem[_5325 + 100]) + mem[64] + 68] = mem[floor32(mem[_5325 + 100]) + mem[64] + -(mem[_5325 + 100] % 32) + 100 len mem[_5325 + 100] % 32]
                                revert with 0, 32, mem[mem[64] + 36 len floor32(_9136) + 64]
                            mem[mem[64] + 68] = mem[_5325 + 132]
                            idx = 32
                            while idx < _9136:
                                mem[idx + mem[64] + 68] = mem[idx + _5325 + 132]
                                idx = idx + 32
                                continue 
                            if not _9136 % 32:
                                revert with memory
                                  from mem[64]
                                   len _9136 + _9134 + -mem[64] + 68
                            mem[floor32(_9136) + _9134 + 68] = mem[floor32(_9136) + _9134 + -(_9136 % 32) + 100 len _9136 % 32]
                            revert with memory
                              from mem[64]
                               len floor32(_9136) + _9134 + -mem[64] + 100
                        _9036 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size) + 1
                        mem[_9036] = return_data.size
                        mem[_9036 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if ext_call.success:
                            if return_data.size:
                                require return_data.size >= 32
                                if not mem[_9036 + 32]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[mem[64] + 110 len 22]
                            require ext_code.size(address(yieldSourceAddress))
                            call address(yieldSourceAddress).0x87a6eeef with:
                                 gas gas_remaining wei
                                args arg2, this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            emit Deposited(arg2, arg4, msg.sender, arg1, arg3);
                            stor101 = 1
                        if return_data.size:
                            revert with ext_call.return_data[0 len return_data.size]
                        _9138 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = mem[_5325 + 100]
                        _9140 = mem[_5325 + 100]
                        if not mem[_5325 + 100]:
                            if not mem[_5325 + 100] % 32:
                                revert with 0, 32, mem[mem[64] + 36 len mem[_5325 + 100] + 32]
                            mem[floor32(mem[_5325 + 100]) + mem[64] + 68] = mem[floor32(mem[_5325 + 100]) + mem[64] + -(mem[_5325 + 100] % 32) + 100 len mem[_5325 + 100] % 32]
                            revert with 0, 32, mem[mem[64] + 36 len floor32(_9140) + 64]
                        mem[mem[64] + 68] = mem[_5325 + 132]
                        idx = 32
                        while idx < _9140:
                            mem[idx + mem[64] + 68] = mem[idx + _5325 + 132]
                            idx = idx + 32
                            continue 
                        if not _9140 % 32:
                            revert with memory
                              from mem[64]
                               len _9140 + _9138 + -mem[64] + 68
                        mem[floor32(_9140) + _9138 + 68] = mem[floor32(_9140) + _9138 + -(_9140 % 32) + 100 len _9140 % 32]
                        revert with memory
                          from mem[64]
                           len floor32(_9140) + _9138 + -mem[64] + 100
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(ext_call.return_data[0]))
                    staticcall address(ext_call.return_data[0]).0xdd62ed3e with:
                            gas gas_remaining wei
                           args this.address, address(yieldSourceAddress)
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if ext_call.return_data[0]:
                        revert with 0, 
                                    32,
                                    54,
                                    0x735361666545524332303a20617070726f76652066726f6d206e6f6e2d7a65726f20746f206e6f6e2d7a65726f20616c6c6f77616e63,
                                    mem[mem[64] + 122 len 10]
                    _5399 = mem[64]
                    mem[mem[64] + 36] = address(yieldSourceAddress)
                    mem[mem[64] + 68] = arg2
                    _5400 = mem[64]
                    mem[mem[64]] = 68
                    mem[64] = mem[64] + 100
                    mem[_5400 + 32] = 0x95ea7b300000000000000000000000000000000000000000000000000000000 or mem[_5400 + 36 len 28]
                    mem[64] = _5399 + 164
                    mem[_5399 + 100] = 32
                    mem[_5399 + 132] = 'SafeERC20: low-level call failed'
                    if eth.balance(this.address) < 0:
                        revert with 0, 32, 38, 0x6f416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_5399 + 270 len 26]
                    if not ext_code.size(address(ext_call.return_data[0])):
                        revert with 0, 'Address: call to non-contract'
                    _5564 = mem[_5400]
                    s = _5400 + 32
                    t = mem[64]
                    idx = mem[_5400]
                    while idx >= 32:
                        mem[t] = mem[s]
                        s = s + 32
                        t = t + 32
                        idx = idx - 32
                        continue 
                    mem[mem[64] + floor32(mem[_5400])] = mem[_5400 + floor32(mem[_5400]) + -(mem[_5400] % 32) + 64 len mem[_5400] % 32] or Mask(8 * -(mem[_5400] % 32) + 32, -(8 * -(mem[_5400] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_5400])])
                    call address(ext_call.return_data[0]).mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len _5564 + _5399 + -mem[64] + 160]
                    if not return_data.size:
                        if ext_call.success:
                            if mem[96]:
                                require mem[96] >= 32
                                if not mem[128]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[mem[64] + 110 len 22]
                            require ext_code.size(address(yieldSourceAddress))
                            call address(yieldSourceAddress).0x87a6eeef with:
                                 gas gas_remaining wei
                                args arg2, this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            emit Deposited(arg2, arg4, msg.sender, arg1, arg3);
                            stor101 = 1
                        if mem[96]:
                            revert with memory
                              from 128
                               len mem[96]
                        _9142 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = mem[_5399 + 100]
                        _9144 = mem[_5399 + 100]
                        if not mem[_5399 + 100]:
                            if not mem[_5399 + 100] % 32:
                                revert with 0, 32, mem[mem[64] + 36 len mem[_5399 + 100] + 32]
                            mem[floor32(mem[_5399 + 100]) + mem[64] + 68] = mem[floor32(mem[_5399 + 100]) + mem[64] + -(mem[_5399 + 100] % 32) + 100 len mem[_5399 + 100] % 32]
                        else:
                            mem[mem[64] + 68] = mem[_5399 + 132]
                            idx = 32
                            while idx < _9144:
                                mem[idx + mem[64] + 68] = mem[idx + _5399 + 132]
                                idx = idx + 32
                                continue 
                            if not _9144 % 32:
                                revert with memory
                                  from mem[64]
                                   len _9144 + _9142 + -mem[64] + 68
                            mem[floor32(_9144) + _9142 + 68] = mem[floor32(_9144) + _9142 + -(_9144 % 32) + 100 len _9144 % 32]
                        revert with memory
                          from mem[64]
                           len floor32(_9144) + _9142 + -mem[64] + 100
                    _9037 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size) + 1
                    mem[_9037] = return_data.size
                    mem[_9037 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if ext_call.success:
                        if return_data.size:
                            require return_data.size >= 32
                            if not mem[_9037 + 32]:
                                revert with 0, 
                                            32,
                                            42,
                                            0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                            mem[mem[64] + 110 len 22]
                        require ext_code.size(address(yieldSourceAddress))
                        call address(yieldSourceAddress).0x87a6eeef with:
                             gas gas_remaining wei
                            args arg2, this.address
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        emit Deposited(arg2, arg4, msg.sender, arg1, arg3);
                        stor101 = 1
                    if return_data.size:
                        revert with ext_call.return_data[0 len return_data.size]
                    _9146 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = mem[_5399 + 100]
                    _9148 = mem[_5399 + 100]
                    if not mem[_5399 + 100]:
                        if not mem[_5399 + 100] % 32:
                            revert with 0, 32, mem[mem[64] + 36 len mem[_5399 + 100] + 32]
                        mem[floor32(mem[_5399 + 100]) + mem[64] + 68] = mem[floor32(mem[_5399 + 100]) + mem[64] + -(mem[_5399 + 100] % 32) + 100 len mem[_5399 + 100] % 32]
                        revert with memory
                          from mem[64]
                           len floor32(_9148) + _9146 + -mem[64] + 100
                    mem[mem[64] + 68] = mem[_5399 + 132]
                    idx = 32
                    while idx < _9148:
                        mem[idx + mem[64] + 68] = mem[idx + _5399 + 132]
                        idx = idx + 32
                        continue 
                    if not _9148 % 32:
                        revert with 0, 32, mem[mem[64] + 36 len _9148 + 32]
                    mem[floor32(_9148) + mem[64] + 68] = mem[floor32(_9148) + mem[64] + -(_9148 % 32) + 100 len _9148 % 32]
                    revert with 0, 32, mem[mem[64] + 36 len floor32(_9148) + 64]
                require return_data.size >= 32
                if not mem[_5164 + 32]:
                    revert with 0, 
                                32,
                                42,
                                0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                mem[mem[64] + 110 len 22]
                require ext_code.size(address(yieldSourceAddress))
                staticcall address(yieldSourceAddress).0xc89039c5 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if not arg2:
                    _5365 = mem[64]
                    mem[mem[64] + 36] = address(yieldSourceAddress)
                    mem[mem[64] + 68] = arg2
                    _5366 = mem[64]
                    mem[mem[64]] = 68
                    mem[64] = mem[64] + 100
                    mem[_5366 + 32] = 0x95ea7b300000000000000000000000000000000000000000000000000000000 or mem[_5366 + 36 len 28]
                    mem[64] = _5365 + 164
                    mem[_5365 + 100] = 32
                    mem[_5365 + 132] = 'SafeERC20: low-level call failed'
                    if eth.balance(this.address) < 0:
                        revert with 0, 32, 38, 0x6f416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_5365 + 270 len 26]
                    if not ext_code.size(address(ext_call.return_data[0])):
                        revert with 0, 'Address: call to non-contract'
                    _5509 = mem[_5366]
                    s = _5366 + 32
                    t = mem[64]
                    idx = mem[_5366]
                    while idx >= 32:
                        mem[t] = mem[s]
                        s = s + 32
                        t = t + 32
                        idx = idx - 32
                        continue 
                    mem[mem[64] + floor32(mem[_5366])] = mem[_5366 + floor32(mem[_5366]) + -(mem[_5366] % 32) + 64 len mem[_5366] % 32] or Mask(8 * -(mem[_5366] % 32) + 32, -(8 * -(mem[_5366] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_5366])])
                    call address(ext_call.return_data[0]).mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len _5509 + _5365 + -mem[64] + 160]
                    if not return_data.size:
                        if ext_call.success:
                            if mem[96]:
                                require mem[96] >= 32
                                if not mem[128]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[mem[64] + 110 len 22]
                            require ext_code.size(address(yieldSourceAddress))
                            call address(yieldSourceAddress).0x87a6eeef with:
                                 gas gas_remaining wei
                                args arg2, this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            emit Deposited(arg2, arg4, msg.sender, arg1, arg3);
                            stor101 = 1
                        if mem[96]:
                            revert with memory
                              from 128
                               len mem[96]
                        _9150 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = mem[_5365 + 100]
                        _9152 = mem[_5365 + 100]
                        if not mem[_5365 + 100]:
                            if not mem[_5365 + 100] % 32:
                                revert with 0, 32, mem[mem[64] + 36 len mem[_5365 + 100] + 32]
                            mem[floor32(mem[_5365 + 100]) + mem[64] + 68] = mem[floor32(mem[_5365 + 100]) + mem[64] + -(mem[_5365 + 100] % 32) + 100 len mem[_5365 + 100] % 32]
                            revert with 0, 32, mem[mem[64] + 36 len floor32(_9152) + 64]
                        mem[mem[64] + 68] = mem[_5365 + 132]
                        idx = 32
                        while idx < _9152:
                            mem[idx + mem[64] + 68] = mem[idx + _5365 + 132]
                            idx = idx + 32
                            continue 
                        if not _9152 % 32:
                            revert with memory
                              from mem[64]
                               len _9152 + _9150 + -mem[64] + 68
                        mem[floor32(_9152) + _9150 + 68] = mem[floor32(_9152) + _9150 + -(_9152 % 32) + 100 len _9152 % 32]
                        revert with memory
                          from mem[64]
                           len floor32(_9152) + _9150 + -mem[64] + 100
                    _9038 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size) + 1
                    mem[_9038] = return_data.size
                    mem[_9038 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if ext_call.success:
                        if return_data.size:
                            require return_data.size >= 32
                            if not mem[_9038 + 32]:
                                revert with 0, 
                                            32,
                                            42,
                                            0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                            mem[mem[64] + 110 len 22]
                        require ext_code.size(address(yieldSourceAddress))
                        call address(yieldSourceAddress).0x87a6eeef with:
                             gas gas_remaining wei
                            args arg2, this.address
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        emit Deposited(arg2, arg4, msg.sender, arg1, arg3);
                        stor101 = 1
                    if return_data.size:
                        revert with ext_call.return_data[0 len return_data.size]
                    _9154 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = mem[_5365 + 100]
                    _9156 = mem[_5365 + 100]
                    if not mem[_5365 + 100]:
                        if not mem[_5365 + 100] % 32:
                            revert with 0, 32, mem[mem[64] + 36 len mem[_5365 + 100] + 32]
                        mem[floor32(mem[_5365 + 100]) + mem[64] + 68] = mem[floor32(mem[_5365 + 100]) + mem[64] + -(mem[_5365 + 100] % 32) + 100 len mem[_5365 + 100] % 32]
                        revert with 0, 32, mem[mem[64] + 36 len floor32(_9156) + 64]
                    mem[mem[64] + 68] = mem[_5365 + 132]
                    idx = 32
                    while idx < _9156:
                        mem[idx + mem[64] + 68] = mem[idx + _5365 + 132]
                        idx = idx + 32
                        continue 
                    if not _9156 % 32:
                        revert with memory
                          from mem[64]
                           len _9156 + _9154 + -mem[64] + 68
                    mem[floor32(_9156) + _9154 + 68] = mem[floor32(_9156) + _9154 + -(_9156 % 32) + 100 len _9156 % 32]
                    revert with memory
                      from mem[64]
                       len floor32(_9156) + _9154 + -mem[64] + 100
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(ext_call.return_data[0]))
                staticcall address(ext_call.return_data[0]).0xdd62ed3e with:
                        gas gas_remaining wei
                       args this.address, address(yieldSourceAddress)
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if ext_call.return_data[0]:
                    revert with 0, 
                                32,
                                54,
                                0x735361666545524332303a20617070726f76652066726f6d206e6f6e2d7a65726f20746f206e6f6e2d7a65726f20616c6c6f77616e63,
                                mem[mem[64] + 122 len 10]
                _5439 = mem[64]
                mem[mem[64] + 36] = address(yieldSourceAddress)
                mem[mem[64] + 68] = arg2
                _5440 = mem[64]
                mem[mem[64]] = 68
                mem[64] = mem[64] + 100
                mem[_5440 + 32] = 0x95ea7b300000000000000000000000000000000000000000000000000000000 or mem[_5440 + 36 len 28]
                mem[64] = _5439 + 164
                mem[_5439 + 100] = 32
                mem[_5439 + 132] = 'SafeERC20: low-level call failed'
                if eth.balance(this.address) < 0:
                    revert with 0, 32, 38, 0x6f416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_5439 + 270 len 26]
                if not ext_code.size(address(ext_call.return_data[0])):
                    revert with 0, 'Address: call to non-contract'
                _5615 = mem[_5440]
                s = _5440 + 32
                t = mem[64]
                idx = mem[_5440]
                while idx >= 32:
                    mem[t] = mem[s]
                    s = s + 32
                    t = t + 32
                    idx = idx - 32
                    continue 
                mem[mem[64] + floor32(mem[_5440])] = mem[_5440 + floor32(mem[_5440]) + -(mem[_5440] % 32) + 64 len mem[_5440] % 32] or Mask(8 * -(mem[_5440] % 32) + 32, -(8 * -(mem[_5440] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_5440])])
                call address(ext_call.return_data[0]).mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len _5615 + _5439 + -mem[64] + 160]
                if not return_data.size:
                    if ext_call.success:
                        if mem[96]:
                            require mem[96] >= 32
                            if not mem[128]:
                                revert with 0, 
                                            32,
                                            42,
                                            0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                            mem[mem[64] + 110 len 22]
                        require ext_code.size(address(yieldSourceAddress))
                        call address(yieldSourceAddress).0x87a6eeef with:
                             gas gas_remaining wei
                            args arg2, this.address
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        emit Deposited(arg2, arg4, msg.sender, arg1, arg3);
                        stor101 = 1
                    if mem[96]:
                        revert with memory
                          from 128
                           len mem[96]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = mem[_5439 + 100]
                    _9160 = mem[_5439 + 100]
                    if not mem[_5439 + 100]:
                        if not mem[_5439 + 100] % 32:
                            revert with 0, 32, mem[mem[64] + 36 len mem[_5439 + 100] + 32]
                        mem[floor32(mem[_5439 + 100]) + mem[64] + 68] = mem[floor32(mem[_5439 + 100]) + mem[64] + -(mem[_5439 + 100] % 32) + 100 len mem[_5439 + 100] % 32]
                    else:
                        mem[mem[64] + 68] = mem[_5439 + 132]
                        idx = 32
                        while idx < _9160:
                            mem[idx + mem[64] + 68] = mem[idx + _5439 + 132]
                            idx = idx + 32
                            continue 
                        if not _9160 % 32:
                            revert with 0, 32, mem[mem[64] + 36 len _9160 + 32]
                        mem[floor32(_9160) + mem[64] + 68] = mem[floor32(_9160) + mem[64] + -(_9160 % 32) + 100 len _9160 % 32]
                    revert with 0, 32, mem[mem[64] + 36 len floor32(_9160) + 64]
                _9039 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size) + 1
                mem[_9039] = return_data.size
                mem[_9039 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if ext_call.success:
                    if return_data.size:
                        require return_data.size >= 32
                        if not mem[_9039 + 32]:
                            revert with 0, 
                                        32,
                                        42,
                                        0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                        mem[mem[64] + 110 len 22]
                    require ext_code.size(address(yieldSourceAddress))
                    call address(yieldSourceAddress).0x87a6eeef with:
                         gas gas_remaining wei
                        args arg2, this.address
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    emit Deposited(arg2, arg4, msg.sender, arg1, arg3);
                    stor101 = 1
                if return_data.size:
                    revert with ext_call.return_data[0 len return_data.size]
                _9162 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = mem[_5439 + 100]
                _9164 = mem[_5439 + 100]
                if not mem[_5439 + 100]:
                    if not mem[_5439 + 100] % 32:
                        revert with 0, 32, mem[mem[64] + 36 len mem[_5439 + 100] + 32]
                    mem[floor32(mem[_5439 + 100]) + mem[64] + 68] = mem[floor32(mem[_5439 + 100]) + mem[64] + -(mem[_5439 + 100] % 32) + 100 len mem[_5439 + 100] % 32]
                    revert with 0, 32, mem[mem[64] + 36 len floor32(_9164) + 64]
                mem[mem[64] + 68] = mem[_5439 + 132]
                idx = 32
                while idx < _9164:
                    mem[idx + mem[64] + 68] = mem[idx + _5439 + 132]
                    idx = idx + 32
                    continue 
                if not _9164 % 32:
                    revert with memory
                      from mem[64]
                       len _9164 + _9162 + -mem[64] + 68
                mem[floor32(_9164) + _9162 + 68] = mem[floor32(_9164) + _9162 + -(_9164 % 32) + 100 len _9164 % 32]
                revert with memory
                  from mem[64]
                   len floor32(_9164) + _9162 + -mem[64] + 100
            mem[0] = 152
            mem[(32 * stor152.length) + 160] = address(stor152.field_0)
            idx = (32 * stor152.length) + 160
            s = sha3(152)
            while (64 * stor152.length) + 128 > idx:
                mem[idx + 32] = stor1[s]
                idx = idx + 32
                s = s + 1
                continue 
            idx = 0
            s = reserveTotalSupply
            while idx < stor152.length:
                require idx < mem[(32 * stor152.length) + 128]
                require ext_code.size(mem[(32 * idx) + (32 * stor152.length) + 172 len 20])
                staticcall mem[(32 * idx) + (32 * stor152.length) + 172 len 20].0x18160ddd with:
                        gas gas_remaining wei
                mem[(64 * stor152.length) + 160] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                _9100 = ext_call.return_data[0]
                if ext_call.return_data[0] + s < s:
                    revert with 0, 'SafeMath: addition overflow'
                idx = idx + 1
                s = ext_call.return_data[0] + s
                continue 
            if arg2 < 0:
                revert with 0, 'SafeMath: addition overflow'
            if arg2 + reserveTotalSupply + (_9100 * stor152.length) > liquidityCap:
                revert with 0, 'PrizePool/exceeds-liquidity-cap'
            if prizeStrategyAddress:
                require ext_code.size(prizeStrategyAddress)
                call prizeStrategyAddress.beforeTokenMint(address arg1, uint256 arg2, address arg3, address arg4) with:
                     gas gas_remaining wei
                    args address(arg1), arg2, address(arg3), arg4
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require ext_code.size(arg3)
                call arg3.0x5d7b0758 with:
                     gas gas_remaining wei
                    args address(arg1), arg2
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require ext_code.size(address(yieldSourceAddress))
                staticcall address(yieldSourceAddress).0xc89039c5 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                mem[(64 * stor152.length) + 196] = msg.sender
                mem[(64 * stor152.length) + 228] = this.address
                mem[(64 * stor152.length) + 260] = arg2
                mem[(64 * stor152.length) + 160] = 100
                mem[(64 * stor152.length) + 192] = 0x23b872dd00000000000000000000000000000000000000000000000000000000 or Mask(224, 32, msg.sender) >> 32
                mem[(64 * stor152.length) + 292] = 32
                mem[(64 * stor152.length) + 324] = 'SafeERC20: low-level call failed'
                if eth.balance(this.address) < 0:
                    revert with 0, 
                                32,
                                38,
                                0x6f416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c,
                                mem[(64 * stor152.length) + 462 len 26]
                if not ext_code.size(address(ext_call.return_data[0])):
                    revert with 0, 'Address: call to non-contract'
                s = (64 * stor152.length) + 192
                t = (64 * stor152.length) + 356
                idx = 100
                while idx >= 32:
                    mem[t] = mem[s]
                    s = s + 32
                    t = t + 32
                    idx = idx - 32
                    continue 
                mem[(64 * stor152.length) + 452] = 0 or Mask(224, 32, mem[(64 * stor152.length) + 452])
                call address(ext_call.return_data[0]).mem[(64 * stor152.length) + 356 len 4] with:
                     gas gas_remaining wei
                    args mem[(64 * stor152.length) + 360 len 96]
                if not return_data.size:
                    if not ext_call.success:
                        if stor152.length:
                            revert with memory
                              from 128
                               len stor152.length
                        mem[(64 * stor152.length) + 356] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[(64 * stor152.length) + 360] = 32
                        idx = 32
                        while idx < 32:
                            mem[idx + (64 * stor152.length) + 424] = mem[idx + (64 * stor152.length) + 324]
                            idx = idx + 32
                            continue 
                        revert with 0, 'SafeERC20: low-level call failed'
                    if stor152.length:
                        require stor152.length >= 32
                        if not mem[128]:
                            revert with 0, 
                                        32,
                                        42,
                                        0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                        mem[(64 * stor152.length) + 466 len 22]
                    require ext_code.size(address(yieldSourceAddress))
                    staticcall address(yieldSourceAddress).0xc89039c5 with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if arg2:
                        require ext_code.size(address(ext_call.return_data[0]))
                        staticcall address(ext_call.return_data[0]).0xdd62ed3e with:
                                gas gas_remaining wei
                               args this.address, address(yieldSourceAddress)
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if ext_call.return_data[0]:
                            revert with 0, 
                                        32,
                                        54,
                                        0x735361666545524332303a20617070726f76652066726f6d206e6f6e2d7a65726f20746f206e6f6e2d7a65726f20616c6c6f77616e63,
                                        mem[(64 * stor152.length) + 478 len 10]
                    mem[(64 * stor152.length) + 392] = address(yieldSourceAddress)
                    mem[(64 * stor152.length) + 424] = arg2
                    mem[(64 * stor152.length) + 388] = 0x95ea7b300000000000000000000000000000000000000000000000000000000 or Mask(224, 0, stor160)
                    mem[(64 * stor152.length) + 456] = 32
                    if eth.balance(this.address) < 0:
                        revert with 0, 
                                    32,
                                    38,
                                    0x6f416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c,
                                    mem[(64 * stor152.length) + 626 len 26]
                    if not ext_code.size(address(ext_call.return_data[0])):
                        revert with 0, 'Address: call to non-contract'
                    s = (64 * stor152.length) + 388
                    t = (64 * stor152.length) + 520
                    idx = 68
                    while idx >= 32:
                        mem[t] = mem[s]
                        s = s + 32
                        t = t + 32
                        idx = idx - 32
                        continue 
                    mem[(64 * stor152.length) + 584] = 0 or Mask(224, 32, mem[(64 * stor152.length) + 584])
                    call address(ext_call.return_data[0]).mem[(64 * stor152.length) + 520 len 4] with:
                         gas gas_remaining wei
                        args mem[(64 * stor152.length) + 524 len 64]
                    if not return_data.size:
                        if not ext_call.success:
                            if stor152.length:
                                revert with memory
                                  from 128
                                   len stor152.length
                            mem[(64 * stor152.length) + 520] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[(64 * stor152.length) + 524] = 32
                            idx = 32
                            while idx < 32:
                                mem[idx + (64 * stor152.length) + 588] = mem[idx + (64 * stor152.length) + 488]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeERC20: low-level call failed'
                        if stor152.length:
                            require stor152.length >= 32
                            if not mem[128]:
                                revert with 0, 
                                            32,
                                            42,
                                            0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                            mem[(64 * stor152.length) + 630 len 22]
                    else:
                        mem[(64 * stor152.length) + 520] = return_data.size
                        mem[(64 * stor152.length) + 552 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[(64 * stor152.length) + ceil32(return_data.size) + 521] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[(64 * stor152.length) + ceil32(return_data.size) + 525] = 32
                            idx = 32
                            while idx < 32:
                                mem[idx + (64 * stor152.length) + ceil32(return_data.size) + 589] = mem[idx + (64 * stor152.length) + 488]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeERC20: low-level call failed'
                        if return_data.size:
                            require return_data.size >= 32
                            if not mem[(64 * stor152.length) + 552]:
                                revert with 0, 
                                            32,
                                            42,
                                            0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                            mem[(64 * stor152.length) + ceil32(return_data.size) + 631 len 22]
                    require ext_code.size(address(yieldSourceAddress))
                    call address(yieldSourceAddress).0x87a6eeef with:
                         gas gas_remaining wei
                        args arg2, this.address
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    emit Deposited(arg2, arg4, msg.sender, arg1, arg3);
                else:
                    mem[(64 * stor152.length) + 356] = return_data.size
                    mem[(64 * stor152.length) + 388 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not ext_call.success:
                        if return_data.size:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(64 * stor152.length) + ceil32(return_data.size) + 357] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[(64 * stor152.length) + ceil32(return_data.size) + 361] = 32
                        idx = 32
                        while idx < 32:
                            mem[idx + (64 * stor152.length) + ceil32(return_data.size) + 425] = mem[idx + (64 * stor152.length) + 324]
                            idx = idx + 32
                            continue 
                        revert with 0, 'SafeERC20: low-level call failed'
                    if not return_data.size:
                        require ext_code.size(address(yieldSourceAddress))
                        staticcall address(yieldSourceAddress).0xc89039c5 with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if arg2:
                            require ext_code.size(address(ext_call.return_data[0]))
                            staticcall address(ext_call.return_data[0]).0xdd62ed3e with:
                                    gas gas_remaining wei
                                   args this.address, address(yieldSourceAddress)
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if ext_call.return_data[0]:
                                revert with 0, 
                                            32,
                                            54,
                                            0x735361666545524332303a20617070726f76652066726f6d206e6f6e2d7a65726f20746f206e6f6e2d7a65726f20616c6c6f77616e63,
                                            mem[(64 * stor152.length) + ceil32(return_data.size) + 479 len 10]
                        mem[(64 * stor152.length) + ceil32(return_data.size) + 393] = address(yieldSourceAddress)
                        mem[(64 * stor152.length) + ceil32(return_data.size) + 425] = arg2
                        mem[(64 * stor152.length) + ceil32(return_data.size) + 389] = 0x95ea7b300000000000000000000000000000000000000000000000000000000 or Mask(224, 0, stor160)
                        mem[(64 * stor152.length) + ceil32(return_data.size) + 457] = 32
                        if eth.balance(this.address) < 0:
                            revert with 0, 
                                        32,
                                        38,
                                        0x6f416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c,
                                        mem[(64 * stor152.length) + ceil32(return_data.size) + 627 len 26]
                        if not ext_code.size(address(ext_call.return_data[0])):
                            revert with 0, 'Address: call to non-contract'
                        s = (64 * stor152.length) + ceil32(return_data.size) + 389
                        t = (64 * stor152.length) + ceil32(return_data.size) + 521
                        idx = 68
                        while idx >= 32:
                            mem[t] = mem[s]
                            s = s + 32
                            t = t + 32
                            idx = idx - 32
                            continue 
                        mem[(64 * stor152.length) + ceil32(return_data.size) + 585] = 0 or Mask(224, 32, mem[(64 * stor152.length) + ceil32(return_data.size) + 585])
                        call address(ext_call.return_data[0]).mem[(64 * stor152.length) + ceil32(return_data.size) + 521 len 4] with:
                             gas gas_remaining wei
                            args mem[(64 * stor152.length) + ceil32(return_data.size) + 525 len 64]
                        if not return_data.size:
                            if not ext_call.success:
                                if stor152.length:
                                    revert with memory
                                      from 128
                                       len stor152.length
                                mem[(64 * stor152.length) + ceil32(return_data.size) + 521] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[(64 * stor152.length) + ceil32(return_data.size) + 525] = 32
                                idx = 32
                                while idx < 32:
                                    mem[idx + (64 * stor152.length) + ceil32(return_data.size) + 589] = mem[idx + (64 * stor152.length) + ceil32(return_data.size) + 489]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeERC20: low-level call failed'
                            if stor152.length:
                                require stor152.length >= 32
                                if not mem[128]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[(64 * stor152.length) + ceil32(return_data.size) + 631 len 22]
                        else:
                            mem[(64 * stor152.length) + ceil32(return_data.size) + 521] = return_data.size
                            mem[(64 * stor152.length) + ceil32(return_data.size) + 553 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                if return_data.size:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(64 * stor152.length) + (2 * ceil32(return_data.size)) + 522] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[(64 * stor152.length) + (2 * ceil32(return_data.size)) + 526] = 32
                                idx = 32
                                while idx < 32:
                                    mem[idx + (64 * stor152.length) + (2 * ceil32(return_data.size)) + 590] = mem[idx + (64 * stor152.length) + ceil32(return_data.size) + 489]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeERC20: low-level call failed'
                            if return_data.size:
                                require return_data.size >= 32
                                if not mem[(64 * stor152.length) + ceil32(return_data.size) + 553]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[(64 * stor152.length) + (2 * ceil32(return_data.size)) + 632 len 22]
                        require ext_code.size(address(yieldSourceAddress))
                        call address(yieldSourceAddress).0x87a6eeef with:
                             gas gas_remaining wei
                            args arg2, this.address
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        emit Deposited(arg2, arg4, msg.sender, arg1, arg3);
                    else:
                        require return_data.size >= 32
                        if not mem[(64 * stor152.length) + 388]:
                            revert with 0, 
                                        32,
                                        42,
                                        0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                        mem[(64 * stor152.length) + ceil32(return_data.size) + 467 len 22]
                        require ext_code.size(address(yieldSourceAddress))
                        staticcall address(yieldSourceAddress).0xc89039c5 with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if not arg2:
                            mem[(64 * stor152.length) + ceil32(return_data.size) + 393] = address(yieldSourceAddress)
                            mem[(64 * stor152.length) + ceil32(return_data.size) + 425] = arg2
                            mem[(64 * stor152.length) + ceil32(return_data.size) + 357] = 68
                            mem[(64 * stor152.length) + ceil32(return_data.size) + 389] = 0x95ea7b300000000000000000000000000000000000000000000000000000000 or Mask(224, 0, stor160)
                            mem[(64 * stor152.length) + ceil32(return_data.size) + 457] = 32
                            mem[(64 * stor152.length) + ceil32(return_data.size) + 489] = 'SafeERC20: low-level call failed'
                            if eth.balance(this.address) < 0:
                                revert with 0, 
                                            32,
                                            38,
                                            0x6f416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c,
                                            mem[(64 * stor152.length) + ceil32(return_data.size) + 627 len 26]
                            if not ext_code.size(address(ext_call.return_data[0])):
                                revert with 0, 'Address: call to non-contract'
                            s = (64 * stor152.length) + ceil32(return_data.size) + 389
                            t = (64 * stor152.length) + ceil32(return_data.size) + 521
                            idx = 68
                            while idx >= 32:
                                mem[t] = mem[s]
                                s = s + 32
                                t = t + 32
                                idx = idx - 32
                                continue 
                            mem[(64 * stor152.length) + ceil32(return_data.size) + 585] = 0 or Mask(224, 32, mem[(64 * stor152.length) + ceil32(return_data.size) + 585])
                            call address(ext_call.return_data[0]).mem[(64 * stor152.length) + ceil32(return_data.size) + 521 len 4] with:
                                 gas gas_remaining wei
                                args mem[(64 * stor152.length) + ceil32(return_data.size) + 525 len 64]
                            if not return_data.size:
                                if not ext_call.success:
                                    if stor152.length:
                                        revert with memory
                                          from 128
                                           len stor152.length
                                    mem[(64 * stor152.length) + ceil32(return_data.size) + 521] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[(64 * stor152.length) + ceil32(return_data.size) + 525] = 32
                                    idx = 32
                                    while idx < 32:
                                        mem[idx + (64 * stor152.length) + ceil32(return_data.size) + 589] = mem[idx + (64 * stor152.length) + ceil32(return_data.size) + 489]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if stor152.length:
                                    require stor152.length >= 32
                                    if not mem[128]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[(64 * stor152.length) + ceil32(return_data.size) + 631 len 22]
                                require ext_code.size(address(yieldSourceAddress))
                                call address(yieldSourceAddress).0x87a6eeef with:
                                     gas gas_remaining wei
                                    args arg2, this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                emit Deposited(arg2, arg4, msg.sender, arg1, arg3);
                            else:
                                mem[64] = (64 * stor152.length) + (2 * ceil32(return_data.size)) + 522
                                mem[(64 * stor152.length) + ceil32(return_data.size) + 521] = return_data.size
                                mem[(64 * stor152.length) + ceil32(return_data.size) + 553 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    if return_data.size:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[(64 * stor152.length) + (2 * ceil32(return_data.size)) + 522] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[(64 * stor152.length) + (2 * ceil32(return_data.size)) + 526] = 32
                                    mem[(64 * stor152.length) + (2 * ceil32(return_data.size)) + 558] = 32
                                    mem[(64 * stor152.length) + (2 * ceil32(return_data.size)) + 590] = 'SafeERC20: low-level call failed'
                                    idx = 32
                                    while idx < mem[(64 * stor152.length) + ceil32(return_data.size) + 457]:
                                        mem[idx + (64 * stor152.length) + (2 * ceil32(return_data.size)) + 590] = mem[idx + (64 * stor152.length) + ceil32(return_data.size) + 489]
                                        idx = idx + 32
                                        continue 
                                    if not mem[(64 * stor152.length) + ceil32(return_data.size) + 457] % 32:
                                        revert with memory
                                          from (64 * stor152.length) + (2 * ceil32(return_data.size)) + 522
                                           len mem[(64 * stor152.length) + ceil32(return_data.size) + 457] + (2 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 68
                                    mem[floor32(mem[(64 * stor152.length) + ceil32(return_data.size) + 457]) + (64 * stor152.length) + (2 * ceil32(return_data.size)) + 590] = mem[floor32(mem[(64 * stor152.length) + ceil32(return_data.size) + 457]) + (64 * stor152.length) + (2 * ceil32(return_data.size)) + -(mem[(64 * stor152.length) + ceil32(return_data.size) + 457] % 32) + 622 len mem[(64 * stor152.length) + ceil32(return_data.size) + 457] % 32]
                                    revert with memory
                                      from (64 * stor152.length) + (2 * ceil32(return_data.size)) + 522
                                       len floor32(mem[(64 * stor152.length) + ceil32(return_data.size) + 457]) + (2 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                if return_data.size:
                                    require return_data.size >= 32
                                    if not mem[(64 * stor152.length) + ceil32(return_data.size) + 553]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[(64 * stor152.length) + (2 * ceil32(return_data.size)) + 632 len (2 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 22]
                                require ext_code.size(address(yieldSourceAddress))
                                call address(yieldSourceAddress).0x87a6eeef with:
                                     gas gas_remaining wei
                                    args arg2, this.address, mem[(64 * stor152.length) + (2 * ceil32(return_data.size)) + 590 len (2 * ceil32(return_data.size)) - (2 * ceil32(return_data.size))]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                emit Deposited(address arg1, address arg2, address arg3, uint256 arg4, address arg5):
                                               arg2,
                                               address(arg4),
                                               mem[(64 * stor152.length) + (2 * ceil32(return_data.size)) + 586 len (2 * ceil32(return_data.size)) - (2 * ceil32(return_data.size))],
                                               msg.sender,
                                               arg1,
                                               arg3,
                        else:
                            require ext_code.size(address(ext_call.return_data[0]))
                            staticcall address(ext_call.return_data[0]).0xdd62ed3e with:
                                    gas gas_remaining wei
                                   args this.address, address(yieldSourceAddress)
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if ext_call.return_data[0]:
                                revert with 0, 
                                            32,
                                            54,
                                            0x735361666545524332303a20617070726f76652066726f6d206e6f6e2d7a65726f20746f206e6f6e2d7a65726f20616c6c6f77616e63,
                                            mem[(64 * stor152.length) + ceil32(return_data.size) + 479 len 10]
                            mem[(64 * stor152.length) + ceil32(return_data.size) + 393] = address(yieldSourceAddress)
                            mem[(64 * stor152.length) + ceil32(return_data.size) + 425] = arg2
                            mem[(64 * stor152.length) + ceil32(return_data.size) + 389] = 0x95ea7b300000000000000000000000000000000000000000000000000000000 or Mask(224, 0, stor160)
                            mem[(64 * stor152.length) + ceil32(return_data.size) + 457] = 32
                            if eth.balance(this.address) < 0:
                                revert with 0, 
                                            32,
                                            38,
                                            0x6f416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c,
                                            mem[(64 * stor152.length) + ceil32(return_data.size) + 627 len 26]
                            if not ext_code.size(address(ext_call.return_data[0])):
                                revert with 0, 'Address: call to non-contract'
                            s = (64 * stor152.length) + ceil32(return_data.size) + 389
                            t = (64 * stor152.length) + ceil32(return_data.size) + 521
                            idx = 68
                            while idx >= 32:
                                mem[t] = mem[s]
                                s = s + 32
                                t = t + 32
                                idx = idx - 32
                                continue 
                            mem[(64 * stor152.length) + ceil32(return_data.size) + 585] = 0 or Mask(224, 32, mem[(64 * stor152.length) + ceil32(return_data.size) + 585])
                            call address(ext_call.return_data[0]).mem[(64 * stor152.length) + ceil32(return_data.size) + 521 len 4] with:
                                 gas gas_remaining wei
                                args mem[(64 * stor152.length) + ceil32(return_data.size) + 525 len 64]
                            if not return_data.size:
                                if not ext_call.success:
                                    if stor152.length:
                                        revert with memory
                                          from 128
                                           len stor152.length
                                    mem[(64 * stor152.length) + ceil32(return_data.size) + 521] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[(64 * stor152.length) + ceil32(return_data.size) + 525] = 32
                                    idx = 32
                                    while idx < 32:
                                        mem[idx + (64 * stor152.length) + ceil32(return_data.size) + 589] = mem[idx + (64 * stor152.length) + ceil32(return_data.size) + 489]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if stor152.length:
                                    require stor152.length >= 32
                                    if not mem[128]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[(64 * stor152.length) + ceil32(return_data.size) + 631 len 22]
                            else:
                                mem[(64 * stor152.length) + ceil32(return_data.size) + 521] = return_data.size
                                mem[(64 * stor152.length) + ceil32(return_data.size) + 553 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    if return_data.size:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[(64 * stor152.length) + (2 * ceil32(return_data.size)) + 522] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[(64 * stor152.length) + (2 * ceil32(return_data.size)) + 526] = 32
                                    idx = 32
                                    while idx < 32:
                                        mem[idx + (64 * stor152.length) + (2 * ceil32(return_data.size)) + 590] = mem[idx + (64 * stor152.length) + ceil32(return_data.size) + 489]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if return_data.size:
                                    require return_data.size >= 32
                                    if not mem[(64 * stor152.length) + ceil32(return_data.size) + 553]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[(64 * stor152.length) + (2 * ceil32(return_data.size)) + 632 len 22]
                            require ext_code.size(address(yieldSourceAddress))
                            call address(yieldSourceAddress).0x87a6eeef with:
                                 gas gas_remaining wei
                                args arg2, this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            emit Deposited(arg2, arg4, msg.sender, arg1, arg3);
                stor101 = 1
            require ext_code.size(arg3)
            call arg3.0x5d7b0758 with:
                 gas gas_remaining wei
                args address(arg1), arg2
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require ext_code.size(address(yieldSourceAddress))
            staticcall address(yieldSourceAddress).0xc89039c5 with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            mem[(64 * stor152.length) + 196] = msg.sender
            mem[(64 * stor152.length) + 228] = this.address
            mem[(64 * stor152.length) + 260] = arg2
            mem[(64 * stor152.length) + 160] = 100
            mem[(64 * stor152.length) + 192] = 0x23b872dd00000000000000000000000000000000000000000000000000000000 or Mask(224, 32, msg.sender) >> 32
            mem[64] = (64 * stor152.length) + 356
            mem[(64 * stor152.length) + 292] = 32
            mem[(64 * stor152.length) + 324] = 'SafeERC20: low-level call failed'
            if eth.balance(this.address) < 0:
                revert with 0, 
                            32,
                            38,
                            0x6f416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c,
                            mem[(64 * stor152.length) + 462 len 26]
            if not ext_code.size(address(ext_call.return_data[0])):
                revert with 0, 'Address: call to non-contract'
            s = (64 * stor152.length) + 192
            t = mem[64]
            idx = mem[(64 * stor152.length) + 160]
            while idx >= 32:
                mem[t] = mem[s]
                s = s + 32
                t = t + 32
                idx = idx - 32
                continue 
            mem[mem[64] + floor32(mem[(64 * stor152.length) + 160])] = mem[(64 * stor152.length) + floor32(mem[(64 * stor152.length) + 160]) + -(mem[(64 * stor152.length) + 160] % 32) + 224 len mem[(64 * stor152.length) + 160] % 32] or Mask(8 * -(mem[(64 * stor152.length) + 160] % 32) + 32, -(8 * -(mem[(64 * stor152.length) + 160] % 32) + 32) + 256, mem[mem[64] + floor32(mem[(64 * stor152.length) + 160])])
            call address(ext_call.return_data[0]).mem[mem[64] len 4] with:
                 gas gas_remaining wei
                args mem[mem[64] + 4 len (64 * stor152.length) + -mem[64] + 452]
            if not return_data.size:
                if not ext_call.success:
                    if mem[96]:
                        revert with memory
                          from 128
                           len mem[96]
                    _12610 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = mem[(64 * stor152.length) + 292]
                    _12612 = mem[(64 * stor152.length) + 292]
                    if not mem[(64 * stor152.length) + 292]:
                        if not mem[(64 * stor152.length) + 292] % 32:
                            revert with 0, 32, mem[mem[64] + 36 len mem[(64 * stor152.length) + 292] + 32]
                        mem[floor32(mem[(64 * stor152.length) + 292]) + mem[64] + 68] = mem[floor32(mem[(64 * stor152.length) + 292]) + mem[64] + -(mem[(64 * stor152.length) + 292] % 32) + 100 len mem[(64 * stor152.length) + 292] % 32]
                    else:
                        mem[mem[64] + 68] = mem[(64 * stor152.length) + 324]
                        idx = 32
                        while idx < _12612:
                            mem[idx + mem[64] + 68] = mem[idx + (64 * stor152.length) + 324]
                            idx = idx + 32
                            continue 
                        if not _12612 % 32:
                            revert with memory
                              from mem[64]
                               len _12612 + _12610 + -mem[64] + 68
                        mem[floor32(_12612) + _12610 + 68] = mem[floor32(_12612) + _12610 + -(_12612 % 32) + 100 len _12612 % 32]
                    revert with memory
                      from mem[64]
                       len floor32(_12612) + _12610 + -mem[64] + 100
                if not mem[96]:
                    require ext_code.size(address(yieldSourceAddress))
                    staticcall address(yieldSourceAddress).0xc89039c5 with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if not arg2:
                        _12843 = mem[64]
                        mem[mem[64] + 36] = address(yieldSourceAddress)
                        mem[mem[64] + 68] = arg2
                        _12844 = mem[64]
                        mem[mem[64]] = 68
                        mem[64] = mem[64] + 100
                        mem[_12844 + 32] = 0x95ea7b300000000000000000000000000000000000000000000000000000000 or mem[_12844 + 36 len 28]
                        mem[64] = _12843 + 164
                        mem[_12843 + 100] = 32
                        mem[_12843 + 132] = 'SafeERC20: low-level call failed'
                        if eth.balance(this.address) < 0:
                            revert with 0, 32, 38, 0x6f416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_12843 + 270 len 26]
                        if not ext_code.size(address(ext_call.return_data[0])):
                            revert with 0, 'Address: call to non-contract'
                        _13088 = mem[_12844]
                        s = _12844 + 32
                        t = mem[64]
                        idx = mem[_12844]
                        while idx >= 32:
                            mem[t] = mem[s]
                            s = s + 32
                            t = t + 32
                            idx = idx - 32
                            continue 
                        mem[mem[64] + floor32(mem[_12844])] = mem[_12844 + floor32(mem[_12844]) + -(mem[_12844] % 32) + 64 len mem[_12844] % 32] or Mask(8 * -(mem[_12844] % 32) + 32, -(8 * -(mem[_12844] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_12844])])
                        call address(ext_call.return_data[0]).mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len _13088 + _12843 + -mem[64] + 160]
                        if not return_data.size:
                            if ext_call.success:
                                if mem[96]:
                                    require mem[96] >= 32
                                    if not mem[128]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[mem[64] + 110 len 22]
                                require ext_code.size(address(yieldSourceAddress))
                                call address(yieldSourceAddress).0x87a6eeef with:
                                     gas gas_remaining wei
                                    args arg2, this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                emit Deposited(arg2, arg4, msg.sender, arg1, arg3);
                                stor101 = 1
                            if mem[96]:
                                revert with memory
                                  from 128
                                   len mem[96]
                            _16587 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = mem[_12843 + 100]
                            _16589 = mem[_12843 + 100]
                            if not mem[_12843 + 100]:
                                if not mem[_12843 + 100] % 32:
                                    revert with 0, 32, mem[mem[64] + 36 len mem[_12843 + 100] + 32]
                                mem[floor32(mem[_12843 + 100]) + mem[64] + 68] = mem[floor32(mem[_12843 + 100]) + mem[64] + -(mem[_12843 + 100] % 32) + 100 len mem[_12843 + 100] % 32]
                            else:
                                mem[mem[64] + 68] = mem[_12843 + 132]
                                idx = 32
                                while idx < _16589:
                                    mem[idx + mem[64] + 68] = mem[idx + _12843 + 132]
                                    idx = idx + 32
                                    continue 
                                if not _16589 % 32:
                                    revert with memory
                                      from mem[64]
                                       len _16589 + _16587 + -mem[64] + 68
                                mem[floor32(_16589) + _16587 + 68] = mem[floor32(_16589) + _16587 + -(_16589 % 32) + 100 len _16589 % 32]
                            revert with memory
                              from mem[64]
                               len floor32(_16589) + _16587 + -mem[64] + 100
                        _16462 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size) + 1
                        mem[_16462] = return_data.size
                        mem[_16462 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if ext_call.success:
                            if return_data.size:
                                require return_data.size >= 32
                                if not mem[_16462 + 32]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[mem[64] + 110 len 22]
                            require ext_code.size(address(yieldSourceAddress))
                            call address(yieldSourceAddress).0x87a6eeef with:
                                 gas gas_remaining wei
                                args arg2, this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            emit Deposited(arg2, arg4, msg.sender, arg1, arg3);
                            stor101 = 1
                        if return_data.size:
                            revert with ext_call.return_data[0 len return_data.size]
                        _16591 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = mem[_12843 + 100]
                        _16593 = mem[_12843 + 100]
                        if not mem[_12843 + 100]:
                            if not mem[_12843 + 100] % 32:
                                revert with 0, 32, mem[mem[64] + 36 len mem[_12843 + 100] + 32]
                            mem[floor32(mem[_12843 + 100]) + mem[64] + 68] = mem[floor32(mem[_12843 + 100]) + mem[64] + -(mem[_12843 + 100] % 32) + 100 len mem[_12843 + 100] % 32]
                        else:
                            mem[mem[64] + 68] = mem[_12843 + 132]
                            idx = 32
                            while idx < _16593:
                                mem[idx + mem[64] + 68] = mem[idx + _12843 + 132]
                                idx = idx + 32
                                continue 
                            if not _16593 % 32:
                                revert with memory
                                  from mem[64]
                                   len _16593 + _16591 + -mem[64] + 68
                            mem[floor32(_16593) + _16591 + 68] = mem[floor32(_16593) + _16591 + -(_16593 % 32) + 100 len _16593 % 32]
                        revert with memory
                          from mem[64]
                           len floor32(_16593) + _16591 + -mem[64] + 100
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(ext_call.return_data[0]))
                    staticcall address(ext_call.return_data[0]).0xdd62ed3e with:
                            gas gas_remaining wei
                           args this.address, address(yieldSourceAddress)
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if ext_call.return_data[0]:
                        revert with 0, 
                                    32,
                                    54,
                                    0x735361666545524332303a20617070726f76652066726f6d206e6f6e2d7a65726f20746f206e6f6e2d7a65726f20616c6c6f77616e63,
                                    mem[mem[64] + 122 len 10]
                    _12958 = mem[64]
                    mem[mem[64] + 36] = address(yieldSourceAddress)
                    mem[mem[64] + 68] = arg2
                    _12959 = mem[64]
                    mem[mem[64]] = 68
                    mem[64] = mem[64] + 100
                    mem[_12959 + 32] = 0x95ea7b300000000000000000000000000000000000000000000000000000000 or mem[_12959 + 36 len 28]
                    mem[64] = _12958 + 164
                    mem[_12958 + 100] = 32
                    mem[_12958 + 132] = 'SafeERC20: low-level call failed'
                    if eth.balance(this.address) < 0:
                        revert with 0, 32, 38, 0x6f416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_12958 + 270 len 26]
                    if not ext_code.size(address(ext_call.return_data[0])):
                        revert with 0, 'Address: call to non-contract'
                    _13247 = mem[_12959]
                    s = _12959 + 32
                    t = _12958 + 164
                    idx = mem[_12959]
                    while idx >= 32:
                        mem[t] = mem[s]
                        s = s + 32
                        t = t + 32
                        idx = idx - 32
                        continue 
                    mem[_12958 + floor32(mem[_12959]) + 164] = mem[_12959 + -(mem[_12959] % 32) + floor32(mem[_12959]) + 64 len mem[_12959] % 32] or Mask(8 * -(mem[_12959] % 32) + 32, -(8 * -(mem[_12959] % 32) + 32) + 256, mem[_12958 + floor32(mem[_12959]) + 164])
                    call address(ext_call.return_data[0]).mem[_12958 + 164 len 4] with:
                         gas gas_remaining wei
                        args mem[_12958 + 168 len _13247 - 4]
                    if not return_data.size:
                        if not ext_call.success:
                            if mem[96]:
                                revert with memory
                                  from 128
                                   len mem[96]
                            mem[_12958 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[_12958 + 168] = 32
                            idx = 32
                            while idx < 32:
                                mem[idx + _12958 + 232] = mem[idx + _12958 + 132]
                                idx = idx + 32
                                continue 
                            revert with 0, 32, 32, mem[_12958 + 132]
                        if mem[96]:
                            require mem[96] >= 32
                            if not mem[128]:
                                revert with 0, 
                                            32,
                                            42,
                                            0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                            mem[_12958 + 274 len 22]
                    else:
                        mem[_12958 + 164] = return_data.size
                        mem[_12958 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_12958 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[_12958 + ceil32(return_data.size) + 169] = 32
                            idx = 32
                            while idx < 32:
                                mem[idx + _12958 + ceil32(return_data.size) + 233] = mem[idx + _12958 + 132]
                                idx = idx + 32
                                continue 
                            revert with 0, 32, 32, mem[_12958 + 132]
                        if return_data.size:
                            require return_data.size >= 32
                            if not mem[_12958 + 196]:
                                revert with 0, 
                                            32,
                                            42,
                                            0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                            mem[_12958 + ceil32(return_data.size) + 275 len 22]
                    require ext_code.size(address(yieldSourceAddress))
                    call address(yieldSourceAddress).0x87a6eeef with:
                         gas gas_remaining wei
                        args arg2, this.address
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    emit Deposited(arg2, arg4, msg.sender, arg1, arg3);
                    stor101 = 1
                require mem[96] >= 32
                if not mem[128]:
                    revert with 0, 
                                32,
                                42,
                                0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                mem[mem[64] + 110 len 22]
                require ext_code.size(address(yieldSourceAddress))
                staticcall address(yieldSourceAddress).0xc89039c5 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if not arg2:
                    _12906 = mem[64]
                    mem[mem[64] + 36] = address(yieldSourceAddress)
                    mem[mem[64] + 68] = arg2
                    _12907 = mem[64]
                    mem[mem[64]] = 68
                    mem[64] = mem[64] + 100
                    mem[_12907 + 32] = 0x95ea7b300000000000000000000000000000000000000000000000000000000 or mem[_12907 + 36 len 28]
                    mem[64] = _12906 + 164
                    mem[_12906 + 100] = 32
                    mem[_12906 + 132] = 'SafeERC20: low-level call failed'
                    if eth.balance(this.address) < 0:
                        revert with 0, 32, 38, 0x6f416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_12906 + 270 len 26]
                    if not ext_code.size(address(ext_call.return_data[0])):
                        revert with 0, 'Address: call to non-contract'
                    _13154 = mem[_12907]
                    s = _12907 + 32
                    t = mem[64]
                    idx = mem[_12907]
                    while idx >= 32:
                        mem[t] = mem[s]
                        s = s + 32
                        t = t + 32
                        idx = idx - 32
                        continue 
                    mem[mem[64] + floor32(mem[_12907])] = mem[_12907 + floor32(mem[_12907]) + -(mem[_12907] % 32) + 64 len mem[_12907] % 32] or Mask(8 * -(mem[_12907] % 32) + 32, -(8 * -(mem[_12907] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_12907])])
                    call address(ext_call.return_data[0]).mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len _13154 + _12906 + -mem[64] + 160]
                    if not return_data.size:
                        if ext_call.success:
                            if mem[96]:
                                require mem[96] >= 32
                                if not mem[128]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[mem[64] + 110 len 22]
                            require ext_code.size(address(yieldSourceAddress))
                            call address(yieldSourceAddress).0x87a6eeef with:
                                 gas gas_remaining wei
                                args arg2, this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            emit Deposited(arg2, arg4, msg.sender, arg1, arg3);
                            stor101 = 1
                        if mem[96]:
                            revert with memory
                              from 128
                               len mem[96]
                        _16603 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = mem[_12906 + 100]
                        _16605 = mem[_12906 + 100]
                        if not mem[_12906 + 100]:
                            if not mem[_12906 + 100] % 32:
                                revert with 0, 32, mem[mem[64] + 36 len mem[_12906 + 100] + 32]
                            mem[floor32(mem[_12906 + 100]) + mem[64] + 68] = mem[floor32(mem[_12906 + 100]) + mem[64] + -(mem[_12906 + 100] % 32) + 100 len mem[_12906 + 100] % 32]
                        else:
                            mem[mem[64] + 68] = mem[_12906 + 132]
                            idx = 32
                            while idx < _16605:
                                mem[idx + mem[64] + 68] = mem[idx + _12906 + 132]
                                idx = idx + 32
                                continue 
                            if not _16605 % 32:
                                revert with memory
                                  from mem[64]
                                   len _16605 + _16603 + -mem[64] + 68
                            mem[floor32(_16605) + _16603 + 68] = mem[floor32(_16605) + _16603 + -(_16605 % 32) + 100 len _16605 % 32]
                        revert with memory
                          from mem[64]
                           len floor32(_16605) + _16603 + -mem[64] + 100
                    _16464 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size) + 1
                    mem[_16464] = return_data.size
                    mem[_16464 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if ext_call.success:
                        if return_data.size:
                            require return_data.size >= 32
                            if not mem[_16464 + 32]:
                                revert with 0, 
                                            32,
                                            42,
                                            0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                            mem[mem[64] + 110 len 22]
                        require ext_code.size(address(yieldSourceAddress))
                        call address(yieldSourceAddress).0x87a6eeef with:
                             gas gas_remaining wei
                            args arg2, this.address
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        emit Deposited(arg2, arg4, msg.sender, arg1, arg3);
                        stor101 = 1
                    if return_data.size:
                        revert with ext_call.return_data[0 len return_data.size]
                    _16607 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = mem[_12906 + 100]
                    _16609 = mem[_12906 + 100]
                    if not mem[_12906 + 100]:
                        if not mem[_12906 + 100] % 32:
                            revert with 0, 32, mem[mem[64] + 36 len mem[_12906 + 100] + 32]
                        mem[floor32(mem[_12906 + 100]) + mem[64] + 68] = mem[floor32(mem[_12906 + 100]) + mem[64] + -(mem[_12906 + 100] % 32) + 100 len mem[_12906 + 100] % 32]
                    else:
                        mem[mem[64] + 68] = mem[_12906 + 132]
                        idx = 32
                        while idx < _16609:
                            mem[idx + mem[64] + 68] = mem[idx + _12906 + 132]
                            idx = idx + 32
                            continue 
                        if not _16609 % 32:
                            revert with memory
                              from mem[64]
                               len _16609 + _16607 + -mem[64] + 68
                        mem[floor32(_16609) + _16607 + 68] = mem[floor32(_16609) + _16607 + -(_16609 % 32) + 100 len _16609 % 32]
                    revert with memory
                      from mem[64]
                       len floor32(_16609) + _16607 + -mem[64] + 100
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(ext_call.return_data[0]))
                staticcall address(ext_call.return_data[0]).0xdd62ed3e with:
                        gas gas_remaining wei
                       args this.address, address(yieldSourceAddress)
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if ext_call.return_data[0]:
                    revert with 0, 
                                32,
                                54,
                                0x735361666545524332303a20617070726f76652066726f6d206e6f6e2d7a65726f20746f206e6f6e2d7a65726f20616c6c6f77616e63,
                                mem[mem[64] + 122 len 10]
                _13033 = mem[64]
                mem[mem[64] + 36] = address(yieldSourceAddress)
                mem[mem[64] + 68] = arg2
                _13034 = mem[64]
                mem[mem[64]] = 68
                mem[64] = mem[64] + 100
                mem[_13034 + 32] = 0x95ea7b300000000000000000000000000000000000000000000000000000000 or mem[_13034 + 36 len 28]
                mem[64] = _13033 + 164
                mem[_13033 + 100] = 32
                mem[_13033 + 132] = 'SafeERC20: low-level call failed'
                if eth.balance(this.address) < 0:
                    revert with 0, 32, 38, 0x6f416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_13033 + 270 len 26]
                if not ext_code.size(address(ext_call.return_data[0])):
                    revert with 0, 'Address: call to non-contract'
                _13329 = mem[_13034]
                s = _13034 + 32
                t = mem[64]
                idx = mem[_13034]
                while idx >= 32:
                    mem[t] = mem[s]
                    s = s + 32
                    t = t + 32
                    idx = idx - 32
                    continue 
                mem[mem[64] + floor32(mem[_13034])] = mem[_13034 + floor32(mem[_13034]) + -(mem[_13034] % 32) + 64 len mem[_13034] % 32] or Mask(8 * -(mem[_13034] % 32) + 32, -(8 * -(mem[_13034] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_13034])])
                call address(ext_call.return_data[0]).mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len _13329 + _13033 + -mem[64] + 160]
                if not return_data.size:
                    if ext_call.success:
                        if mem[96]:
                            require mem[96] >= 32
                            if not mem[128]:
                                revert with 0, 
                                            32,
                                            42,
                                            0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                            mem[mem[64] + 110 len 22]
                        require ext_code.size(address(yieldSourceAddress))
                        call address(yieldSourceAddress).0x87a6eeef with:
                             gas gas_remaining wei
                            args arg2, this.address
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        emit Deposited(arg2, arg4, msg.sender, arg1, arg3);
                        stor101 = 1
                    if mem[96]:
                        revert with memory
                          from 128
                           len mem[96]
                    _16611 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = mem[_13033 + 100]
                    _16613 = mem[_13033 + 100]
                    if not mem[_13033 + 100]:
                        if not mem[_13033 + 100] % 32:
                            revert with 0, 32, mem[mem[64] + 36 len mem[_13033 + 100] + 32]
                        mem[floor32(mem[_13033 + 100]) + mem[64] + 68] = mem[floor32(mem[_13033 + 100]) + mem[64] + -(mem[_13033 + 100] % 32) + 100 len mem[_13033 + 100] % 32]
                        revert with 0, 32, mem[mem[64] + 36 len floor32(_16613) + 64]
                    mem[mem[64] + 68] = mem[_13033 + 132]
                    idx = 32
                    while idx < _16613:
                        mem[idx + mem[64] + 68] = mem[idx + _13033 + 132]
                        idx = idx + 32
                        continue 
                    if not _16613 % 32:
                        revert with memory
                          from mem[64]
                           len _16613 + _16611 + -mem[64] + 68
                    mem[floor32(_16613) + _16611 + 68] = mem[floor32(_16613) + _16611 + -(_16613 % 32) + 100 len _16613 % 32]
                    revert with memory
                      from mem[64]
                       len floor32(_16613) + _16611 + -mem[64] + 100
                _16465 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size) + 1
                mem[_16465] = return_data.size
                mem[_16465 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if ext_call.success:
                    if return_data.size:
                        require return_data.size >= 32
                        if not mem[_16465 + 32]:
                            revert with 0, 
                                        32,
                                        42,
                                        0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                        mem[mem[64] + 110 len 22]
                    require ext_code.size(address(yieldSourceAddress))
                    call address(yieldSourceAddress).0x87a6eeef with:
                         gas gas_remaining wei
                        args arg2, this.address
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    emit Deposited(arg2, arg4, msg.sender, arg1, arg3);
                    stor101 = 1
                if return_data.size:
                    revert with ext_call.return_data[0 len return_data.size]
                _16615 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = mem[_13033 + 100]
                _16617 = mem[_13033 + 100]
                if not mem[_13033 + 100]:
                    if not mem[_13033 + 100] % 32:
                        revert with 0, 32, mem[mem[64] + 36 len mem[_13033 + 100] + 32]
                    mem[floor32(mem[_13033 + 100]) + mem[64] + 68] = mem[floor32(mem[_13033 + 100]) + mem[64] + -(mem[_13033 + 100] % 32) + 100 len mem[_13033 + 100] % 32]
                    revert with 0, 32, mem[mem[64] + 36 len floor32(_16617) + 64]
                mem[mem[64] + 68] = mem[_13033 + 132]
                idx = 32
                while idx < _16617:
                    mem[idx + mem[64] + 68] = mem[idx + _13033 + 132]
                    idx = idx + 32
                    continue 
                if not _16617 % 32:
                    revert with memory
                      from mem[64]
                       len _16617 + _16615 + -mem[64] + 68
                mem[floor32(_16617) + _16615 + 68] = mem[floor32(_16617) + _16615 + -(_16617 % 32) + 100 len _16617 % 32]
                revert with memory
                  from mem[64]
                   len floor32(_16617) + _16615 + -mem[64] + 100
            _12559 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size) + 1
            mem[_12559] = return_data.size
            mem[_12559 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if not ext_call.success:
                if return_data.size:
                    revert with ext_call.return_data[0 len return_data.size]
                _12614 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = mem[(64 * stor152.length) + 292]
                _12616 = mem[(64 * stor152.length) + 292]
                if not mem[(64 * stor152.length) + 292]:
                    if not mem[(64 * stor152.length) + 292] % 32:
                        revert with 0, 32, mem[mem[64] + 36 len mem[(64 * stor152.length) + 292] + 32]
                    mem[floor32(mem[(64 * stor152.length) + 292]) + mem[64] + 68] = mem[floor32(mem[(64 * stor152.length) + 292]) + mem[64] + -(mem[(64 * stor152.length) + 292] % 32) + 100 len mem[(64 * stor152.length) + 292] % 32]
                else:
                    mem[mem[64] + 68] = mem[(64 * stor152.length) + 324]
                    idx = 32
                    while idx < _12616:
                        mem[idx + mem[64] + 68] = mem[idx + (64 * stor152.length) + 324]
                        idx = idx + 32
                        continue 
                    if not _12616 % 32:
                        revert with memory
                          from mem[64]
                           len _12616 + _12614 + -mem[64] + 68
                    mem[floor32(_12616) + _12614 + 68] = mem[floor32(_12616) + _12614 + -(_12616 % 32) + 100 len _12616 % 32]
                revert with memory
                  from mem[64]
                   len floor32(_12616) + _12614 + -mem[64] + 100
            if not return_data.size:
                require ext_code.size(address(yieldSourceAddress))
                staticcall address(yieldSourceAddress).0xc89039c5 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if not arg2:
                    _12846 = mem[64]
                    mem[mem[64] + 36] = address(yieldSourceAddress)
                    mem[mem[64] + 68] = arg2
                    _12847 = mem[64]
                    mem[mem[64]] = 68
                    mem[64] = mem[64] + 100
                    mem[_12847 + 32] = 0x95ea7b300000000000000000000000000000000000000000000000000000000 or mem[_12847 + 36 len 28]
                    mem[64] = _12846 + 164
                    mem[_12846 + 100] = 32
                    mem[_12846 + 132] = 'SafeERC20: low-level call failed'
                    if eth.balance(this.address) < 0:
                        revert with 0, 32, 38, 0x6f416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_12846 + 270 len 26]
                    if not ext_code.size(address(ext_call.return_data[0])):
                        revert with 0, 'Address: call to non-contract'
                    _13093 = mem[_12847]
                    s = _12847 + 32
                    t = mem[64]
                    idx = mem[_12847]
                    while idx >= 32:
                        mem[t] = mem[s]
                        s = s + 32
                        t = t + 32
                        idx = idx - 32
                        continue 
                    mem[mem[64] + floor32(mem[_12847])] = mem[_12847 + floor32(mem[_12847]) + -(mem[_12847] % 32) + 64 len mem[_12847] % 32] or Mask(8 * -(mem[_12847] % 32) + 32, -(8 * -(mem[_12847] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_12847])])
                    call address(ext_call.return_data[0]).mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len _13093 + _12846 + -mem[64] + 160]
                    if not return_data.size:
                        if ext_call.success:
                            if mem[96]:
                                require mem[96] >= 32
                                if not mem[128]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[mem[64] + 110 len 22]
                            require ext_code.size(address(yieldSourceAddress))
                            call address(yieldSourceAddress).0x87a6eeef with:
                                 gas gas_remaining wei
                                args arg2, this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            emit Deposited(arg2, arg4, msg.sender, arg1, arg3);
                            stor101 = 1
                        if mem[96]:
                            revert with memory
                              from 128
                               len mem[96]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = mem[_12846 + 100]
                        _16621 = mem[_12846 + 100]
                        if not mem[_12846 + 100]:
                            if not mem[_12846 + 100] % 32:
                                revert with 0, 32, mem[mem[64] + 36 len mem[_12846 + 100] + 32]
                            mem[floor32(mem[_12846 + 100]) + mem[64] + 68] = mem[floor32(mem[_12846 + 100]) + mem[64] + -(mem[_12846 + 100] % 32) + 100 len mem[_12846 + 100] % 32]
                        else:
                            mem[mem[64] + 68] = mem[_12846 + 132]
                            idx = 32
                            while idx < _16621:
                                mem[idx + mem[64] + 68] = mem[idx + _12846 + 132]
                                idx = idx + 32
                                continue 
                            if not _16621 % 32:
                                revert with 0, 32, mem[mem[64] + 36 len _16621 + 32]
                            mem[floor32(_16621) + mem[64] + 68] = mem[floor32(_16621) + mem[64] + -(_16621 % 32) + 100 len _16621 % 32]
                        revert with 0, 32, mem[mem[64] + 36 len floor32(_16621) + 64]
                    _16468 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size) + 1
                    mem[_16468] = return_data.size
                    mem[_16468 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if ext_call.success:
                        if return_data.size:
                            require return_data.size >= 32
                            if not mem[_16468 + 32]:
                                revert with 0, 
                                            32,
                                            42,
                                            0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                            mem[mem[64] + 110 len 22]
                        require ext_code.size(address(yieldSourceAddress))
                        call address(yieldSourceAddress).0x87a6eeef with:
                             gas gas_remaining wei
                            args arg2, this.address
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        emit Deposited(arg2, arg4, msg.sender, arg1, arg3);
                        stor101 = 1
                    if return_data.size:
                        revert with ext_call.return_data[0 len return_data.size]
                    _16623 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = mem[_12846 + 100]
                    _16625 = mem[_12846 + 100]
                    if not mem[_12846 + 100]:
                        if not mem[_12846 + 100] % 32:
                            revert with 0, 32, mem[mem[64] + 36 len mem[_12846 + 100] + 32]
                        mem[floor32(mem[_12846 + 100]) + mem[64] + 68] = mem[floor32(mem[_12846 + 100]) + mem[64] + -(mem[_12846 + 100] % 32) + 100 len mem[_12846 + 100] % 32]
                        revert with 0, 32, mem[mem[64] + 36 len floor32(_16625) + 64]
                    mem[mem[64] + 68] = mem[_12846 + 132]
                    idx = 32
                    while idx < _16625:
                        mem[idx + mem[64] + 68] = mem[idx + _12846 + 132]
                        idx = idx + 32
                        continue 
                    if not _16625 % 32:
                        revert with memory
                          from mem[64]
                           len _16625 + _16623 + -mem[64] + 68
                    mem[floor32(_16625) + _16623 + 68] = mem[floor32(_16625) + _16623 + -(_16625 % 32) + 100 len _16625 % 32]
                    revert with memory
                      from mem[64]
                       len floor32(_16625) + _16623 + -mem[64] + 100
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(ext_call.return_data[0]))
                staticcall address(ext_call.return_data[0]).0xdd62ed3e with:
                        gas gas_remaining wei
                       args this.address, address(yieldSourceAddress)
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if ext_call.return_data[0]:
                    revert with 0, 
                                32,
                                54,
                                0x735361666545524332303a20617070726f76652066726f6d206e6f6e2d7a65726f20746f206e6f6e2d7a65726f20616c6c6f77616e63,
                                mem[mem[64] + 122 len 10]
                _12966 = mem[64]
                mem[mem[64] + 36] = address(yieldSourceAddress)
                mem[mem[64] + 68] = arg2
                _12967 = mem[64]
                mem[mem[64]] = 68
                mem[64] = mem[64] + 100
                mem[_12967 + 32] = 0x95ea7b300000000000000000000000000000000000000000000000000000000 or mem[_12967 + 36 len 28]
                mem[64] = _12966 + 164
                mem[_12966 + 100] = 32
                mem[_12966 + 132] = 'SafeERC20: low-level call failed'
                if eth.balance(this.address) < 0:
                    revert with 0, 32, 38, 0x6f416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_12966 + 270 len 26]
                if not ext_code.size(address(ext_call.return_data[0])):
                    revert with 0, 'Address: call to non-contract'
                _13255 = mem[_12967]
                s = _12967 + 32
                t = mem[64]
                idx = mem[_12967]
                while idx >= 32:
                    mem[t] = mem[s]
                    s = s + 32
                    t = t + 32
                    idx = idx - 32
                    continue 
                mem[mem[64] + floor32(mem[_12967])] = mem[_12967 + floor32(mem[_12967]) + -(mem[_12967] % 32) + 64 len mem[_12967] % 32] or Mask(8 * -(mem[_12967] % 32) + 32, -(8 * -(mem[_12967] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_12967])])
                call address(ext_call.return_data[0]).mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len _13255 + _12966 + -mem[64] + 160]
                if not return_data.size:
                    if ext_call.success:
                        if mem[96]:
                            require mem[96] >= 32
                            if not mem[128]:
                                revert with 0, 
                                            32,
                                            42,
                                            0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                            mem[mem[64] + 110 len 22]
                        require ext_code.size(address(yieldSourceAddress))
                        call address(yieldSourceAddress).0x87a6eeef with:
                             gas gas_remaining wei
                            args arg2, this.address
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        emit Deposited(arg2, arg4, msg.sender, arg1, arg3);
                        stor101 = 1
                    if mem[96]:
                        revert with memory
                          from 128
                           len mem[96]
                    _16627 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = mem[_12966 + 100]
                    _16629 = mem[_12966 + 100]
                    if not mem[_12966 + 100]:
                        if not mem[_12966 + 100] % 32:
                            revert with 0, 32, mem[mem[64] + 36 len mem[_12966 + 100] + 32]
                        mem[floor32(mem[_12966 + 100]) + mem[64] + 68] = mem[floor32(mem[_12966 + 100]) + mem[64] + -(mem[_12966 + 100] % 32) + 100 len mem[_12966 + 100] % 32]
                        revert with memory
                          from mem[64]
                           len floor32(_16629) + _16627 + -mem[64] + 100
                    mem[mem[64] + 68] = mem[_12966 + 132]
                    idx = 32
                    while idx < _16629:
                        mem[idx + mem[64] + 68] = mem[idx + _12966 + 132]
                        idx = idx + 32
                        continue 
                    if not _16629 % 32:
                        revert with 0, 32, mem[mem[64] + 36 len _16629 + 32]
                    mem[floor32(_16629) + mem[64] + 68] = mem[floor32(_16629) + mem[64] + -(_16629 % 32) + 100 len _16629 % 32]
                    revert with 0, 32, mem[mem[64] + 36 len floor32(_16629) + 64]
                _16469 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size) + 1
                mem[_16469] = return_data.size
                mem[_16469 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if ext_call.success:
                    if return_data.size:
                        require return_data.size >= 32
                        if not mem[_16469 + 32]:
                            revert with 0, 
                                        32,
                                        42,
                                        0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                        mem[mem[64] + 110 len 22]
                    require ext_code.size(address(yieldSourceAddress))
                    call address(yieldSourceAddress).0x87a6eeef with:
                         gas gas_remaining wei
                        args arg2, this.address
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    emit Deposited(arg2, arg4, msg.sender, arg1, arg3);
                    stor101 = 1
                if return_data.size:
                    revert with ext_call.return_data[0 len return_data.size]
                _16631 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = mem[_12966 + 100]
                _16633 = mem[_12966 + 100]
                if not mem[_12966 + 100]:
                    if not mem[_12966 + 100] % 32:
                        revert with 0, 32, mem[mem[64] + 36 len mem[_12966 + 100] + 32]
                    mem[floor32(mem[_12966 + 100]) + mem[64] + 68] = mem[floor32(mem[_12966 + 100]) + mem[64] + -(mem[_12966 + 100] % 32) + 100 len mem[_12966 + 100] % 32]
                else:
                    mem[mem[64] + 68] = mem[_12966 + 132]
                    idx = 32
                    while idx < _16633:
                        mem[idx + mem[64] + 68] = mem[idx + _12966 + 132]
                        idx = idx + 32
                        continue 
                    if not _16633 % 32:
                        revert with memory
                          from mem[64]
                           len _16633 + _16631 + -mem[64] + 68
                    mem[floor32(_16633) + _16631 + 68] = mem[floor32(_16633) + _16631 + -(_16633 % 32) + 100 len _16633 % 32]
                revert with memory
                  from mem[64]
                   len floor32(_16633) + _16631 + -mem[64] + 100
            require return_data.size >= 32
            if not mem[_12559 + 32]:
                revert with 0, 
                            32,
                            42,
                            0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                            mem[mem[64] + 110 len 22]
            require ext_code.size(address(yieldSourceAddress))
            staticcall address(yieldSourceAddress).0xc89039c5 with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if not arg2:
                _12910 = mem[64]
                mem[mem[64] + 36] = address(yieldSourceAddress)
                mem[mem[64] + 68] = arg2
                _12911 = mem[64]
                mem[mem[64]] = 68
                mem[64] = mem[64] + 100
                mem[_12911 + 32] = 0x95ea7b300000000000000000000000000000000000000000000000000000000 or mem[_12911 + 36 len 28]
                mem[64] = _12910 + 164
                mem[_12910 + 100] = 32
                mem[_12910 + 132] = 'SafeERC20: low-level call failed'
                if eth.balance(this.address) < 0:
                    revert with 0, 32, 38, 0x6f416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_12910 + 270 len 26]
                if not ext_code.size(address(ext_call.return_data[0])):
                    revert with 0, 'Address: call to non-contract'
                _13162 = mem[_12911]
                s = _12911 + 32
                t = _12910 + 164
                idx = mem[_12911]
                while idx >= 32:
                    mem[t] = mem[s]
                    s = s + 32
                    t = t + 32
                    idx = idx - 32
                    continue 
                mem[_12910 + floor32(mem[_12911]) + 164] = mem[_12911 + -(mem[_12911] % 32) + floor32(mem[_12911]) + 64 len mem[_12911] % 32] or Mask(8 * -(mem[_12911] % 32) + 32, -(8 * -(mem[_12911] % 32) + 32) + 256, mem[_12910 + floor32(mem[_12911]) + 164])
                call address(ext_call.return_data[0]).mem[_12910 + 164 len 4] with:
                     gas gas_remaining wei
                    args mem[_12910 + 168 len _13162 - 4]
                if not return_data.size:
                    if not ext_call.success:
                        if mem[96]:
                            revert with memory
                              from 128
                               len mem[96]
                        mem[_12910 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[_12910 + 168] = 32
                        idx = 32
                        while idx < 32:
                            mem[idx + _12910 + 232] = mem[idx + _12910 + 132]
                            idx = idx + 32
                            continue 
                        revert with 0, 32, 32, mem[_12910 + 132]
                    if mem[96]:
                        require mem[96] >= 32
                        if not mem[128]:
                            revert with 0, 
                                        32,
                                        42,
                                        0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                        mem[_12910 + 274 len 22]
                else:
                    mem[_12910 + 164] = return_data.size
                    mem[_12910 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not ext_call.success:
                        if return_data.size:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_12910 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[_12910 + ceil32(return_data.size) + 169] = 32
                        idx = 32
                        while idx < 32:
                            mem[idx + _12910 + ceil32(return_data.size) + 233] = mem[idx + _12910 + 132]
                            idx = idx + 32
                            continue 
                        revert with 0, 32, 32, mem[_12910 + 132]
                    if return_data.size:
                        require return_data.size >= 32
                        if not mem[_12910 + 196]:
                            revert with 0, 
                                        32,
                                        42,
                                        0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                        mem[_12910 + ceil32(return_data.size) + 275 len 22]
                require ext_code.size(address(yieldSourceAddress))
                call address(yieldSourceAddress).0x87a6eeef with:
                     gas gas_remaining wei
                    args arg2, this.address
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                emit Deposited(arg2, arg4, msg.sender, arg1, arg3);
                stor101 = 1
            mem[mem[64] + 4] = this.address
            require ext_code.size(address(ext_call.return_data[0]))
            staticcall address(ext_call.return_data[0]).0xdd62ed3e with:
                    gas gas_remaining wei
                   args this.address, address(yieldSourceAddress)
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if ext_call.return_data[0]:
                revert with 0, 
                            32,
                            54,
                            0x735361666545524332303a20617070726f76652066726f6d206e6f6e2d7a65726f20746f206e6f6e2d7a65726f20616c6c6f77616e63,
                            mem[mem[64] + 122 len 10]
            _13040 = mem[64]
            mem[mem[64] + 36] = address(yieldSourceAddress)
            mem[mem[64] + 68] = arg2
            _13041 = mem[64]
            mem[mem[64]] = 68
            mem[64] = mem[64] + 100
            mem[_13041 + 32] = 0x95ea7b300000000000000000000000000000000000000000000000000000000 or mem[_13041 + 36 len 28]
            mem[64] = _13040 + 164
            mem[_13040 + 100] = 32
            mem[_13040 + 132] = 'SafeERC20: low-level call failed'
            if eth.balance(this.address) < 0:
                revert with 0, 32, 38, 0x6f416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_13040 + 270 len 26]
            if not ext_code.size(address(ext_call.return_data[0])):
                revert with 0, 'Address: call to non-contract'
            _13339 = mem[_13041]
            s = _13041 + 32
            t = mem[64]
            idx = mem[_13041]
            while idx >= 32:
                mem[t] = mem[s]
                s = s + 32
                t = t + 32
                idx = idx - 32
                continue 
            mem[mem[64] + floor32(mem[_13041])] = mem[_13041 + floor32(mem[_13041]) + -(mem[_13041] % 32) + 64 len mem[_13041] % 32] or Mask(8 * -(mem[_13041] % 32) + 32, -(8 * -(mem[_13041] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_13041])])
            call address(ext_call.return_data[0]).mem[mem[64] len 4] with:
                 gas gas_remaining wei
                args mem[mem[64] + 4 len _13339 + _13040 + -mem[64] + 160]
            if not return_data.size:
                if ext_call.success:
                    if mem[96]:
                        require mem[96] >= 32
                        if not mem[128]:
                            revert with 0, 
                                        32,
                                        42,
                                        0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                        mem[mem[64] + 110 len 22]
                    require ext_code.size(address(yieldSourceAddress))
                    call address(yieldSourceAddress).0x87a6eeef with:
                         gas gas_remaining wei
                        args arg2, this.address
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    emit Deposited(arg2, arg4, msg.sender, arg1, arg3);
                    stor101 = 1
                if mem[96]:
                    revert with memory
                      from 128
                       len mem[96]
                _16643 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = mem[_13040 + 100]
                _16645 = mem[_13040 + 100]
                if not mem[_13040 + 100]:
                    if not mem[_13040 + 100] % 32:
                        revert with 0, 32, mem[mem[64] + 36 len mem[_13040 + 100] + 32]
                    mem[floor32(mem[_13040 + 100]) + mem[64] + 68] = mem[floor32(mem[_13040 + 100]) + mem[64] + -(mem[_13040 + 100] % 32) + 100 len mem[_13040 + 100] % 32]
                else:
                    mem[mem[64] + 68] = mem[_13040 + 132]
                    idx = 32
                    while idx < _16645:
                        mem[idx + mem[64] + 68] = mem[idx + _13040 + 132]
                        idx = idx + 32
                        continue 
                    if not _16645 % 32:
                        revert with memory
                          from mem[64]
                           len _16645 + _16643 + -mem[64] + 68
                    mem[floor32(_16645) + _16643 + 68] = mem[floor32(_16645) + _16643 + -(_16645 % 32) + 100 len _16645 % 32]
                revert with memory
                  from mem[64]
                   len floor32(_16645) + _16643 + -mem[64] + 100
            _16471 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size) + 1
            mem[_16471] = return_data.size
            mem[_16471 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if ext_call.success:
                if return_data.size:
                    require return_data.size >= 32
                    if not mem[_16471 + 32]:
                        revert with 0, 
                                    32,
                                    42,
                                    0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                    mem[mem[64] + 110 len 22]
                require ext_code.size(address(yieldSourceAddress))
                call address(yieldSourceAddress).0x87a6eeef with:
                     gas gas_remaining wei
                    args arg2, this.address
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                emit Deposited(arg2, arg4, msg.sender, arg1, arg3);
                stor101 = 1
            if return_data.size:
                revert with ext_call.return_data[0 len return_data.size]
            _16647 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = mem[_13040 + 100]
            _16649 = mem[_13040 + 100]
            if not mem[_13040 + 100]:
                if not mem[_13040 + 100] % 32:
                    revert with 0, 32, mem[mem[64] + 36 len mem[_13040 + 100] + 32]
                mem[floor32(mem[_13040 + 100]) + mem[64] + 68] = mem[floor32(mem[_13040 + 100]) + mem[64] + -(mem[_13040 + 100] % 32) + 100 len mem[_13040 + 100] % 32]
            else:
                mem[mem[64] + 68] = mem[_13040 + 132]
                idx = 32
                while idx < _16649:
                    mem[idx + mem[64] + 68] = mem[idx + _13040 + 132]
                    idx = idx + 32
                    continue 
                if not _16649 % 32:
                    revert with memory
                      from mem[64]
                       len _16649 + _16647 + -mem[64] + 68
                mem[floor32(_16649) + _16647 + 68] = mem[floor32(_16649) + _16647 + -(_16649 % 32) + 100 len _16649 % 32]
            revert with memory
              from mem[64]
               len floor32(_16649) + _16647 + -mem[64] + 100
    else:
        mem[0] = 152
        mem[128] = address(stor152.field_0)
        idx = 128
        s = 0
        while (32 * stor152.length) + 96 > idx:
            mem[idx + 32] = stor152[s].field_256
            idx = idx + 32
            s = s + 1
            continue 
        idx = 0
        while idx < stor152.length:
            require idx < stor152.length
            if mem[(32 * idx) + 140 len 20] != arg3:
                idx = idx + 1
                continue 
            mem[(32 * stor152.length) + 128] = stor152.length
            if not stor152.length:
                idx = 0
                s = reserveTotalSupply
                while idx < stor152.length:
                    require idx < mem[(32 * stor152.length) + 128]
                    require ext_code.size(mem[(32 * idx) + (32 * stor152.length) + 172 len 20])
                    staticcall mem[(32 * idx) + (32 * stor152.length) + 172 len 20].0x18160ddd with:
                            gas gas_remaining wei
                    mem[(64 * stor152.length) + 160] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    _9101 = ext_call.return_data[0]
                    if ext_call.return_data[0] + s < s:
                        revert with 0, 'SafeMath: addition overflow'
                    idx = idx + 1
                    s = ext_call.return_data[0] + s
                    continue 
                if arg2 < 0:
                    revert with 0, 'SafeMath: addition overflow'
                if arg2 + reserveTotalSupply + (_9101 * stor152.length) > liquidityCap:
                    revert with 0, 'PrizePool/exceeds-liquidity-cap'
                if not prizeStrategyAddress:
                    require ext_code.size(arg3)
                    call arg3.0x5d7b0758 with:
                         gas gas_remaining wei
                        args address(arg1), arg2
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require ext_code.size(address(yieldSourceAddress))
                    staticcall address(yieldSourceAddress).0xc89039c5 with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    mem[(64 * stor152.length) + 196] = msg.sender
                    mem[(64 * stor152.length) + 228] = this.address
                    mem[(64 * stor152.length) + 260] = arg2
                    mem[(64 * stor152.length) + 192] = 0x23b872dd00000000000000000000000000000000000000000000000000000000 or Mask(224, 32, msg.sender) >> 32
                    mem[(64 * stor152.length) + 292] = 32
                    if eth.balance(this.address) < 0:
                        revert with 0, 
                                    32,
                                    38,
                                    0x6f416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c,
                                    mem[(64 * stor152.length) + 462 len 26]
                    if not ext_code.size(address(ext_call.return_data[0])):
                        revert with 0, 'Address: call to non-contract'
                    s = (64 * stor152.length) + 192
                    t = (64 * stor152.length) + 356
                    idx = 100
                    while idx >= 32:
                        mem[t] = mem[s]
                        s = s + 32
                        t = t + 32
                        idx = idx - 32
                        continue 
                    mem[(64 * stor152.length) + 452] = 0 or Mask(224, 32, mem[(64 * stor152.length) + 452])
                    call address(ext_call.return_data[0]).mem[(64 * stor152.length) + 356 len 4] with:
                         gas gas_remaining wei
                        args mem[(64 * stor152.length) + 360 len 96]
                    if not return_data.size:
                        if not ext_call.success:
                            if stor152.length:
                                revert with memory
                                  from 128
                                   len stor152.length
                            mem[(64 * stor152.length) + 356] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[(64 * stor152.length) + 360] = 32
                            idx = 32
                            while idx < 32:
                                mem[idx + (64 * stor152.length) + 424] = mem[idx + (64 * stor152.length) + 324]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeERC20: low-level call failed'
                        if stor152.length:
                            require stor152.length >= 32
                            if not mem[128]:
                                revert with 0, 
                                            32,
                                            42,
                                            0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                            mem[(64 * stor152.length) + 466 len 22]
                        require ext_code.size(address(yieldSourceAddress))
                        staticcall address(yieldSourceAddress).0xc89039c5 with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if arg2:
                            require ext_code.size(address(ext_call.return_data[0]))
                            staticcall address(ext_call.return_data[0]).0xdd62ed3e with:
                                    gas gas_remaining wei
                                   args this.address, address(yieldSourceAddress)
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if ext_call.return_data[0]:
                                revert with 0, 
                                            32,
                                            54,
                                            0x735361666545524332303a20617070726f76652066726f6d206e6f6e2d7a65726f20746f206e6f6e2d7a65726f20616c6c6f77616e63,
                                            mem[(64 * stor152.length) + 478 len 10]
                        mem[(64 * stor152.length) + 392] = address(yieldSourceAddress)
                        mem[(64 * stor152.length) + 424] = arg2
                        mem[(64 * stor152.length) + 388] = 0x95ea7b300000000000000000000000000000000000000000000000000000000 or Mask(224, 0, stor160)
                        mem[(64 * stor152.length) + 456] = 32
                        if eth.balance(this.address) < 0:
                            revert with 0, 
                                        32,
                                        38,
                                        0x6f416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c,
                                        mem[(64 * stor152.length) + 626 len 26]
                        if not ext_code.size(address(ext_call.return_data[0])):
                            revert with 0, 'Address: call to non-contract'
                        s = (64 * stor152.length) + 388
                        t = (64 * stor152.length) + 520
                        idx = 68
                        while idx >= 32:
                            mem[t] = mem[s]
                            s = s + 32
                            t = t + 32
                            idx = idx - 32
                            continue 
                        mem[(64 * stor152.length) + 584] = 0 or Mask(224, 32, mem[(64 * stor152.length) + 584])
                        call address(ext_call.return_data[0]).mem[(64 * stor152.length) + 520 len 4] with:
                             gas gas_remaining wei
                            args mem[(64 * stor152.length) + 524 len 64]
                        if not return_data.size:
                            if not ext_call.success:
                                if stor152.length:
                                    revert with memory
                                      from 128
                                       len stor152.length
                                mem[(64 * stor152.length) + 520] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[(64 * stor152.length) + 524] = 32
                                idx = 32
                                while idx < 32:
                                    mem[idx + (64 * stor152.length) + 588] = mem[idx + (64 * stor152.length) + 488]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeERC20: low-level call failed'
                            if stor152.length:
                                require stor152.length >= 32
                                if not mem[128]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[(64 * stor152.length) + 630 len 22]
                        else:
                            mem[(64 * stor152.length) + 520] = return_data.size
                            mem[(64 * stor152.length) + 552 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                if return_data.size:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(64 * stor152.length) + ceil32(return_data.size) + 521] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[(64 * stor152.length) + ceil32(return_data.size) + 525] = 32
                                idx = 32
                                while idx < 32:
                                    mem[idx + (64 * stor152.length) + ceil32(return_data.size) + 589] = mem[idx + (64 * stor152.length) + 488]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeERC20: low-level call failed'
                            if return_data.size:
                                require return_data.size >= 32
                                if not mem[(64 * stor152.length) + 552]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[(64 * stor152.length) + ceil32(return_data.size) + 631 len 22]
                    else:
                        mem[(64 * stor152.length) + 356] = return_data.size
                        mem[(64 * stor152.length) + 388 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[(64 * stor152.length) + ceil32(return_data.size) + 357] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[(64 * stor152.length) + ceil32(return_data.size) + 361] = 32
                            idx = 32
                            while idx < 32:
                                mem[idx + (64 * stor152.length) + ceil32(return_data.size) + 425] = mem[idx + (64 * stor152.length) + 324]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeERC20: low-level call failed'
                        if return_data.size:
                            require return_data.size >= 32
                            if not mem[(64 * stor152.length) + 388]:
                                revert with 0, 
                                            32,
                                            42,
                                            0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                            mem[(64 * stor152.length) + ceil32(return_data.size) + 467 len 22]
                        require ext_code.size(address(yieldSourceAddress))
                        staticcall address(yieldSourceAddress).0xc89039c5 with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if arg2:
                            require ext_code.size(address(ext_call.return_data[0]))
                            staticcall address(ext_call.return_data[0]).0xdd62ed3e with:
                                    gas gas_remaining wei
                                   args this.address, address(yieldSourceAddress)
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if ext_call.return_data[0]:
                                revert with 0, 
                                            32,
                                            54,
                                            0x735361666545524332303a20617070726f76652066726f6d206e6f6e2d7a65726f20746f206e6f6e2d7a65726f20616c6c6f77616e63,
                                            mem[(64 * stor152.length) + ceil32(return_data.size) + 479 len 10]
                        mem[(64 * stor152.length) + ceil32(return_data.size) + 393] = address(yieldSourceAddress)
                        mem[(64 * stor152.length) + ceil32(return_data.size) + 425] = arg2
                        mem[(64 * stor152.length) + ceil32(return_data.size) + 389] = 0x95ea7b300000000000000000000000000000000000000000000000000000000 or Mask(224, 0, stor160)
                        mem[(64 * stor152.length) + ceil32(return_data.size) + 457] = 32
                        if eth.balance(this.address) < 0:
                            revert with 0, 
                                        32,
                                        38,
                                        0x6f416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c,
                                        mem[(64 * stor152.length) + ceil32(return_data.size) + 627 len 26]
                        if not ext_code.size(address(ext_call.return_data[0])):
                            revert with 0, 'Address: call to non-contract'
                        s = (64 * stor152.length) + ceil32(return_data.size) + 389
                        t = (64 * stor152.length) + ceil32(return_data.size) + 521
                        idx = 68
                        while idx >= 32:
                            mem[t] = mem[s]
                            s = s + 32
                            t = t + 32
                            idx = idx - 32
                            continue 
                        mem[(64 * stor152.length) + ceil32(return_data.size) + 585] = 0 or Mask(224, 32, mem[(64 * stor152.length) + ceil32(return_data.size) + 585])
                        call address(ext_call.return_data[0]).mem[(64 * stor152.length) + ceil32(return_data.size) + 521 len 4] with:
                             gas gas_remaining wei
                            args mem[(64 * stor152.length) + ceil32(return_data.size) + 525 len 64]
                        if not return_data.size:
                            if not ext_call.success:
                                if stor152.length:
                                    revert with memory
                                      from 128
                                       len stor152.length
                                mem[(64 * stor152.length) + ceil32(return_data.size) + 521] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[(64 * stor152.length) + ceil32(return_data.size) + 525] = 32
                                idx = 32
                                while idx < 32:
                                    mem[idx + (64 * stor152.length) + ceil32(return_data.size) + 589] = mem[idx + (64 * stor152.length) + ceil32(return_data.size) + 489]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeERC20: low-level call failed'
                            if stor152.length:
                                require stor152.length >= 32
                                if not mem[128]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[(64 * stor152.length) + ceil32(return_data.size) + 631 len 22]
                        else:
                            mem[(64 * stor152.length) + ceil32(return_data.size) + 521] = return_data.size
                            mem[(64 * stor152.length) + ceil32(return_data.size) + 553 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                if return_data.size:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(64 * stor152.length) + (2 * ceil32(return_data.size)) + 522] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[(64 * stor152.length) + (2 * ceil32(return_data.size)) + 526] = 32
                                idx = 32
                                while idx < 32:
                                    mem[idx + (64 * stor152.length) + (2 * ceil32(return_data.size)) + 590] = mem[idx + (64 * stor152.length) + ceil32(return_data.size) + 489]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeERC20: low-level call failed'
                            if return_data.size:
                                require return_data.size >= 32
                                if not mem[(64 * stor152.length) + ceil32(return_data.size) + 553]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[(64 * stor152.length) + (2 * ceil32(return_data.size)) + 632 len 22]
                    require ext_code.size(address(yieldSourceAddress))
                    call address(yieldSourceAddress).0x87a6eeef with:
                         gas gas_remaining wei
                        args arg2, this.address
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    emit Deposited(arg2, arg4, msg.sender, arg1, arg3);
                    stor101 = 1
                require ext_code.size(prizeStrategyAddress)
                call prizeStrategyAddress.beforeTokenMint(address arg1, uint256 arg2, address arg3, address arg4) with:
                     gas gas_remaining wei
                    args address(arg1), arg2, address(arg3), arg4
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require ext_code.size(arg3)
                call arg3.0x5d7b0758 with:
                     gas gas_remaining wei
                    args address(arg1), arg2
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require ext_code.size(address(yieldSourceAddress))
                staticcall address(yieldSourceAddress).0xc89039c5 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                mem[(64 * stor152.length) + 196] = msg.sender
                mem[(64 * stor152.length) + 228] = this.address
                mem[(64 * stor152.length) + 260] = arg2
                mem[(64 * stor152.length) + 160] = 100
                mem[(64 * stor152.length) + 192] = 0x23b872dd00000000000000000000000000000000000000000000000000000000 or Mask(224, 32, msg.sender) >> 32
                mem[64] = (64 * stor152.length) + 356
                mem[(64 * stor152.length) + 292] = 32
                mem[(64 * stor152.length) + 324] = 'SafeERC20: low-level call failed'
                if eth.balance(this.address) < 0:
                    revert with 0, 
                                32,
                                38,
                                0x6f416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c,
                                mem[(64 * stor152.length) + 462 len 26]
                if not ext_code.size(address(ext_call.return_data[0])):
                    revert with 0, 'Address: call to non-contract'
                s = (64 * stor152.length) + 192
                t = mem[64]
                idx = mem[(64 * stor152.length) + 160]
                while idx >= 32:
                    mem[t] = mem[s]
                    s = s + 32
                    t = t + 32
                    idx = idx - 32
                    continue 
                mem[mem[64] + floor32(mem[(64 * stor152.length) + 160])] = mem[(64 * stor152.length) + floor32(mem[(64 * stor152.length) + 160]) + -(mem[(64 * stor152.length) + 160] % 32) + 224 len mem[(64 * stor152.length) + 160] % 32] or Mask(8 * -(mem[(64 * stor152.length) + 160] % 32) + 32, -(8 * -(mem[(64 * stor152.length) + 160] % 32) + 32) + 256, mem[mem[64] + floor32(mem[(64 * stor152.length) + 160])])
                call address(ext_call.return_data[0]).mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len (64 * stor152.length) + -mem[64] + 452]
                if not return_data.size:
                    if not ext_call.success:
                        if mem[96]:
                            revert with memory
                              from 128
                               len mem[96]
                        _12634 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = mem[(64 * stor152.length) + 292]
                        _12636 = mem[(64 * stor152.length) + 292]
                        if not mem[(64 * stor152.length) + 292]:
                            if not mem[(64 * stor152.length) + 292] % 32:
                                revert with 0, 32, mem[mem[64] + 36 len mem[(64 * stor152.length) + 292] + 32]
                            mem[floor32(mem[(64 * stor152.length) + 292]) + mem[64] + 68] = mem[floor32(mem[(64 * stor152.length) + 292]) + mem[64] + -(mem[(64 * stor152.length) + 292] % 32) + 100 len mem[(64 * stor152.length) + 292] % 32]
                        else:
                            mem[mem[64] + 68] = mem[(64 * stor152.length) + 324]
                            idx = 32
                            while idx < _12636:
                                mem[idx + mem[64] + 68] = mem[idx + (64 * stor152.length) + 324]
                                idx = idx + 32
                                continue 
                            if not _12636 % 32:
                                revert with memory
                                  from mem[64]
                                   len _12636 + _12634 + -mem[64] + 68
                            mem[floor32(_12636) + _12634 + 68] = mem[floor32(_12636) + _12634 + -(_12636 % 32) + 100 len _12636 % 32]
                        revert with memory
                          from mem[64]
                           len floor32(_12636) + _12634 + -mem[64] + 100
                    if mem[96]:
                        require mem[96] >= 32
                        if not mem[128]:
                            revert with 0, 
                                        32,
                                        42,
                                        0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                        mem[mem[64] + 110 len 22]
                        require ext_code.size(address(yieldSourceAddress))
                        staticcall address(yieldSourceAddress).0xc89039c5 with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if not arg2:
                            _12930 = mem[64]
                            mem[mem[64] + 36] = address(yieldSourceAddress)
                            mem[mem[64] + 68] = arg2
                            _12931 = mem[64]
                            mem[mem[64]] = 68
                            mem[64] = mem[64] + 100
                            mem[_12931 + 32] = 0x95ea7b300000000000000000000000000000000000000000000000000000000 or mem[_12931 + 36 len 28]
                            mem[64] = _12930 + 164
                            mem[_12930 + 100] = 32
                            mem[_12930 + 132] = 'SafeERC20: low-level call failed'
                            if eth.balance(this.address) < 0:
                                revert with 0, 32, 38, 0x6f416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_12930 + 270 len 26]
                            if not ext_code.size(address(ext_call.return_data[0])):
                                revert with 0, 'Address: call to non-contract'
                            _13202 = mem[_12931]
                            s = _12931 + 32
                            t = mem[64]
                            idx = mem[_12931]
                            while idx >= 32:
                                mem[t] = mem[s]
                                s = s + 32
                                t = t + 32
                                idx = idx - 32
                                continue 
                            mem[mem[64] + floor32(mem[_12931])] = mem[_12931 + floor32(mem[_12931]) + -(mem[_12931] % 32) + 64 len mem[_12931] % 32] or Mask(8 * -(mem[_12931] % 32) + 32, -(8 * -(mem[_12931] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_12931])])
                            call address(ext_call.return_data[0]).mem[mem[64] len 4] with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len _13202 + _12930 + -mem[64] + 160]
                            if not return_data.size:
                                if ext_call.success:
                                    if mem[96]:
                                        require mem[96] >= 32
                                        if not mem[128]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[mem[64] + 110 len 22]
                                    require ext_code.size(address(yieldSourceAddress))
                                    call address(yieldSourceAddress).0x87a6eeef with:
                                         gas gas_remaining wei
                                        args arg2, this.address
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    emit Deposited(arg2, arg4, msg.sender, arg1, arg3);
                                    stor101 = 1
                                if mem[96]:
                                    revert with memory
                                      from 128
                                       len mem[96]
                                _16795 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = mem[_12930 + 100]
                                _16797 = mem[_12930 + 100]
                                if not mem[_12930 + 100]:
                                    if not mem[_12930 + 100] % 32:
                                        revert with 0, 32, mem[mem[64] + 36 len mem[_12930 + 100] + 32]
                                    mem[floor32(mem[_12930 + 100]) + mem[64] + 68] = mem[floor32(mem[_12930 + 100]) + mem[64] + -(mem[_12930 + 100] % 32) + 100 len mem[_12930 + 100] % 32]
                                    revert with 0, 32, mem[mem[64] + 36 len floor32(_16797) + 64]
                                mem[mem[64] + 68] = mem[_12930 + 132]
                                idx = 32
                                while idx < _16797:
                                    mem[idx + mem[64] + 68] = mem[idx + _12930 + 132]
                                    idx = idx + 32
                                    continue 
                                if not _16797 % 32:
                                    revert with memory
                                      from mem[64]
                                       len _16797 + _16795 + -mem[64] + 68
                                mem[floor32(_16797) + _16795 + 68] = mem[floor32(_16797) + _16795 + -(_16797 % 32) + 100 len _16797 % 32]
                                revert with memory
                                  from mem[64]
                                   len floor32(_16797) + _16795 + -mem[64] + 100
                            _16500 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                            mem[_16500] = return_data.size
                            mem[_16500 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if ext_call.success:
                                if return_data.size:
                                    require return_data.size >= 32
                                    if not mem[_16500 + 32]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[mem[64] + 110 len 22]
                                require ext_code.size(address(yieldSourceAddress))
                                call address(yieldSourceAddress).0x87a6eeef with:
                                     gas gas_remaining wei
                                    args arg2, this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                emit Deposited(arg2, arg4, msg.sender, arg1, arg3);
                                stor101 = 1
                            if return_data.size:
                                revert with ext_call.return_data[0 len return_data.size]
                            _16799 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = mem[_12930 + 100]
                            _16801 = mem[_12930 + 100]
                            if not mem[_12930 + 100]:
                                if not mem[_12930 + 100] % 32:
                                    revert with 0, 32, mem[mem[64] + 36 len mem[_12930 + 100] + 32]
                                mem[floor32(mem[_12930 + 100]) + mem[64] + 68] = mem[floor32(mem[_12930 + 100]) + mem[64] + -(mem[_12930 + 100] % 32) + 100 len mem[_12930 + 100] % 32]
                                revert with 0, 32, mem[mem[64] + 36 len floor32(_16801) + 64]
                            mem[mem[64] + 68] = mem[_12930 + 132]
                            idx = 32
                            while idx < _16801:
                                mem[idx + mem[64] + 68] = mem[idx + _12930 + 132]
                                idx = idx + 32
                                continue 
                            if not _16801 % 32:
                                revert with memory
                                  from mem[64]
                                   len _16801 + _16799 + -mem[64] + 68
                            mem[floor32(_16801) + _16799 + 68] = mem[floor32(_16801) + _16799 + -(_16801 % 32) + 100 len _16801 % 32]
                            revert with memory
                              from mem[64]
                               len floor32(_16801) + _16799 + -mem[64] + 100
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(ext_call.return_data[0]))
                        staticcall address(ext_call.return_data[0]).0xdd62ed3e with:
                                gas gas_remaining wei
                               args this.address, address(yieldSourceAddress)
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if ext_call.return_data[0]:
                            revert with 0, 
                                        32,
                                        54,
                                        0x735361666545524332303a20617070726f76652066726f6d206e6f6e2d7a65726f20746f206e6f6e2d7a65726f20616c6c6f77616e63,
                                        mem[mem[64] + 122 len 10]
                        _13075 = mem[64]
                        mem[mem[64] + 36] = address(yieldSourceAddress)
                        mem[mem[64] + 68] = arg2
                        _13076 = mem[64]
                        mem[mem[64]] = 68
                        mem[64] = mem[64] + 100
                        mem[_13076 + 32] = 0x95ea7b300000000000000000000000000000000000000000000000000000000 or mem[_13076 + 36 len 28]
                        mem[64] = _13075 + 164
                        mem[_13075 + 100] = 32
                        mem[_13075 + 132] = 'SafeERC20: low-level call failed'
                        if eth.balance(this.address) < 0:
                            revert with 0, 32, 38, 0x6f416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_13075 + 270 len 26]
                        if not ext_code.size(address(ext_call.return_data[0])):
                            revert with 0, 'Address: call to non-contract'
                        _13389 = mem[_13076]
                        s = _13076 + 32
                        t = _13075 + 164
                        idx = mem[_13076]
                        while idx >= 32:
                            mem[t] = mem[s]
                            s = s + 32
                            t = t + 32
                            idx = idx - 32
                            continue 
                        mem[_13075 + floor32(mem[_13076]) + 164] = mem[_13076 + -(mem[_13076] % 32) + floor32(mem[_13076]) + 64 len mem[_13076] % 32] or Mask(8 * -(mem[_13076] % 32) + 32, -(8 * -(mem[_13076] % 32) + 32) + 256, mem[_13075 + floor32(mem[_13076]) + 164])
                        call address(ext_call.return_data[0]).mem[_13075 + 164 len 4] with:
                             gas gas_remaining wei
                            args mem[_13075 + 168 len _13389 - 4]
                        if not return_data.size:
                            if not ext_call.success:
                                if mem[96]:
                                    revert with memory
                                      from 128
                                       len mem[96]
                                mem[_13075 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[_13075 + 168] = 32
                                idx = 32
                                while idx < 32:
                                    mem[idx + _13075 + 232] = mem[idx + _13075 + 132]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 32, 32, mem[_13075 + 132]
                            if mem[96]:
                                require mem[96] >= 32
                                if not mem[128]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[_13075 + 274 len 22]
                        else:
                            mem[_13075 + 164] = return_data.size
                            mem[_13075 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                if return_data.size:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[_13075 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[_13075 + ceil32(return_data.size) + 169] = 32
                                idx = 32
                                while idx < 32:
                                    mem[idx + _13075 + ceil32(return_data.size) + 233] = mem[idx + _13075 + 132]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 32, 32, mem[_13075 + 132]
                            if return_data.size:
                                require return_data.size >= 32
                                if not mem[_13075 + 196]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[_13075 + ceil32(return_data.size) + 275 len 22]
                        require ext_code.size(address(yieldSourceAddress))
                        call address(yieldSourceAddress).0x87a6eeef with:
                             gas gas_remaining wei
                            args arg2, this.address
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        emit Deposited(arg2, arg4, msg.sender, arg1, arg3);
                        stor101 = 1
                    require ext_code.size(address(yieldSourceAddress))
                    staticcall address(yieldSourceAddress).0xc89039c5 with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if not arg2:
                        _12861 = mem[64]
                        mem[mem[64] + 36] = address(yieldSourceAddress)
                        mem[mem[64] + 68] = arg2
                        _12862 = mem[64]
                        mem[mem[64]] = 68
                        mem[64] = mem[64] + 100
                        mem[_12862 + 32] = 0x95ea7b300000000000000000000000000000000000000000000000000000000 or mem[_12862 + 36 len 28]
                        mem[64] = _12861 + 164
                        mem[_12861 + 100] = 32
                        mem[_12861 + 132] = 'SafeERC20: low-level call failed'
                        if eth.balance(this.address) < 0:
                            revert with 0, 32, 38, 0x6f416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_12861 + 270 len 26]
                        if not ext_code.size(address(ext_call.return_data[0])):
                            revert with 0, 'Address: call to non-contract'
                        _13118 = mem[_12862]
                        s = _12862 + 32
                        t = mem[64]
                        idx = mem[_12862]
                        while idx >= 32:
                            mem[t] = mem[s]
                            s = s + 32
                            t = t + 32
                            idx = idx - 32
                            continue 
                        mem[mem[64] + floor32(mem[_12862])] = mem[_12862 + floor32(mem[_12862]) + -(mem[_12862] % 32) + 64 len mem[_12862] % 32] or Mask(8 * -(mem[_12862] % 32) + 32, -(8 * -(mem[_12862] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_12862])])
                        call address(ext_call.return_data[0]).mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len _13118 + _12861 + -mem[64] + 160]
                        if not return_data.size:
                            if ext_call.success:
                                if mem[96]:
                                    require mem[96] >= 32
                                    if not mem[128]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[mem[64] + 110 len 22]
                                require ext_code.size(address(yieldSourceAddress))
                                call address(yieldSourceAddress).0x87a6eeef with:
                                     gas gas_remaining wei
                                    args arg2, this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                emit Deposited(arg2, arg4, msg.sender, arg1, arg3);
                                stor101 = 1
                            if mem[96]:
                                revert with memory
                                  from 128
                                   len mem[96]
                            _16779 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = mem[_12861 + 100]
                            _16781 = mem[_12861 + 100]
                            if not mem[_12861 + 100]:
                                if not mem[_12861 + 100] % 32:
                                    revert with 0, 32, mem[mem[64] + 36 len mem[_12861 + 100] + 32]
                                mem[floor32(mem[_12861 + 100]) + mem[64] + 68] = mem[floor32(mem[_12861 + 100]) + mem[64] + -(mem[_12861 + 100] % 32) + 100 len mem[_12861 + 100] % 32]
                                revert with memory
                                  from mem[64]
                                   len floor32(_16781) + _16779 + -mem[64] + 100
                            mem[mem[64] + 68] = mem[_12861 + 132]
                            idx = 32
                            while idx < _16781:
                                mem[idx + mem[64] + 68] = mem[idx + _12861 + 132]
                                idx = idx + 32
                                continue 
                            if not _16781 % 32:
                                revert with 0, 32, mem[mem[64] + 36 len _16781 + 32]
                            mem[floor32(_16781) + mem[64] + 68] = mem[floor32(_16781) + mem[64] + -(_16781 % 32) + 100 len _16781 % 32]
                            revert with 0, 32, mem[mem[64] + 36 len floor32(_16781) + 64]
                        _16498 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size) + 1
                        mem[_16498] = return_data.size
                        mem[_16498 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if ext_call.success:
                            if return_data.size:
                                require return_data.size >= 32
                                if not mem[_16498 + 32]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[mem[64] + 110 len 22]
                            require ext_code.size(address(yieldSourceAddress))
                            call address(yieldSourceAddress).0x87a6eeef with:
                                 gas gas_remaining wei
                                args arg2, this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            emit Deposited(arg2, arg4, msg.sender, arg1, arg3);
                            stor101 = 1
                        if return_data.size:
                            revert with ext_call.return_data[0 len return_data.size]
                        _16783 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = mem[_12861 + 100]
                        _16785 = mem[_12861 + 100]
                        if not mem[_12861 + 100]:
                            if not mem[_12861 + 100] % 32:
                                revert with 0, 32, mem[mem[64] + 36 len mem[_12861 + 100] + 32]
                            mem[floor32(mem[_12861 + 100]) + mem[64] + 68] = mem[floor32(mem[_12861 + 100]) + mem[64] + -(mem[_12861 + 100] % 32) + 100 len mem[_12861 + 100] % 32]
                        else:
                            mem[mem[64] + 68] = mem[_12861 + 132]
                            idx = 32
                            while idx < _16785:
                                mem[idx + mem[64] + 68] = mem[idx + _12861 + 132]
                                idx = idx + 32
                                continue 
                            if not _16785 % 32:
                                revert with memory
                                  from mem[64]
                                   len _16785 + _16783 + -mem[64] + 68
                            mem[floor32(_16785) + _16783 + 68] = mem[floor32(_16785) + _16783 + -(_16785 % 32) + 100 len _16785 % 32]
                        revert with memory
                          from mem[64]
                           len floor32(_16785) + _16783 + -mem[64] + 100
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(ext_call.return_data[0]))
                    staticcall address(ext_call.return_data[0]).0xdd62ed3e with:
                            gas gas_remaining wei
                           args this.address, address(yieldSourceAddress)
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if ext_call.return_data[0]:
                        revert with 0, 
                                    32,
                                    54,
                                    0x735361666545524332303a20617070726f76652066726f6d206e6f6e2d7a65726f20746f206e6f6e2d7a65726f20616c6c6f77616e63,
                                    mem[mem[64] + 122 len 10]
                    _13006 = mem[64]
                    mem[mem[64] + 36] = address(yieldSourceAddress)
                    mem[mem[64] + 68] = arg2
                    _13007 = mem[64]
                    mem[mem[64]] = 68
                    mem[64] = mem[64] + 100
                    mem[_13007 + 32] = 0x95ea7b300000000000000000000000000000000000000000000000000000000 or mem[_13007 + 36 len 28]
                    mem[64] = _13006 + 164
                    mem[_13006 + 100] = 32
                    mem[_13006 + 132] = 'SafeERC20: low-level call failed'
                    if eth.balance(this.address) < 0:
                        revert with 0, 32, 38, 0x6f416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_13006 + 270 len 26]
                    if not ext_code.size(address(ext_call.return_data[0])):
                        revert with 0, 'Address: call to non-contract'
                    _13295 = mem[_13007]
                    s = _13007 + 32
                    t = mem[64]
                    idx = mem[_13007]
                    while idx >= 32:
                        mem[t] = mem[s]
                        s = s + 32
                        t = t + 32
                        idx = idx - 32
                        continue 
                    mem[mem[64] + floor32(mem[_13007])] = mem[_13007 + floor32(mem[_13007]) + -(mem[_13007] % 32) + 64 len mem[_13007] % 32] or Mask(8 * -(mem[_13007] % 32) + 32, -(8 * -(mem[_13007] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_13007])])
                    call address(ext_call.return_data[0]).mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len _13295 + _13006 + -mem[64] + 160]
                    if not return_data.size:
                        if ext_call.success:
                            if mem[96]:
                                require mem[96] >= 32
                                if not mem[128]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[mem[64] + 110 len 22]
                            require ext_code.size(address(yieldSourceAddress))
                            call address(yieldSourceAddress).0x87a6eeef with:
                                 gas gas_remaining wei
                                args arg2, this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            emit Deposited(arg2, arg4, msg.sender, arg1, arg3);
                            stor101 = 1
                        if mem[96]:
                            revert with memory
                              from 128
                               len mem[96]
                        _16787 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = mem[_13006 + 100]
                        _16789 = mem[_13006 + 100]
                        if not mem[_13006 + 100]:
                            if not mem[_13006 + 100] % 32:
                                revert with 0, 32, mem[mem[64] + 36 len mem[_13006 + 100] + 32]
                            mem[floor32(mem[_13006 + 100]) + mem[64] + 68] = mem[floor32(mem[_13006 + 100]) + mem[64] + -(mem[_13006 + 100] % 32) + 100 len mem[_13006 + 100] % 32]
                        else:
                            mem[mem[64] + 68] = mem[_13006 + 132]
                            idx = 32
                            while idx < _16789:
                                mem[idx + mem[64] + 68] = mem[idx + _13006 + 132]
                                idx = idx + 32
                                continue 
                            if not _16789 % 32:
                                revert with memory
                                  from mem[64]
                                   len _16789 + _16787 + -mem[64] + 68
                            mem[floor32(_16789) + _16787 + 68] = mem[floor32(_16789) + _16787 + -(_16789 % 32) + 100 len _16789 % 32]
                        revert with memory
                          from mem[64]
                           len floor32(_16789) + _16787 + -mem[64] + 100
                    _16499 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size) + 1
                    mem[_16499] = return_data.size
                    mem[_16499 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if ext_call.success:
                        if return_data.size:
                            require return_data.size >= 32
                            if not mem[_16499 + 32]:
                                revert with 0, 
                                            32,
                                            42,
                                            0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                            mem[mem[64] + 110 len 22]
                        require ext_code.size(address(yieldSourceAddress))
                        call address(yieldSourceAddress).0x87a6eeef with:
                             gas gas_remaining wei
                            args arg2, this.address
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        emit Deposited(arg2, arg4, msg.sender, arg1, arg3);
                        stor101 = 1
                    if return_data.size:
                        revert with ext_call.return_data[0 len return_data.size]
                    _16791 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = mem[_13006 + 100]
                    _16793 = mem[_13006 + 100]
                    if not mem[_13006 + 100]:
                        if not mem[_13006 + 100] % 32:
                            revert with 0, 32, mem[mem[64] + 36 len mem[_13006 + 100] + 32]
                        mem[floor32(mem[_13006 + 100]) + mem[64] + 68] = mem[floor32(mem[_13006 + 100]) + mem[64] + -(mem[_13006 + 100] % 32) + 100 len mem[_13006 + 100] % 32]
                    else:
                        mem[mem[64] + 68] = mem[_13006 + 132]
                        idx = 32
                        while idx < _16793:
                            mem[idx + mem[64] + 68] = mem[idx + _13006 + 132]
                            idx = idx + 32
                            continue 
                        if not _16793 % 32:
                            revert with memory
                              from mem[64]
                               len _16793 + _16791 + -mem[64] + 68
                        mem[floor32(_16793) + _16791 + 68] = mem[floor32(_16793) + _16791 + -(_16793 % 32) + 100 len _16793 % 32]
                    revert with memory
                      from mem[64]
                       len floor32(_16793) + _16791 + -mem[64] + 100
                _12562 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size) + 1
                mem[_12562] = return_data.size
                mem[_12562 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not ext_call.success:
                    if return_data.size:
                        revert with ext_call.return_data[0 len return_data.size]
                    _12638 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = mem[(64 * stor152.length) + 292]
                    _12640 = mem[(64 * stor152.length) + 292]
                    if not mem[(64 * stor152.length) + 292]:
                        if not mem[(64 * stor152.length) + 292] % 32:
                            revert with 0, 32, mem[mem[64] + 36 len mem[(64 * stor152.length) + 292] + 32]
                        mem[floor32(mem[(64 * stor152.length) + 292]) + mem[64] + 68] = mem[floor32(mem[(64 * stor152.length) + 292]) + mem[64] + -(mem[(64 * stor152.length) + 292] % 32) + 100 len mem[(64 * stor152.length) + 292] % 32]
                    else:
                        mem[mem[64] + 68] = mem[(64 * stor152.length) + 324]
                        idx = 32
                        while idx < _12640:
                            mem[idx + mem[64] + 68] = mem[idx + (64 * stor152.length) + 324]
                            idx = idx + 32
                            continue 
                        if not _12640 % 32:
                            revert with memory
                              from mem[64]
                               len _12640 + _12638 + -mem[64] + 68
                        mem[floor32(_12640) + _12638 + 68] = mem[floor32(_12640) + _12638 + -(_12640 % 32) + 100 len _12640 % 32]
                    revert with memory
                      from mem[64]
                       len floor32(_12640) + _12638 + -mem[64] + 100
                if return_data.size:
                    require return_data.size >= 32
                    if not mem[_12562 + 32]:
                        revert with 0, 
                                    32,
                                    42,
                                    0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                    mem[mem[64] + 110 len 22]
                    require ext_code.size(address(yieldSourceAddress))
                    staticcall address(yieldSourceAddress).0xc89039c5 with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if not arg2:
                        _12934 = mem[64]
                        mem[mem[64] + 36] = address(yieldSourceAddress)
                        mem[mem[64] + 68] = arg2
                        _12935 = mem[64]
                        mem[mem[64]] = 68
                        mem[64] = mem[64] + 100
                        mem[_12935 + 32] = 0x95ea7b300000000000000000000000000000000000000000000000000000000 or mem[_12935 + 36 len 28]
                        mem[64] = _12934 + 164
                        mem[_12934 + 100] = 32
                        mem[_12934 + 132] = 'SafeERC20: low-level call failed'
                        if eth.balance(this.address) < 0:
                            revert with 0, 32, 38, 0x6f416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_12934 + 270 len 26]
                        if not ext_code.size(address(ext_call.return_data[0])):
                            revert with 0, 'Address: call to non-contract'
                        _13210 = mem[_12935]
                        s = _12935 + 32
                        t = mem[64]
                        idx = mem[_12935]
                        while idx >= 32:
                            mem[t] = mem[s]
                            s = s + 32
                            t = t + 32
                            idx = idx - 32
                            continue 
                        mem[mem[64] + floor32(mem[_12935])] = mem[_12935 + floor32(mem[_12935]) + -(mem[_12935] % 32) + 64 len mem[_12935] % 32] or Mask(8 * -(mem[_12935] % 32) + 32, -(8 * -(mem[_12935] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_12935])])
                        call address(ext_call.return_data[0]).mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len _13210 + _12934 + -mem[64] + 160]
                        if not return_data.size:
                            if ext_call.success:
                                if mem[96]:
                                    require mem[96] >= 32
                                    if not mem[128]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[mem[64] + 110 len 22]
                                require ext_code.size(address(yieldSourceAddress))
                                call address(yieldSourceAddress).0x87a6eeef with:
                                     gas gas_remaining wei
                                    args arg2, this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                emit Deposited(arg2, arg4, msg.sender, arg1, arg3);
                                stor101 = 1
                            if mem[96]:
                                revert with memory
                                  from 128
                                   len mem[96]
                            _16827 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = mem[_12934 + 100]
                            _16829 = mem[_12934 + 100]
                            if not mem[_12934 + 100]:
                                if not mem[_12934 + 100] % 32:
                                    revert with 0, 32, mem[mem[64] + 36 len mem[_12934 + 100] + 32]
                                mem[floor32(mem[_12934 + 100]) + mem[64] + 68] = mem[floor32(mem[_12934 + 100]) + mem[64] + -(mem[_12934 + 100] % 32) + 100 len mem[_12934 + 100] % 32]
                                revert with memory
                                  from mem[64]
                                   len floor32(_16829) + _16827 + -mem[64] + 100
                            mem[mem[64] + 68] = mem[_12934 + 132]
                            idx = 32
                            while idx < _16829:
                                mem[idx + mem[64] + 68] = mem[idx + _12934 + 132]
                                idx = idx + 32
                                continue 
                            if not _16829 % 32:
                                revert with 0, 32, mem[mem[64] + 36 len _16829 + 32]
                            mem[floor32(_16829) + mem[64] + 68] = mem[floor32(_16829) + mem[64] + -(_16829 % 32) + 100 len _16829 % 32]
                            revert with 0, 32, mem[mem[64] + 36 len floor32(_16829) + 64]
                        _16506 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size) + 1
                        mem[_16506] = return_data.size
                        mem[_16506 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if ext_call.success:
                            if return_data.size:
                                require return_data.size >= 32
                                if not mem[_16506 + 32]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[mem[64] + 110 len 22]
                            require ext_code.size(address(yieldSourceAddress))
                            call address(yieldSourceAddress).0x87a6eeef with:
                                 gas gas_remaining wei
                                args arg2, this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            emit Deposited(arg2, arg4, msg.sender, arg1, arg3);
                            stor101 = 1
                        if return_data.size:
                            revert with ext_call.return_data[0 len return_data.size]
                        _16831 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = mem[_12934 + 100]
                        _16833 = mem[_12934 + 100]
                        if not mem[_12934 + 100]:
                            if not mem[_12934 + 100] % 32:
                                revert with 0, 32, mem[mem[64] + 36 len mem[_12934 + 100] + 32]
                            mem[floor32(mem[_12934 + 100]) + mem[64] + 68] = mem[floor32(mem[_12934 + 100]) + mem[64] + -(mem[_12934 + 100] % 32) + 100 len mem[_12934 + 100] % 32]
                            revert with memory
                              from mem[64]
                               len floor32(_16833) + _16831 + -mem[64] + 100
                        mem[mem[64] + 68] = mem[_12934 + 132]
                        idx = 32
                        while idx < _16833:
                            mem[idx + mem[64] + 68] = mem[idx + _12934 + 132]
                            idx = idx + 32
                            continue 
                        if not _16833 % 32:
                            revert with 0, 32, mem[mem[64] + 36 len _16833 + 32]
                        mem[floor32(_16833) + mem[64] + 68] = mem[floor32(_16833) + mem[64] + -(_16833 % 32) + 100 len _16833 % 32]
                        revert with 0, 32, mem[mem[64] + 36 len floor32(_16833) + 64]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(ext_call.return_data[0]))
                    staticcall address(ext_call.return_data[0]).0xdd62ed3e with:
                            gas gas_remaining wei
                           args this.address, address(yieldSourceAddress)
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if ext_call.return_data[0]:
                        revert with 0, 
                                    32,
                                    54,
                                    0x735361666545524332303a20617070726f76652066726f6d206e6f6e2d7a65726f20746f206e6f6e2d7a65726f20616c6c6f77616e63,
                                    mem[mem[64] + 122 len 10]
                    _13082 = mem[64]
                    mem[mem[64] + 36] = address(yieldSourceAddress)
                    mem[mem[64] + 68] = arg2
                    _13083 = mem[64]
                    mem[mem[64]] = 68
                    mem[64] = mem[64] + 100
                    mem[_13083 + 32] = 0x95ea7b300000000000000000000000000000000000000000000000000000000 or mem[_13083 + 36 len 28]
                    mem[64] = _13082 + 164
                    mem[_13082 + 100] = 32
                    mem[_13082 + 132] = 'SafeERC20: low-level call failed'
                    if eth.balance(this.address) < 0:
                        revert with 0, 32, 38, 0x6f416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_13082 + 270 len 26]
                    if not ext_code.size(address(ext_call.return_data[0])):
                        revert with 0, 'Address: call to non-contract'
                    _13399 = mem[_13083]
                    s = _13083 + 32
                    t = _13082 + 164
                    idx = mem[_13083]
                    while idx >= 32:
                        mem[t] = mem[s]
                        s = s + 32
                        t = t + 32
                        idx = idx - 32
                        continue 
                    mem[_13082 + floor32(mem[_13083]) + 164] = mem[_13083 + -(mem[_13083] % 32) + floor32(mem[_13083]) + 64 len mem[_13083] % 32] or Mask(8 * -(mem[_13083] % 32) + 32, -(8 * -(mem[_13083] % 32) + 32) + 256, mem[_13082 + floor32(mem[_13083]) + 164])
                    call address(ext_call.return_data[0]).mem[_13082 + 164 len 4] with:
                         gas gas_remaining wei
                        args mem[_13082 + 168 len _13399 - 4]
                    if not return_data.size:
                        if not ext_call.success:
                            if mem[96]:
                                revert with memory
                                  from 128
                                   len mem[96]
                            mem[_13082 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[_13082 + 168] = 32
                            idx = 32
                            while idx < 32:
                                mem[idx + _13082 + 232] = mem[idx + _13082 + 132]
                                idx = idx + 32
                                continue 
                            revert with 0, 32, 32, mem[_13082 + 132]
                        if mem[96]:
                            require mem[96] >= 32
                            if not mem[128]:
                                revert with 0, 
                                            32,
                                            42,
                                            0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                            mem[_13082 + 274 len 22]
                    else:
                        mem[_13082 + 164] = return_data.size
                        mem[_13082 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_13082 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[_13082 + ceil32(return_data.size) + 169] = 32
                            idx = 32
                            while idx < 32:
                                mem[idx + _13082 + ceil32(return_data.size) + 233] = mem[idx + _13082 + 132]
                                idx = idx + 32
                                continue 
                            revert with 0, 32, 32, mem[_13082 + 132]
                        if return_data.size:
                            require return_data.size >= 32
                            if not mem[_13082 + 196]:
                                revert with 0, 
                                            32,
                                            42,
                                            0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                            mem[_13082 + ceil32(return_data.size) + 275 len 22]
                    require ext_code.size(address(yieldSourceAddress))
                    call address(yieldSourceAddress).0x87a6eeef with:
                         gas gas_remaining wei
                        args arg2, this.address
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    emit Deposited(arg2, arg4, msg.sender, arg1, arg3);
                    stor101 = 1
                require ext_code.size(address(yieldSourceAddress))
                staticcall address(yieldSourceAddress).0xc89039c5 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if not arg2:
                    _12864 = mem[64]
                    mem[mem[64] + 36] = address(yieldSourceAddress)
                    mem[mem[64] + 68] = arg2
                    _12865 = mem[64]
                    mem[mem[64]] = 68
                    mem[64] = mem[64] + 100
                    mem[_12865 + 32] = 0x95ea7b300000000000000000000000000000000000000000000000000000000 or mem[_12865 + 36 len 28]
                    mem[64] = _12864 + 164
                    mem[_12864 + 100] = 32
                    mem[_12864 + 132] = 'SafeERC20: low-level call failed'
                    if eth.balance(this.address) < 0:
                        revert with 0, 32, 38, 0x6f416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_12864 + 270 len 26]
                    if not ext_code.size(address(ext_call.return_data[0])):
                        revert with 0, 'Address: call to non-contract'
                    _13123 = mem[_12865]
                    s = _12865 + 32
                    t = mem[64]
                    idx = mem[_12865]
                    while idx >= 32:
                        mem[t] = mem[s]
                        s = s + 32
                        t = t + 32
                        idx = idx - 32
                        continue 
                    mem[mem[64] + floor32(mem[_12865])] = mem[_12865 + floor32(mem[_12865]) + -(mem[_12865] % 32) + 64 len mem[_12865] % 32] or Mask(8 * -(mem[_12865] % 32) + 32, -(8 * -(mem[_12865] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_12865])])
                    call address(ext_call.return_data[0]).mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len _13123 + _12864 + -mem[64] + 160]
                    if not return_data.size:
                        if ext_call.success:
                            if mem[96]:
                                require mem[96] >= 32
                                if not mem[128]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[mem[64] + 110 len 22]
                            require ext_code.size(address(yieldSourceAddress))
                            call address(yieldSourceAddress).0x87a6eeef with:
                                 gas gas_remaining wei
                                args arg2, this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            emit Deposited(arg2, arg4, msg.sender, arg1, arg3);
                            stor101 = 1
                        if mem[96]:
                            revert with memory
                              from 128
                               len mem[96]
                        _16811 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = mem[_12864 + 100]
                        _16813 = mem[_12864 + 100]
                        if not mem[_12864 + 100]:
                            if not mem[_12864 + 100] % 32:
                                revert with 0, 32, mem[mem[64] + 36 len mem[_12864 + 100] + 32]
                            mem[floor32(mem[_12864 + 100]) + mem[64] + 68] = mem[floor32(mem[_12864 + 100]) + mem[64] + -(mem[_12864 + 100] % 32) + 100 len mem[_12864 + 100] % 32]
                            revert with 0, 32, mem[mem[64] + 36 len floor32(_16813) + 64]
                        mem[mem[64] + 68] = mem[_12864 + 132]
                        idx = 32
                        while idx < _16813:
                            mem[idx + mem[64] + 68] = mem[idx + _12864 + 132]
                            idx = idx + 32
                            continue 
                        if not _16813 % 32:
                            revert with memory
                              from mem[64]
                               len _16813 + _16811 + -mem[64] + 68
                        mem[floor32(_16813) + _16811 + 68] = mem[floor32(_16813) + _16811 + -(_16813 % 32) + 100 len _16813 % 32]
                        revert with memory
                          from mem[64]
                           len floor32(_16813) + _16811 + -mem[64] + 100
                    _16504 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size) + 1
                    mem[_16504] = return_data.size
                    mem[_16504 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if ext_call.success:
                        if return_data.size:
                            require return_data.size >= 32
                            if not mem[_16504 + 32]:
                                revert with 0, 
                                            32,
                                            42,
                                            0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                            mem[mem[64] + 110 len 22]
                        require ext_code.size(address(yieldSourceAddress))
                        call address(yieldSourceAddress).0x87a6eeef with:
                             gas gas_remaining wei
                            args arg2, this.address
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        emit Deposited(arg2, arg4, msg.sender, arg1, arg3);
                        stor101 = 1
                    if return_data.size:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = mem[_12864 + 100]
                    _16817 = mem[_12864 + 100]
                    if not mem[_12864 + 100]:
                        if not mem[_12864 + 100] % 32:
                            revert with 0, 32, mem[mem[64] + 36 len mem[_12864 + 100] + 32]
                        mem[floor32(mem[_12864 + 100]) + mem[64] + 68] = mem[floor32(mem[_12864 + 100]) + mem[64] + -(mem[_12864 + 100] % 32) + 100 len mem[_12864 + 100] % 32]
                    else:
                        mem[mem[64] + 68] = mem[_12864 + 132]
                        idx = 32
                        while idx < _16817:
                            mem[idx + mem[64] + 68] = mem[idx + _12864 + 132]
                            idx = idx + 32
                            continue 
                        if not _16817 % 32:
                            revert with 0, 32, mem[mem[64] + 36 len _16817 + 32]
                        mem[floor32(_16817) + mem[64] + 68] = mem[floor32(_16817) + mem[64] + -(_16817 % 32) + 100 len _16817 % 32]
                    revert with 0, 32, mem[mem[64] + 36 len floor32(_16817) + 64]
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(ext_call.return_data[0]))
                staticcall address(ext_call.return_data[0]).0xdd62ed3e with:
                        gas gas_remaining wei
                       args this.address, address(yieldSourceAddress)
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if ext_call.return_data[0]:
                    revert with 0, 
                                32,
                                54,
                                0x735361666545524332303a20617070726f76652066726f6d206e6f6e2d7a65726f20746f206e6f6e2d7a65726f20616c6c6f77616e63,
                                mem[mem[64] + 122 len 10]
                _13014 = mem[64]
                mem[mem[64] + 36] = address(yieldSourceAddress)
                mem[mem[64] + 68] = arg2
                _13015 = mem[64]
                mem[mem[64]] = 68
                mem[64] = mem[64] + 100
                mem[_13015 + 32] = 0x95ea7b300000000000000000000000000000000000000000000000000000000 or mem[_13015 + 36 len 28]
                mem[64] = _13014 + 164
                mem[_13014 + 100] = 32
                mem[_13014 + 132] = 'SafeERC20: low-level call failed'
                if eth.balance(this.address) < 0:
                    revert with 0, 32, 38, 0x6f416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_13014 + 270 len 26]
                if not ext_code.size(address(ext_call.return_data[0])):
                    revert with 0, 'Address: call to non-contract'
                _13303 = mem[_13015]
                s = _13015 + 32
                t = mem[64]
                idx = mem[_13015]
                while idx >= 32:
                    mem[t] = mem[s]
                    s = s + 32
                    t = t + 32
                    idx = idx - 32
                    continue 
                mem[mem[64] + floor32(mem[_13015])] = mem[_13015 + floor32(mem[_13015]) + -(mem[_13015] % 32) + 64 len mem[_13015] % 32] or Mask(8 * -(mem[_13015] % 32) + 32, -(8 * -(mem[_13015] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_13015])])
                call address(ext_call.return_data[0]).mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len _13303 + _13014 + -mem[64] + 160]
                if not return_data.size:
                    if ext_call.success:
                        if mem[96]:
                            require mem[96] >= 32
                            if not mem[128]:
                                revert with 0, 
                                            32,
                                            42,
                                            0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                            mem[mem[64] + 110 len 22]
                        require ext_code.size(address(yieldSourceAddress))
                        call address(yieldSourceAddress).0x87a6eeef with:
                             gas gas_remaining wei
                            args arg2, this.address
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        emit Deposited(arg2, arg4, msg.sender, arg1, arg3);
                        stor101 = 1
                    if mem[96]:
                        revert with memory
                          from 128
                           len mem[96]
                    _16819 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = mem[_13014 + 100]
                    _16821 = mem[_13014 + 100]
                    if not mem[_13014 + 100]:
                        if not mem[_13014 + 100] % 32:
                            revert with 0, 32, mem[mem[64] + 36 len mem[_13014 + 100] + 32]
                        mem[floor32(mem[_13014 + 100]) + mem[64] + 68] = mem[floor32(mem[_13014 + 100]) + mem[64] + -(mem[_13014 + 100] % 32) + 100 len mem[_13014 + 100] % 32]
                    else:
                        mem[mem[64] + 68] = mem[_13014 + 132]
                        idx = 32
                        while idx < _16821:
                            mem[idx + mem[64] + 68] = mem[idx + _13014 + 132]
                            idx = idx + 32
                            continue 
                        if not _16821 % 32:
                            revert with memory
                              from mem[64]
                               len _16821 + _16819 + -mem[64] + 68
                        mem[floor32(_16821) + _16819 + 68] = mem[floor32(_16821) + _16819 + -(_16821 % 32) + 100 len _16821 % 32]
                    revert with memory
                      from mem[64]
                       len floor32(_16821) + _16819 + -mem[64] + 100
                _16505 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size) + 1
                mem[_16505] = return_data.size
                mem[_16505 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if ext_call.success:
                    if return_data.size:
                        require return_data.size >= 32
                        if not mem[_16505 + 32]:
                            revert with 0, 
                                        32,
                                        42,
                                        0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                        mem[mem[64] + 110 len 22]
                    require ext_code.size(address(yieldSourceAddress))
                    call address(yieldSourceAddress).0x87a6eeef with:
                         gas gas_remaining wei
                        args arg2, this.address
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    emit Deposited(arg2, arg4, msg.sender, arg1, arg3);
                    stor101 = 1
                if return_data.size:
                    revert with ext_call.return_data[0 len return_data.size]
                _16823 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = mem[_13014 + 100]
                _16825 = mem[_13014 + 100]
                if not mem[_13014 + 100]:
                    if not mem[_13014 + 100] % 32:
                        revert with 0, 32, mem[mem[64] + 36 len mem[_13014 + 100] + 32]
                    mem[floor32(mem[_13014 + 100]) + mem[64] + 68] = mem[floor32(mem[_13014 + 100]) + mem[64] + -(mem[_13014 + 100] % 32) + 100 len mem[_13014 + 100] % 32]
                else:
                    mem[mem[64] + 68] = mem[_13014 + 132]
                    idx = 32
                    while idx < _16825:
                        mem[idx + mem[64] + 68] = mem[idx + _13014 + 132]
                        idx = idx + 32
                        continue 
                    if not _16825 % 32:
                        revert with memory
                          from mem[64]
                           len _16825 + _16823 + -mem[64] + 68
                    mem[floor32(_16825) + _16823 + 68] = mem[floor32(_16825) + _16823 + -(_16825 % 32) + 100 len _16825 % 32]
                revert with memory
                  from mem[64]
                   len floor32(_16825) + _16823 + -mem[64] + 100
            mem[0] = 152
            mem[(32 * stor152.length) + 160] = address(stor152.field_0)
            idx = (32 * stor152.length) + 160
            s = sha3(152)
            while (64 * stor152.length) + 128 > idx:
                mem[idx + 32] = stor1[s]
                idx = idx + 32
                s = s + 1
                continue 
            idx = 0
            s = reserveTotalSupply
            while idx < stor152.length:
                require idx < mem[(32 * stor152.length) + 128]
                require ext_code.size(mem[(32 * idx) + (32 * stor152.length) + 172 len 20])
                staticcall mem[(32 * idx) + (32 * stor152.length) + 172 len 20].0x18160ddd with:
                        gas gas_remaining wei
                mem[(64 * stor152.length) + 160] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                _16586 = ext_call.return_data[0]
                if ext_call.return_data[0] + s < s:
                    revert with 0, 'SafeMath: addition overflow'
                idx = idx + 1
                s = ext_call.return_data[0] + s
                continue 
            if arg2 < 0:
                revert with 0, 'SafeMath: addition overflow'
            if arg2 + reserveTotalSupply + (_16586 * stor152.length) > liquidityCap:
                revert with 0, 'PrizePool/exceeds-liquidity-cap'
            if not prizeStrategyAddress:
                require ext_code.size(arg3)
                call arg3.0x5d7b0758 with:
                     gas gas_remaining wei
                    args address(arg1), arg2
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require ext_code.size(address(yieldSourceAddress))
                staticcall address(yieldSourceAddress).0xc89039c5 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                mem[(64 * stor152.length) + 196] = msg.sender
                mem[(64 * stor152.length) + 228] = this.address
                mem[(64 * stor152.length) + 260] = arg2
                mem[(64 * stor152.length) + 160] = 100
                mem[(64 * stor152.length) + 192] = 0x23b872dd00000000000000000000000000000000000000000000000000000000 or Mask(224, 32, msg.sender) >> 32
                mem[(64 * stor152.length) + 292] = 32
                mem[(64 * stor152.length) + 324] = 'SafeERC20: low-level call failed'
                if eth.balance(this.address) < 0:
                    revert with 0, 
                                32,
                                38,
                                0x6f416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c,
                                mem[(64 * stor152.length) + 462 len 26]
                if not ext_code.size(address(ext_call.return_data[0])):
                    revert with 0, 'Address: call to non-contract'
                s = (64 * stor152.length) + 192
                t = (64 * stor152.length) + 356
                idx = 100
                while idx >= 32:
                    mem[t] = mem[s]
                    s = s + 32
                    t = t + 32
                    idx = idx - 32
                    continue 
                mem[(64 * stor152.length) + 452] = 0 or Mask(224, 32, mem[(64 * stor152.length) + 452])
                call address(ext_call.return_data[0]).mem[(64 * stor152.length) + 356 len 4] with:
                     gas gas_remaining wei
                    args mem[(64 * stor152.length) + 360 len 96]
                if not return_data.size:
                    if not ext_call.success:
                        if stor152.length:
                            revert with memory
                              from 128
                               len stor152.length
                        mem[(64 * stor152.length) + 356] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[(64 * stor152.length) + 360] = 32
                        idx = 32
                        while idx < 32:
                            mem[idx + (64 * stor152.length) + 424] = mem[idx + (64 * stor152.length) + 324]
                            idx = idx + 32
                            continue 
                        revert with 0, 'SafeERC20: low-level call failed'
                    if stor152.length:
                        require stor152.length >= 32
                        if not mem[128]:
                            revert with 0, 
                                        32,
                                        42,
                                        0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                        mem[(64 * stor152.length) + 466 len 22]
                    require ext_code.size(address(yieldSourceAddress))
                    staticcall address(yieldSourceAddress).0xc89039c5 with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if arg2:
                        require ext_code.size(address(ext_call.return_data[0]))
                        staticcall address(ext_call.return_data[0]).0xdd62ed3e with:
                                gas gas_remaining wei
                               args this.address, address(yieldSourceAddress)
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if ext_call.return_data[0]:
                            revert with 0, 
                                        32,
                                        54,
                                        0x735361666545524332303a20617070726f76652066726f6d206e6f6e2d7a65726f20746f206e6f6e2d7a65726f20616c6c6f77616e63,
                                        mem[(64 * stor152.length) + 478 len 10]
                    mem[(64 * stor152.length) + 392] = address(yieldSourceAddress)
                    mem[(64 * stor152.length) + 424] = arg2
                    mem[(64 * stor152.length) + 388] = 0x95ea7b300000000000000000000000000000000000000000000000000000000 or Mask(224, 0, stor160)
                    mem[(64 * stor152.length) + 456] = 32
                    if eth.balance(this.address) < 0:
                        revert with 0, 
                                    32,
                                    38,
                                    0x6f416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c,
                                    mem[(64 * stor152.length) + 626 len 26]
                    if not ext_code.size(address(ext_call.return_data[0])):
                        revert with 0, 'Address: call to non-contract'
                    s = (64 * stor152.length) + 388
                    t = (64 * stor152.length) + 520
                    idx = 68
                    while idx >= 32:
                        mem[t] = mem[s]
                        s = s + 32
                        t = t + 32
                        idx = idx - 32
                        continue 
                    mem[(64 * stor152.length) + 584] = 0 or Mask(224, 32, mem[(64 * stor152.length) + 584])
                    call address(ext_call.return_data[0]).mem[(64 * stor152.length) + 520 len 4] with:
                         gas gas_remaining wei
                        args mem[(64 * stor152.length) + 524 len 64]
                    if not return_data.size:
                        if not ext_call.success:
                            if stor152.length:
                                revert with memory
                                  from 128
                                   len stor152.length
                            mem[(64 * stor152.length) + 520] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[(64 * stor152.length) + 524] = 32
                            idx = 32
                            while idx < 32:
                                mem[idx + (64 * stor152.length) + 588] = mem[idx + (64 * stor152.length) + 488]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeERC20: low-level call failed'
                        if stor152.length:
                            require stor152.length >= 32
                            if not mem[128]:
                                revert with 0, 
                                            32,
                                            42,
                                            0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                            mem[(64 * stor152.length) + 630 len 22]
                    else:
                        mem[(64 * stor152.length) + 520] = return_data.size
                        mem[(64 * stor152.length) + 552 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[(64 * stor152.length) + ceil32(return_data.size) + 521] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[(64 * stor152.length) + ceil32(return_data.size) + 525] = 32
                            idx = 32
                            while idx < 32:
                                mem[idx + (64 * stor152.length) + ceil32(return_data.size) + 589] = mem[idx + (64 * stor152.length) + 488]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeERC20: low-level call failed'
                        if return_data.size:
                            require return_data.size >= 32
                            if not mem[(64 * stor152.length) + 552]:
                                revert with 0, 
                                            32,
                                            42,
                                            0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                            mem[(64 * stor152.length) + ceil32(return_data.size) + 631 len 22]
                    require ext_code.size(address(yieldSourceAddress))
                    call address(yieldSourceAddress).0x87a6eeef with:
                         gas gas_remaining wei
                        args arg2, this.address
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    emit Deposited(arg2, arg4, msg.sender, arg1, arg3);
                else:
                    mem[(64 * stor152.length) + 356] = return_data.size
                    mem[(64 * stor152.length) + 388 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not ext_call.success:
                        if return_data.size:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(64 * stor152.length) + ceil32(return_data.size) + 357] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[(64 * stor152.length) + ceil32(return_data.size) + 361] = 32
                        idx = 32
                        while idx < 32:
                            mem[idx + (64 * stor152.length) + ceil32(return_data.size) + 425] = mem[idx + (64 * stor152.length) + 324]
                            idx = idx + 32
                            continue 
                        revert with 0, 'SafeERC20: low-level call failed'
                    if return_data.size:
                        require return_data.size >= 32
                        if not mem[(64 * stor152.length) + 388]:
                            revert with 0, 
                                        32,
                                        42,
                                        0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                        mem[(64 * stor152.length) + ceil32(return_data.size) + 467 len 22]
                    require ext_code.size(address(yieldSourceAddress))
                    staticcall address(yieldSourceAddress).0xc89039c5 with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if not arg2:
                        mem[(64 * stor152.length) + ceil32(return_data.size) + 393] = address(yieldSourceAddress)
                        mem[(64 * stor152.length) + ceil32(return_data.size) + 425] = arg2
                        mem[(64 * stor152.length) + ceil32(return_data.size) + 389] = 0x95ea7b300000000000000000000000000000000000000000000000000000000 or Mask(224, 0, stor160)
                        mem[(64 * stor152.length) + ceil32(return_data.size) + 457] = 32
                        mem[(64 * stor152.length) + ceil32(return_data.size) + 489] = 'SafeERC20: low-level call failed'
                        if eth.balance(this.address) < 0:
                            revert with 0, 
                                        32,
                                        38,
                                        0x6f416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c,
                                        mem[(64 * stor152.length) + ceil32(return_data.size) + 627 len 26]
                        if not ext_code.size(address(ext_call.return_data[0])):
                            revert with 0, 'Address: call to non-contract'
                        s = (64 * stor152.length) + ceil32(return_data.size) + 389
                        t = (64 * stor152.length) + ceil32(return_data.size) + 521
                        idx = 68
                        while idx >= 32:
                            mem[t] = mem[s]
                            s = s + 32
                            t = t + 32
                            idx = idx - 32
                            continue 
                        mem[(64 * stor152.length) + ceil32(return_data.size) + 585] = 0 or Mask(224, 32, mem[(64 * stor152.length) + ceil32(return_data.size) + 585])
                        call address(ext_call.return_data[0]).mem[(64 * stor152.length) + ceil32(return_data.size) + 521 len 4] with:
                             gas gas_remaining wei
                            args mem[(64 * stor152.length) + ceil32(return_data.size) + 525 len 64]
                        if not return_data.size:
                            if not ext_call.success:
                                if stor152.length:
                                    revert with memory
                                      from 128
                                       len stor152.length
                                mem[(64 * stor152.length) + ceil32(return_data.size) + 521] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[(64 * stor152.length) + ceil32(return_data.size) + 525] = 32
                                idx = 32
                                while idx < 32:
                                    mem[idx + (64 * stor152.length) + ceil32(return_data.size) + 589] = mem[idx + (64 * stor152.length) + ceil32(return_data.size) + 489]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeERC20: low-level call failed'
                            if stor152.length:
                                require stor152.length >= 32
                                if not mem[128]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[(64 * stor152.length) + ceil32(return_data.size) + 631 len 22]
                            require ext_code.size(address(yieldSourceAddress))
                            call address(yieldSourceAddress).0x87a6eeef with:
                                 gas gas_remaining wei
                                args arg2, this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            emit Deposited(arg2, arg4, msg.sender, arg1, arg3);
                        else:
                            mem[64] = (64 * stor152.length) + (2 * ceil32(return_data.size)) + 522
                            mem[(64 * stor152.length) + ceil32(return_data.size) + 521] = return_data.size
                            mem[(64 * stor152.length) + ceil32(return_data.size) + 553 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                if return_data.size:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(64 * stor152.length) + (2 * ceil32(return_data.size)) + 522] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[(64 * stor152.length) + (2 * ceil32(return_data.size)) + 526] = 32
                                mem[(64 * stor152.length) + (2 * ceil32(return_data.size)) + 558] = 32
                                mem[(64 * stor152.length) + (2 * ceil32(return_data.size)) + 590] = 'SafeERC20: low-level call failed'
                                idx = 32
                                while idx < mem[(64 * stor152.length) + ceil32(return_data.size) + 457]:
                                    mem[idx + (64 * stor152.length) + (2 * ceil32(return_data.size)) + 590] = mem[idx + (64 * stor152.length) + ceil32(return_data.size) + 489]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 
                                            32,
                                            32,
                                            mem[(64 * stor152.length) + (2 * ceil32(return_data.size)) + 590 len (2 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32]
                            if return_data.size:
                                require return_data.size >= 32
                                if not mem[(64 * stor152.length) + ceil32(return_data.size) + 553]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[(64 * stor152.length) + (2 * ceil32(return_data.size)) + 632 len (2 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 22]
                            require ext_code.size(address(yieldSourceAddress))
                            call address(yieldSourceAddress).0x87a6eeef with:
                                 gas gas_remaining wei
                                args arg2, this.address, mem[(64 * stor152.length) + (2 * ceil32(return_data.size)) + 590 len (2 * ceil32(return_data.size)) - (2 * ceil32(return_data.size))]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            emit Deposited(address arg1, address arg2, address arg3, uint256 arg4, address arg5):
                                           arg2,
                                           address(arg4),
                                           mem[(64 * stor152.length) + (2 * ceil32(return_data.size)) + 586 len (2 * ceil32(return_data.size)) - (2 * ceil32(return_data.size))],
                                           msg.sender,
                                           arg1,
                                           arg3,
                    else:
                        require ext_code.size(address(ext_call.return_data[0]))
                        staticcall address(ext_call.return_data[0]).0xdd62ed3e with:
                                gas gas_remaining wei
                               args this.address, address(yieldSourceAddress)
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if ext_call.return_data[0]:
                            revert with 0, 
                                        32,
                                        54,
                                        0x735361666545524332303a20617070726f76652066726f6d206e6f6e2d7a65726f20746f206e6f6e2d7a65726f20616c6c6f77616e63,
                                        mem[(64 * stor152.length) + ceil32(return_data.size) + 479 len 10]
                        mem[(64 * stor152.length) + ceil32(return_data.size) + 393] = address(yieldSourceAddress)
                        mem[(64 * stor152.length) + ceil32(return_data.size) + 425] = arg2
                        mem[(64 * stor152.length) + ceil32(return_data.size) + 389] = 0x95ea7b300000000000000000000000000000000000000000000000000000000 or Mask(224, 0, stor160)
                        mem[(64 * stor152.length) + ceil32(return_data.size) + 457] = 32
                        if eth.balance(this.address) < 0:
                            revert with 0, 
                                        32,
                                        38,
                                        0x6f416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c,
                                        mem[(64 * stor152.length) + ceil32(return_data.size) + 627 len 26]
                        if not ext_code.size(address(ext_call.return_data[0])):
                            revert with 0, 'Address: call to non-contract'
                        s = (64 * stor152.length) + ceil32(return_data.size) + 389
                        t = (64 * stor152.length) + ceil32(return_data.size) + 521
                        idx = 68
                        while idx >= 32:
                            mem[t] = mem[s]
                            s = s + 32
                            t = t + 32
                            idx = idx - 32
                            continue 
                        mem[(64 * stor152.length) + ceil32(return_data.size) + 585] = 0 or Mask(224, 32, mem[(64 * stor152.length) + ceil32(return_data.size) + 585])
                        call address(ext_call.return_data[0]).mem[(64 * stor152.length) + ceil32(return_data.size) + 521 len 4] with:
                             gas gas_remaining wei
                            args mem[(64 * stor152.length) + ceil32(return_data.size) + 525 len 64]
                        if not return_data.size:
                            if not ext_call.success:
                                if stor152.length:
                                    revert with memory
                                      from 128
                                       len stor152.length
                                mem[(64 * stor152.length) + ceil32(return_data.size) + 521] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[(64 * stor152.length) + ceil32(return_data.size) + 525] = 32
                                idx = 32
                                while idx < 32:
                                    mem[idx + (64 * stor152.length) + ceil32(return_data.size) + 589] = mem[idx + (64 * stor152.length) + ceil32(return_data.size) + 489]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeERC20: low-level call failed'
                            if stor152.length:
                                require stor152.length >= 32
                                if not mem[128]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[(64 * stor152.length) + ceil32(return_data.size) + 631 len 22]
                        else:
                            mem[(64 * stor152.length) + ceil32(return_data.size) + 521] = return_data.size
                            mem[(64 * stor152.length) + ceil32(return_data.size) + 553 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                if return_data.size:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(64 * stor152.length) + (2 * ceil32(return_data.size)) + 522] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[(64 * stor152.length) + (2 * ceil32(return_data.size)) + 526] = 32
                                idx = 32
                                while idx < 32:
                                    mem[idx + (64 * stor152.length) + (2 * ceil32(return_data.size)) + 590] = mem[idx + (64 * stor152.length) + ceil32(return_data.size) + 489]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeERC20: low-level call failed'
                            if return_data.size:
                                require return_data.size >= 32
                                if not mem[(64 * stor152.length) + ceil32(return_data.size) + 553]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[(64 * stor152.length) + (2 * ceil32(return_data.size)) + 632 len 22]
                        require ext_code.size(address(yieldSourceAddress))
                        call address(yieldSourceAddress).0x87a6eeef with:
                             gas gas_remaining wei
                            args arg2, this.address
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        emit Deposited(arg2, arg4, msg.sender, arg1, arg3);
                stor101 = 1
            require ext_code.size(prizeStrategyAddress)
            call prizeStrategyAddress.beforeTokenMint(address arg1, uint256 arg2, address arg3, address arg4) with:
                 gas gas_remaining wei
                args address(arg1), arg2, address(arg3), arg4
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require ext_code.size(arg3)
            call arg3.0x5d7b0758 with:
                 gas gas_remaining wei
                args address(arg1), arg2
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require ext_code.size(address(yieldSourceAddress))
            staticcall address(yieldSourceAddress).0xc89039c5 with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            mem[(64 * stor152.length) + 196] = msg.sender
            mem[(64 * stor152.length) + 228] = this.address
            mem[(64 * stor152.length) + 260] = arg2
            mem[(64 * stor152.length) + 160] = 100
            mem[(64 * stor152.length) + 192] = 0x23b872dd00000000000000000000000000000000000000000000000000000000 or Mask(224, 32, msg.sender) >> 32
            mem[64] = (64 * stor152.length) + 356
            mem[(64 * stor152.length) + 292] = 32
            mem[(64 * stor152.length) + 324] = 'SafeERC20: low-level call failed'
            if eth.balance(this.address) < 0:
                revert with 0, 
                            32,
                            38,
                            0x6f416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c,
                            mem[(64 * stor152.length) + 462 len 26]
            if not ext_code.size(address(ext_call.return_data[0])):
                revert with 0, 'Address: call to non-contract'
            s = (64 * stor152.length) + 192
            t = mem[64]
            idx = mem[(64 * stor152.length) + 160]
            while idx >= 32:
                mem[t] = mem[s]
                s = s + 32
                t = t + 32
                idx = idx - 32
                continue 
            mem[mem[64] + floor32(mem[(64 * stor152.length) + 160])] = mem[(64 * stor152.length) + floor32(mem[(64 * stor152.length) + 160]) + -(mem[(64 * stor152.length) + 160] % 32) + 224 len mem[(64 * stor152.length) + 160] % 32] or Mask(8 * -(mem[(64 * stor152.length) + 160] % 32) + 32, -(8 * -(mem[(64 * stor152.length) + 160] % 32) + 32) + 256, mem[mem[64] + floor32(mem[(64 * stor152.length) + 160])])
            call address(ext_call.return_data[0]).mem[mem[64] len 4] with:
                 gas gas_remaining wei
                args mem[mem[64] + 4 len (64 * stor152.length) + -mem[64] + 452]
            if not return_data.size:
                if not ext_call.success:
                    if mem[96]:
                        revert with memory
                          from 128
                           len mem[96]
                    _19737 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = mem[(64 * stor152.length) + 292]
                    _19739 = mem[(64 * stor152.length) + 292]
                    if not mem[(64 * stor152.length) + 292]:
                        if not mem[(64 * stor152.length) + 292] % 32:
                            revert with 0, 32, mem[mem[64] + 36 len mem[(64 * stor152.length) + 292] + 32]
                        mem[floor32(mem[(64 * stor152.length) + 292]) + mem[64] + 68] = mem[floor32(mem[(64 * stor152.length) + 292]) + mem[64] + -(mem[(64 * stor152.length) + 292] % 32) + 100 len mem[(64 * stor152.length) + 292] % 32]
                    else:
                        mem[mem[64] + 68] = mem[(64 * stor152.length) + 324]
                        idx = 32
                        while idx < _19739:
                            mem[idx + mem[64] + 68] = mem[idx + (64 * stor152.length) + 324]
                            idx = idx + 32
                            continue 
                        if not _19739 % 32:
                            revert with memory
                              from mem[64]
                               len _19739 + _19737 + -mem[64] + 68
                        mem[floor32(_19739) + _19737 + 68] = mem[floor32(_19739) + _19737 + -(_19739 % 32) + 100 len _19739 % 32]
                    revert with memory
                      from mem[64]
                       len floor32(_19739) + _19737 + -mem[64] + 100
                if not mem[96]:
                    require ext_code.size(address(yieldSourceAddress))
                    staticcall address(yieldSourceAddress).0xc89039c5 with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if not arg2:
                        _19843 = mem[64]
                        mem[mem[64] + 36] = address(yieldSourceAddress)
                        mem[mem[64] + 68] = arg2
                        _19844 = mem[64]
                        mem[mem[64]] = 68
                        mem[64] = mem[64] + 100
                        mem[_19844 + 32] = 0x95ea7b300000000000000000000000000000000000000000000000000000000 or mem[_19844 + 36 len 28]
                        mem[64] = _19843 + 164
                        mem[_19843 + 100] = 32
                        mem[_19843 + 132] = 'SafeERC20: low-level call failed'
                        if eth.balance(this.address) < 0:
                            revert with 0, 32, 38, 0x6f416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_19843 + 270 len 26]
                        if not ext_code.size(address(ext_call.return_data[0])):
                            revert with 0, 'Address: call to non-contract'
                        _19964 = mem[_19844]
                        s = _19844 + 32
                        t = mem[64]
                        idx = mem[_19844]
                        while idx >= 32:
                            mem[t] = mem[s]
                            s = s + 32
                            t = t + 32
                            idx = idx - 32
                            continue 
                        mem[mem[64] + floor32(mem[_19844])] = mem[_19844 + floor32(mem[_19844]) + -(mem[_19844] % 32) + 64 len mem[_19844] % 32] or Mask(8 * -(mem[_19844] % 32) + 32, -(8 * -(mem[_19844] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_19844])])
                        call address(ext_call.return_data[0]).mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len _19964 + _19843 + -mem[64] + 160]
                        if not return_data.size:
                            if ext_call.success:
                                if mem[96]:
                                    require mem[96] >= 32
                                    if not mem[128]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[mem[64] + 110 len 22]
                                require ext_code.size(address(yieldSourceAddress))
                                call address(yieldSourceAddress).0x87a6eeef with:
                                     gas gas_remaining wei
                                    args arg2, this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                emit Deposited(arg2, arg4, msg.sender, arg1, arg3);
                                stor101 = 1
                            if mem[96]:
                                revert with memory
                                  from 128
                                   len mem[96]
                            _21141 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = mem[_19843 + 100]
                            _21143 = mem[_19843 + 100]
                            if not mem[_19843 + 100]:
                                if not mem[_19843 + 100] % 32:
                                    revert with 0, 32, mem[mem[64] + 36 len mem[_19843 + 100] + 32]
                                mem[floor32(mem[_19843 + 100]) + mem[64] + 68] = mem[floor32(mem[_19843 + 100]) + mem[64] + -(mem[_19843 + 100] % 32) + 100 len mem[_19843 + 100] % 32]
                            else:
                                mem[mem[64] + 68] = mem[_19843 + 132]
                                idx = 32
                                while idx < _21143:
                                    mem[idx + mem[64] + 68] = mem[idx + _19843 + 132]
                                    idx = idx + 32
                                    continue 
                                if not _21143 % 32:
                                    revert with memory
                                      from mem[64]
                                       len _21143 + _21141 + -mem[64] + 68
                                mem[floor32(_21143) + _21141 + 68] = mem[floor32(_21143) + _21141 + -(_21143 % 32) + 100 len _21143 % 32]
                            revert with memory
                              from mem[64]
                               len floor32(_21143) + _21141 + -mem[64] + 100
                        _21031 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size) + 1
                        mem[_21031] = return_data.size
                        mem[_21031 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if ext_call.success:
                            if return_data.size:
                                require return_data.size >= 32
                                if not mem[_21031 + 32]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[mem[64] + 110 len 22]
                            require ext_code.size(address(yieldSourceAddress))
                            call address(yieldSourceAddress).0x87a6eeef with:
                                 gas gas_remaining wei
                                args arg2, this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            emit Deposited(arg2, arg4, msg.sender, arg1, arg3);
                            stor101 = 1
                        if return_data.size:
                            revert with ext_call.return_data[0 len return_data.size]
                        _21145 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = mem[_19843 + 100]
                        _21147 = mem[_19843 + 100]
                        if not mem[_19843 + 100]:
                            if not mem[_19843 + 100] % 32:
                                revert with 0, 32, mem[mem[64] + 36 len mem[_19843 + 100] + 32]
                            mem[floor32(mem[_19843 + 100]) + mem[64] + 68] = mem[floor32(mem[_19843 + 100]) + mem[64] + -(mem[_19843 + 100] % 32) + 100 len mem[_19843 + 100] % 32]
                        else:
                            mem[mem[64] + 68] = mem[_19843 + 132]
                            idx = 32
                            while idx < _21147:
                                mem[idx + mem[64] + 68] = mem[idx + _19843 + 132]
                                idx = idx + 32
                                continue 
                            if not _21147 % 32:
                                revert with memory
                                  from mem[64]
                                   len _21147 + _21145 + -mem[64] + 68
                            mem[floor32(_21147) + _21145 + 68] = mem[floor32(_21147) + _21145 + -(_21147 % 32) + 100 len _21147 % 32]
                        revert with memory
                          from mem[64]
                           len floor32(_21147) + _21145 + -mem[64] + 100
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(ext_call.return_data[0]))
                    staticcall address(ext_call.return_data[0]).0xdd62ed3e with:
                            gas gas_remaining wei
                           args this.address, address(yieldSourceAddress)
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if ext_call.return_data[0]:
                        revert with 0, 
                                    32,
                                    54,
                                    0x735361666545524332303a20617070726f76652066726f6d206e6f6e2d7a65726f20746f206e6f6e2d7a65726f20616c6c6f77616e63,
                                    mem[mem[64] + 122 len 10]
                    _19907 = mem[64]
                    mem[mem[64] + 36] = address(yieldSourceAddress)
                    mem[mem[64] + 68] = arg2
                    _19908 = mem[64]
                    mem[mem[64]] = 68
                    mem[64] = mem[64] + 100
                    mem[_19908 + 32] = 0x95ea7b300000000000000000000000000000000000000000000000000000000 or mem[_19908 + 36 len 28]
                    mem[64] = _19907 + 164
                    mem[_19907 + 100] = 32
                    mem[_19907 + 132] = 'SafeERC20: low-level call failed'
                    if eth.balance(this.address) < 0:
                        revert with 0, 32, 38, 0x6f416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_19907 + 270 len 26]
                    if not ext_code.size(address(ext_call.return_data[0])):
                        revert with 0, 'Address: call to non-contract'
                    _20042 = mem[_19908]
                    s = _19908 + 32
                    t = _19907 + 164
                    idx = mem[_19908]
                    while idx >= 32:
                        mem[t] = mem[s]
                        s = s + 32
                        t = t + 32
                        idx = idx - 32
                        continue 
                    mem[_19907 + floor32(mem[_19908]) + 164] = mem[_19908 + -(mem[_19908] % 32) + floor32(mem[_19908]) + 64 len mem[_19908] % 32] or Mask(8 * -(mem[_19908] % 32) + 32, -(8 * -(mem[_19908] % 32) + 32) + 256, mem[_19907 + floor32(mem[_19908]) + 164])
                    call address(ext_call.return_data[0]).mem[_19907 + 164 len 4] with:
                         gas gas_remaining wei
                        args mem[_19907 + 168 len _20042 - 4]
                    if not return_data.size:
                        if not ext_call.success:
                            if mem[96]:
                                revert with memory
                                  from 128
                                   len mem[96]
                            mem[_19907 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[_19907 + 168] = 32
                            idx = 32
                            while idx < 32:
                                mem[idx + _19907 + 232] = mem[idx + _19907 + 132]
                                idx = idx + 32
                                continue 
                            revert with 0, 32, 32, mem[_19907 + 132]
                        if mem[96]:
                            require mem[96] >= 32
                            if not mem[128]:
                                revert with 0, 
                                            32,
                                            42,
                                            0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                            mem[_19907 + 274 len 22]
                    else:
                        mem[_19907 + 164] = return_data.size
                        mem[_19907 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_19907 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[_19907 + ceil32(return_data.size) + 169] = 32
                            idx = 32
                            while idx < 32:
                                mem[idx + _19907 + ceil32(return_data.size) + 233] = mem[idx + _19907 + 132]
                                idx = idx + 32
                                continue 
                            revert with 0, 32, 32, mem[_19907 + 132]
                        if return_data.size:
                            require return_data.size >= 32
                            if not mem[_19907 + 196]:
                                revert with 0, 
                                            32,
                                            42,
                                            0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                            mem[_19907 + ceil32(return_data.size) + 275 len 22]
                    require ext_code.size(address(yieldSourceAddress))
                    call address(yieldSourceAddress).0x87a6eeef with:
                         gas gas_remaining wei
                        args arg2, this.address
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    emit Deposited(arg2, arg4, msg.sender, arg1, arg3);
                    stor101 = 1
                require mem[96] >= 32
                if not mem[128]:
                    revert with 0, 
                                32,
                                42,
                                0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                mem[mem[64] + 110 len 22]
                require ext_code.size(address(yieldSourceAddress))
                staticcall address(yieldSourceAddress).0xc89039c5 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if not arg2:
                    _19874 = mem[64]
                    mem[mem[64] + 36] = address(yieldSourceAddress)
                    mem[mem[64] + 68] = arg2
                    _19875 = mem[64]
                    mem[mem[64]] = 68
                    mem[64] = mem[64] + 100
                    mem[_19875 + 32] = 0x95ea7b300000000000000000000000000000000000000000000000000000000 or mem[_19875 + 36 len 28]
                    mem[64] = _19874 + 164
                    mem[_19874 + 100] = 32
                    mem[_19874 + 132] = 'SafeERC20: low-level call failed'
                    if eth.balance(this.address) < 0:
                        revert with 0, 32, 38, 0x6f416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_19874 + 270 len 26]
                    if not ext_code.size(address(ext_call.return_data[0])):
                        revert with 0, 'Address: call to non-contract'
                    _20002 = mem[_19875]
                    s = _19875 + 32
                    t = _19874 + 164
                    idx = mem[_19875]
                    while idx >= 32:
                        mem[t] = mem[s]
                        s = s + 32
                        t = t + 32
                        idx = idx - 32
                        continue 
                    mem[_19874 + floor32(mem[_19875]) + 164] = mem[_19875 + -(mem[_19875] % 32) + floor32(mem[_19875]) + 64 len mem[_19875] % 32] or Mask(8 * -(mem[_19875] % 32) + 32, -(8 * -(mem[_19875] % 32) + 32) + 256, mem[_19874 + floor32(mem[_19875]) + 164])
                    call address(ext_call.return_data[0]).mem[_19874 + 164 len 4] with:
                         gas gas_remaining wei
                        args mem[_19874 + 168 len _20002 - 4]
                    if not return_data.size:
                        if not ext_call.success:
                            if mem[96]:
                                revert with memory
                                  from 128
                                   len mem[96]
                            mem[_19874 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[_19874 + 168] = 32
                            idx = 32
                            while idx < 32:
                                mem[idx + _19874 + 232] = mem[idx + _19874 + 132]
                                idx = idx + 32
                                continue 
                            revert with 0, 32, 32, mem[_19874 + 132]
                        if mem[96]:
                            require mem[96] >= 32
                            if not mem[128]:
                                revert with 0, 
                                            32,
                                            42,
                                            0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                            mem[_19874 + 274 len 22]
                    else:
                        mem[_19874 + 164] = return_data.size
                        mem[_19874 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_19874 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[_19874 + ceil32(return_data.size) + 169] = 32
                            idx = 32
                            while idx < 32:
                                mem[idx + _19874 + ceil32(return_data.size) + 233] = mem[idx + _19874 + 132]
                                idx = idx + 32
                                continue 
                            revert with 0, 32, 32, mem[_19874 + 132]
                        if return_data.size:
                            require return_data.size >= 32
                            if not mem[_19874 + 196]:
                                revert with 0, 
                                            32,
                                            42,
                                            0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                            mem[_19874 + ceil32(return_data.size) + 275 len 22]
                    require ext_code.size(address(yieldSourceAddress))
                    call address(yieldSourceAddress).0x87a6eeef with:
                         gas gas_remaining wei
                        args arg2, this.address
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    emit Deposited(arg2, arg4, msg.sender, arg1, arg3);
                    stor101 = 1
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(ext_call.return_data[0]))
                staticcall address(ext_call.return_data[0]).0xdd62ed3e with:
                        gas gas_remaining wei
                       args this.address, address(yieldSourceAddress)
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if ext_call.return_data[0]:
                    revert with 0, 
                                32,
                                54,
                                0x735361666545524332303a20617070726f76652066726f6d206e6f6e2d7a65726f20746f206e6f6e2d7a65726f20616c6c6f77616e63,
                                mem[mem[64] + 122 len 10]
                _19941 = mem[64]
                mem[mem[64] + 36] = address(yieldSourceAddress)
                mem[mem[64] + 68] = arg2
                _19942 = mem[64]
                mem[mem[64]] = 68
                mem[64] = mem[64] + 100
                mem[_19942 + 32] = 0x95ea7b300000000000000000000000000000000000000000000000000000000 or mem[_19942 + 36 len 28]
                mem[64] = _19941 + 164
                mem[_19941 + 100] = 32
                mem[_19941 + 132] = 'SafeERC20: low-level call failed'
                if eth.balance(this.address) < 0:
                    revert with 0, 32, 38, 0x6f416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_19941 + 270 len 26]
                if not ext_code.size(address(ext_call.return_data[0])):
                    revert with 0, 'Address: call to non-contract'
                _20088 = mem[_19942]
                s = _19942 + 32
                t = mem[64]
                idx = mem[_19942]
                while idx >= 32:
                    mem[t] = mem[s]
                    s = s + 32
                    t = t + 32
                    idx = idx - 32
                    continue 
                mem[mem[64] + floor32(mem[_19942])] = mem[_19942 + floor32(mem[_19942]) + -(mem[_19942] % 32) + 64 len mem[_19942] % 32] or Mask(8 * -(mem[_19942] % 32) + 32, -(8 * -(mem[_19942] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_19942])])
                call address(ext_call.return_data[0]).mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len _20088 + _19941 + -mem[64] + 160]
                if not return_data.size:
                    if ext_call.success:
                        if mem[96]:
                            require mem[96] >= 32
                            if not mem[128]:
                                revert with 0, 
                                            32,
                                            42,
                                            0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                            mem[mem[64] + 110 len 22]
                        require ext_code.size(address(yieldSourceAddress))
                        call address(yieldSourceAddress).0x87a6eeef with:
                             gas gas_remaining wei
                            args arg2, this.address
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        emit Deposited(arg2, arg4, msg.sender, arg1, arg3);
                        stor101 = 1
                    if mem[96]:
                        revert with memory
                          from 128
                           len mem[96]
                    _21165 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = mem[_19941 + 100]
                    _21167 = mem[_19941 + 100]
                    if not mem[_19941 + 100]:
                        if not mem[_19941 + 100] % 32:
                            revert with 0, 32, mem[mem[64] + 36 len mem[_19941 + 100] + 32]
                        mem[floor32(mem[_19941 + 100]) + mem[64] + 68] = mem[floor32(mem[_19941 + 100]) + mem[64] + -(mem[_19941 + 100] % 32) + 100 len mem[_19941 + 100] % 32]
                    else:
                        mem[mem[64] + 68] = mem[_19941 + 132]
                        idx = 32
                        while idx < _21167:
                            mem[idx + mem[64] + 68] = mem[idx + _19941 + 132]
                            idx = idx + 32
                            continue 
                        if not _21167 % 32:
                            revert with memory
                              from mem[64]
                               len _21167 + _21165 + -mem[64] + 68
                        mem[floor32(_21167) + _21165 + 68] = mem[floor32(_21167) + _21165 + -(_21167 % 32) + 100 len _21167 % 32]
                    revert with memory
                      from mem[64]
                       len floor32(_21167) + _21165 + -mem[64] + 100
                _21034 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size) + 1
                mem[_21034] = return_data.size
                mem[_21034 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if ext_call.success:
                    if return_data.size:
                        require return_data.size >= 32
                        if not mem[_21034 + 32]:
                            revert with 0, 
                                        32,
                                        42,
                                        0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                        mem[mem[64] + 110 len 22]
                    require ext_code.size(address(yieldSourceAddress))
                    call address(yieldSourceAddress).0x87a6eeef with:
                         gas gas_remaining wei
                        args arg2, this.address
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    emit Deposited(arg2, arg4, msg.sender, arg1, arg3);
                    stor101 = 1
                if return_data.size:
                    revert with ext_call.return_data[0 len return_data.size]
                _21169 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = mem[_19941 + 100]
                _21171 = mem[_19941 + 100]
                if not mem[_19941 + 100]:
                    if not mem[_19941 + 100] % 32:
                        revert with 0, 32, mem[mem[64] + 36 len mem[_19941 + 100] + 32]
                    mem[floor32(mem[_19941 + 100]) + mem[64] + 68] = mem[floor32(mem[_19941 + 100]) + mem[64] + -(mem[_19941 + 100] % 32) + 100 len mem[_19941 + 100] % 32]
                    revert with memory
                      from mem[64]
                       len floor32(_21171) + _21169 + -mem[64] + 100
                mem[mem[64] + 68] = mem[_19941 + 132]
                idx = 32
                while idx < _21171:
                    mem[idx + mem[64] + 68] = mem[idx + _19941 + 132]
                    idx = idx + 32
                    continue 
                if not _21171 % 32:
                    revert with 0, 32, mem[mem[64] + 36 len _21171 + 32]
                mem[floor32(_21171) + mem[64] + 68] = mem[floor32(_21171) + mem[64] + -(_21171 % 32) + 100 len _21171 % 32]
                revert with 0, 32, mem[mem[64] + 36 len floor32(_21171) + 64]
            _19660 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size) + 1
            mem[_19660] = return_data.size
            mem[_19660 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if not ext_call.success:
                if return_data.size:
                    revert with ext_call.return_data[0 len return_data.size]
                _19741 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = mem[(64 * stor152.length) + 292]
                _19743 = mem[(64 * stor152.length) + 292]
                if not mem[(64 * stor152.length) + 292]:
                    if not mem[(64 * stor152.length) + 292] % 32:
                        revert with 0, 32, mem[mem[64] + 36 len mem[(64 * stor152.length) + 292] + 32]
                    mem[floor32(mem[(64 * stor152.length) + 292]) + mem[64] + 68] = mem[floor32(mem[(64 * stor152.length) + 292]) + mem[64] + -(mem[(64 * stor152.length) + 292] % 32) + 100 len mem[(64 * stor152.length) + 292] % 32]
                else:
                    mem[mem[64] + 68] = mem[(64 * stor152.length) + 324]
                    idx = 32
                    while idx < _19743:
                        mem[idx + mem[64] + 68] = mem[idx + (64 * stor152.length) + 324]
                        idx = idx + 32
                        continue 
                    if not _19743 % 32:
                        revert with memory
                          from mem[64]
                           len _19743 + _19741 + -mem[64] + 68
                    mem[floor32(_19743) + _19741 + 68] = mem[floor32(_19743) + _19741 + -(_19743 % 32) + 100 len _19743 % 32]
                revert with memory
                  from mem[64]
                   len floor32(_19743) + _19741 + -mem[64] + 100
            if not return_data.size:
                require ext_code.size(address(yieldSourceAddress))
                staticcall address(yieldSourceAddress).0xc89039c5 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if not arg2:
                    _19846 = mem[64]
                    mem[mem[64] + 36] = address(yieldSourceAddress)
                    mem[mem[64] + 68] = arg2
                    _19847 = mem[64]
                    mem[mem[64]] = 68
                    mem[64] = mem[64] + 100
                    mem[_19847 + 32] = 0x95ea7b300000000000000000000000000000000000000000000000000000000 or mem[_19847 + 36 len 28]
                    mem[64] = _19846 + 164
                    mem[_19846 + 100] = 32
                    mem[_19846 + 132] = 'SafeERC20: low-level call failed'
                    if eth.balance(this.address) < 0:
                        revert with 0, 32, 38, 0x6f416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_19846 + 270 len 26]
                    if not ext_code.size(address(ext_call.return_data[0])):
                        revert with 0, 'Address: call to non-contract'
                    _19969 = mem[_19847]
                    s = _19847 + 32
                    t = mem[64]
                    idx = mem[_19847]
                    while idx >= 32:
                        mem[t] = mem[s]
                        s = s + 32
                        t = t + 32
                        idx = idx - 32
                        continue 
                    mem[mem[64] + floor32(mem[_19847])] = mem[_19847 + floor32(mem[_19847]) + -(mem[_19847] % 32) + 64 len mem[_19847] % 32] or Mask(8 * -(mem[_19847] % 32) + 32, -(8 * -(mem[_19847] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_19847])])
                    call address(ext_call.return_data[0]).mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len _19969 + _19846 + -mem[64] + 160]
                    if not return_data.size:
                        if ext_call.success:
                            if mem[96]:
                                require mem[96] >= 32
                                if not mem[128]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[mem[64] + 110 len 22]
                            require ext_code.size(address(yieldSourceAddress))
                            call address(yieldSourceAddress).0x87a6eeef with:
                                 gas gas_remaining wei
                                args arg2, this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            emit Deposited(arg2, arg4, msg.sender, arg1, arg3);
                            stor101 = 1
                        if mem[96]:
                            revert with memory
                              from 128
                               len mem[96]
                        _21173 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = mem[_19846 + 100]
                        _21175 = mem[_19846 + 100]
                        if not mem[_19846 + 100]:
                            if not mem[_19846 + 100] % 32:
                                revert with 0, 32, mem[mem[64] + 36 len mem[_19846 + 100] + 32]
                            mem[floor32(mem[_19846 + 100]) + mem[64] + 68] = mem[floor32(mem[_19846 + 100]) + mem[64] + -(mem[_19846 + 100] % 32) + 100 len mem[_19846 + 100] % 32]
                            revert with 0, 32, mem[mem[64] + 36 len floor32(_21175) + 64]
                        mem[mem[64] + 68] = mem[_19846 + 132]
                        idx = 32
                        while idx < _21175:
                            mem[idx + mem[64] + 68] = mem[idx + _19846 + 132]
                            idx = idx + 32
                            continue 
                        if not _21175 % 32:
                            revert with memory
                              from mem[64]
                               len _21175 + _21173 + -mem[64] + 68
                        mem[floor32(_21175) + _21173 + 68] = mem[floor32(_21175) + _21173 + -(_21175 % 32) + 100 len _21175 % 32]
                        revert with memory
                          from mem[64]
                           len floor32(_21175) + _21173 + -mem[64] + 100
                    _21037 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size) + 1
                    mem[_21037] = return_data.size
                    mem[_21037 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if ext_call.success:
                        if return_data.size:
                            require return_data.size >= 32
                            if not mem[_21037 + 32]:
                                revert with 0, 
                                            32,
                                            42,
                                            0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                            mem[mem[64] + 110 len 22]
                        require ext_code.size(address(yieldSourceAddress))
                        call address(yieldSourceAddress).0x87a6eeef with:
                             gas gas_remaining wei
                            args arg2, this.address
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        emit Deposited(arg2, arg4, msg.sender, arg1, arg3);
                        stor101 = 1
                    if return_data.size:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = mem[_19846 + 100]
                    _21179 = mem[_19846 + 100]
                    if not mem[_19846 + 100]:
                        if not mem[_19846 + 100] % 32:
                            revert with 0, 32, mem[mem[64] + 36 len mem[_19846 + 100] + 32]
                        mem[floor32(mem[_19846 + 100]) + mem[64] + 68] = mem[floor32(mem[_19846 + 100]) + mem[64] + -(mem[_19846 + 100] % 32) + 100 len mem[_19846 + 100] % 32]
                    else:
                        mem[mem[64] + 68] = mem[_19846 + 132]
                        idx = 32
                        while idx < _21179:
                            mem[idx + mem[64] + 68] = mem[idx + _19846 + 132]
                            idx = idx + 32
                            continue 
                        if not _21179 % 32:
                            revert with 0, 32, mem[mem[64] + 36 len _21179 + 32]
                        mem[floor32(_21179) + mem[64] + 68] = mem[floor32(_21179) + mem[64] + -(_21179 % 32) + 100 len _21179 % 32]
                    revert with 0, 32, mem[mem[64] + 36 len floor32(_21179) + 64]
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(ext_call.return_data[0]))
                staticcall address(ext_call.return_data[0]).0xdd62ed3e with:
                        gas gas_remaining wei
                       args this.address, address(yieldSourceAddress)
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if ext_call.return_data[0]:
                    revert with 0, 
                                32,
                                54,
                                0x735361666545524332303a20617070726f76652066726f6d206e6f6e2d7a65726f20746f206e6f6e2d7a65726f20616c6c6f77616e63,
                                mem[mem[64] + 122 len 10]
                _19915 = mem[64]
                mem[mem[64] + 36] = address(yieldSourceAddress)
                mem[mem[64] + 68] = arg2
                _19916 = mem[64]
                mem[mem[64]] = 68
                mem[64] = mem[64] + 100
                mem[_19916 + 32] = 0x95ea7b300000000000000000000000000000000000000000000000000000000 or mem[_19916 + 36 len 28]
                mem[64] = _19915 + 164
                mem[_19915 + 100] = 32
                mem[_19915 + 132] = 'SafeERC20: low-level call failed'
                if eth.balance(this.address) < 0:
                    revert with 0, 32, 38, 0x6f416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_19915 + 270 len 26]
                if not ext_code.size(address(ext_call.return_data[0])):
                    revert with 0, 'Address: call to non-contract'
                _20050 = mem[_19916]
                s = _19916 + 32
                t = _19915 + 164
                idx = mem[_19916]
                while idx >= 32:
                    mem[t] = mem[s]
                    s = s + 32
                    t = t + 32
                    idx = idx - 32
                    continue 
                mem[_19915 + floor32(mem[_19916]) + 164] = mem[_19916 + -(mem[_19916] % 32) + floor32(mem[_19916]) + 64 len mem[_19916] % 32] or Mask(8 * -(mem[_19916] % 32) + 32, -(8 * -(mem[_19916] % 32) + 32) + 256, mem[_19915 + floor32(mem[_19916]) + 164])
                call address(ext_call.return_data[0]).mem[_19915 + 164 len 4] with:
                     gas gas_remaining wei
                    args mem[_19915 + 168 len _20050 - 4]
                if not return_data.size:
                    if not ext_call.success:
                        if mem[96]:
                            revert with memory
                              from 128
                               len mem[96]
                        mem[_19915 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[_19915 + 168] = 32
                        idx = 32
                        while idx < 32:
                            mem[idx + _19915 + 232] = mem[idx + _19915 + 132]
                            idx = idx + 32
                            continue 
                        revert with 0, 32, 32, mem[_19915 + 132]
                    if mem[96]:
                        require mem[96] >= 32
                        if not mem[128]:
                            revert with 0, 
                                        32,
                                        42,
                                        0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                        mem[_19915 + 274 len 22]
                else:
                    mem[_19915 + 164] = return_data.size
                    mem[_19915 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not ext_call.success:
                        if return_data.size:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_19915 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[_19915 + ceil32(return_data.size) + 169] = 32
                        idx = 32
                        while idx < 32:
                            mem[idx + _19915 + ceil32(return_data.size) + 233] = mem[idx + _19915 + 132]
                            idx = idx + 32
                            continue 
                        revert with 0, 32, 32, mem[_19915 + 132]
                    if return_data.size:
                        require return_data.size >= 32
                        if not mem[_19915 + 196]:
                            revert with 0, 
                                        32,
                                        42,
                                        0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                        mem[_19915 + ceil32(return_data.size) + 275 len 22]
                require ext_code.size(address(yieldSourceAddress))
                call address(yieldSourceAddress).0x87a6eeef with:
                     gas gas_remaining wei
                    args arg2, this.address
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                emit Deposited(arg2, arg4, msg.sender, arg1, arg3);
                stor101 = 1
            require return_data.size >= 32
            if not mem[_19660 + 32]:
                revert with 0, 
                            32,
                            42,
                            0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                            mem[mem[64] + 110 len 22]
            require ext_code.size(address(yieldSourceAddress))
            staticcall address(yieldSourceAddress).0xc89039c5 with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if not arg2:
                _19878 = mem[64]
                mem[mem[64] + 36] = address(yieldSourceAddress)
                mem[mem[64] + 68] = arg2
                _19879 = mem[64]
                mem[mem[64]] = 68
                mem[64] = mem[64] + 100
                mem[_19879 + 32] = 0x95ea7b300000000000000000000000000000000000000000000000000000000 or mem[_19879 + 36 len 28]
                mem[64] = _19878 + 164
                mem[_19878 + 100] = 32
                mem[_19878 + 132] = 'SafeERC20: low-level call failed'
                if eth.balance(this.address) < 0:
                    revert with 0, 32, 38, 0x6f416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_19878 + 270 len 26]
                if not ext_code.size(address(ext_call.return_data[0])):
                    revert with 0, 'Address: call to non-contract'
                _20010 = mem[_19879]
                s = _19879 + 32
                t = mem[64]
                idx = mem[_19879]
                while idx >= 32:
                    mem[t] = mem[s]
                    s = s + 32
                    t = t + 32
                    idx = idx - 32
                    continue 
                mem[mem[64] + floor32(mem[_19879])] = mem[_19879 + floor32(mem[_19879]) + -(mem[_19879] % 32) + 64 len mem[_19879] % 32] or Mask(8 * -(mem[_19879] % 32) + 32, -(8 * -(mem[_19879] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_19879])])
                call address(ext_call.return_data[0]).mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len _20010 + _19878 + -mem[64] + 160]
                if not return_data.size:
                    if ext_call.success:
                        if mem[96]:
                            require mem[96] >= 32
                            if not mem[128]:
                                revert with 0, 
                                            32,
                                            42,
                                            0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                            mem[mem[64] + 110 len 22]
                        require ext_code.size(address(yieldSourceAddress))
                        call address(yieldSourceAddress).0x87a6eeef with:
                             gas gas_remaining wei
                            args arg2, this.address
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        emit Deposited(arg2, arg4, msg.sender, arg1, arg3);
                        stor101 = 1
                    if mem[96]:
                        revert with memory
                          from 128
                           len mem[96]
                    _21189 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = mem[_19878 + 100]
                    _21191 = mem[_19878 + 100]
                    if not mem[_19878 + 100]:
                        if not mem[_19878 + 100] % 32:
                            revert with 0, 32, mem[mem[64] + 36 len mem[_19878 + 100] + 32]
                        mem[floor32(mem[_19878 + 100]) + mem[64] + 68] = mem[floor32(mem[_19878 + 100]) + mem[64] + -(mem[_19878 + 100] % 32) + 100 len mem[_19878 + 100] % 32]
                    else:
                        mem[mem[64] + 68] = mem[_19878 + 132]
                        idx = 32
                        while idx < _21191:
                            mem[idx + mem[64] + 68] = mem[idx + _19878 + 132]
                            idx = idx + 32
                            continue 
                        if not _21191 % 32:
                            revert with memory
                              from mem[64]
                               len _21191 + _21189 + -mem[64] + 68
                        mem[floor32(_21191) + _21189 + 68] = mem[floor32(_21191) + _21189 + -(_21191 % 32) + 100 len _21191 % 32]
                    revert with memory
                      from mem[64]
                       len floor32(_21191) + _21189 + -mem[64] + 100
                _21039 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size) + 1
                mem[_21039] = return_data.size
                mem[_21039 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if ext_call.success:
                    if return_data.size:
                        require return_data.size >= 32
                        if not mem[_21039 + 32]:
                            revert with 0, 
                                        32,
                                        42,
                                        0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                        mem[mem[64] + 110 len 22]
                    require ext_code.size(address(yieldSourceAddress))
                    call address(yieldSourceAddress).0x87a6eeef with:
                         gas gas_remaining wei
                        args arg2, this.address
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    emit Deposited(arg2, arg4, msg.sender, arg1, arg3);
                    stor101 = 1
                if return_data.size:
                    revert with ext_call.return_data[0 len return_data.size]
                _21193 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = mem[_19878 + 100]
                _21195 = mem[_19878 + 100]
                if not mem[_19878 + 100]:
                    if not mem[_19878 + 100] % 32:
                        revert with 0, 32, mem[mem[64] + 36 len mem[_19878 + 100] + 32]
                    mem[floor32(mem[_19878 + 100]) + mem[64] + 68] = mem[floor32(mem[_19878 + 100]) + mem[64] + -(mem[_19878 + 100] % 32) + 100 len mem[_19878 + 100] % 32]
                else:
                    mem[mem[64] + 68] = mem[_19878 + 132]
                    idx = 32
                    while idx < _21195:
                        mem[idx + mem[64] + 68] = mem[idx + _19878 + 132]
                        idx = idx + 32
                        continue 
                    if not _21195 % 32:
                        revert with memory
                          from mem[64]
                           len _21195 + _21193 + -mem[64] + 68
                    mem[floor32(_21195) + _21193 + 68] = mem[floor32(_21195) + _21193 + -(_21195 % 32) + 100 len _21195 % 32]
                revert with memory
                  from mem[64]
                   len floor32(_21195) + _21193 + -mem[64] + 100
            mem[mem[64] + 4] = this.address
            require ext_code.size(address(ext_call.return_data[0]))
            staticcall address(ext_call.return_data[0]).0xdd62ed3e with:
                    gas gas_remaining wei
                   args this.address, address(yieldSourceAddress)
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if ext_call.return_data[0]:
                revert with 0, 
                            32,
                            54,
                            0x735361666545524332303a20617070726f76652066726f6d206e6f6e2d7a65726f20746f206e6f6e2d7a65726f20616c6c6f77616e63,
                            mem[mem[64] + 122 len 10]
            _19948 = mem[64]
            mem[mem[64] + 36] = address(yieldSourceAddress)
            mem[mem[64] + 68] = arg2
            _19949 = mem[64]
            mem[mem[64]] = 68
            mem[64] = mem[64] + 100
            mem[_19949 + 32] = 0x95ea7b300000000000000000000000000000000000000000000000000000000 or mem[_19949 + 36 len 28]
            mem[64] = _19948 + 164
            mem[_19948 + 100] = 32
            mem[_19948 + 132] = 'SafeERC20: low-level call failed'
            if eth.balance(this.address) < 0:
                revert with 0, 32, 38, 0x6f416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_19948 + 270 len 26]
            if not ext_code.size(address(ext_call.return_data[0])):
                revert with 0, 'Address: call to non-contract'
            _20098 = mem[_19949]
            s = _19949 + 32
            t = mem[64]
            idx = mem[_19949]
            while idx >= 32:
                mem[t] = mem[s]
                s = s + 32
                t = t + 32
                idx = idx - 32
                continue 
            mem[mem[64] + floor32(mem[_19949])] = mem[_19949 + floor32(mem[_19949]) + -(mem[_19949] % 32) + 64 len mem[_19949] % 32] or Mask(8 * -(mem[_19949] % 32) + 32, -(8 * -(mem[_19949] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_19949])])
            call address(ext_call.return_data[0]).mem[mem[64] len 4] with:
                 gas gas_remaining wei
                args mem[mem[64] + 4 len _20098 + _19948 + -mem[64] + 160]
            if not return_data.size:
                if ext_call.success:
                    if mem[96]:
                        require mem[96] >= 32
                        if not mem[128]:
                            revert with 0, 
                                        32,
                                        42,
                                        0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                        mem[mem[64] + 110 len 22]
                    require ext_code.size(address(yieldSourceAddress))
                    call address(yieldSourceAddress).0x87a6eeef with:
                         gas gas_remaining wei
                        args arg2, this.address
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    emit Deposited(arg2, arg4, msg.sender, arg1, arg3);
                    stor101 = 1
                if mem[96]:
                    revert with memory
                      from 128
                       len mem[96]
                _21197 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = mem[_19948 + 100]
                _21199 = mem[_19948 + 100]
                if not mem[_19948 + 100]:
                    if not mem[_19948 + 100] % 32:
                        revert with 0, 32, mem[mem[64] + 36 len mem[_19948 + 100] + 32]
                    mem[floor32(mem[_19948 + 100]) + mem[64] + 68] = mem[floor32(mem[_19948 + 100]) + mem[64] + -(mem[_19948 + 100] % 32) + 100 len mem[_19948 + 100] % 32]
                    revert with memory
                      from mem[64]
                       len floor32(_21199) + _21197 + -mem[64] + 100
                mem[mem[64] + 68] = mem[_19948 + 132]
                idx = 32
                while idx < _21199:
                    mem[idx + mem[64] + 68] = mem[idx + _19948 + 132]
                    idx = idx + 32
                    continue 
                if not _21199 % 32:
                    revert with 0, 32, mem[mem[64] + 36 len _21199 + 32]
                mem[floor32(_21199) + mem[64] + 68] = mem[floor32(_21199) + mem[64] + -(_21199 % 32) + 100 len _21199 % 32]
                revert with 0, 32, mem[mem[64] + 36 len floor32(_21199) + 64]
            _21040 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size) + 1
            mem[_21040] = return_data.size
            mem[_21040 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if ext_call.success:
                if return_data.size:
                    require return_data.size >= 32
                    if not mem[_21040 + 32]:
                        revert with 0, 
                                    32,
                                    42,
                                    0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                    mem[mem[64] + 110 len 22]
                require ext_code.size(address(yieldSourceAddress))
                call address(yieldSourceAddress).0x87a6eeef with:
                     gas gas_remaining wei
                    args arg2, this.address
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                emit Deposited(arg2, arg4, msg.sender, arg1, arg3);
                stor101 = 1
            if return_data.size:
                revert with ext_call.return_data[0 len return_data.size]
            _21201 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = mem[_19948 + 100]
            _21203 = mem[_19948 + 100]
            if not mem[_19948 + 100]:
                if not mem[_19948 + 100] % 32:
                    revert with 0, 32, mem[mem[64] + 36 len mem[_19948 + 100] + 32]
                mem[floor32(mem[_19948 + 100]) + mem[64] + 68] = mem[floor32(mem[_19948 + 100]) + mem[64] + -(mem[_19948 + 100] % 32) + 100 len mem[_19948 + 100] % 32]
                revert with memory
                  from mem[64]
                   len floor32(_21203) + _21201 + -mem[64] + 100
            mem[mem[64] + 68] = mem[_19948 + 132]
            idx = 32
            while idx < _21203:
                mem[idx + mem[64] + 68] = mem[idx + _19948 + 132]
                idx = idx + 32
                continue 
            if not _21203 % 32:
                revert with 0, 32, mem[mem[64] + 36 len _21203 + 32]
            mem[floor32(_21203) + mem[64] + 68] = mem[floor32(_21203) + mem[64] + -(_21203 % 32) + 100 len _21203 % 32]
            revert with 0, 32, mem[mem[64] + 36 len floor32(_21203) + 64]
    revert with 0, 'mPrizePool/unknown-token'
}

function award(address arg1, uint256 arg2, address arg3) payable {
    require calldata.size - 4 >= 96
    if prizeStrategyAddress != msg.sender:
        revert with 0, 'PrizePool/only-prizeStrategy'
    if stor152.length:
        mem[128] = address(stor152.field_0)
        idx = 128
        s = 0
        while (32 * stor152.length) + 96 > idx:
            mem[idx + 32] = stor152[s].field_256
            idx = idx + 32
            s = s + 1
            continue 
    idx = 0
    while idx < stor152.length:
        require idx < stor152.length
        if mem[(32 * idx) + 140 len 20] != arg3:
            idx = idx + 1
            continue 
        if arg2:
            if arg2 > awardBalance:
                revert with 0, 'PrizePool/award-exceeds-avail'
            awardBalance -= arg2
            if not prizeStrategyAddress:
                require ext_code.size(arg3)
                call arg3.0x5d7b0758 with:
                     gas gas_remaining wei
                    args address(arg1), arg2
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if not creditPlanOf[address(arg3)].field_0:
                    if not maxExitFeeMantissa:
                        require ext_code.size(arg3)
                        staticcall arg3.0x70a08231 with:
                                gas gas_remaining wei
                               args arg1
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if not stor159[address(arg3)][address(arg1)].field_224:
                            if block.timestamp >= 4294967296:
                                revert with 0, 
                                            32,
                                            38,
                                            0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                            mem[(32 * stor152.length) + 458 len 26]
                            stor159[address(arg3)][address(arg1)].field_0 = 0
                            stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                            stor159[address(arg3)][address(arg1)].field_224 = 1
                            stor159[address(arg3)][address(arg1)].field_256 = 0
                            if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                            else:
                                if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                    if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                        else:
                            if not stor159[address(arg3)][address(arg1)].field_224:
                                if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not creditPlanOf[address(arg3)].field_0:
                                    if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                        if block.timestamp >= 4294967296:
                                            revert with 0, 
                                                        32,
                                                        38,
                                                        0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                        mem[(32 * stor152.length) + 522 len 26]
                                        stor159[address(arg3)][address(arg1)].field_0 = 0
                                        stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                        stor159[address(arg3)][address(arg1)].field_224 = 1
                                        stor159[address(arg3)][address(arg1)].field_256 = 0
                                        if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                            if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                        else:
                                            if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                                if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                    else:
                                        if stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                            revert with 0, 
                                                        32,
                                                        39,
                                                        0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                        mem[(32 * stor152.length) + 523 len 25]
                                        if block.timestamp >= 4294967296:
                                            revert with 0, 
                                                        32,
                                                        38,
                                                        0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                        mem[(32 * stor152.length) + 522 len 26]
                                        stor159[address(arg3)][address(arg1)].field_0 = stor159[address(arg3)][address(arg1)].field_0
                                        stor159[address(arg3)][address(arg1)].field_128 = 0
                                        stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                        stor159[address(arg3)][address(arg1)].field_224 = 1
                                        if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                            if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            emit CreditMinted(0, arg1, arg3);
                                        else:
                                            if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                emit CreditBurned(0, arg1, arg3);
                                else:
                                    if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / creditPlanOf[address(arg3)].field_0 != ext_call.return_data[0]:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[(32 * stor152.length) + 357 len 31]
                                    if stor159[address(arg3)][address(arg1)].field_0 <= ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                        if stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                            revert with 0, 
                                                        32,
                                                        39,
                                                        0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                        mem[(32 * stor152.length) + 523 len 25]
                                        if block.timestamp >= 4294967296:
                                            revert with 0, 
                                                        32,
                                                        38,
                                                        0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                        mem[(32 * stor152.length) + 522 len 26]
                                        stor159[address(arg3)][address(arg1)].field_0 = stor159[address(arg3)][address(arg1)].field_0
                                        stor159[address(arg3)][address(arg1)].field_128 = 0
                                        stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                        stor159[address(arg3)][address(arg1)].field_224 = 1
                                        if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                            if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            emit CreditMinted(0, arg1, arg3);
                                        else:
                                            if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                emit CreditBurned(0, arg1, arg3);
                                    else:
                                        if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 >= 0x100000000000000000000000000000000:
                                            revert with 0, 
                                                        32,
                                                        39,
                                                        0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                        mem[(32 * stor152.length) + 523 len 25]
                                        if block.timestamp >= 4294967296:
                                            revert with 0, 
                                                        32,
                                                        38,
                                                        0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                        mem[(32 * stor152.length) + 522 len 26]
                                        stor159[address(arg3)][address(arg1)].field_0 = uint128(ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)
                                        stor159[address(arg3)][address(arg1)].field_128 = 0
                                        stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                        stor159[address(arg3)][address(arg1)].field_224 = 1
                                        if stor159[address(arg3)][address(arg1)].field_0 < ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                            if stor159[address(arg3)][address(arg1)].field_0 > ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            emit CreditMinted(((ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18) - stor159[address(arg3)][address(arg1)].field_0), arg1, arg3);
                                        else:
                                            if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 < stor159[address(arg3)][address(arg1)].field_0:
                                                if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 > stor159[address(arg3)][address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                emit CreditBurned((stor159[address(arg3)][address(arg1)].field_0 - (ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)), arg1, arg3);
                            else:
                                if stor159[address(arg3)][address(arg1)].field_192 > block.timestamp:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if not block.timestamp - stor159[address(arg3)][address(arg1)].field_192:
                                    if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not creditPlanOf[address(arg3)].field_0:
                                        if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                            if block.timestamp >= 4294967296:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                            mem[(32 * stor152.length) + 586 len 26]
                                            stor159[address(arg3)][address(arg1)].field_0 = 0
                                            stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                            stor159[address(arg3)][address(arg1)].field_224 = 1
                                            stor159[address(arg3)][address(arg1)].field_256 = 0
                                            if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                                if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                            else:
                                                if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                        else:
                                            if stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                revert with 0, 
                                                            32,
                                                            39,
                                                            0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                            mem[(32 * stor152.length) + 587 len 25]
                                            if block.timestamp >= 4294967296:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                            mem[(32 * stor152.length) + 586 len 26]
                                            stor159[address(arg3)][address(arg1)].field_0 = stor159[address(arg3)][address(arg1)].field_0
                                            stor159[address(arg3)][address(arg1)].field_128 = 0
                                            stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                            stor159[address(arg3)][address(arg1)].field_224 = 1
                                            if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                emit CreditMinted(0, arg1, arg3);
                                            else:
                                                if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditBurned(0, arg1, arg3);
                                    else:
                                        if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / creditPlanOf[address(arg3)].field_0 != ext_call.return_data[0]:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * stor152.length) + 421 len 31]
                                        if stor159[address(arg3)][address(arg1)].field_0 <= ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                            if stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                revert with 0, 
                                                            32,
                                                            39,
                                                            0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                            mem[(32 * stor152.length) + 587 len 25]
                                            if block.timestamp >= 4294967296:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                            mem[(32 * stor152.length) + 586 len 26]
                                            stor159[address(arg3)][address(arg1)].field_0 = stor159[address(arg3)][address(arg1)].field_0
                                            stor159[address(arg3)][address(arg1)].field_128 = 0
                                            stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                            stor159[address(arg3)][address(arg1)].field_224 = 1
                                            if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                emit CreditMinted(0, arg1, arg3);
                                            else:
                                                if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditBurned(0, arg1, arg3);
                                        else:
                                            if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 >= 0x100000000000000000000000000000000:
                                                revert with 0, 
                                                            32,
                                                            39,
                                                            0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                            mem[(32 * stor152.length) + 587 len 25]
                                            if block.timestamp >= 4294967296:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                            mem[(32 * stor152.length) + 586 len 26]
                                            stor159[address(arg3)][address(arg1)].field_0 = uint128(ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)
                                            stor159[address(arg3)][address(arg1)].field_128 = 0
                                            stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                            stor159[address(arg3)][address(arg1)].field_224 = 1
                                            if stor159[address(arg3)][address(arg1)].field_0 < ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                if stor159[address(arg3)][address(arg1)].field_0 > ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                emit CreditMinted(((ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18) - stor159[address(arg3)][address(arg1)].field_0), arg1, arg3);
                                            else:
                                                if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditBurned((stor159[address(arg3)][address(arg1)].field_0 - (ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)), arg1, arg3);
                                else:
                                    if (block.timestamp * creditPlanOf[address(arg3)].field_128) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128) / block.timestamp - stor159[address(arg3)][address(arg1)].field_192 != creditPlanOf[address(arg3)].field_128:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[(32 * stor152.length) + 357 len 31]
                                    if not (block.timestamp * creditPlanOf[address(arg3)].field_128) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128):
                                        if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not creditPlanOf[address(arg3)].field_0:
                                            if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                if block.timestamp >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                mem[(32 * stor152.length) + 586 len 26]
                                                stor159[address(arg3)][address(arg1)].field_0 = 0
                                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                                stor159[address(arg3)][address(arg1)].field_256 = 0
                                                if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                                else:
                                                    if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                            else:
                                                if stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                    revert with 0, 
                                                                32,
                                                                39,
                                                                0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                mem[(32 * stor152.length) + 587 len 25]
                                                if block.timestamp >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                mem[(32 * stor152.length) + 586 len 26]
                                                stor159[address(arg3)][address(arg1)].field_0 = stor159[address(arg3)][address(arg1)].field_0
                                                stor159[address(arg3)][address(arg1)].field_128 = 0
                                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                                if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditMinted(0, arg1, arg3);
                                                else:
                                                    if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditBurned(0, arg1, arg3);
                                        else:
                                            if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / creditPlanOf[address(arg3)].field_0 != ext_call.return_data[0]:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * stor152.length) + 421 len 31]
                                            if stor159[address(arg3)][address(arg1)].field_0 <= ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                if stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                    revert with 0, 
                                                                32,
                                                                39,
                                                                0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                mem[(32 * stor152.length) + 587 len 25]
                                                if block.timestamp >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                mem[(32 * stor152.length) + 586 len 26]
                                                stor159[address(arg3)][address(arg1)].field_0 = stor159[address(arg3)][address(arg1)].field_0
                                                stor159[address(arg3)][address(arg1)].field_128 = 0
                                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                                if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditMinted(0, arg1, arg3);
                                                else:
                                                    if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditBurned(0, arg1, arg3);
                                            else:
                                                if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 >= 0x100000000000000000000000000000000:
                                                    revert with 0, 
                                                                32,
                                                                39,
                                                                0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                mem[(32 * stor152.length) + 587 len 25]
                                                if block.timestamp >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                mem[(32 * stor152.length) + 586 len 26]
                                                stor159[address(arg3)][address(arg1)].field_0 = uint128(ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)
                                                stor159[address(arg3)][address(arg1)].field_128 = 0
                                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                                if stor159[address(arg3)][address(arg1)].field_0 < ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditMinted(((ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18) - stor159[address(arg3)][address(arg1)].field_0), arg1, arg3);
                                                else:
                                                    if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditBurned((stor159[address(arg3)][address(arg1)].field_0 - (ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)), arg1, arg3);
                                    else:
                                        if (block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / (block.timestamp * creditPlanOf[address(arg3)].field_128) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128) != ext_call.return_data[0]:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * stor152.length) + 357 len 31]
                                        if ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not creditPlanOf[address(arg3)].field_0:
                                            if ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                if block.timestamp >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                mem[(32 * stor152.length) + 586 len 26]
                                                stor159[address(arg3)][address(arg1)].field_0 = 0
                                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                                stor159[address(arg3)][address(arg1)].field_256 = 0
                                                if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                                else:
                                                    if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                            else:
                                                if ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                    revert with 0, 
                                                                32,
                                                                39,
                                                                0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                mem[(32 * stor152.length) + 587 len 25]
                                                if block.timestamp >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                mem[(32 * stor152.length) + 586 len 26]
                                                stor159[address(arg3)][address(arg1)].field_0 = uint128(((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                                stor159[address(arg3)][address(arg1)].field_128 = 0
                                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                                if stor159[address(arg3)][address(arg1)].field_0 < ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditMinted(((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18), arg1, arg3);
                                                else:
                                                    if ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditBurned(-((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18), arg1, arg3);
                                        else:
                                            if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / creditPlanOf[address(arg3)].field_0 != ext_call.return_data[0]:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * stor152.length) + 421 len 31]
                                            if ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 <= ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                if ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                    revert with 0, 
                                                                32,
                                                                39,
                                                                0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                mem[(32 * stor152.length) + 587 len 25]
                                                if block.timestamp >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                mem[(32 * stor152.length) + 586 len 26]
                                                stor159[address(arg3)][address(arg1)].field_0 = uint128(((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                                stor159[address(arg3)][address(arg1)].field_128 = 0
                                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                                if stor159[address(arg3)][address(arg1)].field_0 < ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditMinted(((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18), arg1, arg3);
                                                else:
                                                    if ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditBurned(-((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18), arg1, arg3);
                                            else:
                                                if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 >= 0x100000000000000000000000000000000:
                                                    revert with 0, 
                                                                32,
                                                                39,
                                                                0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                mem[(32 * stor152.length) + 587 len 25]
                                                if block.timestamp >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                mem[(32 * stor152.length) + 586 len 26]
                                                stor159[address(arg3)][address(arg1)].field_0 = uint128(ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)
                                                stor159[address(arg3)][address(arg1)].field_128 = 0
                                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                                if stor159[address(arg3)][address(arg1)].field_0 < ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditMinted(((ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18) - stor159[address(arg3)][address(arg1)].field_0), arg1, arg3);
                                                else:
                                                    if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditBurned((stor159[address(arg3)][address(arg1)].field_0 - (ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)), arg1, arg3);
                    else:
                        if arg2 * maxExitFeeMantissa / maxExitFeeMantissa != arg2:
                            revert with 0, 
                                        32,
                                        33,
                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[(32 * stor152.length) + 293 len 31]
                        require ext_code.size(arg3)
                        staticcall arg3.0x70a08231 with:
                                gas gas_remaining wei
                               args arg1
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if 0 <= arg2 * maxExitFeeMantissa / 10^18:
                            if not stor159[address(arg3)][address(arg1)].field_224:
                                if block.timestamp >= 4294967296:
                                    revert with 0, 
                                                32,
                                                38,
                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                mem[(32 * stor152.length) + 458 len 26]
                                stor159[address(arg3)][address(arg1)].field_0 = 0
                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                stor159[address(arg3)][address(arg1)].field_256 = 0
                                if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                    if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                else:
                                    if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                        if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                            else:
                                if not stor159[address(arg3)][address(arg1)].field_224:
                                    if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not creditPlanOf[address(arg3)].field_0:
                                        if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                            if block.timestamp >= 4294967296:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                            mem[(32 * stor152.length) + 522 len 26]
                                            stor159[address(arg3)][address(arg1)].field_0 = 0
                                            stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                            stor159[address(arg3)][address(arg1)].field_224 = 1
                                            stor159[address(arg3)][address(arg1)].field_256 = 0
                                            if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                                if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                            else:
                                                if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                        else:
                                            if stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                revert with 0, 
                                                            32,
                                                            39,
                                                            0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                            mem[(32 * stor152.length) + 523 len 25]
                                            if block.timestamp >= 4294967296:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                            mem[(32 * stor152.length) + 522 len 26]
                                            stor159[address(arg3)][address(arg1)].field_0 = stor159[address(arg3)][address(arg1)].field_0
                                            stor159[address(arg3)][address(arg1)].field_128 = 0
                                            stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                            stor159[address(arg3)][address(arg1)].field_224 = 1
                                            if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                emit CreditMinted(0, arg1, arg3);
                                            else:
                                                if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditBurned(0, arg1, arg3);
                                    else:
                                        if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / creditPlanOf[address(arg3)].field_0 != ext_call.return_data[0]:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * stor152.length) + 357 len 31]
                                        if stor159[address(arg3)][address(arg1)].field_0 <= ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                            if stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                revert with 0, 
                                                            32,
                                                            39,
                                                            0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                            mem[(32 * stor152.length) + 523 len 25]
                                            if block.timestamp >= 4294967296:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                            mem[(32 * stor152.length) + 522 len 26]
                                            stor159[address(arg3)][address(arg1)].field_0 = stor159[address(arg3)][address(arg1)].field_0
                                            stor159[address(arg3)][address(arg1)].field_128 = 0
                                            stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                            stor159[address(arg3)][address(arg1)].field_224 = 1
                                            if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                emit CreditMinted(0, arg1, arg3);
                                            else:
                                                if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditBurned(0, arg1, arg3);
                                        else:
                                            if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 >= 0x100000000000000000000000000000000:
                                                revert with 0, 
                                                            32,
                                                            39,
                                                            0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                            mem[(32 * stor152.length) + 523 len 25]
                                            if block.timestamp >= 4294967296:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                            mem[(32 * stor152.length) + 522 len 26]
                                            stor159[address(arg3)][address(arg1)].field_0 = uint128(ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)
                                            stor159[address(arg3)][address(arg1)].field_128 = 0
                                            stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                            stor159[address(arg3)][address(arg1)].field_224 = 1
                                            if stor159[address(arg3)][address(arg1)].field_0 < ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                if stor159[address(arg3)][address(arg1)].field_0 > ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                emit CreditMinted(((ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18) - stor159[address(arg3)][address(arg1)].field_0), arg1, arg3);
                                            else:
                                                if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditBurned((stor159[address(arg3)][address(arg1)].field_0 - (ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)), arg1, arg3);
                                else:
                                    if stor159[address(arg3)][address(arg1)].field_192 > block.timestamp:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if not block.timestamp - stor159[address(arg3)][address(arg1)].field_192:
                                        if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not creditPlanOf[address(arg3)].field_0:
                                            if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                if block.timestamp >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                mem[(32 * stor152.length) + 586 len 26]
                                                stor159[address(arg3)][address(arg1)].field_0 = 0
                                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                                stor159[address(arg3)][address(arg1)].field_256 = 0
                                                if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                                else:
                                                    if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                            else:
                                                if stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                    revert with 0, 
                                                                32,
                                                                39,
                                                                0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                mem[(32 * stor152.length) + 587 len 25]
                                                if block.timestamp >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                mem[(32 * stor152.length) + 586 len 26]
                                                stor159[address(arg3)][address(arg1)].field_0 = stor159[address(arg3)][address(arg1)].field_0
                                                stor159[address(arg3)][address(arg1)].field_128 = 0
                                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                                if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditMinted(0, arg1, arg3);
                                                else:
                                                    if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditBurned(0, arg1, arg3);
                                        else:
                                            if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / creditPlanOf[address(arg3)].field_0 != ext_call.return_data[0]:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * stor152.length) + 421 len 31]
                                            if stor159[address(arg3)][address(arg1)].field_0 <= ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                if stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                    revert with 0, 
                                                                32,
                                                                39,
                                                                0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                mem[(32 * stor152.length) + 587 len 25]
                                                if block.timestamp >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                mem[(32 * stor152.length) + 586 len 26]
                                                stor159[address(arg3)][address(arg1)].field_0 = stor159[address(arg3)][address(arg1)].field_0
                                                stor159[address(arg3)][address(arg1)].field_128 = 0
                                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                                if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditMinted(0, arg1, arg3);
                                                else:
                                                    if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditBurned(0, arg1, arg3);
                                            else:
                                                if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 >= 0x100000000000000000000000000000000:
                                                    revert with 0, 
                                                                32,
                                                                39,
                                                                0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                mem[(32 * stor152.length) + 587 len 25]
                                                if block.timestamp >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                mem[(32 * stor152.length) + 586 len 26]
                                                stor159[address(arg3)][address(arg1)].field_0 = uint128(ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)
                                                stor159[address(arg3)][address(arg1)].field_128 = 0
                                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                                if stor159[address(arg3)][address(arg1)].field_0 < ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditMinted(((ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18) - stor159[address(arg3)][address(arg1)].field_0), arg1, arg3);
                                                else:
                                                    if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditBurned((stor159[address(arg3)][address(arg1)].field_0 - (ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)), arg1, arg3);
                                    else:
                                        if (block.timestamp * creditPlanOf[address(arg3)].field_128) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128) / block.timestamp - stor159[address(arg3)][address(arg1)].field_192 != creditPlanOf[address(arg3)].field_128:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * stor152.length) + 357 len 31]
                                        if not (block.timestamp * creditPlanOf[address(arg3)].field_128) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128):
                                            if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not creditPlanOf[address(arg3)].field_0:
                                                if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    stor159[address(arg3)][address(arg1)].field_256 = 0
                                                    if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                                    else:
                                                        if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                                else:
                                                    if stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = stor159[address(arg3)][address(arg1)].field_0
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(0, arg1, arg3);
                                                    else:
                                                        if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned(0, arg1, arg3);
                                            else:
                                                if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / creditPlanOf[address(arg3)].field_0 != ext_call.return_data[0]:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * stor152.length) + 421 len 31]
                                                if stor159[address(arg3)][address(arg1)].field_0 <= ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                    if stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = stor159[address(arg3)][address(arg1)].field_0
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(0, arg1, arg3);
                                                    else:
                                                        if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned(0, arg1, arg3);
                                                else:
                                                    if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = uint128(ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(((ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18) - stor159[address(arg3)][address(arg1)].field_0), arg1, arg3);
                                                    else:
                                                        if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned((stor159[address(arg3)][address(arg1)].field_0 - (ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)), arg1, arg3);
                                        else:
                                            if (block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / (block.timestamp * creditPlanOf[address(arg3)].field_128) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128) != ext_call.return_data[0]:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * stor152.length) + 357 len 31]
                                            if ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not creditPlanOf[address(arg3)].field_0:
                                                if ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    stor159[address(arg3)][address(arg1)].field_256 = 0
                                                    if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                                    else:
                                                        if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                                else:
                                                    if ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = uint128(((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18), arg1, arg3);
                                                    else:
                                                        if ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned(-((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18), arg1, arg3);
                                            else:
                                                if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / creditPlanOf[address(arg3)].field_0 != ext_call.return_data[0]:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * stor152.length) + 421 len 31]
                                                if ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 <= ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                    if ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = uint128(((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18), arg1, arg3);
                                                    else:
                                                        if ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned(-((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18), arg1, arg3);
                                                else:
                                                    if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = uint128(ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(((ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18) - stor159[address(arg3)][address(arg1)].field_0), arg1, arg3);
                                                    else:
                                                        if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned((stor159[address(arg3)][address(arg1)].field_0 - (ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)), arg1, arg3);
                        else:
                            if not stor159[address(arg3)][address(arg1)].field_224:
                                if block.timestamp >= 4294967296:
                                    revert with 0, 
                                                32,
                                                38,
                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                mem[(32 * stor152.length) + 458 len 26]
                                stor159[address(arg3)][address(arg1)].field_0 = 0
                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                stor159[address(arg3)][address(arg1)].field_256 = 0
                                if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                    if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                else:
                                    if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                        if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                            else:
                                if not stor159[address(arg3)][address(arg1)].field_224:
                                    if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not creditPlanOf[address(arg3)].field_0:
                                        if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > 0:
                                            if block.timestamp >= 4294967296:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                            mem[(32 * stor152.length) + 522 len 26]
                                            stor159[address(arg3)][address(arg1)].field_0 = 0
                                            stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                            stor159[address(arg3)][address(arg1)].field_224 = 1
                                            stor159[address(arg3)][address(arg1)].field_256 = 0
                                            if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                                if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                            else:
                                                if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                        else:
                                            if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                revert with 0, 
                                                            32,
                                                            39,
                                                            0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                            mem[(32 * stor152.length) + 523 len 25]
                                            if block.timestamp >= 4294967296:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                            mem[(32 * stor152.length) + 522 len 26]
                                            stor159[address(arg3)][address(arg1)].field_0 = uint128((arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                            stor159[address(arg3)][address(arg1)].field_128 = 0
                                            stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                            stor159[address(arg3)][address(arg1)].field_224 = 1
                                            if stor159[address(arg3)][address(arg1)].field_0 < (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                if stor159[address(arg3)][address(arg1)].field_0 > (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                emit CreditMinted((arg2 * maxExitFeeMantissa / 10^18), arg1, arg3);
                                            else:
                                                if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditBurned(-(arg2 * maxExitFeeMantissa / 10^18), arg1, arg3);
                                    else:
                                        if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / creditPlanOf[address(arg3)].field_0 != ext_call.return_data[0]:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * stor152.length) + 357 len 31]
                                        if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 <= ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                            if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                revert with 0, 
                                                            32,
                                                            39,
                                                            0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                            mem[(32 * stor152.length) + 523 len 25]
                                            if block.timestamp >= 4294967296:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                            mem[(32 * stor152.length) + 522 len 26]
                                            stor159[address(arg3)][address(arg1)].field_0 = uint128((arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                            stor159[address(arg3)][address(arg1)].field_128 = 0
                                            stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                            stor159[address(arg3)][address(arg1)].field_224 = 1
                                            if stor159[address(arg3)][address(arg1)].field_0 < (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                if stor159[address(arg3)][address(arg1)].field_0 > (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                emit CreditMinted((arg2 * maxExitFeeMantissa / 10^18), arg1, arg3);
                                            else:
                                                if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditBurned(-(arg2 * maxExitFeeMantissa / 10^18), arg1, arg3);
                                        else:
                                            if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 >= 0x100000000000000000000000000000000:
                                                revert with 0, 
                                                            32,
                                                            39,
                                                            0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                            mem[(32 * stor152.length) + 523 len 25]
                                            if block.timestamp >= 4294967296:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                            mem[(32 * stor152.length) + 522 len 26]
                                            stor159[address(arg3)][address(arg1)].field_0 = uint128(ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)
                                            stor159[address(arg3)][address(arg1)].field_128 = 0
                                            stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                            stor159[address(arg3)][address(arg1)].field_224 = 1
                                            if stor159[address(arg3)][address(arg1)].field_0 < ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                if stor159[address(arg3)][address(arg1)].field_0 > ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                emit CreditMinted(((ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18) - stor159[address(arg3)][address(arg1)].field_0), arg1, arg3);
                                            else:
                                                if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditBurned((stor159[address(arg3)][address(arg1)].field_0 - (ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)), arg1, arg3);
                                else:
                                    if stor159[address(arg3)][address(arg1)].field_192 > block.timestamp:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if not block.timestamp - stor159[address(arg3)][address(arg1)].field_192:
                                        if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not creditPlanOf[address(arg3)].field_0:
                                            if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                if block.timestamp >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                mem[(32 * stor152.length) + 586 len 26]
                                                stor159[address(arg3)][address(arg1)].field_0 = 0
                                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                                stor159[address(arg3)][address(arg1)].field_256 = 0
                                                if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                                else:
                                                    if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                            else:
                                                if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                    revert with 0, 
                                                                32,
                                                                39,
                                                                0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                mem[(32 * stor152.length) + 587 len 25]
                                                if block.timestamp >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                mem[(32 * stor152.length) + 586 len 26]
                                                stor159[address(arg3)][address(arg1)].field_0 = uint128((arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                                stor159[address(arg3)][address(arg1)].field_128 = 0
                                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                                if stor159[address(arg3)][address(arg1)].field_0 < (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditMinted((arg2 * maxExitFeeMantissa / 10^18), arg1, arg3);
                                                else:
                                                    if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditBurned(-(arg2 * maxExitFeeMantissa / 10^18), arg1, arg3);
                                        else:
                                            if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / creditPlanOf[address(arg3)].field_0 != ext_call.return_data[0]:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * stor152.length) + 421 len 31]
                                            if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 <= ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                    revert with 0, 
                                                                32,
                                                                39,
                                                                0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                mem[(32 * stor152.length) + 587 len 25]
                                                if block.timestamp >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                mem[(32 * stor152.length) + 586 len 26]
                                                stor159[address(arg3)][address(arg1)].field_0 = uint128((arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                                stor159[address(arg3)][address(arg1)].field_128 = 0
                                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                                if stor159[address(arg3)][address(arg1)].field_0 < (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditMinted((arg2 * maxExitFeeMantissa / 10^18), arg1, arg3);
                                                else:
                                                    if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditBurned(-(arg2 * maxExitFeeMantissa / 10^18), arg1, arg3);
                                            else:
                                                if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 >= 0x100000000000000000000000000000000:
                                                    revert with 0, 
                                                                32,
                                                                39,
                                                                0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                mem[(32 * stor152.length) + 587 len 25]
                                                if block.timestamp >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                mem[(32 * stor152.length) + 586 len 26]
                                                stor159[address(arg3)][address(arg1)].field_0 = uint128(ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)
                                                stor159[address(arg3)][address(arg1)].field_128 = 0
                                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                                if stor159[address(arg3)][address(arg1)].field_0 < ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditMinted(((ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18) - stor159[address(arg3)][address(arg1)].field_0), arg1, arg3);
                                                else:
                                                    if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditBurned((stor159[address(arg3)][address(arg1)].field_0 - (ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)), arg1, arg3);
                                    else:
                                        if (block.timestamp * creditPlanOf[address(arg3)].field_128) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128) / block.timestamp - stor159[address(arg3)][address(arg1)].field_192 != creditPlanOf[address(arg3)].field_128:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * stor152.length) + 357 len 31]
                                        if not (block.timestamp * creditPlanOf[address(arg3)].field_128) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128):
                                            if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not creditPlanOf[address(arg3)].field_0:
                                                if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    stor159[address(arg3)][address(arg1)].field_256 = 0
                                                    if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                                    else:
                                                        if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                                else:
                                                    if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = uint128((arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted((arg2 * maxExitFeeMantissa / 10^18), arg1, arg3);
                                                    else:
                                                        if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned(-(arg2 * maxExitFeeMantissa / 10^18), arg1, arg3);
                                            else:
                                                if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / creditPlanOf[address(arg3)].field_0 != ext_call.return_data[0]:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * stor152.length) + 421 len 31]
                                                if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 <= ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                    if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = uint128((arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted((arg2 * maxExitFeeMantissa / 10^18), arg1, arg3);
                                                    else:
                                                        if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned(-(arg2 * maxExitFeeMantissa / 10^18), arg1, arg3);
                                                else:
                                                    if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = uint128(ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(((ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18) - stor159[address(arg3)][address(arg1)].field_0), arg1, arg3);
                                                    else:
                                                        if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned((stor159[address(arg3)][address(arg1)].field_0 - (ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)), arg1, arg3);
                                        else:
                                            if (block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / (block.timestamp * creditPlanOf[address(arg3)].field_128) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128) != ext_call.return_data[0]:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * stor152.length) + 357 len 31]
                                            if ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if arg2 * maxExitFeeMantissa / 10^18 < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not creditPlanOf[address(arg3)].field_0:
                                                if (arg2 * maxExitFeeMantissa / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    stor159[address(arg3)][address(arg1)].field_256 = 0
                                                    if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                                    else:
                                                        if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                                else:
                                                    if (arg2 * maxExitFeeMantissa / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = uint128((arg2 * maxExitFeeMantissa / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < (arg2 * maxExitFeeMantissa / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > (arg2 * maxExitFeeMantissa / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(((arg2 * maxExitFeeMantissa / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18)), arg1, arg3);
                                                    else:
                                                        if (arg2 * maxExitFeeMantissa / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if (arg2 * maxExitFeeMantissa / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned((-(arg2 * maxExitFeeMantissa / 10^18) - ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18)), arg1, arg3);
                                            else:
                                                if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / creditPlanOf[address(arg3)].field_0 != ext_call.return_data[0]:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * stor152.length) + 421 len 31]
                                                if (arg2 * maxExitFeeMantissa / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 <= ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                    if (arg2 * maxExitFeeMantissa / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = uint128((arg2 * maxExitFeeMantissa / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < (arg2 * maxExitFeeMantissa / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > (arg2 * maxExitFeeMantissa / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(((arg2 * maxExitFeeMantissa / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18)), arg1, arg3);
                                                    else:
                                                        if (arg2 * maxExitFeeMantissa / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if (arg2 * maxExitFeeMantissa / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned((-(arg2 * maxExitFeeMantissa / 10^18) - ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18)), arg1, arg3);
                                                else:
                                                    if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = uint128(ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(((ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18) - stor159[address(arg3)][address(arg1)].field_0), arg1, arg3);
                                                    else:
                                                        if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned((stor159[address(arg3)][address(arg1)].field_0 - (ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)), arg1, arg3);
                else:
                    if arg2 * creditPlanOf[address(arg3)].field_0 / creditPlanOf[address(arg3)].field_0 != arg2:
                        revert with 0, 
                                    32,
                                    33,
                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[(32 * stor152.length) + 229 len 31]
                    if not maxExitFeeMantissa:
                        require ext_code.size(arg3)
                        staticcall arg3.0x70a08231 with:
                                gas gas_remaining wei
                               args arg1
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if arg2 * creditPlanOf[address(arg3)].field_0 / 10^18 > 0:
                            if not stor159[address(arg3)][address(arg1)].field_224:
                                if block.timestamp >= 4294967296:
                                    revert with 0, 
                                                32,
                                                38,
                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                mem[(32 * stor152.length) + 458 len 26]
                                stor159[address(arg3)][address(arg1)].field_0 = 0
                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                stor159[address(arg3)][address(arg1)].field_256 = 0
                                if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                    if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                else:
                                    if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                        if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                            else:
                                if not stor159[address(arg3)][address(arg1)].field_224:
                                    if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not creditPlanOf[address(arg3)].field_0:
                                        if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                            if block.timestamp >= 4294967296:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                            mem[(32 * stor152.length) + 522 len 26]
                                            stor159[address(arg3)][address(arg1)].field_0 = 0
                                            stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                            stor159[address(arg3)][address(arg1)].field_224 = 1
                                            stor159[address(arg3)][address(arg1)].field_256 = 0
                                            if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                                if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                            else:
                                                if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                        else:
                                            if stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                revert with 0, 
                                                            32,
                                                            39,
                                                            0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                            mem[(32 * stor152.length) + 523 len 25]
                                            if block.timestamp >= 4294967296:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                            mem[(32 * stor152.length) + 522 len 26]
                                            stor159[address(arg3)][address(arg1)].field_0 = stor159[address(arg3)][address(arg1)].field_0
                                            stor159[address(arg3)][address(arg1)].field_128 = 0
                                            stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                            stor159[address(arg3)][address(arg1)].field_224 = 1
                                            if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                emit CreditMinted(0, arg1, arg3);
                                            else:
                                                if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditBurned(0, arg1, arg3);
                                    else:
                                        if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / creditPlanOf[address(arg3)].field_0 != ext_call.return_data[0]:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * stor152.length) + 357 len 31]
                                        if stor159[address(arg3)][address(arg1)].field_0 <= ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                            if stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                revert with 0, 
                                                            32,
                                                            39,
                                                            0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                            mem[(32 * stor152.length) + 523 len 25]
                                            if block.timestamp >= 4294967296:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                            mem[(32 * stor152.length) + 522 len 26]
                                            stor159[address(arg3)][address(arg1)].field_0 = stor159[address(arg3)][address(arg1)].field_0
                                            stor159[address(arg3)][address(arg1)].field_128 = 0
                                            stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                            stor159[address(arg3)][address(arg1)].field_224 = 1
                                            if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                emit CreditMinted(0, arg1, arg3);
                                            else:
                                                if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditBurned(0, arg1, arg3);
                                        else:
                                            if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 >= 0x100000000000000000000000000000000:
                                                revert with 0, 
                                                            32,
                                                            39,
                                                            0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                            mem[(32 * stor152.length) + 523 len 25]
                                            if block.timestamp >= 4294967296:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                            mem[(32 * stor152.length) + 522 len 26]
                                            stor159[address(arg3)][address(arg1)].field_0 = uint128(ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)
                                            stor159[address(arg3)][address(arg1)].field_128 = 0
                                            stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                            stor159[address(arg3)][address(arg1)].field_224 = 1
                                            if stor159[address(arg3)][address(arg1)].field_0 < ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                if stor159[address(arg3)][address(arg1)].field_0 > ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                emit CreditMinted(((ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18) - stor159[address(arg3)][address(arg1)].field_0), arg1, arg3);
                                            else:
                                                if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditBurned((stor159[address(arg3)][address(arg1)].field_0 - (ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)), arg1, arg3);
                                else:
                                    if stor159[address(arg3)][address(arg1)].field_192 > block.timestamp:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if not block.timestamp - stor159[address(arg3)][address(arg1)].field_192:
                                        if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not creditPlanOf[address(arg3)].field_0:
                                            if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                if block.timestamp >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                mem[(32 * stor152.length) + 586 len 26]
                                                stor159[address(arg3)][address(arg1)].field_0 = 0
                                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                                stor159[address(arg3)][address(arg1)].field_256 = 0
                                                if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                                else:
                                                    if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                            else:
                                                if stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                    revert with 0, 
                                                                32,
                                                                39,
                                                                0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                mem[(32 * stor152.length) + 587 len 25]
                                                if block.timestamp >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                mem[(32 * stor152.length) + 586 len 26]
                                                stor159[address(arg3)][address(arg1)].field_0 = stor159[address(arg3)][address(arg1)].field_0
                                                stor159[address(arg3)][address(arg1)].field_128 = 0
                                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                                if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditMinted(0, arg1, arg3);
                                                else:
                                                    if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditBurned(0, arg1, arg3);
                                        else:
                                            if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / creditPlanOf[address(arg3)].field_0 != ext_call.return_data[0]:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * stor152.length) + 421 len 31]
                                            if stor159[address(arg3)][address(arg1)].field_0 <= ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                if stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                    revert with 0, 
                                                                32,
                                                                39,
                                                                0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                mem[(32 * stor152.length) + 587 len 25]
                                                if block.timestamp >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                mem[(32 * stor152.length) + 586 len 26]
                                                stor159[address(arg3)][address(arg1)].field_0 = stor159[address(arg3)][address(arg1)].field_0
                                                stor159[address(arg3)][address(arg1)].field_128 = 0
                                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                                if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditMinted(0, arg1, arg3);
                                                else:
                                                    if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditBurned(0, arg1, arg3);
                                            else:
                                                if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 >= 0x100000000000000000000000000000000:
                                                    revert with 0, 
                                                                32,
                                                                39,
                                                                0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                mem[(32 * stor152.length) + 587 len 25]
                                                if block.timestamp >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                mem[(32 * stor152.length) + 586 len 26]
                                                stor159[address(arg3)][address(arg1)].field_0 = uint128(ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)
                                                stor159[address(arg3)][address(arg1)].field_128 = 0
                                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                                if stor159[address(arg3)][address(arg1)].field_0 < ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditMinted(((ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18) - stor159[address(arg3)][address(arg1)].field_0), arg1, arg3);
                                                else:
                                                    if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditBurned((stor159[address(arg3)][address(arg1)].field_0 - (ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)), arg1, arg3);
                                    else:
                                        if (block.timestamp * creditPlanOf[address(arg3)].field_128) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128) / block.timestamp - stor159[address(arg3)][address(arg1)].field_192 != creditPlanOf[address(arg3)].field_128:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * stor152.length) + 357 len 31]
                                        if not (block.timestamp * creditPlanOf[address(arg3)].field_128) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128):
                                            if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not creditPlanOf[address(arg3)].field_0:
                                                if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    stor159[address(arg3)][address(arg1)].field_256 = 0
                                                    if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                                    else:
                                                        if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                                else:
                                                    if stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = stor159[address(arg3)][address(arg1)].field_0
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(0, arg1, arg3);
                                                    else:
                                                        if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned(0, arg1, arg3);
                                            else:
                                                if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / creditPlanOf[address(arg3)].field_0 != ext_call.return_data[0]:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * stor152.length) + 421 len 31]
                                                if stor159[address(arg3)][address(arg1)].field_0 <= ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                    if stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = stor159[address(arg3)][address(arg1)].field_0
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(0, arg1, arg3);
                                                    else:
                                                        if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned(0, arg1, arg3);
                                                else:
                                                    if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = uint128(ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(((ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18) - stor159[address(arg3)][address(arg1)].field_0), arg1, arg3);
                                                    else:
                                                        if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned((stor159[address(arg3)][address(arg1)].field_0 - (ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)), arg1, arg3);
                                        else:
                                            if (block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / (block.timestamp * creditPlanOf[address(arg3)].field_128) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128) != ext_call.return_data[0]:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * stor152.length) + 357 len 31]
                                            if ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not creditPlanOf[address(arg3)].field_0:
                                                if ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    stor159[address(arg3)][address(arg1)].field_256 = 0
                                                    if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                                    else:
                                                        if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                                else:
                                                    if ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = uint128(((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18), arg1, arg3);
                                                    else:
                                                        if ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned(-((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18), arg1, arg3);
                                            else:
                                                if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / creditPlanOf[address(arg3)].field_0 != ext_call.return_data[0]:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * stor152.length) + 421 len 31]
                                                if ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 <= ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                    if ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = uint128(((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18), arg1, arg3);
                                                    else:
                                                        if ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned(-((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18), arg1, arg3);
                                                else:
                                                    if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = uint128(ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(((ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18) - stor159[address(arg3)][address(arg1)].field_0), arg1, arg3);
                                                    else:
                                                        if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned((stor159[address(arg3)][address(arg1)].field_0 - (ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)), arg1, arg3);
                        else:
                            if not stor159[address(arg3)][address(arg1)].field_224:
                                if block.timestamp >= 4294967296:
                                    revert with 0, 
                                                32,
                                                38,
                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                mem[(32 * stor152.length) + 458 len 26]
                                stor159[address(arg3)][address(arg1)].field_0 = 0
                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                stor159[address(arg3)][address(arg1)].field_256 = 0
                                if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                    if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                else:
                                    if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                        if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                            else:
                                if not stor159[address(arg3)][address(arg1)].field_224:
                                    if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not creditPlanOf[address(arg3)].field_0:
                                        if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > 0:
                                            if block.timestamp >= 4294967296:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                            mem[(32 * stor152.length) + 522 len 26]
                                            stor159[address(arg3)][address(arg1)].field_0 = 0
                                            stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                            stor159[address(arg3)][address(arg1)].field_224 = 1
                                            stor159[address(arg3)][address(arg1)].field_256 = 0
                                            if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                                if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                            else:
                                                if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                        else:
                                            if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                revert with 0, 
                                                            32,
                                                            39,
                                                            0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                            mem[(32 * stor152.length) + 523 len 25]
                                            if block.timestamp >= 4294967296:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                            mem[(32 * stor152.length) + 522 len 26]
                                            stor159[address(arg3)][address(arg1)].field_0 = uint128((arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                            stor159[address(arg3)][address(arg1)].field_128 = 0
                                            stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                            stor159[address(arg3)][address(arg1)].field_224 = 1
                                            if stor159[address(arg3)][address(arg1)].field_0 < (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                if stor159[address(arg3)][address(arg1)].field_0 > (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                emit CreditMinted((arg2 * creditPlanOf[address(arg3)].field_0 / 10^18), arg1, arg3);
                                            else:
                                                if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditBurned(-(arg2 * creditPlanOf[address(arg3)].field_0 / 10^18), arg1, arg3);
                                    else:
                                        if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / creditPlanOf[address(arg3)].field_0 != ext_call.return_data[0]:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * stor152.length) + 357 len 31]
                                        if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 <= ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                            if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                revert with 0, 
                                                            32,
                                                            39,
                                                            0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                            mem[(32 * stor152.length) + 523 len 25]
                                            if block.timestamp >= 4294967296:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                            mem[(32 * stor152.length) + 522 len 26]
                                            stor159[address(arg3)][address(arg1)].field_0 = uint128((arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                            stor159[address(arg3)][address(arg1)].field_128 = 0
                                            stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                            stor159[address(arg3)][address(arg1)].field_224 = 1
                                            if stor159[address(arg3)][address(arg1)].field_0 < (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                if stor159[address(arg3)][address(arg1)].field_0 > (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                emit CreditMinted((arg2 * creditPlanOf[address(arg3)].field_0 / 10^18), arg1, arg3);
                                            else:
                                                if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditBurned(-(arg2 * creditPlanOf[address(arg3)].field_0 / 10^18), arg1, arg3);
                                        else:
                                            if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 >= 0x100000000000000000000000000000000:
                                                revert with 0, 
                                                            32,
                                                            39,
                                                            0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                            mem[(32 * stor152.length) + 523 len 25]
                                            if block.timestamp >= 4294967296:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                            mem[(32 * stor152.length) + 522 len 26]
                                            stor159[address(arg3)][address(arg1)].field_0 = uint128(ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)
                                            stor159[address(arg3)][address(arg1)].field_128 = 0
                                            stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                            stor159[address(arg3)][address(arg1)].field_224 = 1
                                            if stor159[address(arg3)][address(arg1)].field_0 < ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                if stor159[address(arg3)][address(arg1)].field_0 > ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                emit CreditMinted(((ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18) - stor159[address(arg3)][address(arg1)].field_0), arg1, arg3);
                                            else:
                                                if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditBurned((stor159[address(arg3)][address(arg1)].field_0 - (ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)), arg1, arg3);
                                else:
                                    if stor159[address(arg3)][address(arg1)].field_192 > block.timestamp:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if not block.timestamp - stor159[address(arg3)][address(arg1)].field_192:
                                        if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not creditPlanOf[address(arg3)].field_0:
                                            if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                if block.timestamp >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                mem[(32 * stor152.length) + 586 len 26]
                                                stor159[address(arg3)][address(arg1)].field_0 = 0
                                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                                stor159[address(arg3)][address(arg1)].field_256 = 0
                                                if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                                else:
                                                    if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                            else:
                                                if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                    revert with 0, 
                                                                32,
                                                                39,
                                                                0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                mem[(32 * stor152.length) + 587 len 25]
                                                if block.timestamp >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                mem[(32 * stor152.length) + 586 len 26]
                                                stor159[address(arg3)][address(arg1)].field_0 = uint128((arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                                stor159[address(arg3)][address(arg1)].field_128 = 0
                                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                                if stor159[address(arg3)][address(arg1)].field_0 < (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditMinted((arg2 * creditPlanOf[address(arg3)].field_0 / 10^18), arg1, arg3);
                                                else:
                                                    if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditBurned(-(arg2 * creditPlanOf[address(arg3)].field_0 / 10^18), arg1, arg3);
                                        else:
                                            if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / creditPlanOf[address(arg3)].field_0 != ext_call.return_data[0]:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * stor152.length) + 421 len 31]
                                            if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 <= ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                    revert with 0, 
                                                                32,
                                                                39,
                                                                0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                mem[(32 * stor152.length) + 587 len 25]
                                                if block.timestamp >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                mem[(32 * stor152.length) + 586 len 26]
                                                stor159[address(arg3)][address(arg1)].field_0 = uint128((arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                                stor159[address(arg3)][address(arg1)].field_128 = 0
                                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                                if stor159[address(arg3)][address(arg1)].field_0 < (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditMinted((arg2 * creditPlanOf[address(arg3)].field_0 / 10^18), arg1, arg3);
                                                else:
                                                    if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditBurned(-(arg2 * creditPlanOf[address(arg3)].field_0 / 10^18), arg1, arg3);
                                            else:
                                                if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 >= 0x100000000000000000000000000000000:
                                                    revert with 0, 
                                                                32,
                                                                39,
                                                                0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                mem[(32 * stor152.length) + 587 len 25]
                                                if block.timestamp >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                mem[(32 * stor152.length) + 586 len 26]
                                                stor159[address(arg3)][address(arg1)].field_0 = uint128(ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)
                                                stor159[address(arg3)][address(arg1)].field_128 = 0
                                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                                if stor159[address(arg3)][address(arg1)].field_0 < ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditMinted(((ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18) - stor159[address(arg3)][address(arg1)].field_0), arg1, arg3);
                                                else:
                                                    if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditBurned((stor159[address(arg3)][address(arg1)].field_0 - (ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)), arg1, arg3);
                                    else:
                                        if (block.timestamp * creditPlanOf[address(arg3)].field_128) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128) / block.timestamp - stor159[address(arg3)][address(arg1)].field_192 != creditPlanOf[address(arg3)].field_128:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * stor152.length) + 357 len 31]
                                        if not (block.timestamp * creditPlanOf[address(arg3)].field_128) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128):
                                            if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not creditPlanOf[address(arg3)].field_0:
                                                if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    stor159[address(arg3)][address(arg1)].field_256 = 0
                                                    if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                                    else:
                                                        if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                                else:
                                                    if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = uint128((arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted((arg2 * creditPlanOf[address(arg3)].field_0 / 10^18), arg1, arg3);
                                                    else:
                                                        if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned(-(arg2 * creditPlanOf[address(arg3)].field_0 / 10^18), arg1, arg3);
                                            else:
                                                if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / creditPlanOf[address(arg3)].field_0 != ext_call.return_data[0]:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * stor152.length) + 421 len 31]
                                                if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 <= ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                    if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = uint128((arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted((arg2 * creditPlanOf[address(arg3)].field_0 / 10^18), arg1, arg3);
                                                    else:
                                                        if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned(-(arg2 * creditPlanOf[address(arg3)].field_0 / 10^18), arg1, arg3);
                                                else:
                                                    if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = uint128(ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(((ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18) - stor159[address(arg3)][address(arg1)].field_0), arg1, arg3);
                                                    else:
                                                        if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned((stor159[address(arg3)][address(arg1)].field_0 - (ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)), arg1, arg3);
                                        else:
                                            if (block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / (block.timestamp * creditPlanOf[address(arg3)].field_128) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128) != ext_call.return_data[0]:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * stor152.length) + 357 len 31]
                                            if ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if arg2 * creditPlanOf[address(arg3)].field_0 / 10^18 < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not creditPlanOf[address(arg3)].field_0:
                                                if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    stor159[address(arg3)][address(arg1)].field_256 = 0
                                                    if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                                    else:
                                                        if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                                else:
                                                    if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = uint128((arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(((arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18)), arg1, arg3);
                                                    else:
                                                        if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned((-(arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) - ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18)), arg1, arg3);
                                            else:
                                                if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / creditPlanOf[address(arg3)].field_0 != ext_call.return_data[0]:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * stor152.length) + 421 len 31]
                                                if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 <= ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                    if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = uint128((arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(((arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18)), arg1, arg3);
                                                    else:
                                                        if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned((-(arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) - ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18)), arg1, arg3);
                                                else:
                                                    if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = uint128(ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(((ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18) - stor159[address(arg3)][address(arg1)].field_0), arg1, arg3);
                                                    else:
                                                        if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned((stor159[address(arg3)][address(arg1)].field_0 - (ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)), arg1, arg3);
                    else:
                        if arg2 * maxExitFeeMantissa / maxExitFeeMantissa != arg2:
                            revert with 0, 
                                        32,
                                        33,
                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[(32 * stor152.length) + 293 len 31]
                        require ext_code.size(arg3)
                        staticcall arg3.0x70a08231 with:
                                gas gas_remaining wei
                               args arg1
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if arg2 * creditPlanOf[address(arg3)].field_0 / 10^18 <= arg2 * maxExitFeeMantissa / 10^18:
                            if not stor159[address(arg3)][address(arg1)].field_224:
                                if block.timestamp >= 4294967296:
                                    revert with 0, 
                                                32,
                                                38,
                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                mem[(32 * stor152.length) + 458 len 26]
                                stor159[address(arg3)][address(arg1)].field_0 = 0
                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                stor159[address(arg3)][address(arg1)].field_256 = 0
                                if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                    if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                else:
                                    if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                        if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                            else:
                                if not stor159[address(arg3)][address(arg1)].field_224:
                                    if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not creditPlanOf[address(arg3)].field_0:
                                        if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > 0:
                                            if block.timestamp >= 4294967296:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                            mem[(32 * stor152.length) + 522 len 26]
                                            stor159[address(arg3)][address(arg1)].field_0 = 0
                                            stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                            stor159[address(arg3)][address(arg1)].field_224 = 1
                                            stor159[address(arg3)][address(arg1)].field_256 = 0
                                            if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                                if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                            else:
                                                if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                        else:
                                            if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                revert with 0, 
                                                            32,
                                                            39,
                                                            0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                            mem[(32 * stor152.length) + 523 len 25]
                                            if block.timestamp >= 4294967296:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                            mem[(32 * stor152.length) + 522 len 26]
                                            stor159[address(arg3)][address(arg1)].field_0 = uint128((arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                            stor159[address(arg3)][address(arg1)].field_128 = 0
                                            stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                            stor159[address(arg3)][address(arg1)].field_224 = 1
                                            if stor159[address(arg3)][address(arg1)].field_0 < (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                if stor159[address(arg3)][address(arg1)].field_0 > (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                emit CreditMinted((arg2 * creditPlanOf[address(arg3)].field_0 / 10^18), arg1, arg3);
                                            else:
                                                if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditBurned(-(arg2 * creditPlanOf[address(arg3)].field_0 / 10^18), arg1, arg3);
                                    else:
                                        if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / creditPlanOf[address(arg3)].field_0 != ext_call.return_data[0]:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * stor152.length) + 357 len 31]
                                        if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 <= ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                            if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                revert with 0, 
                                                            32,
                                                            39,
                                                            0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                            mem[(32 * stor152.length) + 523 len 25]
                                            if block.timestamp >= 4294967296:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                            mem[(32 * stor152.length) + 522 len 26]
                                            stor159[address(arg3)][address(arg1)].field_0 = uint128((arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                            stor159[address(arg3)][address(arg1)].field_128 = 0
                                            stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                            stor159[address(arg3)][address(arg1)].field_224 = 1
                                            if stor159[address(arg3)][address(arg1)].field_0 < (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                if stor159[address(arg3)][address(arg1)].field_0 > (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                emit CreditMinted((arg2 * creditPlanOf[address(arg3)].field_0 / 10^18), arg1, arg3);
                                            else:
                                                if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditBurned(-(arg2 * creditPlanOf[address(arg3)].field_0 / 10^18), arg1, arg3);
                                        else:
                                            if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 >= 0x100000000000000000000000000000000:
                                                revert with 0, 
                                                            32,
                                                            39,
                                                            0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                            mem[(32 * stor152.length) + 523 len 25]
                                            if block.timestamp >= 4294967296:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                            mem[(32 * stor152.length) + 522 len 26]
                                            stor159[address(arg3)][address(arg1)].field_0 = uint128(ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)
                                            stor159[address(arg3)][address(arg1)].field_128 = 0
                                            stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                            stor159[address(arg3)][address(arg1)].field_224 = 1
                                            if stor159[address(arg3)][address(arg1)].field_0 < ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                if stor159[address(arg3)][address(arg1)].field_0 > ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                emit CreditMinted(((ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18) - stor159[address(arg3)][address(arg1)].field_0), arg1, arg3);
                                            else:
                                                if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditBurned((stor159[address(arg3)][address(arg1)].field_0 - (ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)), arg1, arg3);
                                else:
                                    if stor159[address(arg3)][address(arg1)].field_192 > block.timestamp:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if not block.timestamp - stor159[address(arg3)][address(arg1)].field_192:
                                        if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not creditPlanOf[address(arg3)].field_0:
                                            if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                if block.timestamp >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                mem[(32 * stor152.length) + 586 len 26]
                                                stor159[address(arg3)][address(arg1)].field_0 = 0
                                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                                stor159[address(arg3)][address(arg1)].field_256 = 0
                                                if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                                else:
                                                    if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                            else:
                                                if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                    revert with 0, 
                                                                32,
                                                                39,
                                                                0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                mem[(32 * stor152.length) + 587 len 25]
                                                if block.timestamp >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                mem[(32 * stor152.length) + 586 len 26]
                                                stor159[address(arg3)][address(arg1)].field_0 = uint128((arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                                stor159[address(arg3)][address(arg1)].field_128 = 0
                                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                                if stor159[address(arg3)][address(arg1)].field_0 < (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditMinted((arg2 * creditPlanOf[address(arg3)].field_0 / 10^18), arg1, arg3);
                                                else:
                                                    if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditBurned(-(arg2 * creditPlanOf[address(arg3)].field_0 / 10^18), arg1, arg3);
                                        else:
                                            if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / creditPlanOf[address(arg3)].field_0 != ext_call.return_data[0]:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * stor152.length) + 421 len 31]
                                            if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 <= ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                    revert with 0, 
                                                                32,
                                                                39,
                                                                0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                mem[(32 * stor152.length) + 587 len 25]
                                                if block.timestamp >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                mem[(32 * stor152.length) + 586 len 26]
                                                stor159[address(arg3)][address(arg1)].field_0 = uint128((arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                                stor159[address(arg3)][address(arg1)].field_128 = 0
                                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                                if stor159[address(arg3)][address(arg1)].field_0 < (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditMinted((arg2 * creditPlanOf[address(arg3)].field_0 / 10^18), arg1, arg3);
                                                else:
                                                    if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditBurned(-(arg2 * creditPlanOf[address(arg3)].field_0 / 10^18), arg1, arg3);
                                            else:
                                                if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 >= 0x100000000000000000000000000000000:
                                                    revert with 0, 
                                                                32,
                                                                39,
                                                                0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                mem[(32 * stor152.length) + 587 len 25]
                                                if block.timestamp >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                mem[(32 * stor152.length) + 586 len 26]
                                                stor159[address(arg3)][address(arg1)].field_0 = uint128(ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)
                                                stor159[address(arg3)][address(arg1)].field_128 = 0
                                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                                if stor159[address(arg3)][address(arg1)].field_0 < ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditMinted(((ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18) - stor159[address(arg3)][address(arg1)].field_0), arg1, arg3);
                                                else:
                                                    if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditBurned((stor159[address(arg3)][address(arg1)].field_0 - (ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)), arg1, arg3);
                                    else:
                                        if (block.timestamp * creditPlanOf[address(arg3)].field_128) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128) / block.timestamp - stor159[address(arg3)][address(arg1)].field_192 != creditPlanOf[address(arg3)].field_128:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * stor152.length) + 357 len 31]
                                        if not (block.timestamp * creditPlanOf[address(arg3)].field_128) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128):
                                            if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not creditPlanOf[address(arg3)].field_0:
                                                if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    stor159[address(arg3)][address(arg1)].field_256 = 0
                                                    if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                                    else:
                                                        if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                                else:
                                                    if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = uint128((arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted((arg2 * creditPlanOf[address(arg3)].field_0 / 10^18), arg1, arg3);
                                                    else:
                                                        if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned(-(arg2 * creditPlanOf[address(arg3)].field_0 / 10^18), arg1, arg3);
                                            else:
                                                if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / creditPlanOf[address(arg3)].field_0 != ext_call.return_data[0]:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * stor152.length) + 421 len 31]
                                                if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 <= ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                    if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = uint128((arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted((arg2 * creditPlanOf[address(arg3)].field_0 / 10^18), arg1, arg3);
                                                    else:
                                                        if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned(-(arg2 * creditPlanOf[address(arg3)].field_0 / 10^18), arg1, arg3);
                                                else:
                                                    if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = uint128(ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(((ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18) - stor159[address(arg3)][address(arg1)].field_0), arg1, arg3);
                                                    else:
                                                        if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned((stor159[address(arg3)][address(arg1)].field_0 - (ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)), arg1, arg3);
                                        else:
                                            if (block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / (block.timestamp * creditPlanOf[address(arg3)].field_128) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128) != ext_call.return_data[0]:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * stor152.length) + 357 len 31]
                                            if ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if arg2 * creditPlanOf[address(arg3)].field_0 / 10^18 < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not creditPlanOf[address(arg3)].field_0:
                                                if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    stor159[address(arg3)][address(arg1)].field_256 = 0
                                                    if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                                    else:
                                                        if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                                else:
                                                    if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = uint128((arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(((arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18)), arg1, arg3);
                                                    else:
                                                        if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned((-(arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) - ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18)), arg1, arg3);
                                            else:
                                                if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / creditPlanOf[address(arg3)].field_0 != ext_call.return_data[0]:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * stor152.length) + 421 len 31]
                                                if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 <= ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                    if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = uint128((arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(((arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18)), arg1, arg3);
                                                    else:
                                                        if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned((-(arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) - ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18)), arg1, arg3);
                                                else:
                                                    if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = uint128(ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(((ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18) - stor159[address(arg3)][address(arg1)].field_0), arg1, arg3);
                                                    else:
                                                        if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned((stor159[address(arg3)][address(arg1)].field_0 - (ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)), arg1, arg3);
                        else:
                            if not stor159[address(arg3)][address(arg1)].field_224:
                                if block.timestamp >= 4294967296:
                                    revert with 0, 
                                                32,
                                                38,
                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                mem[(32 * stor152.length) + 458 len 26]
                                stor159[address(arg3)][address(arg1)].field_0 = 0
                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                stor159[address(arg3)][address(arg1)].field_256 = 0
                                if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                    if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                else:
                                    if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                        if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                            else:
                                if not stor159[address(arg3)][address(arg1)].field_224:
                                    if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not creditPlanOf[address(arg3)].field_0:
                                        if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > 0:
                                            if block.timestamp >= 4294967296:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                            mem[(32 * stor152.length) + 522 len 26]
                                            stor159[address(arg3)][address(arg1)].field_0 = 0
                                            stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                            stor159[address(arg3)][address(arg1)].field_224 = 1
                                            stor159[address(arg3)][address(arg1)].field_256 = 0
                                            if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                                if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                            else:
                                                if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                        else:
                                            if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                revert with 0, 
                                                            32,
                                                            39,
                                                            0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                            mem[(32 * stor152.length) + 523 len 25]
                                            if block.timestamp >= 4294967296:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                            mem[(32 * stor152.length) + 522 len 26]
                                            stor159[address(arg3)][address(arg1)].field_0 = uint128((arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                            stor159[address(arg3)][address(arg1)].field_128 = 0
                                            stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                            stor159[address(arg3)][address(arg1)].field_224 = 1
                                            if stor159[address(arg3)][address(arg1)].field_0 < (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                if stor159[address(arg3)][address(arg1)].field_0 > (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                emit CreditMinted((arg2 * maxExitFeeMantissa / 10^18), arg1, arg3);
                                            else:
                                                if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditBurned(-(arg2 * maxExitFeeMantissa / 10^18), arg1, arg3);
                                    else:
                                        if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / creditPlanOf[address(arg3)].field_0 != ext_call.return_data[0]:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * stor152.length) + 357 len 31]
                                        if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 <= ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                            if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                revert with 0, 
                                                            32,
                                                            39,
                                                            0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                            mem[(32 * stor152.length) + 523 len 25]
                                            if block.timestamp >= 4294967296:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                            mem[(32 * stor152.length) + 522 len 26]
                                            stor159[address(arg3)][address(arg1)].field_0 = uint128((arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                            stor159[address(arg3)][address(arg1)].field_128 = 0
                                            stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                            stor159[address(arg3)][address(arg1)].field_224 = 1
                                            if stor159[address(arg3)][address(arg1)].field_0 < (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                if stor159[address(arg3)][address(arg1)].field_0 > (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                emit CreditMinted((arg2 * maxExitFeeMantissa / 10^18), arg1, arg3);
                                            else:
                                                if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditBurned(-(arg2 * maxExitFeeMantissa / 10^18), arg1, arg3);
                                        else:
                                            if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 >= 0x100000000000000000000000000000000:
                                                revert with 0, 
                                                            32,
                                                            39,
                                                            0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                            mem[(32 * stor152.length) + 523 len 25]
                                            if block.timestamp >= 4294967296:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                            mem[(32 * stor152.length) + 522 len 26]
                                            stor159[address(arg3)][address(arg1)].field_0 = uint128(ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)
                                            stor159[address(arg3)][address(arg1)].field_128 = 0
                                            stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                            stor159[address(arg3)][address(arg1)].field_224 = 1
                                            if stor159[address(arg3)][address(arg1)].field_0 < ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                if stor159[address(arg3)][address(arg1)].field_0 > ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                emit CreditMinted(((ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18) - stor159[address(arg3)][address(arg1)].field_0), arg1, arg3);
                                            else:
                                                if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditBurned((stor159[address(arg3)][address(arg1)].field_0 - (ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)), arg1, arg3);
                                else:
                                    if stor159[address(arg3)][address(arg1)].field_192 > block.timestamp:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if not block.timestamp - stor159[address(arg3)][address(arg1)].field_192:
                                        if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not creditPlanOf[address(arg3)].field_0:
                                            if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                if block.timestamp >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                mem[(32 * stor152.length) + 586 len 26]
                                                stor159[address(arg3)][address(arg1)].field_0 = 0
                                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                                stor159[address(arg3)][address(arg1)].field_256 = 0
                                                if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                                else:
                                                    if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                            else:
                                                if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                    revert with 0, 
                                                                32,
                                                                39,
                                                                0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                mem[(32 * stor152.length) + 587 len 25]
                                                if block.timestamp >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                mem[(32 * stor152.length) + 586 len 26]
                                                stor159[address(arg3)][address(arg1)].field_0 = uint128((arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                                stor159[address(arg3)][address(arg1)].field_128 = 0
                                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                                if stor159[address(arg3)][address(arg1)].field_0 < (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditMinted((arg2 * maxExitFeeMantissa / 10^18), arg1, arg3);
                                                else:
                                                    if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditBurned(-(arg2 * maxExitFeeMantissa / 10^18), arg1, arg3);
                                        else:
                                            if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / creditPlanOf[address(arg3)].field_0 != ext_call.return_data[0]:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * stor152.length) + 421 len 31]
                                            if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 <= ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                    revert with 0, 
                                                                32,
                                                                39,
                                                                0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                mem[(32 * stor152.length) + 587 len 25]
                                                if block.timestamp >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                mem[(32 * stor152.length) + 586 len 26]
                                                stor159[address(arg3)][address(arg1)].field_0 = uint128((arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                                stor159[address(arg3)][address(arg1)].field_128 = 0
                                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                                if stor159[address(arg3)][address(arg1)].field_0 < (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditMinted((arg2 * maxExitFeeMantissa / 10^18), arg1, arg3);
                                                else:
                                                    if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditBurned(-(arg2 * maxExitFeeMantissa / 10^18), arg1, arg3);
                                            else:
                                                if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 >= 0x100000000000000000000000000000000:
                                                    revert with 0, 
                                                                32,
                                                                39,
                                                                0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                mem[(32 * stor152.length) + 587 len 25]
                                                if block.timestamp >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                mem[(32 * stor152.length) + 586 len 26]
                                                stor159[address(arg3)][address(arg1)].field_0 = uint128(ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)
                                                stor159[address(arg3)][address(arg1)].field_128 = 0
                                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                                if stor159[address(arg3)][address(arg1)].field_0 < ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditMinted(((ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18) - stor159[address(arg3)][address(arg1)].field_0), arg1, arg3);
                                                else:
                                                    if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditBurned((stor159[address(arg3)][address(arg1)].field_0 - (ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)), arg1, arg3);
                                    else:
                                        if (block.timestamp * creditPlanOf[address(arg3)].field_128) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128) / block.timestamp - stor159[address(arg3)][address(arg1)].field_192 != creditPlanOf[address(arg3)].field_128:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * stor152.length) + 357 len 31]
                                        if not (block.timestamp * creditPlanOf[address(arg3)].field_128) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128):
                                            if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not creditPlanOf[address(arg3)].field_0:
                                                if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    stor159[address(arg3)][address(arg1)].field_256 = 0
                                                    if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                                    else:
                                                        if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                                else:
                                                    if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = uint128((arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted((arg2 * maxExitFeeMantissa / 10^18), arg1, arg3);
                                                    else:
                                                        if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned(-(arg2 * maxExitFeeMantissa / 10^18), arg1, arg3);
                                            else:
                                                if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / creditPlanOf[address(arg3)].field_0 != ext_call.return_data[0]:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * stor152.length) + 421 len 31]
                                                if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 <= ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                    if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = uint128((arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted((arg2 * maxExitFeeMantissa / 10^18), arg1, arg3);
                                                    else:
                                                        if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned(-(arg2 * maxExitFeeMantissa / 10^18), arg1, arg3);
                                                else:
                                                    if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = uint128(ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(((ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18) - stor159[address(arg3)][address(arg1)].field_0), arg1, arg3);
                                                    else:
                                                        if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned((stor159[address(arg3)][address(arg1)].field_0 - (ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)), arg1, arg3);
                                        else:
                                            if (block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / (block.timestamp * creditPlanOf[address(arg3)].field_128) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128) != ext_call.return_data[0]:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * stor152.length) + 357 len 31]
                                            if ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if arg2 * maxExitFeeMantissa / 10^18 < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not creditPlanOf[address(arg3)].field_0:
                                                if (arg2 * maxExitFeeMantissa / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    stor159[address(arg3)][address(arg1)].field_256 = 0
                                                    if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                                    else:
                                                        if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                                else:
                                                    if (arg2 * maxExitFeeMantissa / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = uint128((arg2 * maxExitFeeMantissa / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < (arg2 * maxExitFeeMantissa / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > (arg2 * maxExitFeeMantissa / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(((arg2 * maxExitFeeMantissa / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18)), arg1, arg3);
                                                    else:
                                                        if (arg2 * maxExitFeeMantissa / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if (arg2 * maxExitFeeMantissa / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned((-(arg2 * maxExitFeeMantissa / 10^18) - ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18)), arg1, arg3);
                                            else:
                                                if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / creditPlanOf[address(arg3)].field_0 != ext_call.return_data[0]:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * stor152.length) + 421 len 31]
                                                if (arg2 * maxExitFeeMantissa / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 <= ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                    if (arg2 * maxExitFeeMantissa / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = uint128((arg2 * maxExitFeeMantissa / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < (arg2 * maxExitFeeMantissa / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > (arg2 * maxExitFeeMantissa / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(((arg2 * maxExitFeeMantissa / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18)), arg1, arg3);
                                                    else:
                                                        if (arg2 * maxExitFeeMantissa / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if (arg2 * maxExitFeeMantissa / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned((-(arg2 * maxExitFeeMantissa / 10^18) - ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18)), arg1, arg3);
                                                else:
                                                    if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = uint128(ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(((ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18) - stor159[address(arg3)][address(arg1)].field_0), arg1, arg3);
                                                    else:
                                                        if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned((stor159[address(arg3)][address(arg1)].field_0 - (ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)), arg1, arg3);
            else:
                require ext_code.size(prizeStrategyAddress)
                call prizeStrategyAddress.beforeTokenMint(address arg1, uint256 arg2, address arg3, address arg4) with:
                     gas gas_remaining wei
                    args address(arg1), arg2, address(arg3), 0
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require ext_code.size(arg3)
                call arg3.0x5d7b0758 with:
                     gas gas_remaining wei
                    args address(arg1), arg2
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if not creditPlanOf[address(arg3)].field_0:
                    if not maxExitFeeMantissa:
                        require ext_code.size(arg3)
                        staticcall arg3.0x70a08231 with:
                                gas gas_remaining wei
                               args arg1
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if not stor159[address(arg3)][address(arg1)].field_224:
                            if block.timestamp >= 4294967296:
                                revert with 0, 
                                            32,
                                            38,
                                            0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                            mem[(32 * stor152.length) + 458 len 26]
                            stor159[address(arg3)][address(arg1)].field_0 = 0
                            stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                            stor159[address(arg3)][address(arg1)].field_224 = 1
                            stor159[address(arg3)][address(arg1)].field_256 = 0
                            if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                            else:
                                if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                    if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                        else:
                            if not stor159[address(arg3)][address(arg1)].field_224:
                                if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not creditPlanOf[address(arg3)].field_0:
                                    if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                        if block.timestamp >= 4294967296:
                                            revert with 0, 
                                                        32,
                                                        38,
                                                        0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                        mem[(32 * stor152.length) + 522 len 26]
                                        stor159[address(arg3)][address(arg1)].field_0 = 0
                                        stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                        stor159[address(arg3)][address(arg1)].field_224 = 1
                                        stor159[address(arg3)][address(arg1)].field_256 = 0
                                        if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                            if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                        else:
                                            if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                                if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                    else:
                                        if stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                            revert with 0, 
                                                        32,
                                                        39,
                                                        0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                        mem[(32 * stor152.length) + 523 len 25]
                                        if block.timestamp >= 4294967296:
                                            revert with 0, 
                                                        32,
                                                        38,
                                                        0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                        mem[(32 * stor152.length) + 522 len 26]
                                        stor159[address(arg3)][address(arg1)].field_0 = stor159[address(arg3)][address(arg1)].field_0
                                        stor159[address(arg3)][address(arg1)].field_128 = 0
                                        stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                        stor159[address(arg3)][address(arg1)].field_224 = 1
                                        if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                            if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            emit CreditMinted(0, arg1, arg3);
                                        else:
                                            if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                emit CreditBurned(0, arg1, arg3);
                                else:
                                    if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / creditPlanOf[address(arg3)].field_0 != ext_call.return_data[0]:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[(32 * stor152.length) + 357 len 31]
                                    if stor159[address(arg3)][address(arg1)].field_0 <= ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                        if stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                            revert with 0, 
                                                        32,
                                                        39,
                                                        0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                        mem[(32 * stor152.length) + 523 len 25]
                                        if block.timestamp >= 4294967296:
                                            revert with 0, 
                                                        32,
                                                        38,
                                                        0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                        mem[(32 * stor152.length) + 522 len 26]
                                        stor159[address(arg3)][address(arg1)].field_0 = stor159[address(arg3)][address(arg1)].field_0
                                        stor159[address(arg3)][address(arg1)].field_128 = 0
                                        stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                        stor159[address(arg3)][address(arg1)].field_224 = 1
                                        if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                            if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            emit CreditMinted(0, arg1, arg3);
                                        else:
                                            if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                emit CreditBurned(0, arg1, arg3);
                                    else:
                                        if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 >= 0x100000000000000000000000000000000:
                                            revert with 0, 
                                                        32,
                                                        39,
                                                        0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                        mem[(32 * stor152.length) + 523 len 25]
                                        if block.timestamp >= 4294967296:
                                            revert with 0, 
                                                        32,
                                                        38,
                                                        0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                        mem[(32 * stor152.length) + 522 len 26]
                                        stor159[address(arg3)][address(arg1)].field_0 = uint128(ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)
                                        stor159[address(arg3)][address(arg1)].field_128 = 0
                                        stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                        stor159[address(arg3)][address(arg1)].field_224 = 1
                                        if stor159[address(arg3)][address(arg1)].field_0 < ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                            if stor159[address(arg3)][address(arg1)].field_0 > ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            emit CreditMinted(((ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18) - stor159[address(arg3)][address(arg1)].field_0), arg1, arg3);
                                        else:
                                            if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 < stor159[address(arg3)][address(arg1)].field_0:
                                                if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 > stor159[address(arg3)][address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                emit CreditBurned((stor159[address(arg3)][address(arg1)].field_0 - (ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)), arg1, arg3);
                            else:
                                if stor159[address(arg3)][address(arg1)].field_192 > block.timestamp:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if not block.timestamp - stor159[address(arg3)][address(arg1)].field_192:
                                    if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not creditPlanOf[address(arg3)].field_0:
                                        if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                            if block.timestamp >= 4294967296:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                            mem[(32 * stor152.length) + 586 len 26]
                                            stor159[address(arg3)][address(arg1)].field_0 = 0
                                            stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                            stor159[address(arg3)][address(arg1)].field_224 = 1
                                            stor159[address(arg3)][address(arg1)].field_256 = 0
                                            if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                                if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                            else:
                                                if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                        else:
                                            if stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                revert with 0, 
                                                            32,
                                                            39,
                                                            0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                            mem[(32 * stor152.length) + 587 len 25]
                                            if block.timestamp >= 4294967296:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                            mem[(32 * stor152.length) + 586 len 26]
                                            stor159[address(arg3)][address(arg1)].field_0 = stor159[address(arg3)][address(arg1)].field_0
                                            stor159[address(arg3)][address(arg1)].field_128 = 0
                                            stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                            stor159[address(arg3)][address(arg1)].field_224 = 1
                                            if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                emit CreditMinted(0, arg1, arg3);
                                            else:
                                                if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditBurned(0, arg1, arg3);
                                    else:
                                        if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / creditPlanOf[address(arg3)].field_0 != ext_call.return_data[0]:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * stor152.length) + 421 len 31]
                                        if stor159[address(arg3)][address(arg1)].field_0 <= ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                            if stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                revert with 0, 
                                                            32,
                                                            39,
                                                            0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                            mem[(32 * stor152.length) + 587 len 25]
                                            if block.timestamp >= 4294967296:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                            mem[(32 * stor152.length) + 586 len 26]
                                            stor159[address(arg3)][address(arg1)].field_0 = stor159[address(arg3)][address(arg1)].field_0
                                            stor159[address(arg3)][address(arg1)].field_128 = 0
                                            stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                            stor159[address(arg3)][address(arg1)].field_224 = 1
                                            if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                emit CreditMinted(0, arg1, arg3);
                                            else:
                                                if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditBurned(0, arg1, arg3);
                                        else:
                                            if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 >= 0x100000000000000000000000000000000:
                                                revert with 0, 
                                                            32,
                                                            39,
                                                            0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                            mem[(32 * stor152.length) + 587 len 25]
                                            if block.timestamp >= 4294967296:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                            mem[(32 * stor152.length) + 586 len 26]
                                            stor159[address(arg3)][address(arg1)].field_0 = uint128(ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)
                                            stor159[address(arg3)][address(arg1)].field_128 = 0
                                            stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                            stor159[address(arg3)][address(arg1)].field_224 = 1
                                            if stor159[address(arg3)][address(arg1)].field_0 < ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                if stor159[address(arg3)][address(arg1)].field_0 > ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                emit CreditMinted(((ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18) - stor159[address(arg3)][address(arg1)].field_0), arg1, arg3);
                                            else:
                                                if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditBurned((stor159[address(arg3)][address(arg1)].field_0 - (ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)), arg1, arg3);
                                else:
                                    if (block.timestamp * creditPlanOf[address(arg3)].field_128) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128) / block.timestamp - stor159[address(arg3)][address(arg1)].field_192 != creditPlanOf[address(arg3)].field_128:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[(32 * stor152.length) + 357 len 31]
                                    if not (block.timestamp * creditPlanOf[address(arg3)].field_128) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128):
                                        if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not creditPlanOf[address(arg3)].field_0:
                                            if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                if block.timestamp >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                mem[(32 * stor152.length) + 586 len 26]
                                                stor159[address(arg3)][address(arg1)].field_0 = 0
                                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                                stor159[address(arg3)][address(arg1)].field_256 = 0
                                                if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                                else:
                                                    if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                            else:
                                                if stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                    revert with 0, 
                                                                32,
                                                                39,
                                                                0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                mem[(32 * stor152.length) + 587 len 25]
                                                if block.timestamp >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                mem[(32 * stor152.length) + 586 len 26]
                                                stor159[address(arg3)][address(arg1)].field_0 = stor159[address(arg3)][address(arg1)].field_0
                                                stor159[address(arg3)][address(arg1)].field_128 = 0
                                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                                if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditMinted(0, arg1, arg3);
                                                else:
                                                    if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditBurned(0, arg1, arg3);
                                        else:
                                            if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / creditPlanOf[address(arg3)].field_0 != ext_call.return_data[0]:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * stor152.length) + 421 len 31]
                                            if stor159[address(arg3)][address(arg1)].field_0 <= ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                if stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                    revert with 0, 
                                                                32,
                                                                39,
                                                                0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                mem[(32 * stor152.length) + 587 len 25]
                                                if block.timestamp >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                mem[(32 * stor152.length) + 586 len 26]
                                                stor159[address(arg3)][address(arg1)].field_0 = stor159[address(arg3)][address(arg1)].field_0
                                                stor159[address(arg3)][address(arg1)].field_128 = 0
                                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                                if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditMinted(0, arg1, arg3);
                                                else:
                                                    if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditBurned(0, arg1, arg3);
                                            else:
                                                if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 >= 0x100000000000000000000000000000000:
                                                    revert with 0, 
                                                                32,
                                                                39,
                                                                0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                mem[(32 * stor152.length) + 587 len 25]
                                                if block.timestamp >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                mem[(32 * stor152.length) + 586 len 26]
                                                stor159[address(arg3)][address(arg1)].field_0 = uint128(ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)
                                                stor159[address(arg3)][address(arg1)].field_128 = 0
                                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                                if stor159[address(arg3)][address(arg1)].field_0 < ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditMinted(((ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18) - stor159[address(arg3)][address(arg1)].field_0), arg1, arg3);
                                                else:
                                                    if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditBurned((stor159[address(arg3)][address(arg1)].field_0 - (ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)), arg1, arg3);
                                    else:
                                        if (block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / (block.timestamp * creditPlanOf[address(arg3)].field_128) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128) != ext_call.return_data[0]:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * stor152.length) + 357 len 31]
                                        if ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not creditPlanOf[address(arg3)].field_0:
                                            if ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                if block.timestamp >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                mem[(32 * stor152.length) + 586 len 26]
                                                stor159[address(arg3)][address(arg1)].field_0 = 0
                                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                                stor159[address(arg3)][address(arg1)].field_256 = 0
                                                if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                                else:
                                                    if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                            else:
                                                if ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                    revert with 0, 
                                                                32,
                                                                39,
                                                                0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                mem[(32 * stor152.length) + 587 len 25]
                                                if block.timestamp >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                mem[(32 * stor152.length) + 586 len 26]
                                                stor159[address(arg3)][address(arg1)].field_0 = uint128(((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                                stor159[address(arg3)][address(arg1)].field_128 = 0
                                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                                if stor159[address(arg3)][address(arg1)].field_0 < ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditMinted(((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18), arg1, arg3);
                                                else:
                                                    if ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditBurned(-((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18), arg1, arg3);
                                        else:
                                            if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / creditPlanOf[address(arg3)].field_0 != ext_call.return_data[0]:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * stor152.length) + 421 len 31]
                                            if ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 <= ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                if ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                    revert with 0, 
                                                                32,
                                                                39,
                                                                0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                mem[(32 * stor152.length) + 587 len 25]
                                                if block.timestamp >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                mem[(32 * stor152.length) + 586 len 26]
                                                stor159[address(arg3)][address(arg1)].field_0 = uint128(((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                                stor159[address(arg3)][address(arg1)].field_128 = 0
                                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                                if stor159[address(arg3)][address(arg1)].field_0 < ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditMinted(((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18), arg1, arg3);
                                                else:
                                                    if ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditBurned(-((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18), arg1, arg3);
                                            else:
                                                if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 >= 0x100000000000000000000000000000000:
                                                    revert with 0, 
                                                                32,
                                                                39,
                                                                0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                mem[(32 * stor152.length) + 587 len 25]
                                                if block.timestamp >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                mem[(32 * stor152.length) + 586 len 26]
                                                stor159[address(arg3)][address(arg1)].field_0 = uint128(ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)
                                                stor159[address(arg3)][address(arg1)].field_128 = 0
                                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                                if stor159[address(arg3)][address(arg1)].field_0 < ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditMinted(((ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18) - stor159[address(arg3)][address(arg1)].field_0), arg1, arg3);
                                                else:
                                                    if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditBurned((stor159[address(arg3)][address(arg1)].field_0 - (ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)), arg1, arg3);
                    else:
                        if arg2 * maxExitFeeMantissa / maxExitFeeMantissa != arg2:
                            revert with 0, 
                                        32,
                                        33,
                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[(32 * stor152.length) + 293 len 31]
                        require ext_code.size(arg3)
                        staticcall arg3.0x70a08231 with:
                                gas gas_remaining wei
                               args arg1
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if 0 <= arg2 * maxExitFeeMantissa / 10^18:
                            if not stor159[address(arg3)][address(arg1)].field_224:
                                if block.timestamp >= 4294967296:
                                    revert with 0, 
                                                32,
                                                38,
                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                mem[(32 * stor152.length) + 458 len 26]
                                stor159[address(arg3)][address(arg1)].field_0 = 0
                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                stor159[address(arg3)][address(arg1)].field_256 = 0
                                if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                    if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                else:
                                    if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                        if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                            else:
                                if not stor159[address(arg3)][address(arg1)].field_224:
                                    if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not creditPlanOf[address(arg3)].field_0:
                                        if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                            if block.timestamp >= 4294967296:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                            mem[(32 * stor152.length) + 522 len 26]
                                            stor159[address(arg3)][address(arg1)].field_0 = 0
                                            stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                            stor159[address(arg3)][address(arg1)].field_224 = 1
                                            stor159[address(arg3)][address(arg1)].field_256 = 0
                                            if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                                if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                            else:
                                                if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                        else:
                                            if stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                revert with 0, 
                                                            32,
                                                            39,
                                                            0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                            mem[(32 * stor152.length) + 523 len 25]
                                            if block.timestamp >= 4294967296:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                            mem[(32 * stor152.length) + 522 len 26]
                                            stor159[address(arg3)][address(arg1)].field_0 = stor159[address(arg3)][address(arg1)].field_0
                                            stor159[address(arg3)][address(arg1)].field_128 = 0
                                            stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                            stor159[address(arg3)][address(arg1)].field_224 = 1
                                            if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                emit CreditMinted(0, arg1, arg3);
                                            else:
                                                if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditBurned(0, arg1, arg3);
                                    else:
                                        if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / creditPlanOf[address(arg3)].field_0 != ext_call.return_data[0]:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * stor152.length) + 357 len 31]
                                        if stor159[address(arg3)][address(arg1)].field_0 <= ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                            if stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                revert with 0, 
                                                            32,
                                                            39,
                                                            0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                            mem[(32 * stor152.length) + 523 len 25]
                                            if block.timestamp >= 4294967296:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                            mem[(32 * stor152.length) + 522 len 26]
                                            stor159[address(arg3)][address(arg1)].field_0 = stor159[address(arg3)][address(arg1)].field_0
                                            stor159[address(arg3)][address(arg1)].field_128 = 0
                                            stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                            stor159[address(arg3)][address(arg1)].field_224 = 1
                                            if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                emit CreditMinted(0, arg1, arg3);
                                            else:
                                                if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditBurned(0, arg1, arg3);
                                        else:
                                            if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 >= 0x100000000000000000000000000000000:
                                                revert with 0, 
                                                            32,
                                                            39,
                                                            0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                            mem[(32 * stor152.length) + 523 len 25]
                                            if block.timestamp >= 4294967296:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                            mem[(32 * stor152.length) + 522 len 26]
                                            stor159[address(arg3)][address(arg1)].field_0 = uint128(ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)
                                            stor159[address(arg3)][address(arg1)].field_128 = 0
                                            stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                            stor159[address(arg3)][address(arg1)].field_224 = 1
                                            if stor159[address(arg3)][address(arg1)].field_0 < ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                if stor159[address(arg3)][address(arg1)].field_0 > ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                emit CreditMinted(((ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18) - stor159[address(arg3)][address(arg1)].field_0), arg1, arg3);
                                            else:
                                                if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditBurned((stor159[address(arg3)][address(arg1)].field_0 - (ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)), arg1, arg3);
                                else:
                                    if stor159[address(arg3)][address(arg1)].field_192 > block.timestamp:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if not block.timestamp - stor159[address(arg3)][address(arg1)].field_192:
                                        if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not creditPlanOf[address(arg3)].field_0:
                                            if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                if block.timestamp >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                mem[(32 * stor152.length) + 586 len 26]
                                                stor159[address(arg3)][address(arg1)].field_0 = 0
                                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                                stor159[address(arg3)][address(arg1)].field_256 = 0
                                                if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                                else:
                                                    if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                            else:
                                                if stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                    revert with 0, 
                                                                32,
                                                                39,
                                                                0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                mem[(32 * stor152.length) + 587 len 25]
                                                if block.timestamp >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                mem[(32 * stor152.length) + 586 len 26]
                                                stor159[address(arg3)][address(arg1)].field_0 = stor159[address(arg3)][address(arg1)].field_0
                                                stor159[address(arg3)][address(arg1)].field_128 = 0
                                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                                if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditMinted(0, arg1, arg3);
                                                else:
                                                    if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditBurned(0, arg1, arg3);
                                        else:
                                            if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / creditPlanOf[address(arg3)].field_0 != ext_call.return_data[0]:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * stor152.length) + 421 len 31]
                                            if stor159[address(arg3)][address(arg1)].field_0 <= ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                if stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                    revert with 0, 
                                                                32,
                                                                39,
                                                                0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                mem[(32 * stor152.length) + 587 len 25]
                                                if block.timestamp >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                mem[(32 * stor152.length) + 586 len 26]
                                                stor159[address(arg3)][address(arg1)].field_0 = stor159[address(arg3)][address(arg1)].field_0
                                                stor159[address(arg3)][address(arg1)].field_128 = 0
                                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                                if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditMinted(0, arg1, arg3);
                                                else:
                                                    if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditBurned(0, arg1, arg3);
                                            else:
                                                if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 >= 0x100000000000000000000000000000000:
                                                    revert with 0, 
                                                                32,
                                                                39,
                                                                0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                mem[(32 * stor152.length) + 587 len 25]
                                                if block.timestamp >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                mem[(32 * stor152.length) + 586 len 26]
                                                stor159[address(arg3)][address(arg1)].field_0 = uint128(ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)
                                                stor159[address(arg3)][address(arg1)].field_128 = 0
                                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                                if stor159[address(arg3)][address(arg1)].field_0 < ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditMinted(((ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18) - stor159[address(arg3)][address(arg1)].field_0), arg1, arg3);
                                                else:
                                                    if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditBurned((stor159[address(arg3)][address(arg1)].field_0 - (ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)), arg1, arg3);
                                    else:
                                        if (block.timestamp * creditPlanOf[address(arg3)].field_128) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128) / block.timestamp - stor159[address(arg3)][address(arg1)].field_192 != creditPlanOf[address(arg3)].field_128:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * stor152.length) + 357 len 31]
                                        if not (block.timestamp * creditPlanOf[address(arg3)].field_128) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128):
                                            if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not creditPlanOf[address(arg3)].field_0:
                                                if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    stor159[address(arg3)][address(arg1)].field_256 = 0
                                                    if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                                    else:
                                                        if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                                else:
                                                    if stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = stor159[address(arg3)][address(arg1)].field_0
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(0, arg1, arg3);
                                                    else:
                                                        if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned(0, arg1, arg3);
                                            else:
                                                if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / creditPlanOf[address(arg3)].field_0 != ext_call.return_data[0]:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * stor152.length) + 421 len 31]
                                                if stor159[address(arg3)][address(arg1)].field_0 <= ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                    if stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = stor159[address(arg3)][address(arg1)].field_0
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(0, arg1, arg3);
                                                    else:
                                                        if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned(0, arg1, arg3);
                                                else:
                                                    if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = uint128(ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(((ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18) - stor159[address(arg3)][address(arg1)].field_0), arg1, arg3);
                                                    else:
                                                        if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned((stor159[address(arg3)][address(arg1)].field_0 - (ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)), arg1, arg3);
                                        else:
                                            if (block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / (block.timestamp * creditPlanOf[address(arg3)].field_128) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128) != ext_call.return_data[0]:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * stor152.length) + 357 len 31]
                                            if ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not creditPlanOf[address(arg3)].field_0:
                                                if ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    stor159[address(arg3)][address(arg1)].field_256 = 0
                                                    if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                                    else:
                                                        if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                                else:
                                                    if ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = uint128(((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18), arg1, arg3);
                                                    else:
                                                        if ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned(-((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18), arg1, arg3);
                                            else:
                                                if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / creditPlanOf[address(arg3)].field_0 != ext_call.return_data[0]:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * stor152.length) + 421 len 31]
                                                if ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 <= ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                    if ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = uint128(((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18), arg1, arg3);
                                                    else:
                                                        if ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned(-((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18), arg1, arg3);
                                                else:
                                                    if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = uint128(ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(((ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18) - stor159[address(arg3)][address(arg1)].field_0), arg1, arg3);
                                                    else:
                                                        if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned((stor159[address(arg3)][address(arg1)].field_0 - (ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)), arg1, arg3);
                        else:
                            if not stor159[address(arg3)][address(arg1)].field_224:
                                if block.timestamp >= 4294967296:
                                    revert with 0, 
                                                32,
                                                38,
                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                mem[(32 * stor152.length) + 458 len 26]
                                stor159[address(arg3)][address(arg1)].field_0 = 0
                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                stor159[address(arg3)][address(arg1)].field_256 = 0
                                if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                    if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                else:
                                    if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                        if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                            else:
                                if not stor159[address(arg3)][address(arg1)].field_224:
                                    if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not creditPlanOf[address(arg3)].field_0:
                                        if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > 0:
                                            if block.timestamp >= 4294967296:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                            mem[(32 * stor152.length) + 522 len 26]
                                            stor159[address(arg3)][address(arg1)].field_0 = 0
                                            stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                            stor159[address(arg3)][address(arg1)].field_224 = 1
                                            stor159[address(arg3)][address(arg1)].field_256 = 0
                                            if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                                if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                            else:
                                                if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                        else:
                                            if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                revert with 0, 
                                                            32,
                                                            39,
                                                            0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                            mem[(32 * stor152.length) + 523 len 25]
                                            if block.timestamp >= 4294967296:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                            mem[(32 * stor152.length) + 522 len 26]
                                            stor159[address(arg3)][address(arg1)].field_0 = uint128((arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                            stor159[address(arg3)][address(arg1)].field_128 = 0
                                            stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                            stor159[address(arg3)][address(arg1)].field_224 = 1
                                            if stor159[address(arg3)][address(arg1)].field_0 < (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                if stor159[address(arg3)][address(arg1)].field_0 > (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                emit CreditMinted((arg2 * maxExitFeeMantissa / 10^18), arg1, arg3);
                                            else:
                                                if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditBurned(-(arg2 * maxExitFeeMantissa / 10^18), arg1, arg3);
                                    else:
                                        if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / creditPlanOf[address(arg3)].field_0 != ext_call.return_data[0]:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * stor152.length) + 357 len 31]
                                        if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 <= ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                            if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                revert with 0, 
                                                            32,
                                                            39,
                                                            0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                            mem[(32 * stor152.length) + 523 len 25]
                                            if block.timestamp >= 4294967296:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                            mem[(32 * stor152.length) + 522 len 26]
                                            stor159[address(arg3)][address(arg1)].field_0 = uint128((arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                            stor159[address(arg3)][address(arg1)].field_128 = 0
                                            stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                            stor159[address(arg3)][address(arg1)].field_224 = 1
                                            if stor159[address(arg3)][address(arg1)].field_0 < (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                if stor159[address(arg3)][address(arg1)].field_0 > (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                emit CreditMinted((arg2 * maxExitFeeMantissa / 10^18), arg1, arg3);
                                            else:
                                                if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditBurned(-(arg2 * maxExitFeeMantissa / 10^18), arg1, arg3);
                                        else:
                                            if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 >= 0x100000000000000000000000000000000:
                                                revert with 0, 
                                                            32,
                                                            39,
                                                            0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                            mem[(32 * stor152.length) + 523 len 25]
                                            if block.timestamp >= 4294967296:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                            mem[(32 * stor152.length) + 522 len 26]
                                            stor159[address(arg3)][address(arg1)].field_0 = uint128(ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)
                                            stor159[address(arg3)][address(arg1)].field_128 = 0
                                            stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                            stor159[address(arg3)][address(arg1)].field_224 = 1
                                            if stor159[address(arg3)][address(arg1)].field_0 < ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                if stor159[address(arg3)][address(arg1)].field_0 > ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                emit CreditMinted(((ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18) - stor159[address(arg3)][address(arg1)].field_0), arg1, arg3);
                                            else:
                                                if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditBurned((stor159[address(arg3)][address(arg1)].field_0 - (ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)), arg1, arg3);
                                else:
                                    if stor159[address(arg3)][address(arg1)].field_192 > block.timestamp:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if not block.timestamp - stor159[address(arg3)][address(arg1)].field_192:
                                        if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not creditPlanOf[address(arg3)].field_0:
                                            if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                if block.timestamp >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                mem[(32 * stor152.length) + 586 len 26]
                                                stor159[address(arg3)][address(arg1)].field_0 = 0
                                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                                stor159[address(arg3)][address(arg1)].field_256 = 0
                                                if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                                else:
                                                    if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                            else:
                                                if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                    revert with 0, 
                                                                32,
                                                                39,
                                                                0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                mem[(32 * stor152.length) + 587 len 25]
                                                if block.timestamp >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                mem[(32 * stor152.length) + 586 len 26]
                                                stor159[address(arg3)][address(arg1)].field_0 = uint128((arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                                stor159[address(arg3)][address(arg1)].field_128 = 0
                                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                                if stor159[address(arg3)][address(arg1)].field_0 < (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditMinted((arg2 * maxExitFeeMantissa / 10^18), arg1, arg3);
                                                else:
                                                    if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditBurned(-(arg2 * maxExitFeeMantissa / 10^18), arg1, arg3);
                                        else:
                                            if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / creditPlanOf[address(arg3)].field_0 != ext_call.return_data[0]:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * stor152.length) + 421 len 31]
                                            if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 <= ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                    revert with 0, 
                                                                32,
                                                                39,
                                                                0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                mem[(32 * stor152.length) + 587 len 25]
                                                if block.timestamp >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                mem[(32 * stor152.length) + 586 len 26]
                                                stor159[address(arg3)][address(arg1)].field_0 = uint128((arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                                stor159[address(arg3)][address(arg1)].field_128 = 0
                                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                                if stor159[address(arg3)][address(arg1)].field_0 < (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditMinted((arg2 * maxExitFeeMantissa / 10^18), arg1, arg3);
                                                else:
                                                    if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditBurned(-(arg2 * maxExitFeeMantissa / 10^18), arg1, arg3);
                                            else:
                                                if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 >= 0x100000000000000000000000000000000:
                                                    revert with 0, 
                                                                32,
                                                                39,
                                                                0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                mem[(32 * stor152.length) + 587 len 25]
                                                if block.timestamp >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                mem[(32 * stor152.length) + 586 len 26]
                                                stor159[address(arg3)][address(arg1)].field_0 = uint128(ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)
                                                stor159[address(arg3)][address(arg1)].field_128 = 0
                                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                                if stor159[address(arg3)][address(arg1)].field_0 < ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditMinted(((ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18) - stor159[address(arg3)][address(arg1)].field_0), arg1, arg3);
                                                else:
                                                    if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditBurned((stor159[address(arg3)][address(arg1)].field_0 - (ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)), arg1, arg3);
                                    else:
                                        if (block.timestamp * creditPlanOf[address(arg3)].field_128) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128) / block.timestamp - stor159[address(arg3)][address(arg1)].field_192 != creditPlanOf[address(arg3)].field_128:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * stor152.length) + 357 len 31]
                                        if not (block.timestamp * creditPlanOf[address(arg3)].field_128) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128):
                                            if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not creditPlanOf[address(arg3)].field_0:
                                                if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    stor159[address(arg3)][address(arg1)].field_256 = 0
                                                    if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                                    else:
                                                        if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                                else:
                                                    if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = uint128((arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted((arg2 * maxExitFeeMantissa / 10^18), arg1, arg3);
                                                    else:
                                                        if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned(-(arg2 * maxExitFeeMantissa / 10^18), arg1, arg3);
                                            else:
                                                if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / creditPlanOf[address(arg3)].field_0 != ext_call.return_data[0]:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * stor152.length) + 421 len 31]
                                                if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 <= ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                    if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = uint128((arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted((arg2 * maxExitFeeMantissa / 10^18), arg1, arg3);
                                                    else:
                                                        if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned(-(arg2 * maxExitFeeMantissa / 10^18), arg1, arg3);
                                                else:
                                                    if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = uint128(ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(((ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18) - stor159[address(arg3)][address(arg1)].field_0), arg1, arg3);
                                                    else:
                                                        if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned((stor159[address(arg3)][address(arg1)].field_0 - (ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)), arg1, arg3);
                                        else:
                                            if (block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / (block.timestamp * creditPlanOf[address(arg3)].field_128) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128) != ext_call.return_data[0]:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * stor152.length) + 357 len 31]
                                            if ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if arg2 * maxExitFeeMantissa / 10^18 < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not creditPlanOf[address(arg3)].field_0:
                                                if (arg2 * maxExitFeeMantissa / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    stor159[address(arg3)][address(arg1)].field_256 = 0
                                                    if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                                    else:
                                                        if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                                else:
                                                    if (arg2 * maxExitFeeMantissa / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = uint128((arg2 * maxExitFeeMantissa / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < (arg2 * maxExitFeeMantissa / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > (arg2 * maxExitFeeMantissa / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(((arg2 * maxExitFeeMantissa / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18)), arg1, arg3);
                                                    else:
                                                        if (arg2 * maxExitFeeMantissa / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if (arg2 * maxExitFeeMantissa / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned((-(arg2 * maxExitFeeMantissa / 10^18) - ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18)), arg1, arg3);
                                            else:
                                                if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / creditPlanOf[address(arg3)].field_0 != ext_call.return_data[0]:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * stor152.length) + 421 len 31]
                                                if (arg2 * maxExitFeeMantissa / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 <= ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                    if (arg2 * maxExitFeeMantissa / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = uint128((arg2 * maxExitFeeMantissa / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < (arg2 * maxExitFeeMantissa / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > (arg2 * maxExitFeeMantissa / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(((arg2 * maxExitFeeMantissa / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18)), arg1, arg3);
                                                    else:
                                                        if (arg2 * maxExitFeeMantissa / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if (arg2 * maxExitFeeMantissa / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned((-(arg2 * maxExitFeeMantissa / 10^18) - ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18)), arg1, arg3);
                                                else:
                                                    if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = uint128(ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(((ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18) - stor159[address(arg3)][address(arg1)].field_0), arg1, arg3);
                                                    else:
                                                        if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned((stor159[address(arg3)][address(arg1)].field_0 - (ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)), arg1, arg3);
                else:
                    if arg2 * creditPlanOf[address(arg3)].field_0 / creditPlanOf[address(arg3)].field_0 != arg2:
                        revert with 0, 'dSafeMath: multiplication overflo'
                    if not maxExitFeeMantissa:
                        require ext_code.size(arg3)
                        staticcall arg3.0x70a08231 with:
                                gas gas_remaining wei
                               args arg1
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if arg2 * creditPlanOf[address(arg3)].field_0 / 10^18 > 0:
                            if not stor159[address(arg3)][address(arg1)].field_224:
                                if block.timestamp >= 4294967296:
                                    revert with 0, 
                                                32,
                                                38,
                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                mem[(32 * stor152.length) + 458 len 26]
                                stor159[address(arg3)][address(arg1)].field_0 = 0
                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                stor159[address(arg3)][address(arg1)].field_256 = 0
                                if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                    if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                else:
                                    if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                        if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                            else:
                                if not stor159[address(arg3)][address(arg1)].field_224:
                                    if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not creditPlanOf[address(arg3)].field_0:
                                        if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                            if block.timestamp >= 4294967296:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                            mem[(32 * stor152.length) + 522 len 26]
                                            stor159[address(arg3)][address(arg1)].field_0 = 0
                                            stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                            stor159[address(arg3)][address(arg1)].field_224 = 1
                                            stor159[address(arg3)][address(arg1)].field_256 = 0
                                            if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                                if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                            else:
                                                if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                        else:
                                            if stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                revert with 0, 
                                                            32,
                                                            39,
                                                            0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                            mem[(32 * stor152.length) + 523 len 25]
                                            if block.timestamp >= 4294967296:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                            mem[(32 * stor152.length) + 522 len 26]
                                            stor159[address(arg3)][address(arg1)].field_0 = stor159[address(arg3)][address(arg1)].field_0
                                            stor159[address(arg3)][address(arg1)].field_128 = 0
                                            stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                            stor159[address(arg3)][address(arg1)].field_224 = 1
                                            if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                emit CreditMinted(0, arg1, arg3);
                                            else:
                                                if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditBurned(0, arg1, arg3);
                                    else:
                                        if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / creditPlanOf[address(arg3)].field_0 != ext_call.return_data[0]:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * stor152.length) + 357 len 31]
                                        if stor159[address(arg3)][address(arg1)].field_0 <= ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                            if stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                revert with 0, 
                                                            32,
                                                            39,
                                                            0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                            mem[(32 * stor152.length) + 523 len 25]
                                            if block.timestamp >= 4294967296:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                            mem[(32 * stor152.length) + 522 len 26]
                                            stor159[address(arg3)][address(arg1)].field_0 = stor159[address(arg3)][address(arg1)].field_0
                                            stor159[address(arg3)][address(arg1)].field_128 = 0
                                            stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                            stor159[address(arg3)][address(arg1)].field_224 = 1
                                            if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                emit CreditMinted(0, arg1, arg3);
                                            else:
                                                if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditBurned(0, arg1, arg3);
                                        else:
                                            if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 >= 0x100000000000000000000000000000000:
                                                revert with 0, 
                                                            32,
                                                            39,
                                                            0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                            mem[(32 * stor152.length) + 523 len 25]
                                            if block.timestamp >= 4294967296:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                            mem[(32 * stor152.length) + 522 len 26]
                                            stor159[address(arg3)][address(arg1)].field_0 = uint128(ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)
                                            stor159[address(arg3)][address(arg1)].field_128 = 0
                                            stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                            stor159[address(arg3)][address(arg1)].field_224 = 1
                                            if stor159[address(arg3)][address(arg1)].field_0 < ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                if stor159[address(arg3)][address(arg1)].field_0 > ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                emit CreditMinted(((ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18) - stor159[address(arg3)][address(arg1)].field_0), arg1, arg3);
                                            else:
                                                if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditBurned((stor159[address(arg3)][address(arg1)].field_0 - (ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)), arg1, arg3);
                                else:
                                    if stor159[address(arg3)][address(arg1)].field_192 > block.timestamp:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if not block.timestamp - stor159[address(arg3)][address(arg1)].field_192:
                                        if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not creditPlanOf[address(arg3)].field_0:
                                            if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                if block.timestamp >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                mem[(32 * stor152.length) + 586 len 26]
                                                stor159[address(arg3)][address(arg1)].field_0 = 0
                                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                                stor159[address(arg3)][address(arg1)].field_256 = 0
                                                if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                                else:
                                                    if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                            else:
                                                if stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                    revert with 0, 
                                                                32,
                                                                39,
                                                                0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                mem[(32 * stor152.length) + 587 len 25]
                                                if block.timestamp >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                mem[(32 * stor152.length) + 586 len 26]
                                                stor159[address(arg3)][address(arg1)].field_0 = stor159[address(arg3)][address(arg1)].field_0
                                                stor159[address(arg3)][address(arg1)].field_128 = 0
                                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                                if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditMinted(0, arg1, arg3);
                                                else:
                                                    if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditBurned(0, arg1, arg3);
                                        else:
                                            if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / creditPlanOf[address(arg3)].field_0 != ext_call.return_data[0]:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * stor152.length) + 421 len 31]
                                            if stor159[address(arg3)][address(arg1)].field_0 <= ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                if stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                    revert with 0, 
                                                                32,
                                                                39,
                                                                0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                mem[(32 * stor152.length) + 587 len 25]
                                                if block.timestamp >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                mem[(32 * stor152.length) + 586 len 26]
                                                stor159[address(arg3)][address(arg1)].field_0 = stor159[address(arg3)][address(arg1)].field_0
                                                stor159[address(arg3)][address(arg1)].field_128 = 0
                                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                                if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditMinted(0, arg1, arg3);
                                                else:
                                                    if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditBurned(0, arg1, arg3);
                                            else:
                                                if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 >= 0x100000000000000000000000000000000:
                                                    revert with 0, 
                                                                32,
                                                                39,
                                                                0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                mem[(32 * stor152.length) + 587 len 25]
                                                if block.timestamp >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                mem[(32 * stor152.length) + 586 len 26]
                                                stor159[address(arg3)][address(arg1)].field_0 = uint128(ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)
                                                stor159[address(arg3)][address(arg1)].field_128 = 0
                                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                                if stor159[address(arg3)][address(arg1)].field_0 < ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditMinted(((ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18) - stor159[address(arg3)][address(arg1)].field_0), arg1, arg3);
                                                else:
                                                    if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditBurned((stor159[address(arg3)][address(arg1)].field_0 - (ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)), arg1, arg3);
                                    else:
                                        if (block.timestamp * creditPlanOf[address(arg3)].field_128) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128) / block.timestamp - stor159[address(arg3)][address(arg1)].field_192 != creditPlanOf[address(arg3)].field_128:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * stor152.length) + 357 len 31]
                                        if not (block.timestamp * creditPlanOf[address(arg3)].field_128) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128):
                                            if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not creditPlanOf[address(arg3)].field_0:
                                                if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    stor159[address(arg3)][address(arg1)].field_256 = 0
                                                    if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                                    else:
                                                        if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                                else:
                                                    if stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = stor159[address(arg3)][address(arg1)].field_0
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(0, arg1, arg3);
                                                    else:
                                                        if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned(0, arg1, arg3);
                                            else:
                                                if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / creditPlanOf[address(arg3)].field_0 != ext_call.return_data[0]:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * stor152.length) + 421 len 31]
                                                if stor159[address(arg3)][address(arg1)].field_0 <= ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                    if stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = stor159[address(arg3)][address(arg1)].field_0
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(0, arg1, arg3);
                                                    else:
                                                        if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned(0, arg1, arg3);
                                                else:
                                                    if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = uint128(ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(((ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18) - stor159[address(arg3)][address(arg1)].field_0), arg1, arg3);
                                                    else:
                                                        if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned((stor159[address(arg3)][address(arg1)].field_0 - (ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)), arg1, arg3);
                                        else:
                                            if (block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / (block.timestamp * creditPlanOf[address(arg3)].field_128) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128) != ext_call.return_data[0]:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * stor152.length) + 357 len 31]
                                            if ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not creditPlanOf[address(arg3)].field_0:
                                                if ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    stor159[address(arg3)][address(arg1)].field_256 = 0
                                                    if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                                    else:
                                                        if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                                else:
                                                    if ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = uint128(((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18), arg1, arg3);
                                                    else:
                                                        if ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned(-((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18), arg1, arg3);
                                            else:
                                                if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / creditPlanOf[address(arg3)].field_0 != ext_call.return_data[0]:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * stor152.length) + 421 len 31]
                                                if ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 <= ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                    if ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = uint128(((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18), arg1, arg3);
                                                    else:
                                                        if ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned(-((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18), arg1, arg3);
                                                else:
                                                    if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = uint128(ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(((ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18) - stor159[address(arg3)][address(arg1)].field_0), arg1, arg3);
                                                    else:
                                                        if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned((stor159[address(arg3)][address(arg1)].field_0 - (ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)), arg1, arg3);
                        else:
                            if not stor159[address(arg3)][address(arg1)].field_224:
                                if block.timestamp >= 4294967296:
                                    revert with 0, 
                                                32,
                                                38,
                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                mem[(32 * stor152.length) + 458 len 26]
                                stor159[address(arg3)][address(arg1)].field_0 = 0
                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                stor159[address(arg3)][address(arg1)].field_256 = 0
                                if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                    if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                else:
                                    if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                        if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                            else:
                                if not stor159[address(arg3)][address(arg1)].field_224:
                                    if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not creditPlanOf[address(arg3)].field_0:
                                        if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > 0:
                                            if block.timestamp >= 4294967296:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                            mem[(32 * stor152.length) + 522 len 26]
                                            stor159[address(arg3)][address(arg1)].field_0 = 0
                                            stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                            stor159[address(arg3)][address(arg1)].field_224 = 1
                                            stor159[address(arg3)][address(arg1)].field_256 = 0
                                            if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                                if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                            else:
                                                if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                        else:
                                            if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                revert with 0, 
                                                            32,
                                                            39,
                                                            0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                            mem[(32 * stor152.length) + 523 len 25]
                                            if block.timestamp >= 4294967296:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                            mem[(32 * stor152.length) + 522 len 26]
                                            stor159[address(arg3)][address(arg1)].field_0 = uint128((arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                            stor159[address(arg3)][address(arg1)].field_128 = 0
                                            stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                            stor159[address(arg3)][address(arg1)].field_224 = 1
                                            if stor159[address(arg3)][address(arg1)].field_0 < (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                if stor159[address(arg3)][address(arg1)].field_0 > (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                emit CreditMinted((arg2 * creditPlanOf[address(arg3)].field_0 / 10^18), arg1, arg3);
                                            else:
                                                if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditBurned(-(arg2 * creditPlanOf[address(arg3)].field_0 / 10^18), arg1, arg3);
                                    else:
                                        if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / creditPlanOf[address(arg3)].field_0 != ext_call.return_data[0]:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * stor152.length) + 357 len 31]
                                        if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 <= ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                            if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                revert with 0, 
                                                            32,
                                                            39,
                                                            0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                            mem[(32 * stor152.length) + 523 len 25]
                                            if block.timestamp >= 4294967296:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                            mem[(32 * stor152.length) + 522 len 26]
                                            stor159[address(arg3)][address(arg1)].field_0 = uint128((arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                            stor159[address(arg3)][address(arg1)].field_128 = 0
                                            stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                            stor159[address(arg3)][address(arg1)].field_224 = 1
                                            if stor159[address(arg3)][address(arg1)].field_0 < (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                if stor159[address(arg3)][address(arg1)].field_0 > (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                emit CreditMinted((arg2 * creditPlanOf[address(arg3)].field_0 / 10^18), arg1, arg3);
                                            else:
                                                if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditBurned(-(arg2 * creditPlanOf[address(arg3)].field_0 / 10^18), arg1, arg3);
                                        else:
                                            if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 >= 0x100000000000000000000000000000000:
                                                revert with 0, 
                                                            32,
                                                            39,
                                                            0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                            mem[(32 * stor152.length) + 523 len 25]
                                            if block.timestamp >= 4294967296:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                            mem[(32 * stor152.length) + 522 len 26]
                                            stor159[address(arg3)][address(arg1)].field_0 = uint128(ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)
                                            stor159[address(arg3)][address(arg1)].field_128 = 0
                                            stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                            stor159[address(arg3)][address(arg1)].field_224 = 1
                                            if stor159[address(arg3)][address(arg1)].field_0 < ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                if stor159[address(arg3)][address(arg1)].field_0 > ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                emit CreditMinted(((ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18) - stor159[address(arg3)][address(arg1)].field_0), arg1, arg3);
                                            else:
                                                if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditBurned((stor159[address(arg3)][address(arg1)].field_0 - (ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)), arg1, arg3);
                                else:
                                    if stor159[address(arg3)][address(arg1)].field_192 > block.timestamp:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if not block.timestamp - stor159[address(arg3)][address(arg1)].field_192:
                                        if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not creditPlanOf[address(arg3)].field_0:
                                            if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                if block.timestamp >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                mem[(32 * stor152.length) + 586 len 26]
                                                stor159[address(arg3)][address(arg1)].field_0 = 0
                                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                                stor159[address(arg3)][address(arg1)].field_256 = 0
                                                if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                                else:
                                                    if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                            else:
                                                if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                    revert with 0, 
                                                                32,
                                                                39,
                                                                0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                mem[(32 * stor152.length) + 587 len 25]
                                                if block.timestamp >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                mem[(32 * stor152.length) + 586 len 26]
                                                stor159[address(arg3)][address(arg1)].field_0 = uint128((arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                                stor159[address(arg3)][address(arg1)].field_128 = 0
                                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                                if stor159[address(arg3)][address(arg1)].field_0 < (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditMinted((arg2 * creditPlanOf[address(arg3)].field_0 / 10^18), arg1, arg3);
                                                else:
                                                    if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditBurned(-(arg2 * creditPlanOf[address(arg3)].field_0 / 10^18), arg1, arg3);
                                        else:
                                            if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / creditPlanOf[address(arg3)].field_0 != ext_call.return_data[0]:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * stor152.length) + 421 len 31]
                                            if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 <= ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                    revert with 0, 
                                                                32,
                                                                39,
                                                                0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                mem[(32 * stor152.length) + 587 len 25]
                                                if block.timestamp >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                mem[(32 * stor152.length) + 586 len 26]
                                                stor159[address(arg3)][address(arg1)].field_0 = uint128((arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                                stor159[address(arg3)][address(arg1)].field_128 = 0
                                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                                if stor159[address(arg3)][address(arg1)].field_0 < (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditMinted((arg2 * creditPlanOf[address(arg3)].field_0 / 10^18), arg1, arg3);
                                                else:
                                                    if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditBurned(-(arg2 * creditPlanOf[address(arg3)].field_0 / 10^18), arg1, arg3);
                                            else:
                                                if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 >= 0x100000000000000000000000000000000:
                                                    revert with 0, 
                                                                32,
                                                                39,
                                                                0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                mem[(32 * stor152.length) + 587 len 25]
                                                if block.timestamp >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                mem[(32 * stor152.length) + 586 len 26]
                                                stor159[address(arg3)][address(arg1)].field_0 = uint128(ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)
                                                stor159[address(arg3)][address(arg1)].field_128 = 0
                                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                                if stor159[address(arg3)][address(arg1)].field_0 < ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditMinted(((ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18) - stor159[address(arg3)][address(arg1)].field_0), arg1, arg3);
                                                else:
                                                    if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditBurned((stor159[address(arg3)][address(arg1)].field_0 - (ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)), arg1, arg3);
                                    else:
                                        if (block.timestamp * creditPlanOf[address(arg3)].field_128) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128) / block.timestamp - stor159[address(arg3)][address(arg1)].field_192 != creditPlanOf[address(arg3)].field_128:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * stor152.length) + 357 len 31]
                                        if not (block.timestamp * creditPlanOf[address(arg3)].field_128) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128):
                                            if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not creditPlanOf[address(arg3)].field_0:
                                                if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    stor159[address(arg3)][address(arg1)].field_256 = 0
                                                    if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                                    else:
                                                        if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                                else:
                                                    if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = uint128((arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted((arg2 * creditPlanOf[address(arg3)].field_0 / 10^18), arg1, arg3);
                                                    else:
                                                        if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned(-(arg2 * creditPlanOf[address(arg3)].field_0 / 10^18), arg1, arg3);
                                            else:
                                                if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / creditPlanOf[address(arg3)].field_0 != ext_call.return_data[0]:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * stor152.length) + 421 len 31]
                                                if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 <= ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                    if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = uint128((arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted((arg2 * creditPlanOf[address(arg3)].field_0 / 10^18), arg1, arg3);
                                                    else:
                                                        if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned(-(arg2 * creditPlanOf[address(arg3)].field_0 / 10^18), arg1, arg3);
                                                else:
                                                    if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = uint128(ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(((ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18) - stor159[address(arg3)][address(arg1)].field_0), arg1, arg3);
                                                    else:
                                                        if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned((stor159[address(arg3)][address(arg1)].field_0 - (ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)), arg1, arg3);
                                        else:
                                            if (block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / (block.timestamp * creditPlanOf[address(arg3)].field_128) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128) != ext_call.return_data[0]:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * stor152.length) + 357 len 31]
                                            if ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if arg2 * creditPlanOf[address(arg3)].field_0 / 10^18 < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not creditPlanOf[address(arg3)].field_0:
                                                if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    stor159[address(arg3)][address(arg1)].field_256 = 0
                                                    if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                                    else:
                                                        if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                                else:
                                                    if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = uint128((arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(((arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18)), arg1, arg3);
                                                    else:
                                                        if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned((-(arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) - ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18)), arg1, arg3);
                                            else:
                                                if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / creditPlanOf[address(arg3)].field_0 != ext_call.return_data[0]:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * stor152.length) + 421 len 31]
                                                if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 <= ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                    if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = uint128((arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(((arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18)), arg1, arg3);
                                                    else:
                                                        if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned((-(arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) - ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18)), arg1, arg3);
                                                else:
                                                    if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = uint128(ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(((ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18) - stor159[address(arg3)][address(arg1)].field_0), arg1, arg3);
                                                    else:
                                                        if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned((stor159[address(arg3)][address(arg1)].field_0 - (ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)), arg1, arg3);
                    else:
                        if arg2 * maxExitFeeMantissa / maxExitFeeMantissa != arg2:
                            revert with 0, 
                                        32,
                                        33,
                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[(32 * stor152.length) + 293 len 31]
                        require ext_code.size(arg3)
                        staticcall arg3.0x70a08231 with:
                                gas gas_remaining wei
                               args arg1
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if arg2 * creditPlanOf[address(arg3)].field_0 / 10^18 <= arg2 * maxExitFeeMantissa / 10^18:
                            if not stor159[address(arg3)][address(arg1)].field_224:
                                if block.timestamp >= 4294967296:
                                    revert with 0, 
                                                32,
                                                38,
                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                mem[(32 * stor152.length) + 458 len 26]
                                stor159[address(arg3)][address(arg1)].field_0 = 0
                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                stor159[address(arg3)][address(arg1)].field_256 = 0
                                if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                    if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                else:
                                    if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                        if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                            else:
                                if not stor159[address(arg3)][address(arg1)].field_224:
                                    if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not creditPlanOf[address(arg3)].field_0:
                                        if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > 0:
                                            if block.timestamp >= 4294967296:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                            mem[(32 * stor152.length) + 522 len 26]
                                            stor159[address(arg3)][address(arg1)].field_0 = 0
                                            stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                            stor159[address(arg3)][address(arg1)].field_224 = 1
                                            stor159[address(arg3)][address(arg1)].field_256 = 0
                                            if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                                if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                            else:
                                                if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                        else:
                                            if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                revert with 0, 
                                                            32,
                                                            39,
                                                            0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                            mem[(32 * stor152.length) + 523 len 25]
                                            if block.timestamp >= 4294967296:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                            mem[(32 * stor152.length) + 522 len 26]
                                            stor159[address(arg3)][address(arg1)].field_0 = uint128((arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                            stor159[address(arg3)][address(arg1)].field_128 = 0
                                            stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                            stor159[address(arg3)][address(arg1)].field_224 = 1
                                            if stor159[address(arg3)][address(arg1)].field_0 < (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                if stor159[address(arg3)][address(arg1)].field_0 > (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                emit CreditMinted((arg2 * creditPlanOf[address(arg3)].field_0 / 10^18), arg1, arg3);
                                            else:
                                                if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditBurned(-(arg2 * creditPlanOf[address(arg3)].field_0 / 10^18), arg1, arg3);
                                    else:
                                        if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / creditPlanOf[address(arg3)].field_0 != ext_call.return_data[0]:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * stor152.length) + 357 len 31]
                                        if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 <= ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                            if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                revert with 0, 
                                                            32,
                                                            39,
                                                            0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                            mem[(32 * stor152.length) + 523 len 25]
                                            if block.timestamp >= 4294967296:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                            mem[(32 * stor152.length) + 522 len 26]
                                            stor159[address(arg3)][address(arg1)].field_0 = uint128((arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                            stor159[address(arg3)][address(arg1)].field_128 = 0
                                            stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                            stor159[address(arg3)][address(arg1)].field_224 = 1
                                            if stor159[address(arg3)][address(arg1)].field_0 < (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                if stor159[address(arg3)][address(arg1)].field_0 > (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                emit CreditMinted((arg2 * creditPlanOf[address(arg3)].field_0 / 10^18), arg1, arg3);
                                            else:
                                                if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditBurned(-(arg2 * creditPlanOf[address(arg3)].field_0 / 10^18), arg1, arg3);
                                        else:
                                            if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 >= 0x100000000000000000000000000000000:
                                                revert with 0, 
                                                            32,
                                                            39,
                                                            0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                            mem[(32 * stor152.length) + 523 len 25]
                                            if block.timestamp >= 4294967296:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                            mem[(32 * stor152.length) + 522 len 26]
                                            stor159[address(arg3)][address(arg1)].field_0 = uint128(ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)
                                            stor159[address(arg3)][address(arg1)].field_128 = 0
                                            stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                            stor159[address(arg3)][address(arg1)].field_224 = 1
                                            if stor159[address(arg3)][address(arg1)].field_0 < ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                if stor159[address(arg3)][address(arg1)].field_0 > ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                emit CreditMinted(((ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18) - stor159[address(arg3)][address(arg1)].field_0), arg1, arg3);
                                            else:
                                                if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditBurned((stor159[address(arg3)][address(arg1)].field_0 - (ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)), arg1, arg3);
                                else:
                                    if stor159[address(arg3)][address(arg1)].field_192 > block.timestamp:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if not block.timestamp - stor159[address(arg3)][address(arg1)].field_192:
                                        if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not creditPlanOf[address(arg3)].field_0:
                                            if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                if block.timestamp >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                mem[(32 * stor152.length) + 586 len 26]
                                                stor159[address(arg3)][address(arg1)].field_0 = 0
                                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                                stor159[address(arg3)][address(arg1)].field_256 = 0
                                                if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                                else:
                                                    if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                            else:
                                                if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                    revert with 0, 
                                                                32,
                                                                39,
                                                                0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                mem[(32 * stor152.length) + 587 len 25]
                                                if block.timestamp >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                mem[(32 * stor152.length) + 586 len 26]
                                                stor159[address(arg3)][address(arg1)].field_0 = uint128((arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                                stor159[address(arg3)][address(arg1)].field_128 = 0
                                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                                if stor159[address(arg3)][address(arg1)].field_0 < (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditMinted((arg2 * creditPlanOf[address(arg3)].field_0 / 10^18), arg1, arg3);
                                                else:
                                                    if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditBurned(-(arg2 * creditPlanOf[address(arg3)].field_0 / 10^18), arg1, arg3);
                                        else:
                                            if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / creditPlanOf[address(arg3)].field_0 != ext_call.return_data[0]:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * stor152.length) + 421 len 31]
                                            if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 <= ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                    revert with 0, 
                                                                32,
                                                                39,
                                                                0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                mem[(32 * stor152.length) + 587 len 25]
                                                if block.timestamp >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                mem[(32 * stor152.length) + 586 len 26]
                                                stor159[address(arg3)][address(arg1)].field_0 = uint128((arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                                stor159[address(arg3)][address(arg1)].field_128 = 0
                                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                                if stor159[address(arg3)][address(arg1)].field_0 < (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditMinted((arg2 * creditPlanOf[address(arg3)].field_0 / 10^18), arg1, arg3);
                                                else:
                                                    if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditBurned(-(arg2 * creditPlanOf[address(arg3)].field_0 / 10^18), arg1, arg3);
                                            else:
                                                if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 >= 0x100000000000000000000000000000000:
                                                    revert with 0, 
                                                                32,
                                                                39,
                                                                0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                mem[(32 * stor152.length) + 587 len 25]
                                                if block.timestamp >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                mem[(32 * stor152.length) + 586 len 26]
                                                stor159[address(arg3)][address(arg1)].field_0 = uint128(ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)
                                                stor159[address(arg3)][address(arg1)].field_128 = 0
                                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                                if stor159[address(arg3)][address(arg1)].field_0 < ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditMinted(((ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18) - stor159[address(arg3)][address(arg1)].field_0), arg1, arg3);
                                                else:
                                                    if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditBurned((stor159[address(arg3)][address(arg1)].field_0 - (ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)), arg1, arg3);
                                    else:
                                        if (block.timestamp * creditPlanOf[address(arg3)].field_128) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128) / block.timestamp - stor159[address(arg3)][address(arg1)].field_192 != creditPlanOf[address(arg3)].field_128:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * stor152.length) + 357 len 31]
                                        if not (block.timestamp * creditPlanOf[address(arg3)].field_128) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128):
                                            if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not creditPlanOf[address(arg3)].field_0:
                                                if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    stor159[address(arg3)][address(arg1)].field_256 = 0
                                                    if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                                    else:
                                                        if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                                else:
                                                    if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = uint128((arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted((arg2 * creditPlanOf[address(arg3)].field_0 / 10^18), arg1, arg3);
                                                    else:
                                                        if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned(-(arg2 * creditPlanOf[address(arg3)].field_0 / 10^18), arg1, arg3);
                                            else:
                                                if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / creditPlanOf[address(arg3)].field_0 != ext_call.return_data[0]:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * stor152.length) + 421 len 31]
                                                if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 <= ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                    if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = uint128((arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted((arg2 * creditPlanOf[address(arg3)].field_0 / 10^18), arg1, arg3);
                                                    else:
                                                        if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned(-(arg2 * creditPlanOf[address(arg3)].field_0 / 10^18), arg1, arg3);
                                                else:
                                                    if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = uint128(ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(((ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18) - stor159[address(arg3)][address(arg1)].field_0), arg1, arg3);
                                                    else:
                                                        if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned((stor159[address(arg3)][address(arg1)].field_0 - (ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)), arg1, arg3);
                                        else:
                                            if (block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / (block.timestamp * creditPlanOf[address(arg3)].field_128) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128) != ext_call.return_data[0]:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * stor152.length) + 357 len 31]
                                            if ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if arg2 * creditPlanOf[address(arg3)].field_0 / 10^18 < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not creditPlanOf[address(arg3)].field_0:
                                                if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    stor159[address(arg3)][address(arg1)].field_256 = 0
                                                    if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                                    else:
                                                        if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                                else:
                                                    if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = uint128((arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(((arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18)), arg1, arg3);
                                                    else:
                                                        if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned((-(arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) - ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18)), arg1, arg3);
                                            else:
                                                if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / creditPlanOf[address(arg3)].field_0 != ext_call.return_data[0]:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * stor152.length) + 421 len 31]
                                                if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 <= ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                    if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = uint128((arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(((arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18)), arg1, arg3);
                                                    else:
                                                        if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned((-(arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) - ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18)), arg1, arg3);
                                                else:
                                                    if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = uint128(ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(((ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18) - stor159[address(arg3)][address(arg1)].field_0), arg1, arg3);
                                                    else:
                                                        if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned((stor159[address(arg3)][address(arg1)].field_0 - (ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)), arg1, arg3);
                        else:
                            if not stor159[address(arg3)][address(arg1)].field_224:
                                if block.timestamp >= 4294967296:
                                    revert with 0, 
                                                32,
                                                38,
                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                mem[(32 * stor152.length) + 458 len 26]
                                stor159[address(arg3)][address(arg1)].field_0 = 0
                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                stor159[address(arg3)][address(arg1)].field_256 = 0
                                if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                    if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                else:
                                    if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                        if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                            else:
                                if not stor159[address(arg3)][address(arg1)].field_224:
                                    if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not creditPlanOf[address(arg3)].field_0:
                                        if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > 0:
                                            if block.timestamp >= 4294967296:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                            mem[(32 * stor152.length) + 522 len 26]
                                            stor159[address(arg3)][address(arg1)].field_0 = 0
                                            stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                            stor159[address(arg3)][address(arg1)].field_224 = 1
                                            stor159[address(arg3)][address(arg1)].field_256 = 0
                                            if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                                if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                            else:
                                                if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                        else:
                                            if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                revert with 0, 
                                                            32,
                                                            39,
                                                            0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                            mem[(32 * stor152.length) + 523 len 25]
                                            if block.timestamp >= 4294967296:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                            mem[(32 * stor152.length) + 522 len 26]
                                            stor159[address(arg3)][address(arg1)].field_0 = uint128((arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                            stor159[address(arg3)][address(arg1)].field_128 = 0
                                            stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                            stor159[address(arg3)][address(arg1)].field_224 = 1
                                            if stor159[address(arg3)][address(arg1)].field_0 < (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                if stor159[address(arg3)][address(arg1)].field_0 > (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                emit CreditMinted((arg2 * maxExitFeeMantissa / 10^18), arg1, arg3);
                                            else:
                                                if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditBurned(-(arg2 * maxExitFeeMantissa / 10^18), arg1, arg3);
                                    else:
                                        if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / creditPlanOf[address(arg3)].field_0 != ext_call.return_data[0]:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * stor152.length) + 357 len 31]
                                        if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 <= ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                            if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                revert with 0, 
                                                            32,
                                                            39,
                                                            0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                            mem[(32 * stor152.length) + 523 len 25]
                                            if block.timestamp >= 4294967296:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                            mem[(32 * stor152.length) + 522 len 26]
                                            stor159[address(arg3)][address(arg1)].field_0 = uint128((arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                            stor159[address(arg3)][address(arg1)].field_128 = 0
                                            stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                            stor159[address(arg3)][address(arg1)].field_224 = 1
                                            if stor159[address(arg3)][address(arg1)].field_0 < (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                if stor159[address(arg3)][address(arg1)].field_0 > (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                emit CreditMinted((arg2 * maxExitFeeMantissa / 10^18), arg1, arg3);
                                            else:
                                                if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditBurned(-(arg2 * maxExitFeeMantissa / 10^18), arg1, arg3);
                                        else:
                                            if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 >= 0x100000000000000000000000000000000:
                                                revert with 0, 
                                                            32,
                                                            39,
                                                            0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                            mem[(32 * stor152.length) + 523 len 25]
                                            if block.timestamp >= 4294967296:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                            mem[(32 * stor152.length) + 522 len 26]
                                            stor159[address(arg3)][address(arg1)].field_0 = uint128(ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)
                                            stor159[address(arg3)][address(arg1)].field_128 = 0
                                            stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                            stor159[address(arg3)][address(arg1)].field_224 = 1
                                            if stor159[address(arg3)][address(arg1)].field_0 < ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                if stor159[address(arg3)][address(arg1)].field_0 > ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                emit CreditMinted(((ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18) - stor159[address(arg3)][address(arg1)].field_0), arg1, arg3);
                                            else:
                                                if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditBurned((stor159[address(arg3)][address(arg1)].field_0 - (ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)), arg1, arg3);
                                else:
                                    if stor159[address(arg3)][address(arg1)].field_192 > block.timestamp:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if not block.timestamp - stor159[address(arg3)][address(arg1)].field_192:
                                        if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not creditPlanOf[address(arg3)].field_0:
                                            if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                if block.timestamp >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                mem[(32 * stor152.length) + 586 len 26]
                                                stor159[address(arg3)][address(arg1)].field_0 = 0
                                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                                stor159[address(arg3)][address(arg1)].field_256 = 0
                                                if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                                else:
                                                    if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                            else:
                                                if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                    revert with 0, 
                                                                32,
                                                                39,
                                                                0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                mem[(32 * stor152.length) + 587 len 25]
                                                if block.timestamp >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                mem[(32 * stor152.length) + 586 len 26]
                                                stor159[address(arg3)][address(arg1)].field_0 = uint128((arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                                stor159[address(arg3)][address(arg1)].field_128 = 0
                                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                                if stor159[address(arg3)][address(arg1)].field_0 < (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditMinted((arg2 * maxExitFeeMantissa / 10^18), arg1, arg3);
                                                else:
                                                    if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditBurned(-(arg2 * maxExitFeeMantissa / 10^18), arg1, arg3);
                                        else:
                                            if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / creditPlanOf[address(arg3)].field_0 != ext_call.return_data[0]:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * stor152.length) + 421 len 31]
                                            if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 <= ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                    revert with 0, 
                                                                32,
                                                                39,
                                                                0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                mem[(32 * stor152.length) + 587 len 25]
                                                if block.timestamp >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                mem[(32 * stor152.length) + 586 len 26]
                                                stor159[address(arg3)][address(arg1)].field_0 = uint128((arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                                stor159[address(arg3)][address(arg1)].field_128 = 0
                                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                                if stor159[address(arg3)][address(arg1)].field_0 < (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditMinted((arg2 * maxExitFeeMantissa / 10^18), arg1, arg3);
                                                else:
                                                    if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditBurned(-(arg2 * maxExitFeeMantissa / 10^18), arg1, arg3);
                                            else:
                                                if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 >= 0x100000000000000000000000000000000:
                                                    revert with 0, 
                                                                32,
                                                                39,
                                                                0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                mem[(32 * stor152.length) + 587 len 25]
                                                if block.timestamp >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                mem[(32 * stor152.length) + 586 len 26]
                                                stor159[address(arg3)][address(arg1)].field_0 = uint128(ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)
                                                stor159[address(arg3)][address(arg1)].field_128 = 0
                                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                                if stor159[address(arg3)][address(arg1)].field_0 < ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditMinted(((ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18) - stor159[address(arg3)][address(arg1)].field_0), arg1, arg3);
                                                else:
                                                    if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditBurned((stor159[address(arg3)][address(arg1)].field_0 - (ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)), arg1, arg3);
                                    else:
                                        if (block.timestamp * creditPlanOf[address(arg3)].field_128) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128) / block.timestamp - stor159[address(arg3)][address(arg1)].field_192 != creditPlanOf[address(arg3)].field_128:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * stor152.length) + 357 len 31]
                                        if not (block.timestamp * creditPlanOf[address(arg3)].field_128) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128):
                                            if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not creditPlanOf[address(arg3)].field_0:
                                                if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    stor159[address(arg3)][address(arg1)].field_256 = 0
                                                    if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                                    else:
                                                        if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                                else:
                                                    if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = uint128((arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted((arg2 * maxExitFeeMantissa / 10^18), arg1, arg3);
                                                    else:
                                                        if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned(-(arg2 * maxExitFeeMantissa / 10^18), arg1, arg3);
                                            else:
                                                if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / creditPlanOf[address(arg3)].field_0 != ext_call.return_data[0]:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * stor152.length) + 421 len 31]
                                                if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 <= ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                    if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = uint128((arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted((arg2 * maxExitFeeMantissa / 10^18), arg1, arg3);
                                                    else:
                                                        if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned(-(arg2 * maxExitFeeMantissa / 10^18), arg1, arg3);
                                                else:
                                                    if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = uint128(ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(((ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18) - stor159[address(arg3)][address(arg1)].field_0), arg1, arg3);
                                                    else:
                                                        if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned((stor159[address(arg3)][address(arg1)].field_0 - (ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)), arg1, arg3);
                                        else:
                                            if (block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / (block.timestamp * creditPlanOf[address(arg3)].field_128) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128) != ext_call.return_data[0]:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * stor152.length) + 357 len 31]
                                            if ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if arg2 * maxExitFeeMantissa / 10^18 < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not creditPlanOf[address(arg3)].field_0:
                                                if (arg2 * maxExitFeeMantissa / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    stor159[address(arg3)][address(arg1)].field_256 = 0
                                                    if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                                    else:
                                                        if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                                else:
                                                    if (arg2 * maxExitFeeMantissa / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = uint128((arg2 * maxExitFeeMantissa / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < (arg2 * maxExitFeeMantissa / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > (arg2 * maxExitFeeMantissa / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(((arg2 * maxExitFeeMantissa / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18)), arg1, arg3);
                                                    else:
                                                        if (arg2 * maxExitFeeMantissa / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if (arg2 * maxExitFeeMantissa / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned((-(arg2 * maxExitFeeMantissa / 10^18) - ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18)), arg1, arg3);
                                            else:
                                                if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / creditPlanOf[address(arg3)].field_0 != ext_call.return_data[0]:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * stor152.length) + 421 len 31]
                                                if (arg2 * maxExitFeeMantissa / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 <= ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                    if (arg2 * maxExitFeeMantissa / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = uint128((arg2 * maxExitFeeMantissa / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < (arg2 * maxExitFeeMantissa / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > (arg2 * maxExitFeeMantissa / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(((arg2 * maxExitFeeMantissa / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18)), arg1, arg3);
                                                    else:
                                                        if (arg2 * maxExitFeeMantissa / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if (arg2 * maxExitFeeMantissa / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned((-(arg2 * maxExitFeeMantissa / 10^18) - ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18)), arg1, arg3);
                                                else:
                                                    if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = uint128(ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(((ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18) - stor159[address(arg3)][address(arg1)].field_0), arg1, arg3);
                                                    else:
                                                        if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned((stor159[address(arg3)][address(arg1)].field_0 - (ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)), arg1, arg3);
            emit Awarded(arg2, arg1, arg3);
    revert with 0, 'mPrizePool/unknown-token'
}



}
