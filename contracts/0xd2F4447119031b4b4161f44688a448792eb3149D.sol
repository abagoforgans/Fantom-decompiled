contract main {




// =====================  Runtime code  =====================


mapping of struct price;

function getPrice(address arg1, string arg2) payable {
    require calldata.size - 4 >= 64
    require arg2 <= 4294967296
    require arg2 + 36 <= calldata.size
    require arg2.length <= 4294967296 and arg2 + arg2.length + 36 <= calldata.size
    return price[address(arg1)][arg2[all]].field_64
}

function _fallback() payable {
    revert
}

function get(address arg1, string arg2) payable {
    require calldata.size - 4 >= 64
    require arg2 <= 4294967296
    require arg2 + 36 <= calldata.size
    require arg2.length <= 4294967296 and arg2 + arg2.length + 36 <= calldata.size
    return price[address(arg1)][arg2[all]].field_0, price[address(arg1)][arg2[all]].field_64
}

function source(bytes arg1, bytes arg2) payable {
    require calldata.size - 4 >= 64
    require arg1 <= 4294967296
    require arg1 + 36 <= calldata.size
    require arg1.length <= 4294967296 and arg1 + arg1.length + 36 <= calldata.size
    require arg2 <= 4294967296
    require arg2 + 36 <= calldata.size
    require arg2.length <= 4294967296 and arg2 + arg2.length + 36 <= calldata.size
    mem[ceil32(arg1.length) + 160 len arg2.length] = arg2[all]
    mem[ceil32(arg1.length) + arg2.length + 160] = 0
    require arg2.length >= 96
    _4 = mem[ceil32(arg1.length) + 160]
    _5 = mem[ceil32(arg1.length) + 192]
    _6 = mem[ceil32(arg1.length) + 224]
    require mem[ceil32(arg1.length) + 224] == mem[ceil32(arg1.length) + 255 len 1]
    mem[ceil32(arg1.length) + ceil32(arg2.length) + 192] = '\x19Ethereum Signed Message:\n32'
    mem[ceil32(arg1.length) + ceil32(arg2.length) + 220] = sha3(arg1[all])
    mem[ceil32(arg1.length) + ceil32(arg2.length) + 160] = 60
    signer = erecover(sha3(mem[ceil32(arg1.length) + ceil32(arg2.length) + 192 len Mask(8 * -ceil32(arg2.length) + arg2.length + 32, 0, 0), mem[ceil32(arg1.length) + arg2.length + 192 len -arg2.length + ceil32(arg2.length)]]), _6 << 248, _4, _5) 
    if not erecover.result:
        revert with ext_call.return_data[0 len return_data.size]
    return address(signer)
}

function put(bytes arg1, bytes arg2) payable {
    require calldata.size - 4 >= 64
    require arg1 <= 4294967296
    require arg1 + 36 <= calldata.size
    require arg1.length <= 4294967296 and arg1 + arg1.length + 36 <= calldata.size
    require arg2 <= 4294967296
    require arg2 + 36 <= calldata.size
    require arg2.length <= 4294967296 and arg2 + arg2.length + 36 <= calldata.size
    mem[96] = arg1.length
    mem[128 len arg1.length] = arg1[all]
    mem[arg1.length + 128] = 0
    mem[ceil32(arg1.length) + 128] = arg2.length
    mem[ceil32(arg1.length) + 160 len arg2.length] = arg2[all]
    mem[ceil32(arg1.length) + arg2.length + 160] = 0
    require arg2.length >= 96
    _4 = mem[ceil32(arg1.length) + 160]
    _5 = mem[ceil32(arg1.length) + 192]
    _6 = mem[ceil32(arg1.length) + 224]
    require mem[ceil32(arg1.length) + 224] == mem[ceil32(arg1.length) + 255 len 1]
    mem[ceil32(arg1.length) + ceil32(arg2.length) + 192] = '\x19Ethereum Signed Message:\n32'
    mem[ceil32(arg1.length) + ceil32(arg2.length) + 220] = sha3(arg1[all])
    mem[ceil32(arg1.length) + ceil32(arg2.length) + 160] = 60
    _12 = sha3(mem[ceil32(arg1.length) + ceil32(arg2.length) + 192 len Mask(8 * -ceil32(arg2.length) + arg2.length + 32, 0, 0), mem[ceil32(arg1.length) + arg2.length + 192 len -arg2.length + ceil32(arg2.length)]])
    mem[ceil32(arg1.length) + ceil32(arg2.length) + 316] = uint8(_6)
    mem[ceil32(arg1.length) + ceil32(arg2.length) + 348] = _4
    mem[ceil32(arg1.length) + ceil32(arg2.length) + 380] = _5
    signer = erecover(_12, _6 << 248, _4, _5) 
    mem[ceil32(arg1.length) + ceil32(arg2.length) + 252] = signer
    if not erecover.result:
        revert with ext_call.return_data[0 len return_data.size]
    require arg1.length >= 128
    require cd[(arg1 + 36)] <= 4294967296
    require cd[(arg1 + 36)] + 68 <= arg1.length + 36
    require cd[(arg1 + cd[(arg1 + 36)] + 36)] <= 4294967296 and cd[(arg1 + 36)] + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 68 <= arg1.length + 36
    mem[ceil32(arg1.length) + ceil32(arg2.length) + 284] = cd[(arg1 + cd[(arg1 + 36)] + 36)]
    mem[ceil32(arg1.length) + ceil32(arg2.length) + 316 len cd[(arg1 + cd[(arg1 + 36)] + 36)]] = call.data[arg1 + cd[(arg1 + 36)] + 68 len cd[(arg1 + cd[(arg1 + 36)] + 36)]]
    mem[ceil32(arg1.length) + ceil32(arg2.length) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 316] = 0
    require cd[(arg1 + 100)] <= 4294967296
    require cd[(arg1 + 100)] + 68 <= arg1.length + 36
    require cd[(arg1 + cd[(arg1 + 100)] + 36)] <= 4294967296 and cd[(arg1 + 100)] + cd[(arg1 + cd[(arg1 + 100)] + 36)] + 68 <= arg1.length + 36
    mem[ceil32(arg1.length) + ceil32(arg2.length) + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + 316] = cd[(arg1 + cd[(arg1 + 100)] + 36)]
    mem[ceil32(arg1.length) + ceil32(arg2.length) + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + 348 len cd[(arg1 + cd[(arg1 + 100)] + 36)]] = call.data[arg1 + cd[(arg1 + 100)] + 68 len cd[(arg1 + cd[(arg1 + 100)] + 36)]]
    mem[ceil32(arg1.length) + ceil32(arg2.length) + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + cd[(arg1 + cd[(arg1 + 100)] + 36)] + 348] = 0
    mem[ceil32(arg1.length) + ceil32(arg2.length) + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + ceil32(cd[(arg1 + cd[(arg1 + 100)] + 36)]) + 380] = 0x7072696365730000000000000000000000000000000000000000000000000000
    mem[ceil32(arg1.length) + ceil32(arg2.length) + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + ceil32(cd[(arg1 + cd[(arg1 + 100)] + 36)]) + 348] = 6
    _23 = sha3(mem[ceil32(arg1.length) + ceil32(arg2.length) + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + ceil32(cd[(arg1 + cd[(arg1 + 100)] + 36)]) + 380 len Mask(8 * -ceil32(cd[(arg1 + cd[(arg1 + 100)] + 36)]) + cd[(arg1 + cd[(arg1 + 100)] + 36)] + 32, 0, 0), mem[ceil32(arg1.length) + ceil32(arg2.length) + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + cd[(arg1 + cd[(arg1 + 100)] + 36)] + 380 len -cd[(arg1 + cd[(arg1 + 100)] + 36)] + ceil32(cd[(arg1 + cd[(arg1 + 100)] + 36)])]])
    mem[ceil32(arg1.length) + ceil32(arg2.length) + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + ceil32(cd[(arg1 + cd[(arg1 + 100)] + 36)]) + 418 len floor32(cd[(arg1 + cd[(arg1 + 36)] + 36)])] = call.data[arg1 + cd[(arg1 + 36)] + 68 len floor32(cd[(arg1 + cd[(arg1 + 36)] + 36)])]
    mem[ceil32(arg1.length) + ceil32(arg2.length) + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + ceil32(cd[(arg1 + cd[(arg1 + 100)] + 36)]) + floor32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + -(cd[(arg1 + cd[(arg1 + 36)] + 36)] % 32) + 450 len cd[(arg1 + cd[(arg1 + 36)] + 36)] % 32] = mem[ceil32(arg1.length) + ceil32(arg2.length) + floor32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + -(cd[(arg1 + cd[(arg1 + 36)] + 36)] % 32) + 348 len cd[(arg1 + cd[(arg1 + 36)] + 36)] % 32]
    mem[ceil32(arg1.length) + ceil32(arg2.length) + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + ceil32(cd[(arg1 + cd[(arg1 + 100)] + 36)]) + 386] = cd[(arg1 + cd[(arg1 + 36)] + 36)]
    mem[64] = cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(arg1.length) + ceil32(arg2.length) + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + ceil32(cd[(arg1 + cd[(arg1 + 100)] + 36)]) + 418
    if sha3(call.data[arg1 + cd[(arg1 + 36)] + 68 len floor32(cd[(arg1 + cd[(arg1 + 36)] + 36)])], mem[ceil32(arg1.length) + ceil32(arg2.length) + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + ceil32(cd[(arg1 + cd[(arg1 + 100)] + 36)]) + floor32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + 418 len cd[(arg1 + cd[(arg1 + 36)] + 36)] % 32]) != _23:
        revert with 0, 'Kind of data must be 'prices''
    mem[0] = address(signer)
    mem[32] = 0
    _109 = Mask(8 * -ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 32, 0, 0), mem[ceil32(arg1.length) + ceil32(arg2.length) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 348 len -cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)])]
    mem[cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(arg1.length) + ceil32(arg2.length) + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + ceil32(cd[(arg1 + cd[(arg1 + 100)] + 36)]) + 418 len floor32(Mask(8 * -ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 32, 0, 0), mem[ceil32(arg1.length) + ceil32(arg2.length) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 348 len -cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)])])] = mem[ceil32(arg1.length) + ceil32(arg2.length) + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + 348 len floor32(Mask(8 * -ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 32, 0, 0), mem[ceil32(arg1.length) + ceil32(arg2.length) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 348 len -cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)])])]
    mem[cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(arg1.length) + ceil32(arg2.length) + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + ceil32(cd[(arg1 + cd[(arg1 + 100)] + 36)]) + floor32(Mask(8 * -ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 32, 0, 0), mem[ceil32(arg1.length) + ceil32(arg2.length) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 348 len -cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)])]) + 418] = 256^(-(Mask(8 * -ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 32, 0, 0), mem[ceil32(arg1.length) + ceil32(arg2.length) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 348 len -cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)])] % 32) + 32) - 1 and mem[cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(arg1.length) + ceil32(arg2.length) + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + ceil32(cd[(arg1 + cd[(arg1 + 100)] + 36)]) + floor32(Mask(8 * -ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 32, 0, 0), mem[ceil32(arg1.length) + ceil32(arg2.length) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 348 len -cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)])]) + 418] or mem[ceil32(arg1.length) + ceil32(arg2.length) + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + floor32(Mask(8 * -ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 32, 0, 0), mem[ceil32(arg1.length) + ceil32(arg2.length) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 348 len -cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)])]) + 348] and !(256^(-(Mask(8 * -ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 32, 0, 0), mem[ceil32(arg1.length) + ceil32(arg2.length) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 348 len -cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)])] % 32) + 32) - 1)
    mem[cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(arg1.length) + ceil32(arg2.length) + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + ceil32(cd[(arg1 + cd[(arg1 + 100)] + 36)]) + _109 + 418] = sha3(address(signer), 0)
    if uint64(cd[(arg1 + 68)]) <= stor[sha3(mem[cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(arg1.length) + ceil32(arg2.length) + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + ceil32(cd[(arg1 + cd[(arg1 + 100)] + 36)]) + 418 len _109 + 32])].field_0:
        mem[cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(arg1.length) + ceil32(arg2.length) + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + ceil32(cd[(arg1 + cd[(arg1 + 100)] + 36)]) + 418] = stor[sha3(mem[cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(arg1.length) + ceil32(arg2.length) + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + ceil32(cd[(arg1 + cd[(arg1 + 100)] + 36)]) + 418 len _109 + 32])].field_0
        mem[cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(arg1.length) + ceil32(arg2.length) + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + ceil32(cd[(arg1 + cd[(arg1 + 100)] + 36)]) + 482] = block.timestamp
        emit NotWritten(mem[cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(arg1.length) + ceil32(arg2.length) + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + ceil32(cd[(arg1 + cd[(arg1 + 100)] + 36)]) + 418], cd[(arg1 + 68)] << 192, block.timestamp);
        mem[cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(arg1.length) + ceil32(arg2.length) + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + ceil32(cd[(arg1 + cd[(arg1 + 100)] + 36)]) + 418] = 32
        mem[cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(arg1.length) + ceil32(arg2.length) + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + ceil32(cd[(arg1 + cd[(arg1 + 100)] + 36)]) + 450] = Mask(8 * -ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 32, 0, 0), mem[ceil32(arg1.length) + ceil32(arg2.length) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 348 len -cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)])]
        mem[cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(arg1.length) + ceil32(arg2.length) + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + ceil32(cd[(arg1 + cd[(arg1 + 100)] + 36)]) + 482 len ceil32(Mask(8 * -ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 32, 0, 0), mem[ceil32(arg1.length) + ceil32(arg2.length) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 348 len -cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)])])] = mem[ceil32(arg1.length) + ceil32(arg2.length) + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + 348 len ceil32(Mask(8 * -ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 32, 0, 0), mem[ceil32(arg1.length) + ceil32(arg2.length) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 348 len -cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)])])]
        if not Mask(8 * -ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 32, 0, 0), mem[ceil32(arg1.length) + ceil32(arg2.length) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 348 len -cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)])] % 32:
            return memory
              from cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(arg1.length) + ceil32(arg2.length) + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + ceil32(cd[(arg1 + cd[(arg1 + 100)] + 36)]) + 418
               len Mask(8 * -ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 32, 0, 0), mem[ceil32(arg1.length) + ceil32(arg2.length) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 348 len -cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)])] + 64
        mem[floor32(Mask(8 * -ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 32, 0, 0), mem[ceil32(arg1.length) + ceil32(arg2.length) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 348 len -cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)])]) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(arg1.length) + ceil32(arg2.length) + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + ceil32(cd[(arg1 + cd[(arg1 + 100)] + 36)]) + 482] = mem[floor32(Mask(8 * -ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 32, 0, 0), mem[ceil32(arg1.length) + ceil32(arg2.length) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 348 len -cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)])]) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(arg1.length) + ceil32(arg2.length) + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + ceil32(cd[(arg1 + cd[(arg1 + 100)] + 36)]) + -(Mask(8 * -ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 32, 0, 0), mem[ceil32(arg1.length) + ceil32(arg2.length) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 348 len -cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)])] % 32) + 514 len Mask(8 * -ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 32, 0, 0), mem[ceil32(arg1.length) + ceil32(arg2.length) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 348 len -cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)])] % 32]
        return memory
          from cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(arg1.length) + ceil32(arg2.length) + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + ceil32(cd[(arg1 + cd[(arg1 + 100)] + 36)]) + 418
           len floor32(Mask(8 * -ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 32, 0, 0), mem[ceil32(arg1.length) + ceil32(arg2.length) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 348 len -cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)])]) + 96
    if uint64(cd[(arg1 + 68)]) >= block.timestamp + 3600:
        mem[cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(arg1.length) + ceil32(arg2.length) + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + ceil32(cd[(arg1 + cd[(arg1 + 100)] + 36)]) + 418] = stor[sha3(mem[cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(arg1.length) + ceil32(arg2.length) + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + ceil32(cd[(arg1 + cd[(arg1 + 100)] + 36)]) + 418 len _109 + 32])].field_0
        mem[cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(arg1.length) + ceil32(arg2.length) + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + ceil32(cd[(arg1 + cd[(arg1 + 100)] + 36)]) + 482] = block.timestamp
        emit NotWritten(mem[cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(arg1.length) + ceil32(arg2.length) + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + ceil32(cd[(arg1 + cd[(arg1 + 100)] + 36)]) + 418], cd[(arg1 + 68)] << 192, block.timestamp);
        mem[cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(arg1.length) + ceil32(arg2.length) + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + ceil32(cd[(arg1 + cd[(arg1 + 100)] + 36)]) + 418] = 32
        mem[cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(arg1.length) + ceil32(arg2.length) + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + ceil32(cd[(arg1 + cd[(arg1 + 100)] + 36)]) + 450] = Mask(8 * -ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 32, 0, 0), mem[ceil32(arg1.length) + ceil32(arg2.length) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 348 len -cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)])]
        mem[cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(arg1.length) + ceil32(arg2.length) + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + ceil32(cd[(arg1 + cd[(arg1 + 100)] + 36)]) + 482 len ceil32(Mask(8 * -ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 32, 0, 0), mem[ceil32(arg1.length) + ceil32(arg2.length) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 348 len -cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)])])] = mem[ceil32(arg1.length) + ceil32(arg2.length) + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + 348 len ceil32(Mask(8 * -ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 32, 0, 0), mem[ceil32(arg1.length) + ceil32(arg2.length) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 348 len -cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)])])]
        if not Mask(8 * -ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 32, 0, 0), mem[ceil32(arg1.length) + ceil32(arg2.length) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 348 len -cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)])] % 32:
            return memory
              from cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(arg1.length) + ceil32(arg2.length) + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + ceil32(cd[(arg1 + cd[(arg1 + 100)] + 36)]) + 418
               len Mask(8 * -ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 32, 0, 0), mem[ceil32(arg1.length) + ceil32(arg2.length) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 348 len -cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)])] + 64
        mem[floor32(Mask(8 * -ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 32, 0, 0), mem[ceil32(arg1.length) + ceil32(arg2.length) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 348 len -cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)])]) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(arg1.length) + ceil32(arg2.length) + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + ceil32(cd[(arg1 + cd[(arg1 + 100)] + 36)]) + 482] = mem[floor32(Mask(8 * -ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 32, 0, 0), mem[ceil32(arg1.length) + ceil32(arg2.length) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 348 len -cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)])]) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(arg1.length) + ceil32(arg2.length) + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + ceil32(cd[(arg1 + cd[(arg1 + 100)] + 36)]) + -(Mask(8 * -ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 32, 0, 0), mem[ceil32(arg1.length) + ceil32(arg2.length) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 348 len -cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)])] % 32) + 514 len Mask(8 * -ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 32, 0, 0), mem[ceil32(arg1.length) + ceil32(arg2.length) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 348 len -cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)])] % 32]
        return memory
          from cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(arg1.length) + ceil32(arg2.length) + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + ceil32(cd[(arg1 + cd[(arg1 + 100)] + 36)]) + 418
           len floor32(Mask(8 * -ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 32, 0, 0), mem[ceil32(arg1.length) + ceil32(arg2.length) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 348 len -cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)])]) + 96
    if not address(signer):
        mem[cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(arg1.length) + ceil32(arg2.length) + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + ceil32(cd[(arg1 + cd[(arg1 + 100)] + 36)]) + 418] = stor[sha3(mem[cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(arg1.length) + ceil32(arg2.length) + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + ceil32(cd[(arg1 + cd[(arg1 + 100)] + 36)]) + 418 len _109 + 32])].field_0
        mem[cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(arg1.length) + ceil32(arg2.length) + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + ceil32(cd[(arg1 + cd[(arg1 + 100)] + 36)]) + 482] = block.timestamp
        emit NotWritten(mem[cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(arg1.length) + ceil32(arg2.length) + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + ceil32(cd[(arg1 + cd[(arg1 + 100)] + 36)]) + 418], cd[(arg1 + 68)] << 192, block.timestamp);
        mem[cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(arg1.length) + ceil32(arg2.length) + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + ceil32(cd[(arg1 + cd[(arg1 + 100)] + 36)]) + 418] = 32
        mem[cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(arg1.length) + ceil32(arg2.length) + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + ceil32(cd[(arg1 + cd[(arg1 + 100)] + 36)]) + 450] = Mask(8 * -ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 32, 0, 0), mem[ceil32(arg1.length) + ceil32(arg2.length) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 348 len -cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)])]
        mem[cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(arg1.length) + ceil32(arg2.length) + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + ceil32(cd[(arg1 + cd[(arg1 + 100)] + 36)]) + 482 len ceil32(Mask(8 * -ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 32, 0, 0), mem[ceil32(arg1.length) + ceil32(arg2.length) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 348 len -cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)])])] = mem[ceil32(arg1.length) + ceil32(arg2.length) + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + 348 len ceil32(Mask(8 * -ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 32, 0, 0), mem[ceil32(arg1.length) + ceil32(arg2.length) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 348 len -cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)])])]
        if not Mask(8 * -ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 32, 0, 0), mem[ceil32(arg1.length) + ceil32(arg2.length) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 348 len -cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)])] % 32:
            return memory
              from cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(arg1.length) + ceil32(arg2.length) + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + ceil32(cd[(arg1 + cd[(arg1 + 100)] + 36)]) + 418
               len Mask(8 * -ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 32, 0, 0), mem[ceil32(arg1.length) + ceil32(arg2.length) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 348 len -cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)])] + 64
        mem[floor32(Mask(8 * -ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 32, 0, 0), mem[ceil32(arg1.length) + ceil32(arg2.length) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 348 len -cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)])]) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(arg1.length) + ceil32(arg2.length) + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + ceil32(cd[(arg1 + cd[(arg1 + 100)] + 36)]) + 482] = mem[floor32(Mask(8 * -ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 32, 0, 0), mem[ceil32(arg1.length) + ceil32(arg2.length) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 348 len -cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)])]) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(arg1.length) + ceil32(arg2.length) + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + ceil32(cd[(arg1 + cd[(arg1 + 100)] + 36)]) + -(Mask(8 * -ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 32, 0, 0), mem[ceil32(arg1.length) + ceil32(arg2.length) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 348 len -cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)])] % 32) + 514 len Mask(8 * -ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 32, 0, 0), mem[ceil32(arg1.length) + ceil32(arg2.length) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 348 len -cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)])] % 32]
        return memory
          from cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(arg1.length) + ceil32(arg2.length) + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + ceil32(cd[(arg1 + cd[(arg1 + 100)] + 36)]) + 418
           len floor32(Mask(8 * -ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 32, 0, 0), mem[ceil32(arg1.length) + ceil32(arg2.length) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 348 len -cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)])]) + 96
    mem[64] = cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(arg1.length) + ceil32(arg2.length) + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + ceil32(cd[(arg1 + cd[(arg1 + 100)] + 36)]) + 482
    mem[cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(arg1.length) + ceil32(arg2.length) + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + ceil32(cd[(arg1 + cd[(arg1 + 100)] + 36)]) + 418] = uint64(cd[(arg1 + 68)])
    mem[cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(arg1.length) + ceil32(arg2.length) + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + ceil32(cd[(arg1 + cd[(arg1 + 100)] + 36)]) + 450] = uint64(cd[(arg1 + 132)])
    mem[0] = address(signer)
    mem[32] = 0
    _187 = Mask(8 * -ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 32, 0, 0), mem[ceil32(arg1.length) + ceil32(arg2.length) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 348 len -cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)])]
    mem[cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(arg1.length) + ceil32(arg2.length) + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + ceil32(cd[(arg1 + cd[(arg1 + 100)] + 36)]) + 482 len floor32(Mask(8 * -ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 32, 0, 0), mem[ceil32(arg1.length) + ceil32(arg2.length) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 348 len -cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)])])] = mem[ceil32(arg1.length) + ceil32(arg2.length) + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + 348 len floor32(Mask(8 * -ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 32, 0, 0), mem[ceil32(arg1.length) + ceil32(arg2.length) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 348 len -cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)])])]
    mem[cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(arg1.length) + ceil32(arg2.length) + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + ceil32(cd[(arg1 + cd[(arg1 + 100)] + 36)]) + floor32(Mask(8 * -ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 32, 0, 0), mem[ceil32(arg1.length) + ceil32(arg2.length) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 348 len -cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)])]) + 482] = 256^(-(Mask(8 * -ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 32, 0, 0), mem[ceil32(arg1.length) + ceil32(arg2.length) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 348 len -cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)])] % 32) + 32) - 1 and mem[cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(arg1.length) + ceil32(arg2.length) + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + ceil32(cd[(arg1 + cd[(arg1 + 100)] + 36)]) + floor32(Mask(8 * -ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 32, 0, 0), mem[ceil32(arg1.length) + ceil32(arg2.length) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 348 len -cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)])]) + 482] or mem[ceil32(arg1.length) + ceil32(arg2.length) + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + floor32(Mask(8 * -ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 32, 0, 0), mem[ceil32(arg1.length) + ceil32(arg2.length) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 348 len -cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)])]) + 348] and !(256^(-(Mask(8 * -ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 32, 0, 0), mem[ceil32(arg1.length) + ceil32(arg2.length) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 348 len -cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)])] % 32) + 32) - 1)
    mem[cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(arg1.length) + ceil32(arg2.length) + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + ceil32(cd[(arg1 + cd[(arg1 + 100)] + 36)]) + _187 + 482] = sha3(address(signer), 0)
    stor[sha3(mem[cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(arg1.length) + ceil32(arg2.length) + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + ceil32(cd[(arg1 + cd[(arg1 + 100)] + 36)]) + 482 len _187 + 32])].field_0 = 0
    stor[sha3(mem[cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(arg1.length) + ceil32(arg2.length) + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + ceil32(cd[(arg1 + cd[(arg1 + 100)] + 36)]) + 482 len _187 + 32])].field_64 = 0
    mem[cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(arg1.length) + ceil32(arg2.length) + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + ceil32(cd[(arg1 + cd[(arg1 + 100)] + 36)]) + 514] = uint64(cd[(arg1 + 68)])
    mem[cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(arg1.length) + ceil32(arg2.length) + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + ceil32(cd[(arg1 + cd[(arg1 + 100)] + 36)]) + 546] = uint64(cd[(arg1 + 132)])
    mem[cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(arg1.length) + ceil32(arg2.length) + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + ceil32(cd[(arg1 + cd[(arg1 + 100)] + 36)]) + 482] = 96
    mem[cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(arg1.length) + ceil32(arg2.length) + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + ceil32(cd[(arg1 + cd[(arg1 + 100)] + 36)]) + 578] = Mask(8 * -ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 32, 0, 0), mem[ceil32(arg1.length) + ceil32(arg2.length) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 348 len -cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)])]
    mem[cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(arg1.length) + ceil32(arg2.length) + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + ceil32(cd[(arg1 + cd[(arg1 + 100)] + 36)]) + 610 len ceil32(Mask(8 * -ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 32, 0, 0), mem[ceil32(arg1.length) + ceil32(arg2.length) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 348 len -cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)])])] = mem[ceil32(arg1.length) + ceil32(arg2.length) + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + 348 len ceil32(Mask(8 * -ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 32, 0, 0), mem[ceil32(arg1.length) + ceil32(arg2.length) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 348 len -cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)])])]
    if not Mask(8 * -ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 32, 0, 0), mem[ceil32(arg1.length) + ceil32(arg2.length) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 348 len -cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)])] % 32:
        emit Write(address arg1, string arg2, uint64 arg3, uint64 arg4):
                   mem[cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(arg1.length) + ceil32(arg2.length) + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + ceil32(cd[(arg1 + cd[(arg1 + 100)] + 36)]) + 482 len Mask(8 * -ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 32, 0, 0), mem[ceil32(arg1.length) + ceil32(arg2.length) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 348 len -cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)])] + 128],
                   address(signer),
    else:
        mem[floor32(Mask(8 * -ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 32, 0, 0), mem[ceil32(arg1.length) + ceil32(arg2.length) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 348 len -cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)])]) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(arg1.length) + ceil32(arg2.length) + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + ceil32(cd[(arg1 + cd[(arg1 + 100)] + 36)]) + 610] = mem[floor32(Mask(8 * -ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 32, 0, 0), mem[ceil32(arg1.length) + ceil32(arg2.length) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 348 len -cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)])]) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(arg1.length) + ceil32(arg2.length) + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + ceil32(cd[(arg1 + cd[(arg1 + 100)] + 36)]) + -(Mask(8 * -ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 32, 0, 0), mem[ceil32(arg1.length) + ceil32(arg2.length) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 348 len -cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)])] % 32) + 642 len Mask(8 * -ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 32, 0, 0), mem[ceil32(arg1.length) + ceil32(arg2.length) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 348 len -cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)])] % 32]
        emit Write(address arg1, string arg2, uint64 arg3, uint64 arg4):
                   mem[cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(arg1.length) + ceil32(arg2.length) + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + ceil32(cd[(arg1 + cd[(arg1 + 100)] + 36)]) + 482 len floor32(Mask(8 * -ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 32, 0, 0), mem[ceil32(arg1.length) + ceil32(arg2.length) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 348 len -cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)])]) + 160],
                   address(signer),
    mem[cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(arg1.length) + ceil32(arg2.length) + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + ceil32(cd[(arg1 + cd[(arg1 + 100)] + 36)]) + 482] = 32
    mem[cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(arg1.length) + ceil32(arg2.length) + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + ceil32(cd[(arg1 + cd[(arg1 + 100)] + 36)]) + 514] = Mask(8 * -ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 32, 0, 0), mem[ceil32(arg1.length) + ceil32(arg2.length) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 348 len -cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)])]
    mem[cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(arg1.length) + ceil32(arg2.length) + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + ceil32(cd[(arg1 + cd[(arg1 + 100)] + 36)]) + 546 len ceil32(Mask(8 * -ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 32, 0, 0), mem[ceil32(arg1.length) + ceil32(arg2.length) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 348 len -cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)])])] = mem[ceil32(arg1.length) + ceil32(arg2.length) + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + 348 len ceil32(Mask(8 * -ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 32, 0, 0), mem[ceil32(arg1.length) + ceil32(arg2.length) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 348 len -cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)])])]
    if not Mask(8 * -ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 32, 0, 0), mem[ceil32(arg1.length) + ceil32(arg2.length) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 348 len -cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)])] % 32:
        return memory
          from cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(arg1.length) + ceil32(arg2.length) + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + ceil32(cd[(arg1 + cd[(arg1 + 100)] + 36)]) + 482
           len Mask(8 * -ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 32, 0, 0), mem[ceil32(arg1.length) + ceil32(arg2.length) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 348 len -cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)])] + 64
    mem[floor32(Mask(8 * -ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 32, 0, 0), mem[ceil32(arg1.length) + ceil32(arg2.length) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 348 len -cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)])]) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(arg1.length) + ceil32(arg2.length) + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + ceil32(cd[(arg1 + cd[(arg1 + 100)] + 36)]) + 546] = mem[floor32(Mask(8 * -ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 32, 0, 0), mem[ceil32(arg1.length) + ceil32(arg2.length) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 348 len -cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)])]) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(arg1.length) + ceil32(arg2.length) + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + ceil32(cd[(arg1 + cd[(arg1 + 100)] + 36)]) + -(Mask(8 * -ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 32, 0, 0), mem[ceil32(arg1.length) + ceil32(arg2.length) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 348 len -cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)])] % 32) + 578 len Mask(8 * -ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 32, 0, 0), mem[ceil32(arg1.length) + ceil32(arg2.length) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 348 len -cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)])] % 32]
    return memory
      from cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(arg1.length) + ceil32(arg2.length) + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + ceil32(cd[(arg1 + cd[(arg1 + 100)] + 36)]) + 482
       len floor32(Mask(8 * -ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)]) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 32, 0, 0), mem[ceil32(arg1.length) + ceil32(arg2.length) + cd[(arg1 + cd[(arg1 + 36)] + 36)] + 348 len -cd[(arg1 + cd[(arg1 + 36)] + 36)] + ceil32(cd[(arg1 + cd[(arg1 + 36)] + 36)])]) + 96
}



}
