contract main {




// =====================  Runtime code  =====================


#
#  - safeTransferFrom(address arg1, address arg2, uint256 arg3)
#  - safeTransferFrom(address arg1, address arg2, uint256 arg3, bytes arg4)
#
const sub_7fc4eda8(?) = 480


array of uint256 tokenOfOwnerByIndex;
array of uint256 tokenByIndex;
mapping of uint256 stor2;
mapping of struct stor3;
mapping of address approved;
mapping of uint8 stor5;
array of struct stor6;
array of struct stor7;
mapping of struct stor8;
array of struct stor9;
array of uint256 stor10;
array of uint256 stor11;
array of uint256 stor12;
array of struct stor13;
uint256 price;
uint256 tvl;
address storE6A0;
address feeAddress;

function getApproved(uint256 arg1) {
    require calldata.size - 4 >= 32
    if not stor2[arg1]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: approved query for nonexistent token'
    return approved[arg1]
}

function totalSupply() {
    return tokenByIndex.length
}

function tokenOfOwnerByIndex(address arg1, uint256 arg2) {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    if arg2 >= tokenOfOwnerByIndex[address(arg1)]:
        revert with 'NH{q', 50
    return tokenOfOwnerByIndex[address(arg1)][arg2]
}

function feeAddress() {
    return feeAddress
}

function tokenByIndex(uint256 arg1) {
    require calldata.size - 4 >= 32
    if arg1 >= tokenByIndex.length:
        revert with 'NH{q', 50
    return tokenByIndex[arg1]
}

function balanceOf(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: balance query for the zero address'
    return tokenOfOwnerByIndex[address(arg1)]
}

function price() {
    return price
}

function tvl() {
    return tvl
}

function isApprovedForAll(address arg1, address arg2) {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    require arg2 == arg2
    return bool(stor5[address(arg1)][address(arg2)])
}

function _fallback() payable {
    revert
}

function setFeeAddress(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if storE6A0 != msg.sender:
        revert with 0, 'Pixyz: not the owner'
    feeAddress = arg1
}

function transferOwnership(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if storE6A0 != msg.sender:
        revert with 0, 'Pixyz: not the owner'
    storE6A0 = arg1
}

function supportsInterface(bytes4 arg1) {
    require calldata.size - 4 >= 32
    require arg1 == Mask(32, 224, arg1)
    return (0x1ffc9a700000000000000000000000000000000000000000000000000000000 == Mask(32, 224, arg1))
}

function pixels(uint256 arg1) {
    require calldata.size - 4 >= 32
    require arg1 < 64 * 3600
    return stor10[arg1], 
           stor11[arg1],
           stor12[arg1],
           stor13[arg1].field_0 % 16777216,
           address(stor13[arg1].field_24),
           bool(uint8(stor13[arg1].field_184))
}

function setApprovalForAll(address arg1, bool arg2) {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    require arg2 == arg2
    if msg.sender == arg1:
        revert with 0, 'ERC721: approve to caller'
    stor5[msg.sender][address(arg1)] = uint8(arg2)
    emit ApprovalForAll(arg2, msg.sender, arg1);
}

function ownerOf(uint256 arg1) {
    require calldata.size - 4 >= 32
    if not uint256(stor3[arg1].field_0):
        if not stor2[arg1]:
            revert with 0, 
                        32,
                        41,
                        0x724552433732313a206f776e657220717565727920666f72206e6f6e6578697374656e7420746f6b65, mem[169 len 23] >> 72,
                        0
    return address(stor3[arg1].field_0)
}

function sub_1a55745c(?) {
    require calldata.size - 4 >= 32
    require arg1 < 480
    mem[15456] = storE100[arg1].field_0 % 16777216
    idx = 15456
    s = 0
    while 30816 > idx + 32:
        mem[idx + 32] = storE100[arg1].field_8 * (-3 * s + 5 / 32) + s + (-1 * s + 5 / 32 * s) + 3 % 16777216
        idx = idx + 32
        s = (-3 * s + 5 / 32) + s + (-1 * s + 5 / 32 * s) + 3
        continue 
    idx = 0
    s = 15456
    t = 30816
    while idx < 480:
        mem[t] = mem[s + 29 len 3]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    return memory
      from 30816
       len 15360
}

function getPixel(uint256 arg1, uint256 arg2) {
    require calldata.size - 4 >= 64
    if arg1 >= 480:
        revert with 0, 'Pixies: x too big'
    if arg2 >= 480:
        revert with 0, 'Pixies: y too big'
    if arg2 and 480 > -1 / arg2:
        revert with 'NH{q', 17
    if 480 * arg2 > !arg1:
        revert with 'NH{q', 17
    if (480 * arg2) + arg1 >= 64 * 3600:
        revert with 'NH{q', 50
    return stor10[(480 * arg2) + arg1], 
           stor11[(480 * arg2) + arg1],
           stor12[(480 * arg2) + arg1],
           stor13[(480 * arg2) + arg1].field_0 % 16777216,
           address(stor13[(480 * arg2) + arg1].field_0),
           bool(uint8(stor13[(480 * arg2) + arg1].field_184))
}

function approve(address arg1, uint256 arg2) {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    if not uint256(stor3[arg2].field_0):
        if not stor2[arg2]:
            revert with 0, 
                        32,
                        41,
                        0x724552433732313a206f776e657220717565727920666f72206e6f6e6578697374656e7420746f6b65, mem[169 len 23] >> 72,
                        0
    if arg1 == address(stor3[arg2].field_0):
        revert with 0, 'ERC721: approval to current owner'
    if address(stor3[arg2].field_0) != msg.sender:
        if not stor5[address(stor3[arg2].field_0)][address(msg.sender)]:
            revert with 0, 'ERC721: approve caller is not owner nor approved for all'
    approved[arg2] = arg1
    if not uint256(stor3[arg2].field_0):
        if not stor2[arg2]:
            revert with 0, 
                        32,
                        41,
                        0x724552433732313a206f776e657220717565727920666f72206e6f6e6578697374656e7420746f6b65, mem[265 len 23] >> 72,
                        0
    emit Approval(address(stor3[arg2].field_0), arg1, arg2);
}

function sub_b1010988(?) {
    require calldata.size - 4 >= 96
    require arg3 == arg3 % 16777216
    if arg1 >= 480:
        revert with 0, 'Pixies: x too big'
    if arg2 >= 480:
        revert with 0, 'Pixies: y too big'
    if arg2 and 480 > -1 / arg2:
        revert with 'NH{q', 17
    if 480 * arg2 > !arg1:
        revert with 'NH{q', 17
    if not uint256(stor3[(480 * arg2) + arg1].field_0):
        if not stor2[(480 * arg2) + arg1]:
            revert with 0, 
                        32,
                        41,
                        0x724552433732313a206f776e657220717565727920666f72206e6f6e6578697374656e7420746f6b65, mem[169 len 23] >> 72,
                        0
    if address(stor3[(480 * arg2) + arg1].field_0) != msg.sender:
        revert with 0, 'Pixies: you are not the owner'
    if (480 * arg2) + arg1 >= 64 * 3600:
        revert with 'NH{q', 50
    stor13[(480 * arg2) + arg1].field_0 % 16777216 = arg3 % 16777216
    if arg2 >= 480:
        revert with 'NH{q', 50
    if arg1 >= 480:
        revert with 'NH{q', 50
    uint256(stor[(arg1 / 10) + (48 * arg2) + 921612].field_0) = arg3 % 16777216 * 256^(3 * arg1 % 10) or !(16777215 * 256^(3 * arg1 % 10)) and uint256(stor[(arg1 / 10) + (48 * arg2) + 921612].field_0)
    emit 0xdd3ae694: arg1, arg2, arg3 % 16777216
}

function sub_6b4406ba(?) {
    mem[64] = 30816
    mem[15456 len 15360] = call.data[calldata.size len 15360]
    mem[var8001] = 15456
    s = var8001
    idx = var8002
    while idx - 1:
        mem[64] = mem[64] + 15360
        mem[15456 len 15360] = call.data[calldata.size len 15360]
        mem[s + 32] = 15456
        s = s + 32
        idx = idx - 1
        continue 
    _7 = mem[64]
    mem[64] = mem[64] + 15360
    s = _7
    idx = 0
    while idx < 480:
        _9 = mem[64]
        mem[64] = mem[64] + 15360
        mem[_9] = storE100.length
        t = _9
        s = 0
        while _9 + 15360 > t + 32:
            mem[t + 32] = stor[(-144 * 0.03125 / s + 5) + (48 * s) + (-48 * 0.03125 / s + 5 * s) + 921756].field_8 * (-3 * s + 5 / 32) + s + (-1 * s + 5 / 32 * s) + 3 % 16777216
            t = t + 32
            s = (-3 * s + 5 / 32) + s + (-1 * s + 5 / 32 * s) + 3
            continue 
        mem[_9 + 15328] = _9
        t = _9 + 15360
        s = 1438
        continue 
    _10 = mem[64]
    idx = 0
    s = _7
    t = mem[64]
    while idx < 480:
        u = 0
        v = mem[s]
        w = t
        while u < 480:
            mem[w] = mem[v + 29 len 3]
            u = u + 1
            v = v + 32
            w = w + 32
            continue 
        idx = idx + 1
        s = s + 32
        t = t + 15360
        continue 
    return memory
      from mem[64]
       len _10 + -mem[64] + (2048 * 3600)
}

function sub_3f2888a9(?) payable {
    require calldata.size - 4 >= 96
    require arg3 == arg3 % 16777216
    if msg.value < price:
        revert with 0, 'Pixies: not enough value to mint'
    if arg1 >= 480:
        revert with 0, 'Pixies: x too big'
    if arg2 >= 480:
        revert with 0, 'Pixies: y too big'
    if arg2 and 480 > -1 / arg2:
        revert with 'NH{q', 17
    if 480 * arg2 > !arg1:
        revert with 'NH{q', 17
    require not stor2[(480 * arg2) + arg1]
    if eth.balance(this.address) > 0x2b1da46102b1da46102b1da46102b1da46102b1da46102b1da46102b1da4610:
        revert with 'NH{q', 17
    if eth.balance(this.address) < 95 * eth.balance(this.address) / 100:
        revert with 'NH{q', 17
    if tvl > !(95 * eth.balance(this.address) / 100):
        revert with 'NH{q', 17
    tvl += 95 * eth.balance(this.address) / 100
    if arg2 >= 480:
        revert with 'NH{q', 50
    if arg1 >= 480:
        revert with 'NH{q', 50
    uint256(stor[(arg1 / 10) + (48 * arg2) + 921612].field_0) = arg3 % 16777216 * 256^(3 * arg1 % 10) or !(16777215 * 256^(3 * arg1 % 10)) and uint256(stor[(arg1 / 10) + (48 * arg2) + 921612].field_0)
    if (480 * arg2) + arg1 >= 64 * 3600:
        revert with 'NH{q', 50
    stor13[(480 * arg2) + arg1].field_0 % 16777216 = arg3 % 16777216
    address(stor13[(480 * arg2) + arg1].field_24) = msg.sender
    stor11[(480 * arg2) + arg1] = msg.value
    Mask(72, 0, stor13[(480 * arg2) + arg1].field_184) = 0
    if not msg.sender:
        revert with 0, 'ERC721: mint to the zero address'
    if stor2[(480 * arg2) + arg1]:
        revert with 0, 'ERC721: token already minted'
    if not tokenOfOwnerByIndex[address(msg.sender)][1][(480 * arg2) + arg1]:
        tokenOfOwnerByIndex[address(msg.sender)]++
        tokenOfOwnerByIndex[address(msg.sender)][tokenOfOwnerByIndex[address(msg.sender)]] = (480 * arg2) + arg1
        tokenOfOwnerByIndex[address(msg.sender)][1][(480 * arg2) + arg1] = tokenOfOwnerByIndex[address(msg.sender)]
    address(stor3[(480 * arg2) + arg1].field_0) = msg.sender
    Mask(96, 0, stor3[(480 * arg2) + arg1].field_160) = 0
    if not stor2[(480 * arg2) + arg1]:
        tokenByIndex.length++
        tokenByIndex[tokenByIndex.length] = (480 * arg2) + arg1
        stor2[(480 * arg2) + arg1] = tokenByIndex.length
    emit Transfer(0, msg.sender, (480 * arg2) + arg1);
    call storE6A0 with:
       value 95 * eth.balance(this.address) / 100 wei
         gas 2300 * is_zero(value) wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    call feeAddress with:
       value eth.balance(this.address) - (95 * eth.balance(this.address) / 100) wei
         gas 2300 * is_zero(value) wei
    emit Minted(msg.sender, arg1, arg2);
}

function transferFrom(address arg1, address arg2, uint256 arg3) {
    require calldata.size - 4 >= 96
    require arg1 == arg1
    require arg2 == arg2
    if not stor2[arg3]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: operator query for nonexistent token'
    if not uint256(stor3[arg3].field_0):
        if not stor2[arg3]:
            revert with 0, 
                        32,
                        41,
                        0x724552433732313a206f776e657220717565727920666f72206e6f6e6578697374656e7420746f6b65, mem[169 len 23] >> 72,
                        0
    if address(stor3[arg3].field_0) != msg.sender:
        if not stor2[arg3]:
            revert with 0, 'ERC721: approved query for nonexistent token'
        if approved[arg3] != msg.sender:
            if not stor5[address(stor3[arg3].field_0)][address(msg.sender)]:
                revert with 0, 'ERC721: transfer caller is not owner nor approved'
    if not uint256(stor3[arg3].field_0):
        if not stor2[arg3]:
            revert with 0, 
                        32,
                        41,
                        0x724552433732313a206f776e657220717565727920666f72206e6f6e6578697374656e7420746f6b65, mem[265 len 23] >> 72,
                        0
    if address(stor3[arg3].field_0) != arg1:
        revert with 0, 'ERC721: transfer of token that is not own'
    if not arg2:
        revert with 0, 'ERC721: transfer to the zero address'
    approved[arg3] = 0
    if not uint256(stor3[arg3].field_0):
        if not stor2[arg3]:
            revert with 0, 
                        32,
                        41,
                        0x724552433732313a206f776e657220717565727920666f72206e6f6e6578697374656e7420746f6b65, mem[361 len 23] >> 72,
                        0
    emit Approval(address(stor3[arg3].field_0), 0, arg3);
    if tokenOfOwnerByIndex[address(arg1)][1][arg3]:
        if tokenOfOwnerByIndex[address(arg1)][1][arg3] < 1:
            revert with 'NH{q', 17
        if tokenOfOwnerByIndex[address(arg1)] < 1:
            revert with 'NH{q', 17
        if tokenOfOwnerByIndex[address(arg1)] - 1 != tokenOfOwnerByIndex[address(arg1)][1][arg3] - 1:
            if tokenOfOwnerByIndex[address(arg1)] - 1 >= tokenOfOwnerByIndex[address(arg1)]:
                revert with 'NH{q', 50
            if tokenOfOwnerByIndex[address(arg1)][1][arg3] - 1 >= tokenOfOwnerByIndex[address(arg1)]:
                revert with 'NH{q', 50
            tokenOfOwnerByIndex[address(arg1)][tokenOfOwnerByIndex[address(arg1)][1][arg3]] = tokenOfOwnerByIndex[address(arg1)][tokenOfOwnerByIndex[address(arg1)]]
            tokenOfOwnerByIndex[address(arg1)][1][tokenOfOwnerByIndex[address(arg1)][tokenOfOwnerByIndex[address(arg1)]]] = tokenOfOwnerByIndex[address(arg1)][1][arg3]
        if not tokenOfOwnerByIndex[address(arg1)]:
            revert with 'NH{q', 49
        tokenOfOwnerByIndex[address(arg1)][tokenOfOwnerByIndex[address(arg1)]] = 0
        tokenOfOwnerByIndex[address(arg1)]--
        tokenOfOwnerByIndex[address(arg1)][1][arg3] = 0
    if not tokenOfOwnerByIndex[address(arg2)][1][arg3]:
        tokenOfOwnerByIndex[address(arg2)]++
        tokenOfOwnerByIndex[address(arg2)][tokenOfOwnerByIndex[address(arg2)]] = arg3
        tokenOfOwnerByIndex[address(arg2)][1][arg3] = tokenOfOwnerByIndex[address(arg2)]
    address(stor3[arg3].field_0) = arg2
    Mask(96, 0, stor3[arg3].field_160) = 0
    if not stor2[arg3]:
        tokenByIndex.length++
        tokenByIndex[tokenByIndex.length] = arg3
        stor2[arg3] = tokenByIndex.length
    emit Transfer(arg1, arg2, arg3);
}

function name() {
    if bool(stor6.length):
        if bool(stor6.length) == uint255(stor6.length) * 0.5 < 32:
            revert with 'NH{q', 34
        if bool(stor6.length):
            if bool(stor6.length) == uint255(stor6.length) * 0.5 < 32:
                revert with 'NH{q', 34
            if Mask(256, -1, stor6.length):
                if 31 < uint255(stor6.length) * 0.5:
                    mem[128] = uint256(stor6.field_0)
                    idx = 128
                    s = 0
                    while (uint255(stor6.length) * 0.5) + 96 > idx:
                        mem[idx + 32] = uint256(stor6[s].field_256)
                        idx = idx + 32
                        s = s + 1
                        continue 
                    return Array(len=2 * Mask(256, -1, stor6.length), data=mem[128 len ceil32(uint255(stor6.length) * 0.5)])
                mem[128] = 256 * Mask(248, 0, stor6.length.field_8)
        else:
            if bool(stor6.length) == stor6.length.field_1 % 128 < 32:
                revert with 'NH{q', 34
            if stor6.length.field_1 % 128:
                if 31 < stor6.length.field_1 % 128:
                    mem[128] = uint256(stor6.field_0)
                    idx = 128
                    s = 0
                    while stor6.length.field_1 % 128 + 96 > idx:
                        mem[idx + 32] = uint256(stor6[s].field_256)
                        idx = idx + 32
                        s = s + 1
                        continue 
                    return Array(len=2 * Mask(256, -1, stor6.length), data=mem[128 len ceil32(uint255(stor6.length) * 0.5)])
                mem[128] = 256 * Mask(248, 0, stor6.length.field_8)
        mem[ceil32(uint255(stor6.length) * 0.5) + 192 len ceil32(uint255(stor6.length) * 0.5)] = mem[128 len ceil32(uint255(stor6.length) * 0.5)]
        if ceil32(uint255(stor6.length) * 0.5) > uint255(stor6.length) * 0.5:
            mem[(uint255(stor6.length) * 0.5) + ceil32(uint255(stor6.length) * 0.5) + 192] = 0
        return Array(len=2 * Mask(256, -1, stor6.length), data=mem[128 len ceil32(uint255(stor6.length) * 0.5)], mem[(2 * ceil32(uint255(stor6.length) * 0.5)) + 192 len 2 * ceil32(uint255(stor6.length) * 0.5)]), 
    if bool(stor6.length) == stor6.length.field_1 % 128 < 32:
        revert with 'NH{q', 34
    if bool(stor6.length):
        if bool(stor6.length) == uint255(stor6.length) * 0.5 < 32:
            revert with 'NH{q', 34
        if Mask(256, -1, stor6.length):
            if 31 < uint255(stor6.length) * 0.5:
                mem[128] = uint256(stor6.field_0)
                idx = 128
                s = 0
                while (uint255(stor6.length) * 0.5) + 96 > idx:
                    mem[idx + 32] = uint256(stor6[s].field_256)
                    idx = idx + 32
                    s = s + 1
                    continue 
                return Array(len=stor6.length % 128, data=mem[128 len ceil32(stor6.length.field_1 % 128)])
            mem[128] = 256 * Mask(248, 0, stor6.length.field_8)
    else:
        if bool(stor6.length) == stor6.length.field_1 % 128 < 32:
            revert with 'NH{q', 34
        if stor6.length.field_1 % 128:
            if 31 < stor6.length.field_1 % 128:
                mem[128] = uint256(stor6.field_0)
                idx = 128
                s = 0
                while stor6.length.field_1 % 128 + 96 > idx:
                    mem[idx + 32] = uint256(stor6[s].field_256)
                    idx = idx + 32
                    s = s + 1
                    continue 
                return Array(len=stor6.length % 128, data=mem[128 len ceil32(stor6.length.field_1 % 128)])
            mem[128] = 256 * Mask(248, 0, stor6.length.field_8)
    mem[ceil32(stor6.length.field_1 % 128) + 192 len ceil32(stor6.length.field_1 % 128)] = mem[128 len ceil32(stor6.length.field_1 % 128)]
    if ceil32(stor6.length.field_1 % 128) > stor6.length.field_1 % 128:
        mem[stor6.length.field_1 % 128 + ceil32(stor6.length.field_1 % 128) + 192] = 0
    return Array(len=stor6.length % 128, data=mem[128 len ceil32(stor6.length.field_1 % 128)], mem[(2 * ceil32(stor6.length.field_1 % 128)) + 192 len 2 * ceil32(stor6.length.field_1 % 128)]), 
}

function symbol() {
    if bool(stor7.length):
        if bool(stor7.length) == uint255(stor7.length) * 0.5 < 32:
            revert with 'NH{q', 34
        if bool(stor7.length):
            if bool(stor7.length) == uint255(stor7.length) * 0.5 < 32:
                revert with 'NH{q', 34
            if Mask(256, -1, stor7.length):
                if 31 < uint255(stor7.length) * 0.5:
                    mem[128] = uint256(stor7.field_0)
                    idx = 128
                    s = 0
                    while (uint255(stor7.length) * 0.5) + 96 > idx:
                        mem[idx + 32] = uint256(stor7[s].field_256)
                        idx = idx + 32
                        s = s + 1
                        continue 
                    return Array(len=2 * Mask(256, -1, stor7.length), data=mem[128 len ceil32(uint255(stor7.length) * 0.5)])
                mem[128] = 256 * Mask(248, 0, stor7.length.field_8)
        else:
            if bool(stor7.length) == stor7.length.field_1 % 128 < 32:
                revert with 'NH{q', 34
            if stor7.length.field_1 % 128:
                if 31 < stor7.length.field_1 % 128:
                    mem[128] = uint256(stor7.field_0)
                    idx = 128
                    s = 0
                    while stor7.length.field_1 % 128 + 96 > idx:
                        mem[idx + 32] = uint256(stor7[s].field_256)
                        idx = idx + 32
                        s = s + 1
                        continue 
                    return Array(len=2 * Mask(256, -1, stor7.length), data=mem[128 len ceil32(uint255(stor7.length) * 0.5)])
                mem[128] = 256 * Mask(248, 0, stor7.length.field_8)
        mem[ceil32(uint255(stor7.length) * 0.5) + 192 len ceil32(uint255(stor7.length) * 0.5)] = mem[128 len ceil32(uint255(stor7.length) * 0.5)]
        if ceil32(uint255(stor7.length) * 0.5) > uint255(stor7.length) * 0.5:
            mem[(uint255(stor7.length) * 0.5) + ceil32(uint255(stor7.length) * 0.5) + 192] = 0
        return Array(len=2 * Mask(256, -1, stor7.length), data=mem[128 len ceil32(uint255(stor7.length) * 0.5)], mem[(2 * ceil32(uint255(stor7.length) * 0.5)) + 192 len 2 * ceil32(uint255(stor7.length) * 0.5)]), 
    if bool(stor7.length) == stor7.length.field_1 % 128 < 32:
        revert with 'NH{q', 34
    if bool(stor7.length):
        if bool(stor7.length) == uint255(stor7.length) * 0.5 < 32:
            revert with 'NH{q', 34
        if Mask(256, -1, stor7.length):
            if 31 < uint255(stor7.length) * 0.5:
                mem[128] = uint256(stor7.field_0)
                idx = 128
                s = 0
                while (uint255(stor7.length) * 0.5) + 96 > idx:
                    mem[idx + 32] = uint256(stor7[s].field_256)
                    idx = idx + 32
                    s = s + 1
                    continue 
                return Array(len=stor7.length % 128, data=mem[128 len ceil32(stor7.length.field_1 % 128)])
            mem[128] = 256 * Mask(248, 0, stor7.length.field_8)
    else:
        if bool(stor7.length) == stor7.length.field_1 % 128 < 32:
            revert with 'NH{q', 34
        if stor7.length.field_1 % 128:
            if 31 < stor7.length.field_1 % 128:
                mem[128] = uint256(stor7.field_0)
                idx = 128
                s = 0
                while stor7.length.field_1 % 128 + 96 > idx:
                    mem[idx + 32] = uint256(stor7[s].field_256)
                    idx = idx + 32
                    s = s + 1
                    continue 
                return Array(len=stor7.length % 128, data=mem[128 len ceil32(stor7.length.field_1 % 128)])
            mem[128] = 256 * Mask(248, 0, stor7.length.field_8)
    mem[ceil32(stor7.length.field_1 % 128) + 192 len ceil32(stor7.length.field_1 % 128)] = mem[128 len ceil32(stor7.length.field_1 % 128)]
    if ceil32(stor7.length.field_1 % 128) > stor7.length.field_1 % 128:
        mem[stor7.length.field_1 % 128 + ceil32(stor7.length.field_1 % 128) + 192] = 0
    return Array(len=stor7.length % 128, data=mem[128 len ceil32(stor7.length.field_1 % 128)], mem[(2 * ceil32(stor7.length.field_1 % 128)) + 192 len 2 * ceil32(stor7.length.field_1 % 128)]), 
}

function baseURI() {
    if bool(stor9.length):
        if bool(stor9.length) == uint255(stor9.length) * 0.5 < 32:
            revert with 'NH{q', 34
        if bool(stor9.length):
            if bool(stor9.length) == uint255(stor9.length) * 0.5 < 32:
                revert with 'NH{q', 34
            if Mask(256, -1, stor9.length):
                if 31 < uint255(stor9.length) * 0.5:
                    mem[128] = uint256(stor9.field_0)
                    idx = 128
                    s = 0
                    while (uint255(stor9.length) * 0.5) + 96 > idx:
                        mem[idx + 32] = uint256(stor9[s].field_256)
                        idx = idx + 32
                        s = s + 1
                        continue 
                    return Array(len=2 * Mask(256, -1, stor9.length), data=mem[128 len ceil32(uint255(stor9.length) * 0.5)])
                mem[128] = 256 * Mask(248, 0, stor9.length.field_8)
        else:
            if bool(stor9.length) == stor9.length.field_1 % 128 < 32:
                revert with 'NH{q', 34
            if stor9.length.field_1 % 128:
                if 31 < stor9.length.field_1 % 128:
                    mem[128] = uint256(stor9.field_0)
                    idx = 128
                    s = 0
                    while stor9.length.field_1 % 128 + 96 > idx:
                        mem[idx + 32] = uint256(stor9[s].field_256)
                        idx = idx + 32
                        s = s + 1
                        continue 
                    return Array(len=2 * Mask(256, -1, stor9.length), data=mem[128 len ceil32(uint255(stor9.length) * 0.5)])
                mem[128] = 256 * Mask(248, 0, stor9.length.field_8)
        mem[ceil32(uint255(stor9.length) * 0.5) + 192 len ceil32(uint255(stor9.length) * 0.5)] = mem[128 len ceil32(uint255(stor9.length) * 0.5)]
        if ceil32(uint255(stor9.length) * 0.5) > uint255(stor9.length) * 0.5:
            mem[(uint255(stor9.length) * 0.5) + ceil32(uint255(stor9.length) * 0.5) + 192] = 0
        return Array(len=2 * Mask(256, -1, stor9.length), data=mem[128 len ceil32(uint255(stor9.length) * 0.5)], mem[(2 * ceil32(uint255(stor9.length) * 0.5)) + 192 len 2 * ceil32(uint255(stor9.length) * 0.5)]), 
    if bool(stor9.length) == stor9.length.field_1 % 128 < 32:
        revert with 'NH{q', 34
    if bool(stor9.length):
        if bool(stor9.length) == uint255(stor9.length) * 0.5 < 32:
            revert with 'NH{q', 34
        if Mask(256, -1, stor9.length):
            if 31 < uint255(stor9.length) * 0.5:
                mem[128] = uint256(stor9.field_0)
                idx = 128
                s = 0
                while (uint255(stor9.length) * 0.5) + 96 > idx:
                    mem[idx + 32] = uint256(stor9[s].field_256)
                    idx = idx + 32
                    s = s + 1
                    continue 
                return Array(len=stor9.length % 128, data=mem[128 len ceil32(stor9.length.field_1 % 128)])
            mem[128] = 256 * Mask(248, 0, stor9.length.field_8)
    else:
        if bool(stor9.length) == stor9.length.field_1 % 128 < 32:
            revert with 'NH{q', 34
        if stor9.length.field_1 % 128:
            if 31 < stor9.length.field_1 % 128:
                mem[128] = uint256(stor9.field_0)
                idx = 128
                s = 0
                while stor9.length.field_1 % 128 + 96 > idx:
                    mem[idx + 32] = uint256(stor9[s].field_256)
                    idx = idx + 32
                    s = s + 1
                    continue 
                return Array(len=stor9.length % 128, data=mem[128 len ceil32(stor9.length.field_1 % 128)])
            mem[128] = 256 * Mask(248, 0, stor9.length.field_8)
    mem[ceil32(stor9.length.field_1 % 128) + 192 len ceil32(stor9.length.field_1 % 128)] = mem[128 len ceil32(stor9.length.field_1 % 128)]
    if ceil32(stor9.length.field_1 % 128) > stor9.length.field_1 % 128:
        mem[stor9.length.field_1 % 128 + ceil32(stor9.length.field_1 % 128) + 192] = 0
    return Array(len=stor9.length % 128, data=mem[128 len ceil32(stor9.length.field_1 % 128)], mem[(2 * ceil32(stor9.length.field_1 % 128)) + 192 len 2 * ceil32(stor9.length.field_1 % 128)]), 
}

function sub_64339dbf(?) {
    require calldata.size - 4 >= 64
    if arg1 >= 480:
        revert with 0, 'Pixies: x too big'
    if arg2 >= 480:
        revert with 0, 'Pixies: y too big'
    if arg2 and 480 > -1 / arg2:
        revert with 'NH{q', 17
    if 480 * arg2 > !arg1:
        revert with 'NH{q', 17
    if (480 * arg2) + arg1 >= 64 * 3600:
        revert with 'NH{q', 50
    if address(stor13[(480 * arg2) + arg1].field_24) != msg.sender:
        revert with 0, 'Pixies: you are not the owner'
    if not uint8(stor13[(480 * arg2) + arg1].field_184):
        revert with 0, 'Pixies: pixel is not for sale'
    if not uint256(stor3[(480 * arg2) + arg1].field_0):
        if not stor2[(480 * arg2) + arg1]:
            revert with 0, 
                        32,
                        41,
                        0x724552433732313a206f776e657220717565727920666f72206e6f6e6578697374656e7420746f6b65, mem[169 len 23] >> 72,
                        0
    if address(stor3[(480 * arg2) + arg1].field_0) != this.address:
        revert with 0, 'ERC721: transfer of token that is not own'
    if not address(stor13[(480 * arg2) + arg1].field_24):
        revert with 0, 'ERC721: transfer to the zero address'
    approved[(480 * arg2) + arg1] = 0
    if not uint256(stor3[(480 * arg2) + arg1].field_0):
        if not stor2[(480 * arg2) + arg1]:
            revert with 0, 
                        32,
                        41,
                        0x724552433732313a206f776e657220717565727920666f72206e6f6e6578697374656e7420746f6b65, mem[265 len 23] >> 72,
                        0
    emit Approval(address(stor3[(480 * arg2) + arg1].field_0), 0, (480 * arg2) + arg1);
    if tokenOfOwnerByIndex[address(this.address)][1][(480 * arg2) + arg1]:
        if tokenOfOwnerByIndex[address(this.address)][1][(480 * arg2) + arg1] < 1:
            revert with 'NH{q', 17
        if tokenOfOwnerByIndex[address(this.address)] < 1:
            revert with 'NH{q', 17
        if tokenOfOwnerByIndex[address(this.address)] - 1 != tokenOfOwnerByIndex[address(this.address)][1][(480 * arg2) + arg1] - 1:
            if tokenOfOwnerByIndex[address(this.address)] - 1 >= tokenOfOwnerByIndex[address(this.address)]:
                revert with 'NH{q', 50
            if tokenOfOwnerByIndex[address(this.address)][1][(480 * arg2) + arg1] - 1 >= tokenOfOwnerByIndex[address(this.address)]:
                revert with 'NH{q', 50
            tokenOfOwnerByIndex[address(this.address)][tokenOfOwnerByIndex[address(this.address)][1][(480 * arg2) + arg1]] = tokenOfOwnerByIndex[address(this.address)][tokenOfOwnerByIndex[address(this.address)]]
            tokenOfOwnerByIndex[address(this.address)][1][tokenOfOwnerByIndex[address(this.address)][tokenOfOwnerByIndex[address(this.address)]]] = tokenOfOwnerByIndex[address(this.address)][1][(480 * arg2) + arg1]
        if not tokenOfOwnerByIndex[address(this.address)]:
            revert with 'NH{q', 49
        tokenOfOwnerByIndex[address(this.address)][tokenOfOwnerByIndex[address(this.address)]] = 0
        tokenOfOwnerByIndex[address(this.address)]--
        tokenOfOwnerByIndex[address(this.address)][1][(480 * arg2) + arg1] = 0
    if not tokenOfOwnerByIndex[address(stor13[(480 * arg2) + arg1].field_0)][1][(480 * arg2) + arg1]:
        tokenOfOwnerByIndex[address(stor13[(480 * arg2) + arg1].field_0)]++
        tokenOfOwnerByIndex[address(stor13[(480 * arg2) + arg1].field_0)][tokenOfOwnerByIndex[address(stor13[(480 * arg2) + arg1].field_0)]] = (480 * arg2) + arg1
        tokenOfOwnerByIndex[address(stor13[(480 * arg2) + arg1].field_0)][1][(480 * arg2) + arg1] = tokenOfOwnerByIndex[address(stor13[(480 * arg2) + arg1].field_0)]
    uint256(stor3[(480 * arg2) + arg1].field_0) = address(stor13[(480 * arg2) + arg1].field_24)
    if not stor2[(480 * arg2) + arg1]:
        tokenByIndex.length++
        tokenByIndex[tokenByIndex.length] = (480 * arg2) + arg1
        stor2[(480 * arg2) + arg1] = tokenByIndex.length
    emit Transfer(this.address, address(stor13[(480 * arg2) + arg1].field_24), (480 * arg2) + arg1);
    uint8(stor13[(480 * arg2) + arg1].field_184) = 0
    if (480 * arg2) + arg1 >= 64 * 3600:
        revert with 'NH{q', 50
    stor12[(480 * arg2) + arg1] = stor11[(480 * arg2) + arg1]
    emit 0xd5ae1968: msg.sender, arg1, arg2
}

function openTrade(uint256 arg1, uint256 arg2, uint256 arg3) {
    require calldata.size - 4 >= 96
    if arg1 >= 480:
        revert with 0, 'Pixies: x too big'
    if arg2 >= 480:
        revert with 0, 'Pixies: y too big'
    if arg2 and 480 > -1 / arg2:
        revert with 'NH{q', 17
    if 480 * arg2 > !arg1:
        revert with 'NH{q', 17
    if (480 * arg2) + arg1 >= 64 * 3600:
        revert with 'NH{q', 50
    if uint8(stor13[(480 * arg2) + arg1].field_184):
        revert with 0, 'Pixies: pixel is not for sale'
    if not uint256(stor3[(480 * arg2) + arg1].field_0):
        if not stor2[(480 * arg2) + arg1]:
            revert with 0, 
                        32,
                        41,
                        0x724552433732313a206f776e657220717565727920666f72206e6f6e6578697374656e7420746f6b65, mem[169 len 23] >> 72,
                        0
    if address(stor3[(480 * arg2) + arg1].field_0) != msg.sender:
        revert with 0, 'Pixies: you are not the owner'
    if not uint256(stor3[(480 * arg2) + arg1].field_0):
        if not stor2[(480 * arg2) + arg1]:
            revert with 0, 
                        32,
                        41,
                        0x724552433732313a206f776e657220717565727920666f72206e6f6e6578697374656e7420746f6b65, mem[265 len 23] >> 72,
                        0
    if address(stor3[(480 * arg2) + arg1].field_0) != msg.sender:
        revert with 0, 'ERC721: transfer of token that is not own'
    if not this.address:
        revert with 0, 'ERC721: transfer to the zero address'
    approved[(480 * arg2) + arg1] = 0
    if not uint256(stor3[(480 * arg2) + arg1].field_0):
        if not stor2[(480 * arg2) + arg1]:
            revert with 0, 
                        32,
                        41,
                        0x724552433732313a206f776e657220717565727920666f72206e6f6e6578697374656e7420746f6b65, mem[361 len 23] >> 72,
                        0
    emit Approval(address(stor3[(480 * arg2) + arg1].field_0), 0, (480 * arg2) + arg1);
    if tokenOfOwnerByIndex[address(msg.sender)][1][(480 * arg2) + arg1]:
        if tokenOfOwnerByIndex[address(msg.sender)][1][(480 * arg2) + arg1] < 1:
            revert with 'NH{q', 17
        if tokenOfOwnerByIndex[address(msg.sender)] < 1:
            revert with 'NH{q', 17
        if tokenOfOwnerByIndex[address(msg.sender)] - 1 != tokenOfOwnerByIndex[address(msg.sender)][1][(480 * arg2) + arg1] - 1:
            if tokenOfOwnerByIndex[address(msg.sender)] - 1 >= tokenOfOwnerByIndex[address(msg.sender)]:
                revert with 'NH{q', 50
            if tokenOfOwnerByIndex[address(msg.sender)][1][(480 * arg2) + arg1] - 1 >= tokenOfOwnerByIndex[address(msg.sender)]:
                revert with 'NH{q', 50
            tokenOfOwnerByIndex[address(msg.sender)][tokenOfOwnerByIndex[address(msg.sender)][1][(480 * arg2) + arg1]] = tokenOfOwnerByIndex[address(msg.sender)][tokenOfOwnerByIndex[address(msg.sender)]]
            tokenOfOwnerByIndex[address(msg.sender)][1][tokenOfOwnerByIndex[address(msg.sender)][tokenOfOwnerByIndex[address(msg.sender)]]] = tokenOfOwnerByIndex[address(msg.sender)][1][(480 * arg2) + arg1]
        if not tokenOfOwnerByIndex[address(msg.sender)]:
            revert with 'NH{q', 49
        tokenOfOwnerByIndex[address(msg.sender)][tokenOfOwnerByIndex[address(msg.sender)]] = 0
        tokenOfOwnerByIndex[address(msg.sender)]--
        tokenOfOwnerByIndex[address(msg.sender)][1][(480 * arg2) + arg1] = 0
    if not tokenOfOwnerByIndex[address(this.address)][1][(480 * arg2) + arg1]:
        tokenOfOwnerByIndex[address(this.address)]++
        tokenOfOwnerByIndex[address(this.address)][tokenOfOwnerByIndex[address(this.address)]] = (480 * arg2) + arg1
        tokenOfOwnerByIndex[address(this.address)][1][(480 * arg2) + arg1] = tokenOfOwnerByIndex[address(this.address)]
    address(stor3[(480 * arg2) + arg1].field_0) = this.address
    Mask(96, 0, stor3[(480 * arg2) + arg1].field_160) = 0
    if not stor2[(480 * arg2) + arg1]:
        tokenByIndex.length++
        tokenByIndex[tokenByIndex.length] = (480 * arg2) + arg1
        stor2[(480 * arg2) + arg1] = tokenByIndex.length
    emit Transfer(msg.sender, this.address, (480 * arg2) + arg1);
    stor12[(480 * arg2) + arg1] = arg3
    uint8(stor13[(480 * arg2) + arg1].field_184) = 1
    emit 0x8f262547: msg.sender, arg3, arg1, arg2
}

function executeTrade(uint256 arg1, uint256 arg2) payable {
    require calldata.size - 4 >= 64
    if arg1 >= 480:
        revert with 0, 'Pixies: x too big'
    if arg2 >= 480:
        revert with 0, 'Pixies: y too big'
    if arg2 and 480 > -1 / arg2:
        revert with 'NH{q', 17
    if 480 * arg2 > !arg1:
        revert with 'NH{q', 17
    if (480 * arg2) + arg1 >= 64 * 3600:
        revert with 'NH{q', 50
    if address(stor13[(480 * arg2) + arg1].field_24) == msg.sender:
        revert with 0, 'Pixies: can't buy own pixie'
    if not uint8(stor13[(480 * arg2) + arg1].field_184):
        revert with 0, 'Pixies: pixel is not for sale'
    if msg.value < stor12[(480 * arg2) + arg1]:
        revert with 0, 'Pixies: insufficient offer price'
    if msg.value > 0x2b1da46102b1da46102b1da46102b1da46102b1da46102b1da46102b1da4610:
        revert with 'NH{q', 17
    if msg.value < 95 * msg.value / 100:
        revert with 'NH{q', 17
    call feeAddress with:
       value msg.value - (95 * msg.value / 100) wei
         gas 2300 * is_zero(value) wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    if tvl > !(95 * msg.value / 100):
        revert with 'NH{q', 17
    if tvl + (95 * msg.value / 100) < stor11[(480 * arg2) + arg1]:
        revert with 'NH{q', 17
    tvl = tvl + (95 * msg.value / 100) - stor11[(480 * arg2) + arg1]
    if not uint256(stor3[(480 * arg2) + arg1].field_0):
        if not stor2[(480 * arg2) + arg1]:
            revert with 0, 
                        32,
                        41,
                        0x724552433732313a206f776e657220717565727920666f72206e6f6e6578697374656e7420746f6b65, mem[169 len 23] >> 72,
                        0
    if address(stor3[(480 * arg2) + arg1].field_0) != this.address:
        revert with 0, 'ERC721: transfer of token that is not own'
    if not msg.sender:
        revert with 0, 'ERC721: transfer to the zero address'
    approved[(480 * arg2) + arg1] = 0
    if not uint256(stor3[(480 * arg2) + arg1].field_0):
        if not stor2[(480 * arg2) + arg1]:
            revert with 0, 
                        32,
                        41,
                        0x724552433732313a206f776e657220717565727920666f72206e6f6e6578697374656e7420746f6b65, mem[265 len 23] >> 72,
                        0
    emit Approval(address(stor3[(480 * arg2) + arg1].field_0), 0, (480 * arg2) + arg1);
    if tokenOfOwnerByIndex[address(this.address)][1][(480 * arg2) + arg1]:
        if tokenOfOwnerByIndex[address(this.address)][1][(480 * arg2) + arg1] < 1:
            revert with 'NH{q', 17
        if tokenOfOwnerByIndex[address(this.address)] < 1:
            revert with 'NH{q', 17
        if tokenOfOwnerByIndex[address(this.address)] - 1 != tokenOfOwnerByIndex[address(this.address)][1][(480 * arg2) + arg1] - 1:
            if tokenOfOwnerByIndex[address(this.address)] - 1 >= tokenOfOwnerByIndex[address(this.address)]:
                revert with 'NH{q', 50
            if tokenOfOwnerByIndex[address(this.address)][1][(480 * arg2) + arg1] - 1 >= tokenOfOwnerByIndex[address(this.address)]:
                revert with 'NH{q', 50
            tokenOfOwnerByIndex[address(this.address)][tokenOfOwnerByIndex[address(this.address)][1][(480 * arg2) + arg1]] = tokenOfOwnerByIndex[address(this.address)][tokenOfOwnerByIndex[address(this.address)]]
            tokenOfOwnerByIndex[address(this.address)][1][tokenOfOwnerByIndex[address(this.address)][tokenOfOwnerByIndex[address(this.address)]]] = tokenOfOwnerByIndex[address(this.address)][1][(480 * arg2) + arg1]
        if not tokenOfOwnerByIndex[address(this.address)]:
            revert with 'NH{q', 49
        tokenOfOwnerByIndex[address(this.address)][tokenOfOwnerByIndex[address(this.address)]] = 0
        tokenOfOwnerByIndex[address(this.address)]--
        tokenOfOwnerByIndex[address(this.address)][1][(480 * arg2) + arg1] = 0
    if not tokenOfOwnerByIndex[address(msg.sender)][1][(480 * arg2) + arg1]:
        tokenOfOwnerByIndex[address(msg.sender)]++
        tokenOfOwnerByIndex[address(msg.sender)][tokenOfOwnerByIndex[address(msg.sender)]] = (480 * arg2) + arg1
        tokenOfOwnerByIndex[address(msg.sender)][1][(480 * arg2) + arg1] = tokenOfOwnerByIndex[address(msg.sender)]
    address(stor3[(480 * arg2) + arg1].field_0) = msg.sender
    Mask(96, 0, stor3[(480 * arg2) + arg1].field_160) = 0
    if not stor2[(480 * arg2) + arg1]:
        tokenByIndex.length++
        tokenByIndex[tokenByIndex.length] = (480 * arg2) + arg1
        stor2[(480 * arg2) + arg1] = tokenByIndex.length
    emit Transfer(this.address, msg.sender, (480 * arg2) + arg1);
    call address(stor13[(480 * arg2) + arg1].field_24) with:
       value 95 * msg.value / 100 wei
         gas 2300 * is_zero(value) wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    Mask(232, 0, stor13[(480 * arg2) + arg1].field_24) = Mask(232, 0, msg.sender)
    stor11[(480 * arg2) + arg1] = msg.value
    emit 0x6fe91cfa: msg.sender, msg.value, arg1, arg2
}

function tokenURI(uint256 arg1) {
    require calldata.size - 4 >= 32
    if not stor2[arg1]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721Metadata: URI query for nonexistent token'
    mem[0] = arg1
    mem[32] = 8
    if bool(stor8[arg1].field_0):
        if bool(stor8[arg1].field_0) == uint255(uint256(stor8[arg1].field_0)) * 0.5 < 32:
            revert with 'NH{q', 34
        mem[96] = uint255(uint256(stor8[arg1].field_0)) * 0.5
        if bool(stor8[arg1].field_0):
            if bool(stor8[arg1].field_0) == uint255(uint256(stor8[arg1].field_0)) * 0.5 < 32:
                revert with 'NH{q', 34
            if not Mask(256, -1, uint256(stor8[arg1].field_0)):
                if bool(stor9.length):
                    if bool(stor9.length) == uint255(stor9.length) * 0.5 < 32:
                        revert with 'NH{q', 34
                    if not uint255(stor9.length) * 0.5:
                        mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192 len ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5)] = mem[128 len ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5)]
                        if ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) > uint255(uint256(stor8[arg1].field_0)) * 0.5:
                            mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192] = 0
                        return Array(len=2 * Mask(256, -1, uint256(stor8[arg1].field_0)), data=mem[128 len ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5)], mem[(2 * ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5)) + 192 len 2 * ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5)]), 
                    if Mask(256, -1, uint256(stor8[arg1].field_0)):
                        if bool(stor9.length):
                            if bool(stor9.length) == uint255(stor9.length) * 0.5 < 32:
                                revert with 'NH{q', 34
                            if not bool(stor9.length):
                                mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160] = Mask(248, 8, stor9.length)
                            else:
                                if bool(stor9.length) != 1:
                                    mem[64] = uint255(uint256(stor8[arg1].field_0)) * 0.5
                                    if ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) <= uint255(uint256(stor8[arg1].field_0)) * 0.5:
                                        _5233 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                                        mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                                        mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 64 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                                        if ceil32(_5233) > _5233:
                                            mem[_5233 + (uint255(uint256(stor8[arg1].field_0)) * 0.5) + 64] = 0
                                        return 32, mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 32 len ceil32(_5233) + 32]
                                    _5234 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                                    mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                                    mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 64 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                                    if ceil32(_5234) > _5234:
                                        mem[_5234 + (uint255(uint256(stor8[arg1].field_0)) * 0.5) + 64] = 0
                                    return 32, mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 32 len ceil32(_5234) + 32]
                                idx = 0
                                s = 0
                                while idx < uint255(stor9.length) * 0.5:
                                    mem[idx + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160] = uint256(stor9[s].field_0)
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                            mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 160 len ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5)] = mem[128 len ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5)]
                            mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 160] = 32
                            mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 192] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                            mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 224 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                            if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]) <= mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]:
                                return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128], data=mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 224 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]), 
                            mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + (uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 224] = 0
                            return 32, mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]) + 32], 
                        if bool(stor9.length) == stor9.length.field_1 % 128 < 32:
                            revert with 'NH{q', 34
                        if not bool(stor9.length):
                            mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160] = Mask(248, 8, stor9.length)
                        else:
                            if bool(stor9.length) != 1:
                                mem[64] = uint255(uint256(stor8[arg1].field_0)) * 0.5
                                if ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) <= uint255(uint256(stor8[arg1].field_0)) * 0.5:
                                    _5237 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                                    mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                                    mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 64 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                                    if ceil32(_5237) > _5237:
                                        mem[_5237 + (uint255(uint256(stor8[arg1].field_0)) * 0.5) + 64] = 0
                                    return 32, mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 32 len ceil32(_5237) + 32]
                                _5238 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                                mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                                mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 64 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                                if ceil32(_5238) > _5238:
                                    mem[_5238 + (uint255(uint256(stor8[arg1].field_0)) * 0.5) + 64] = 0
                                return 32, mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 32 len ceil32(_5238) + 32]
                            idx = 0
                            s = 0
                            while idx < stor9.length.field_1 % 128:
                                mem[idx + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160] = uint256(stor9[s].field_0)
                                idx = idx + 32
                                s = s + 1
                                continue 
                        mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 160 len ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5)] = mem[128 len ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5)]
                        mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 160] = 32
                        mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 192] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                        mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 224 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                        if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]) <= mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]:
                            return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128], data=mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 224 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]), 
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + (uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 224] = 0
                        return 32, mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]) + 32], 
                    if not arg1:
                        mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] = 1
                        mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160] = '0'
                        if bool(stor9.length):
                            if bool(stor9.length) == uint255(stor9.length) * 0.5 < 32:
                                revert with 'NH{q', 34
                            if not bool(stor9.length):
                                mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 224] = Mask(248, 8, stor9.length)
                            else:
                                if bool(stor9.length) != 1:
                                    mem[64] = 1
                                    _5226 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192]
                                    mem[33] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192]
                                    mem[65 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 224 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192])]
                                    if ceil32(_5226) > _5226:
                                        mem[_5226 + 65] = 0
                                    return memory
                                      from mem[64]
                                       len ceil32(_5226) + -mem[64] + 65
                                idx = 0
                                s = 0
                                while idx < uint255(stor9.length) * 0.5:
                                    mem[idx + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 224] = uint256(stor9[s].field_0)
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                            mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 224] = '0'
                            mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 225] = 32
                            mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 257] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192]
                            mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 289 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 224 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192])]
                            if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192]) > mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192]:
                                mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 289] = 0
                            return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192], data=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 289 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192])]), 
                        if bool(stor9.length) == stor9.length.field_1 % 128 < 32:
                            revert with 'NH{q', 34
                        if not bool(stor9.length):
                            mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 224] = Mask(248, 8, stor9.length)
                        else:
                            if bool(stor9.length) != 1:
                                mem[64] = 1
                                _5230 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192]
                                mem[33] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192]
                                mem[65 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 224 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192])]
                                if ceil32(_5230) > _5230:
                                    mem[_5230 + 65] = 0
                                return memory
                                  from mem[64]
                                   len ceil32(_5230) + -mem[64] + 65
                            idx = 0
                            s = 0
                            while idx < stor9.length.field_1 % 128:
                                mem[idx + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 224] = uint256(stor9[s].field_0)
                                idx = idx + 32
                                s = s + 1
                                continue 
                        mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 224] = '0'
                        mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 225] = 32
                        mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 257] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192]
                        mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 289 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 224 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192])]
                        if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192]) > mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192]:
                            mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 289] = 0
                        return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192], data=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 289 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192])]), 
                    s = 0
                    idx = arg1
                    while idx:
                        if s == -1:
                            revert with 'NH{q', 17
                        s = s + 1
                        idx = idx / 10
                        continue 
                    if s > test266151307():
                        revert with 'NH{q', 65
                    mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] = s
                    if not s:
                        t = s
                        idx = arg1
                        while idx:
                            if t < 1:
                                revert with 'NH{q', 17
                            if 48 > !(idx % 10):
                                revert with 'NH{q', 17
                            if t - 1 >= mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]:
                                revert with 'NH{q', 50
                            mem[t + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 159 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
                            t = t - 1
                            idx = idx / 10
                            continue 
                        if bool(stor9.length):
                            if bool(stor9.length) == uint255(stor9.length) * 0.5 < 32:
                                revert with 'NH{q', 34
                            if not bool(stor9.length):
                                mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192] = Mask(248, 8, stor9.length)
                                mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                                mem[64] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192
                                mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192] = 32
                                mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 224] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                                mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]
                                if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]) > mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]:
                                    mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160] + mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256] = 0
                                return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160], data=mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]), 
                            if bool(stor9.length) == 1:
                                mem[0] = 9
                                idx = 0
                                t = 0
                                while idx < uint255(stor9.length) * 0.5:
                                    mem[idx + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192] = uint256(stor9[t].field_0)
                                    idx = idx + 32
                                    t = t + 1
                                    continue 
                                mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                                mem[64] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192
                                mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192] = 32
                                mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 224] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                                mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]
                                if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]) > mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]:
                                    mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160] + mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256] = 0
                                return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160], data=mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]), 
                            _13147 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                            mem[0 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                            mem[64] = _13147
                            mem[_13147] = 32
                            if ceil32(_13147) <= _13147:
                                _20109 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                                mem[_13147 + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                                mem[_13147 + 64 len ceil32(_20109)] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(_20109)]
                                if ceil32(_20109) > _20109:
                                    mem[_20109 + _13147 + 64] = 0
                                return 32, mem[_13147 + 32 len ceil32(_20109) + 32]
                            _20110 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                            mem[_13147 + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                            mem[_13147 + 64 len ceil32(_20110)] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(_20110)]
                            if ceil32(_20110) > _20110:
                                mem[_20110 + _13147 + 64] = 0
                            return 32, mem[_13147 + 32 len ceil32(_20110) + 32]
                        if bool(stor9.length) == stor9.length.field_1 % 128 < 32:
                            revert with 'NH{q', 34
                        if not bool(stor9.length):
                            mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192] = Mask(248, 8, stor9.length)
                            mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                            mem[64] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192
                            mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192] = 32
                            mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 224] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                            mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]
                            if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]) > mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]:
                                mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160] + mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256] = 0
                            return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160], data=mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]), 
                        if bool(stor9.length) == 1:
                            mem[0] = 9
                            idx = 0
                            t = 0
                            while idx < stor9.length.field_1 % 128:
                                mem[idx + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192] = uint256(stor9[t].field_0)
                                idx = idx + 32
                                t = t + 1
                                continue 
                            mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                            mem[64] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192
                            mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192] = 32
                            mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 224] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                            mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]
                            if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]) > mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]:
                                mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160] + mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256] = 0
                            return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160], data=mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]), 
                        _13211 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                        mem[0 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                        mem[64] = _13211
                        mem[_13211] = 32
                        if ceil32(_13211) <= _13211:
                            _20113 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                            mem[_13211 + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                            mem[_13211 + 64 len ceil32(_20113)] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(_20113)]
                            if ceil32(_20113) > _20113:
                                mem[_20113 + _13211 + 64] = 0
                            return 32, mem[_13211 + 32 len ceil32(_20113) + 32]
                        _20114 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                        mem[_13211 + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                        mem[_13211 + 64 len ceil32(_20114)] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(_20114)]
                        if ceil32(_20114) > _20114:
                            mem[_20114 + _13211 + 64] = 0
                        return 32, mem[_13211 + 32 len ceil32(_20114) + 32]
                    mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len s] = call.data[calldata.size len s]
                    t = s
                    idx = arg1
                    while idx:
                        if t < 1:
                            revert with 'NH{q', 17
                        if 48 > !(idx % 10):
                            revert with 'NH{q', 17
                        if t - 1 >= mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]:
                            revert with 'NH{q', 50
                        mem[t + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 159 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
                        t = t - 1
                        idx = idx / 10
                        continue 
                    if bool(stor9.length):
                        if bool(stor9.length) == uint255(stor9.length) * 0.5 < 32:
                            revert with 'NH{q', 34
                        if not bool(stor9.length):
                            mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192] = Mask(248, 8, stor9.length)
                            mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                            mem[64] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192
                            mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192] = 32
                            mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 224] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                            mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]
                            if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]) > mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]:
                                mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160] + mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256] = 0
                            return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160], data=mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]), 
                        if bool(stor9.length) == 1:
                            mem[0] = 9
                            idx = 0
                            t = 0
                            while idx < uint255(stor9.length) * 0.5:
                                mem[idx + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192] = uint256(stor9[t].field_0)
                                idx = idx + 32
                                t = t + 1
                                continue 
                            mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                            mem[64] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192
                            mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192] = 32
                            mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 224] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                            mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]
                            if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]) > mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]:
                                mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160] + mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256] = 0
                            return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160], data=mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]), 
                        _13149 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                        mem[0 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                        mem[64] = _13149
                        mem[_13149] = 32
                        if ceil32(_13149) <= _13149:
                            _20117 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                            mem[_13149 + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                            mem[_13149 + 64 len ceil32(_20117)] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(_20117)]
                            if ceil32(_20117) > _20117:
                                mem[_20117 + _13149 + 64] = 0
                            return 32, mem[_13149 + 32 len ceil32(_20117) + 32]
                        _20118 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                        mem[_13149 + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                        mem[_13149 + 64 len ceil32(_20118)] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(_20118)]
                        if ceil32(_20118) > _20118:
                            mem[_20118 + _13149 + 64] = 0
                        return 32, mem[_13149 + 32 len ceil32(_20118) + 32]
                    if bool(stor9.length) == stor9.length.field_1 % 128 < 32:
                        revert with 'NH{q', 34
                    if not bool(stor9.length):
                        mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192] = Mask(248, 8, stor9.length)
                        mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                        mem[64] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192] = 32
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 224] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]
                        if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]) > mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]:
                            mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160] + mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256] = 0
                        return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160], data=mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]), 
                    if bool(stor9.length) == 1:
                        mem[0] = 9
                        idx = 0
                        t = 0
                        while idx < stor9.length.field_1 % 128:
                            mem[idx + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192] = uint256(stor9[t].field_0)
                            idx = idx + 32
                            t = t + 1
                            continue 
                        mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                        mem[64] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192] = 32
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 224] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]
                        if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]) > mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]:
                            mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160] + mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256] = 0
                        return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160], data=mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]), 
                    _13213 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                    mem[0 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                    mem[64] = _13213
                    mem[_13213] = 32
                    if ceil32(_13213) <= _13213:
                        _20121 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                        mem[_13213 + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                        mem[_13213 + 64 len ceil32(_20121)] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(_20121)]
                        if ceil32(_20121) > _20121:
                            mem[_20121 + _13213 + 64] = 0
                        return 32, mem[_13213 + 32 len ceil32(_20121) + 32]
                    _20122 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                    mem[_13213 + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                    mem[_13213 + 64 len ceil32(_20122)] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(_20122)]
                    if ceil32(_20122) > _20122:
                        mem[_20122 + _13213 + 64] = 0
                    return 32, mem[_13213 + 32 len ceil32(_20122) + 32]
                if bool(stor9.length) == stor9.length.field_1 % 128 < 32:
                    revert with 'NH{q', 34
                if not stor9.length.field_1 % 128:
                    mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192 len ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5)] = mem[128 len ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5)]
                    if ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) > uint255(uint256(stor8[arg1].field_0)) * 0.5:
                        mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192] = 0
                    return Array(len=2 * Mask(256, -1, uint256(stor8[arg1].field_0)), data=mem[128 len ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5)], mem[(2 * ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5)) + 192 len 2 * ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5)]), 
                if Mask(256, -1, uint256(stor8[arg1].field_0)):
                    if bool(stor9.length):
                        if bool(stor9.length) == uint255(stor9.length) * 0.5 < 32:
                            revert with 'NH{q', 34
                        if not bool(stor9.length):
                            mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160] = Mask(248, 8, stor9.length)
                        else:
                            if bool(stor9.length) != 1:
                                mem[64] = uint255(uint256(stor8[arg1].field_0)) * 0.5
                                if ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) <= uint255(uint256(stor8[arg1].field_0)) * 0.5:
                                    _5249 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                                    mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                                    mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 64 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                                    if ceil32(_5249) > _5249:
                                        mem[_5249 + (uint255(uint256(stor8[arg1].field_0)) * 0.5) + 64] = 0
                                    return 32, mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 32 len ceil32(_5249) + 32]
                                _5250 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                                mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                                mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 64 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                                if ceil32(_5250) > _5250:
                                    mem[_5250 + (uint255(uint256(stor8[arg1].field_0)) * 0.5) + 64] = 0
                                return 32, mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 32 len ceil32(_5250) + 32]
                            idx = 0
                            s = 0
                            while idx < uint255(stor9.length) * 0.5:
                                mem[idx + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160] = uint256(stor9[s].field_0)
                                idx = idx + 32
                                s = s + 1
                                continue 
                        mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 160 len ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5)] = mem[128 len ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5)]
                        mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 160] = 32
                        mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 192] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                        mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 224 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                        if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]) <= mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]:
                            return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128], data=mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 224 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]), 
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + (uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 224] = 0
                        return 32, mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]) + 32], 
                    if bool(stor9.length) == stor9.length.field_1 % 128 < 32:
                        revert with 'NH{q', 34
                    if not bool(stor9.length):
                        mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160] = Mask(248, 8, stor9.length)
                    else:
                        if bool(stor9.length) != 1:
                            mem[64] = uint255(uint256(stor8[arg1].field_0)) * 0.5
                            if ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) <= uint255(uint256(stor8[arg1].field_0)) * 0.5:
                                _5253 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                                mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                                mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 64 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                                if ceil32(_5253) > _5253:
                                    mem[_5253 + (uint255(uint256(stor8[arg1].field_0)) * 0.5) + 64] = 0
                                return 32, mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 32 len ceil32(_5253) + 32]
                            _5254 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                            mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                            mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 64 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                            if ceil32(_5254) > _5254:
                                mem[_5254 + (uint255(uint256(stor8[arg1].field_0)) * 0.5) + 64] = 0
                            return 32, mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 32 len ceil32(_5254) + 32]
                        idx = 0
                        s = 0
                        while idx < stor9.length.field_1 % 128:
                            mem[idx + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160] = uint256(stor9[s].field_0)
                            idx = idx + 32
                            s = s + 1
                            continue 
                    mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 160 len ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5)] = mem[128 len ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5)]
                    mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 160] = 32
                    mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 192] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                    mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 224 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                    if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]) <= mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]:
                        return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128], data=mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 224 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]), 
                    mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + (uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 224] = 0
                    return 32, mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]) + 32], 
                if not arg1:
                    mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] = 1
                    mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160] = '0'
                    if bool(stor9.length):
                        if bool(stor9.length) == uint255(stor9.length) * 0.5 < 32:
                            revert with 'NH{q', 34
                        if not bool(stor9.length):
                            mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 224] = Mask(248, 8, stor9.length)
                        else:
                            if bool(stor9.length) != 1:
                                mem[64] = 1
                                _5242 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192]
                                mem[33] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192]
                                mem[65 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 224 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192])]
                                if ceil32(_5242) > _5242:
                                    mem[_5242 + 65] = 0
                                return memory
                                  from mem[64]
                                   len ceil32(_5242) + -mem[64] + 65
                            idx = 0
                            s = 0
                            while idx < uint255(stor9.length) * 0.5:
                                mem[idx + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 224] = uint256(stor9[s].field_0)
                                idx = idx + 32
                                s = s + 1
                                continue 
                        mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 224] = '0'
                        mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 225] = 32
                        mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 257] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192]
                        mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 289 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 224 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192])]
                        if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192]) > mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192]:
                            mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 289] = 0
                        return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192], data=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 289 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192])]), 
                    if bool(stor9.length) == stor9.length.field_1 % 128 < 32:
                        revert with 'NH{q', 34
                    if not bool(stor9.length):
                        mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 224] = Mask(248, 8, stor9.length)
                    else:
                        if bool(stor9.length) != 1:
                            mem[64] = 1
                            _5246 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192]
                            mem[33] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192]
                            mem[65 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 224 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192])]
                            if ceil32(_5246) > _5246:
                                mem[_5246 + 65] = 0
                            return memory
                              from mem[64]
                               len ceil32(_5246) + -mem[64] + 65
                        idx = 0
                        s = 0
                        while idx < stor9.length.field_1 % 128:
                            mem[idx + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 224] = uint256(stor9[s].field_0)
                            idx = idx + 32
                            s = s + 1
                            continue 
                    mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 224] = '0'
                    mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 225] = 32
                    mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 257] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192]
                    mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 289 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 224 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192])]
                    if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192]) > mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192]:
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 289] = 0
                    return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192], data=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 289 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192])]), 
                s = 0
                idx = arg1
                while idx:
                    if s == -1:
                        revert with 'NH{q', 17
                    s = s + 1
                    idx = idx / 10
                    continue 
                if s > test266151307():
                    revert with 'NH{q', 65
                mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] = s
                if not s:
                    t = s
                    idx = arg1
                    while idx:
                        if t < 1:
                            revert with 'NH{q', 17
                        if 48 > !(idx % 10):
                            revert with 'NH{q', 17
                        if t - 1 >= mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]:
                            revert with 'NH{q', 50
                        mem[t + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 159 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
                        t = t - 1
                        idx = idx / 10
                        continue 
                    if bool(stor9.length):
                        if bool(stor9.length) == uint255(stor9.length) * 0.5 < 32:
                            revert with 'NH{q', 34
                        if not bool(stor9.length):
                            mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192] = Mask(248, 8, stor9.length)
                            mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                            mem[64] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192
                            mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192] = 32
                            mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 224] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                            mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]
                            if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]) > mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]:
                                mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160] + mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256] = 0
                            return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160], data=mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]), 
                        if bool(stor9.length) == 1:
                            mem[0] = 9
                            idx = 0
                            t = 0
                            while idx < uint255(stor9.length) * 0.5:
                                mem[idx + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192] = uint256(stor9[t].field_0)
                                idx = idx + 32
                                t = t + 1
                                continue 
                            mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                            mem[64] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192
                            mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192] = 32
                            mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 224] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                            mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]
                            if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]) > mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]:
                                mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160] + mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256] = 0
                            return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160], data=mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]), 
                        _13151 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                        mem[0 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                        mem[64] = _13151
                        mem[_13151] = 32
                        if ceil32(_13151) <= _13151:
                            _20125 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                            mem[_13151 + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                            mem[_13151 + 64 len ceil32(_20125)] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(_20125)]
                            if ceil32(_20125) > _20125:
                                mem[_20125 + _13151 + 64] = 0
                            return 32, mem[_13151 + 32 len ceil32(_20125) + 32]
                        _20126 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                        mem[_13151 + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                        mem[_13151 + 64 len ceil32(_20126)] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(_20126)]
                        if ceil32(_20126) > _20126:
                            mem[_20126 + _13151 + 64] = 0
                        return 32, mem[_13151 + 32 len ceil32(_20126) + 32]
                    if bool(stor9.length) == stor9.length.field_1 % 128 < 32:
                        revert with 'NH{q', 34
                    if not bool(stor9.length):
                        mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192] = Mask(248, 8, stor9.length)
                        mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                        mem[64] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192] = 32
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 224] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]
                        if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]) > mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]:
                            mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160] + mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256] = 0
                        return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160], data=mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]), 
                    if bool(stor9.length) == 1:
                        mem[0] = 9
                        idx = 0
                        t = 0
                        while idx < stor9.length.field_1 % 128:
                            mem[idx + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192] = uint256(stor9[t].field_0)
                            idx = idx + 32
                            t = t + 1
                            continue 
                        mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                        mem[64] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192] = 32
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 224] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]
                        if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]) > mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]:
                            mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160] + mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256] = 0
                        return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160], data=mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]), 
                    _13215 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                    mem[0 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                    mem[64] = _13215
                    mem[_13215] = 32
                    if ceil32(_13215) <= _13215:
                        _20129 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                        mem[_13215 + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                        mem[_13215 + 64 len ceil32(_20129)] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(_20129)]
                        if ceil32(_20129) > _20129:
                            mem[_20129 + _13215 + 64] = 0
                        return 32, mem[_13215 + 32 len ceil32(_20129) + 32]
                    _20130 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                    mem[_13215 + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                    mem[_13215 + 64 len ceil32(_20130)] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(_20130)]
                    if ceil32(_20130) > _20130:
                        mem[_20130 + _13215 + 64] = 0
                    return 32, mem[_13215 + 32 len ceil32(_20130) + 32]
                mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len s] = call.data[calldata.size len s]
                t = s
                idx = arg1
                while idx:
                    if t < 1:
                        revert with 'NH{q', 17
                    if 48 > !(idx % 10):
                        revert with 'NH{q', 17
                    if t - 1 >= mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]:
                        revert with 'NH{q', 50
                    mem[t + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 159 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
                    t = t - 1
                    idx = idx / 10
                    continue 
                if bool(stor9.length):
                    if bool(stor9.length) == uint255(stor9.length) * 0.5 < 32:
                        revert with 'NH{q', 34
                    if not bool(stor9.length):
                        mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192] = Mask(248, 8, stor9.length)
                        mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                        mem[64] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192] = 32
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 224] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]
                        if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]) > mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]:
                            mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160] + mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256] = 0
                        return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160], data=mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]), 
                    if bool(stor9.length) == 1:
                        mem[0] = 9
                        idx = 0
                        t = 0
                        while idx < uint255(stor9.length) * 0.5:
                            mem[idx + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192] = uint256(stor9[t].field_0)
                            idx = idx + 32
                            t = t + 1
                            continue 
                        mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                        mem[64] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192] = 32
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 224] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]
                        if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]) > mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]:
                            mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160] + mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256] = 0
                        return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160], data=mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]), 
                    _13153 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                    mem[0 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                    mem[64] = _13153
                    mem[_13153] = 32
                    if ceil32(_13153) <= _13153:
                        _20133 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                        mem[_13153 + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                        mem[_13153 + 64 len ceil32(_20133)] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(_20133)]
                        if ceil32(_20133) > _20133:
                            mem[_20133 + _13153 + 64] = 0
                        return 32, mem[_13153 + 32 len ceil32(_20133) + 32]
                    _20134 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                    mem[_13153 + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                    mem[_13153 + 64 len ceil32(_20134)] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(_20134)]
                    if ceil32(_20134) > _20134:
                        mem[_20134 + _13153 + 64] = 0
                    return 32, mem[_13153 + 32 len ceil32(_20134) + 32]
                if bool(stor9.length) == stor9.length.field_1 % 128 < 32:
                    revert with 'NH{q', 34
                if not bool(stor9.length):
                    mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192] = Mask(248, 8, stor9.length)
                    mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                    mem[64] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192
                    mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192] = 32
                    mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 224] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                    mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]
                    if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]) > mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]:
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160] + mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256] = 0
                    return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160], data=mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]), 
                if bool(stor9.length) == 1:
                    mem[0] = 9
                    idx = 0
                    t = 0
                    while idx < stor9.length.field_1 % 128:
                        mem[idx + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192] = uint256(stor9[t].field_0)
                        idx = idx + 32
                        t = t + 1
                        continue 
                    mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                    mem[64] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192
                    mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192] = 32
                    mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 224] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                    mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]
                    if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]) > mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]:
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160] + mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256] = 0
                    return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160], data=mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]), 
                _13217 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                mem[0 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                mem[64] = _13217
                mem[_13217] = 32
                if ceil32(_13217) <= _13217:
                    _20137 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                    mem[_13217 + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                    mem[_13217 + 64 len ceil32(_20137)] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(_20137)]
                    if ceil32(_20137) > _20137:
                        mem[_20137 + _13217 + 64] = 0
                    return 32, mem[_13217 + 32 len ceil32(_20137) + 32]
                _20138 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                mem[_13217 + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                mem[_13217 + 64 len ceil32(_20138)] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(_20138)]
                if ceil32(_20138) > _20138:
                    mem[_20138 + _13217 + 64] = 0
                return 32, mem[_13217 + 32 len ceil32(_20138) + 32]
            if 31 >= uint255(uint256(stor8[arg1].field_0)) * 0.5:
                mem[128] = 256 * Mask(248, 0, stor8[arg1].field_8)
                if bool(stor9.length):
                    if bool(stor9.length) == uint255(stor9.length) * 0.5 < 32:
                        revert with 'NH{q', 34
                    if not uint255(stor9.length) * 0.5:
                        mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192 len ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5)] = mem[128 len ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5)]
                        if ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) > uint255(uint256(stor8[arg1].field_0)) * 0.5:
                            mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192] = 0
                        return Array(len=2 * Mask(256, -1, uint256(stor8[arg1].field_0)), data=mem[128 len ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5)], mem[(2 * ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5)) + 192 len 2 * ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5)]), 
                    if Mask(256, -1, uint256(stor8[arg1].field_0)):
                        if bool(stor9.length):
                            if bool(stor9.length) == uint255(stor9.length) * 0.5 < 32:
                                revert with 'NH{q', 34
                            if not bool(stor9.length):
                                mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160] = Mask(248, 8, stor9.length)
                            else:
                                if bool(stor9.length) != 1:
                                    mem[64] = uint255(uint256(stor8[arg1].field_0)) * 0.5
                                    if ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) <= uint255(uint256(stor8[arg1].field_0)) * 0.5:
                                        _5268 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                                        mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                                        mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 64 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                                        if ceil32(_5268) > _5268:
                                            mem[_5268 + (uint255(uint256(stor8[arg1].field_0)) * 0.5) + 64] = 0
                                        return 32, mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 32 len ceil32(_5268) + 32]
                                    _5269 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                                    mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                                    mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 64 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                                    if ceil32(_5269) > _5269:
                                        mem[_5269 + (uint255(uint256(stor8[arg1].field_0)) * 0.5) + 64] = 0
                                    return 32, mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 32 len ceil32(_5269) + 32]
                                idx = 0
                                s = 0
                                while idx < uint255(stor9.length) * 0.5:
                                    mem[idx + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160] = uint256(stor9[s].field_0)
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                            mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 160 len ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5)] = mem[128 len ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5)]
                            mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 160] = 32
                            mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 192] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                            mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 224 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                            if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]) <= mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]:
                                return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128], data=mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 224 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]), 
                            mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + (uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 224] = 0
                            return 32, mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]) + 32], 
                        if bool(stor9.length) == stor9.length.field_1 % 128 < 32:
                            revert with 'NH{q', 34
                        if not bool(stor9.length):
                            mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160] = Mask(248, 8, stor9.length)
                        else:
                            if bool(stor9.length) != 1:
                                mem[64] = uint255(uint256(stor8[arg1].field_0)) * 0.5
                                if ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) <= uint255(uint256(stor8[arg1].field_0)) * 0.5:
                                    _5272 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                                    mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                                    mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 64 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                                    if ceil32(_5272) > _5272:
                                        mem[_5272 + (uint255(uint256(stor8[arg1].field_0)) * 0.5) + 64] = 0
                                    return 32, mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 32 len ceil32(_5272) + 32]
                                _5273 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                                mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                                mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 64 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                                if ceil32(_5273) > _5273:
                                    mem[_5273 + (uint255(uint256(stor8[arg1].field_0)) * 0.5) + 64] = 0
                                return 32, mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 32 len ceil32(_5273) + 32]
                            idx = 0
                            s = 0
                            while idx < stor9.length.field_1 % 128:
                                mem[idx + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160] = uint256(stor9[s].field_0)
                                idx = idx + 32
                                s = s + 1
                                continue 
                        mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 160 len ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5)] = mem[128 len ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5)]
                        mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 160] = 32
                        mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 192] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                        mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 224 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                        if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]) <= mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]:
                            return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128], data=mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 224 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]), 
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + (uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 224] = 0
                        return 32, mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]) + 32], 
                    if not arg1:
                        mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] = 1
                        mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160] = '0'
                        if bool(stor9.length):
                            if bool(stor9.length) == uint255(stor9.length) * 0.5 < 32:
                                revert with 'NH{q', 34
                            if not bool(stor9.length):
                                mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 224] = Mask(248, 8, stor9.length)
                            else:
                                if bool(stor9.length) != 1:
                                    mem[64] = 1
                                    _5261 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192]
                                    mem[33] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192]
                                    mem[65 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 224 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192])]
                                    if ceil32(_5261) > _5261:
                                        mem[_5261 + 65] = 0
                                    return memory
                                      from mem[64]
                                       len ceil32(_5261) + -mem[64] + 65
                                idx = 0
                                s = 0
                                while idx < uint255(stor9.length) * 0.5:
                                    mem[idx + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 224] = uint256(stor9[s].field_0)
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                            mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 224] = '0'
                            mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 225] = 32
                            mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 257] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192]
                            mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 289 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 224 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192])]
                            if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192]) > mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192]:
                                mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 289] = 0
                            return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192], data=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 289 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192])]), 
                        if bool(stor9.length) == stor9.length.field_1 % 128 < 32:
                            revert with 'NH{q', 34
                        if not bool(stor9.length):
                            mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 224] = Mask(248, 8, stor9.length)
                        else:
                            if bool(stor9.length) != 1:
                                mem[64] = 1
                                _5265 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192]
                                mem[33] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192]
                                mem[65 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 224 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192])]
                                if ceil32(_5265) > _5265:
                                    mem[_5265 + 65] = 0
                                return memory
                                  from mem[64]
                                   len ceil32(_5265) + -mem[64] + 65
                            idx = 0
                            s = 0
                            while idx < stor9.length.field_1 % 128:
                                mem[idx + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 224] = uint256(stor9[s].field_0)
                                idx = idx + 32
                                s = s + 1
                                continue 
                        mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 224] = '0'
                        mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 225] = 32
                        mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 257] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192]
                        mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 289 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 224 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192])]
                        if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192]) > mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192]:
                            mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 289] = 0
                        return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192], data=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 289 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192])]), 
                    s = 0
                    idx = arg1
                    while idx:
                        if s == -1:
                            revert with 'NH{q', 17
                        s = s + 1
                        idx = idx / 10
                        continue 
                    if s > test266151307():
                        revert with 'NH{q', 65
                    mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] = s
                    if not s:
                        t = s
                        idx = arg1
                        while idx:
                            if t < 1:
                                revert with 'NH{q', 17
                            if 48 > !(idx % 10):
                                revert with 'NH{q', 17
                            if t - 1 >= mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]:
                                revert with 'NH{q', 50
                            mem[t + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 159 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
                            t = t - 1
                            idx = idx / 10
                            continue 
                        if bool(stor9.length):
                            if bool(stor9.length) == uint255(stor9.length) * 0.5 < 32:
                                revert with 'NH{q', 34
                            if not bool(stor9.length):
                                mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192] = Mask(248, 8, stor9.length)
                                mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                                mem[64] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192
                                mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192] = 32
                                mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 224] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                                mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]
                                if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]) > mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]:
                                    mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160] + mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256] = 0
                                return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160], data=mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]), 
                            if bool(stor9.length) == 1:
                                mem[0] = 9
                                idx = 0
                                t = 0
                                while idx < uint255(stor9.length) * 0.5:
                                    mem[idx + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192] = uint256(stor9[t].field_0)
                                    idx = idx + 32
                                    t = t + 1
                                    continue 
                                mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                                mem[64] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192
                                mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192] = 32
                                mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 224] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                                mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]
                                if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]) > mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]:
                                    mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160] + mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256] = 0
                                return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160], data=mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]), 
                            _13155 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                            mem[0 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                            mem[64] = _13155
                            mem[_13155] = 32
                            if ceil32(_13155) <= _13155:
                                _20165 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                                mem[_13155 + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                                mem[_13155 + 64 len ceil32(_20165)] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(_20165)]
                                if ceil32(_20165) > _20165:
                                    mem[_20165 + _13155 + 64] = 0
                                return 32, mem[_13155 + 32 len ceil32(_20165) + 32]
                            _20166 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                            mem[_13155 + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                            mem[_13155 + 64 len ceil32(_20166)] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(_20166)]
                            if ceil32(_20166) > _20166:
                                mem[_20166 + _13155 + 64] = 0
                            return 32, mem[_13155 + 32 len ceil32(_20166) + 32]
                        if bool(stor9.length) == stor9.length.field_1 % 128 < 32:
                            revert with 'NH{q', 34
                        if not bool(stor9.length):
                            mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192] = Mask(248, 8, stor9.length)
                            mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                            mem[64] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192
                            mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192] = 32
                            mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 224] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                            mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]
                            if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]) > mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]:
                                mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160] + mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256] = 0
                            return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160], data=mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]), 
                        if bool(stor9.length) == 1:
                            mem[0] = 9
                            idx = 0
                            t = 0
                            while idx < stor9.length.field_1 % 128:
                                mem[idx + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192] = uint256(stor9[t].field_0)
                                idx = idx + 32
                                t = t + 1
                                continue 
                            mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                            mem[64] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192
                            mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192] = 32
                            mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 224] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                            mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]
                            if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]) > mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]:
                                mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160] + mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256] = 0
                            return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160], data=mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]), 
                        _13235 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                        mem[0 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                        mem[64] = _13235
                        mem[_13235] = 32
                        if ceil32(_13235) <= _13235:
                            _20169 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                            mem[_13235 + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                            mem[_13235 + 64 len ceil32(_20169)] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(_20169)]
                            if ceil32(_20169) > _20169:
                                mem[_20169 + _13235 + 64] = 0
                            return 32, mem[_13235 + 32 len ceil32(_20169) + 32]
                        _20170 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                        mem[_13235 + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                        mem[_13235 + 64 len ceil32(_20170)] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(_20170)]
                        if ceil32(_20170) > _20170:
                            mem[_20170 + _13235 + 64] = 0
                        return 32, mem[_13235 + 32 len ceil32(_20170) + 32]
                    mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len s] = call.data[calldata.size len s]
                    t = s
                    idx = arg1
                    while idx:
                        if t < 1:
                            revert with 'NH{q', 17
                        if 48 > !(idx % 10):
                            revert with 'NH{q', 17
                        if t - 1 >= mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]:
                            revert with 'NH{q', 50
                        mem[t + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 159 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
                        t = t - 1
                        idx = idx / 10
                        continue 
                    if bool(stor9.length):
                        if bool(stor9.length) == uint255(stor9.length) * 0.5 < 32:
                            revert with 'NH{q', 34
                        if not bool(stor9.length):
                            mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192] = Mask(248, 8, stor9.length)
                            mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                            mem[64] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192
                            mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192] = 32
                            mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 224] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                            mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]
                            if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]) > mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]:
                                mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160] + mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256] = 0
                            return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160], data=mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]), 
                        if bool(stor9.length) == 1:
                            mem[0] = 9
                            idx = 0
                            t = 0
                            while idx < uint255(stor9.length) * 0.5:
                                mem[idx + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192] = uint256(stor9[t].field_0)
                                idx = idx + 32
                                t = t + 1
                                continue 
                            mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                            mem[64] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192
                            mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192] = 32
                            mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 224] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                            mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]
                            if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]) > mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]:
                                mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160] + mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256] = 0
                            return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160], data=mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]), 
                        _13157 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                        mem[0 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                        mem[64] = _13157
                        mem[_13157] = 32
                        if ceil32(_13157) <= _13157:
                            _20173 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                            mem[_13157 + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                            mem[_13157 + 64 len ceil32(_20173)] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(_20173)]
                            if ceil32(_20173) > _20173:
                                mem[_20173 + _13157 + 64] = 0
                            return 32, mem[_13157 + 32 len ceil32(_20173) + 32]
                        _20174 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                        mem[_13157 + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                        mem[_13157 + 64 len ceil32(_20174)] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(_20174)]
                        if ceil32(_20174) > _20174:
                            mem[_20174 + _13157 + 64] = 0
                        return 32, mem[_13157 + 32 len ceil32(_20174) + 32]
                    if bool(stor9.length) == stor9.length.field_1 % 128 < 32:
                        revert with 'NH{q', 34
                    if not bool(stor9.length):
                        mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192] = Mask(248, 8, stor9.length)
                        mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                        mem[64] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192] = 32
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 224] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]
                        if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]) > mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]:
                            mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160] + mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256] = 0
                        return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160], data=mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]), 
                    if bool(stor9.length) == 1:
                        mem[0] = 9
                        idx = 0
                        t = 0
                        while idx < stor9.length.field_1 % 128:
                            mem[idx + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192] = uint256(stor9[t].field_0)
                            idx = idx + 32
                            t = t + 1
                            continue 
                        mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                        mem[64] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192] = 32
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 224] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]
                        if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]) > mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]:
                            mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160] + mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256] = 0
                        return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160], data=mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]), 
                    _13237 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                    mem[0 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                    mem[64] = _13237
                    mem[_13237] = 32
                    if ceil32(_13237) <= _13237:
                        _20177 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                        mem[_13237 + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                        mem[_13237 + 64 len ceil32(_20177)] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(_20177)]
                        if ceil32(_20177) > _20177:
                            mem[_20177 + _13237 + 64] = 0
                        return 32, mem[_13237 + 32 len ceil32(_20177) + 32]
                    _20178 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                    mem[_13237 + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                    mem[_13237 + 64 len ceil32(_20178)] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(_20178)]
                    if ceil32(_20178) > _20178:
                        mem[_20178 + _13237 + 64] = 0
                    return 32, mem[_13237 + 32 len ceil32(_20178) + 32]
                if bool(stor9.length) == stor9.length.field_1 % 128 < 32:
                    revert with 'NH{q', 34
                if not stor9.length.field_1 % 128:
                    mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192 len ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5)] = mem[128 len ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5)]
                    if ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) > uint255(uint256(stor8[arg1].field_0)) * 0.5:
                        mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192] = 0
                    return Array(len=2 * Mask(256, -1, uint256(stor8[arg1].field_0)), data=mem[128 len ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5)], mem[(2 * ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5)) + 192 len 2 * ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5)]), 
                if Mask(256, -1, uint256(stor8[arg1].field_0)):
                    if bool(stor9.length):
                        if bool(stor9.length) == uint255(stor9.length) * 0.5 < 32:
                            revert with 'NH{q', 34
                        if not bool(stor9.length):
                            mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160] = Mask(248, 8, stor9.length)
                        else:
                            if bool(stor9.length) != 1:
                                mem[64] = uint255(uint256(stor8[arg1].field_0)) * 0.5
                                if ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) <= uint255(uint256(stor8[arg1].field_0)) * 0.5:
                                    _5284 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                                    mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                                    mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 64 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                                    if ceil32(_5284) > _5284:
                                        mem[_5284 + (uint255(uint256(stor8[arg1].field_0)) * 0.5) + 64] = 0
                                    return 32, mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 32 len ceil32(_5284) + 32]
                                _5285 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                                mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                                mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 64 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                                if ceil32(_5285) > _5285:
                                    mem[_5285 + (uint255(uint256(stor8[arg1].field_0)) * 0.5) + 64] = 0
                                return 32, mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 32 len ceil32(_5285) + 32]
                            idx = 0
                            s = 0
                            while idx < uint255(stor9.length) * 0.5:
                                mem[idx + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160] = uint256(stor9[s].field_0)
                                idx = idx + 32
                                s = s + 1
                                continue 
                        mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 160 len ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5)] = mem[128 len ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5)]
                        mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 160] = 32
                        mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 192] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                        mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 224 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                        if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]) <= mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]:
                            return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128], data=mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 224 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]), 
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + (uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 224] = 0
                        return 32, mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]) + 32], 
                    if bool(stor9.length) == stor9.length.field_1 % 128 < 32:
                        revert with 'NH{q', 34
                    if not bool(stor9.length):
                        mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160] = Mask(248, 8, stor9.length)
                    else:
                        if bool(stor9.length) != 1:
                            mem[64] = uint255(uint256(stor8[arg1].field_0)) * 0.5
                            if ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) <= uint255(uint256(stor8[arg1].field_0)) * 0.5:
                                _5288 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                                mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                                mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 64 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                                if ceil32(_5288) > _5288:
                                    mem[_5288 + (uint255(uint256(stor8[arg1].field_0)) * 0.5) + 64] = 0
                                return 32, mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 32 len ceil32(_5288) + 32]
                            _5289 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                            mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                            mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 64 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                            if ceil32(_5289) > _5289:
                                mem[_5289 + (uint255(uint256(stor8[arg1].field_0)) * 0.5) + 64] = 0
                            return 32, mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 32 len ceil32(_5289) + 32]
                        idx = 0
                        s = 0
                        while idx < stor9.length.field_1 % 128:
                            mem[idx + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160] = uint256(stor9[s].field_0)
                            idx = idx + 32
                            s = s + 1
                            continue 
                    mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 160 len ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5)] = mem[128 len ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5)]
                    mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 160] = 32
                    mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 192] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                    mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 224 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                    if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]) <= mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]:
                        return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128], data=mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 224 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]), 
                    mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + (uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 224] = 0
                    return 32, mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]) + 32], 
                if not arg1:
                    mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] = 1
                    mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160] = '0'
                    if bool(stor9.length):
                        if bool(stor9.length) == uint255(stor9.length) * 0.5 < 32:
                            revert with 'NH{q', 34
                        if not bool(stor9.length):
                            mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 224] = Mask(248, 8, stor9.length)
                        else:
                            if bool(stor9.length) != 1:
                                mem[64] = 1
                                _5277 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192]
                                mem[33] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192]
                                mem[65 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 224 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192])]
                                if ceil32(_5277) > _5277:
                                    mem[_5277 + 65] = 0
                                return memory
                                  from mem[64]
                                   len ceil32(_5277) + -mem[64] + 65
                            idx = 0
                            s = 0
                            while idx < uint255(stor9.length) * 0.5:
                                mem[idx + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 224] = uint256(stor9[s].field_0)
                                idx = idx + 32
                                s = s + 1
                                continue 
                        mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 224] = '0'
                        mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 225] = 32
                        mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 257] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192]
                        mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 289 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 224 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192])]
                        if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192]) > mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192]:
                            mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 289] = 0
                        return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192], data=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 289 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192])]), 
                    if bool(stor9.length) == stor9.length.field_1 % 128 < 32:
                        revert with 'NH{q', 34
                    if not bool(stor9.length):
                        mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 224] = Mask(248, 8, stor9.length)
                    else:
                        if bool(stor9.length) != 1:
                            mem[64] = 1
                            _5281 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192]
                            mem[33] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192]
                            mem[65 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 224 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192])]
                            if ceil32(_5281) > _5281:
                                mem[_5281 + 65] = 0
                            return memory
                              from mem[64]
                               len ceil32(_5281) + -mem[64] + 65
                        idx = 0
                        s = 0
                        while idx < stor9.length.field_1 % 128:
                            mem[idx + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 224] = uint256(stor9[s].field_0)
                            idx = idx + 32
                            s = s + 1
                            continue 
                    mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 224] = '0'
                    mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 225] = 32
                    mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 257] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192]
                    mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 289 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 224 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192])]
                    if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192]) > mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192]:
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 289] = 0
                    return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192], data=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 289 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192])]), 
                s = 0
                idx = arg1
                while idx:
                    if s == -1:
                        revert with 'NH{q', 17
                    s = s + 1
                    idx = idx / 10
                    continue 
                if s > test266151307():
                    revert with 'NH{q', 65
                mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] = s
                if not s:
                    t = s
                    idx = arg1
                    while idx:
                        if t < 1:
                            revert with 'NH{q', 17
                        if 48 > !(idx % 10):
                            revert with 'NH{q', 17
                        if t - 1 >= mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]:
                            revert with 'NH{q', 50
                        mem[t + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 159 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
                        t = t - 1
                        idx = idx / 10
                        continue 
                    if bool(stor9.length):
                        if bool(stor9.length) == uint255(stor9.length) * 0.5 < 32:
                            revert with 'NH{q', 34
                        if not bool(stor9.length):
                            mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192] = Mask(248, 8, stor9.length)
                            mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                            mem[64] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192
                            mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192] = 32
                            mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 224] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                            mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]
                            if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]) > mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]:
                                mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160] + mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256] = 0
                            return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160], data=mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]), 
                        if bool(stor9.length) == 1:
                            mem[0] = 9
                            idx = 0
                            t = 0
                            while idx < uint255(stor9.length) * 0.5:
                                mem[idx + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192] = uint256(stor9[t].field_0)
                                idx = idx + 32
                                t = t + 1
                                continue 
                            mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                            mem[64] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192
                            mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192] = 32
                            mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 224] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                            mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]
                            if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]) > mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]:
                                mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160] + mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256] = 0
                            return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160], data=mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]), 
                        _13159 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                        mem[0 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                        mem[64] = _13159
                        mem[_13159] = 32
                        if ceil32(_13159) <= _13159:
                            _20181 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                            mem[_13159 + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                            mem[_13159 + 64 len ceil32(_20181)] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(_20181)]
                            if ceil32(_20181) > _20181:
                                mem[_20181 + _13159 + 64] = 0
                            return 32, mem[_13159 + 32 len ceil32(_20181) + 32]
                        _20182 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                        mem[_13159 + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                        mem[_13159 + 64 len ceil32(_20182)] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(_20182)]
                        if ceil32(_20182) > _20182:
                            mem[_20182 + _13159 + 64] = 0
                        return 32, mem[_13159 + 32 len ceil32(_20182) + 32]
                    if bool(stor9.length) == stor9.length.field_1 % 128 < 32:
                        revert with 'NH{q', 34
                    if not bool(stor9.length):
                        mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192] = Mask(248, 8, stor9.length)
                        mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                        mem[64] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192] = 32
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 224] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]
                        if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]) > mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]:
                            mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160] + mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256] = 0
                        return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160], data=mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]), 
                    if bool(stor9.length) == 1:
                        mem[0] = 9
                        idx = 0
                        t = 0
                        while idx < stor9.length.field_1 % 128:
                            mem[idx + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192] = uint256(stor9[t].field_0)
                            idx = idx + 32
                            t = t + 1
                            continue 
                        mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                        mem[64] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192] = 32
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 224] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]
                        if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]) > mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]:
                            mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160] + mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256] = 0
                        return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160], data=mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]), 
                    _13239 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                    mem[0 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                    mem[64] = _13239
                    mem[_13239] = 32
                    if ceil32(_13239) <= _13239:
                        _20185 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                        mem[_13239 + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                        mem[_13239 + 64 len ceil32(_20185)] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(_20185)]
                        if ceil32(_20185) > _20185:
                            mem[_20185 + _13239 + 64] = 0
                        return 32, mem[_13239 + 32 len ceil32(_20185) + 32]
                    _20186 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                    mem[_13239 + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                    mem[_13239 + 64 len ceil32(_20186)] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(_20186)]
                    if ceil32(_20186) > _20186:
                        mem[_20186 + _13239 + 64] = 0
                    return 32, mem[_13239 + 32 len ceil32(_20186) + 32]
                mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len s] = call.data[calldata.size len s]
                t = s
                idx = arg1
                while idx:
                    if t < 1:
                        revert with 'NH{q', 17
                    if 48 > !(idx % 10):
                        revert with 'NH{q', 17
                    if t - 1 >= mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]:
                        revert with 'NH{q', 50
                    mem[t + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 159 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
                    t = t - 1
                    idx = idx / 10
                    continue 
                if bool(stor9.length):
                    if bool(stor9.length) == uint255(stor9.length) * 0.5 < 32:
                        revert with 'NH{q', 34
                    if not bool(stor9.length):
                        mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192] = Mask(248, 8, stor9.length)
                        mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                        mem[64] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192] = 32
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 224] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]
                        if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]) > mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]:
                            mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160] + mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256] = 0
                        return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160], data=mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]), 
                    if bool(stor9.length) == 1:
                        mem[0] = 9
                        idx = 0
                        t = 0
                        while idx < uint255(stor9.length) * 0.5:
                            mem[idx + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192] = uint256(stor9[t].field_0)
                            idx = idx + 32
                            t = t + 1
                            continue 
                        mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                        mem[64] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192] = 32
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 224] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]
                        if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]) > mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]:
                            mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160] + mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256] = 0
                        return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160], data=mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]), 
                    _13161 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                    mem[0 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                    mem[64] = _13161
                    mem[_13161] = 32
                    if ceil32(_13161) <= _13161:
                        _20189 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                        mem[_13161 + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                        mem[_13161 + 64 len ceil32(_20189)] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(_20189)]
                        if ceil32(_20189) > _20189:
                            mem[_20189 + _13161 + 64] = 0
                        return 32, mem[_13161 + 32 len ceil32(_20189) + 32]
                    _20190 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                    mem[_13161 + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                    mem[_13161 + 64 len ceil32(_20190)] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(_20190)]
                    if ceil32(_20190) > _20190:
                        mem[_20190 + _13161 + 64] = 0
                    return 32, mem[_13161 + 32 len ceil32(_20190) + 32]
                if bool(stor9.length) == stor9.length.field_1 % 128 < 32:
                    revert with 'NH{q', 34
                if not bool(stor9.length):
                    mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192] = Mask(248, 8, stor9.length)
                    mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                    mem[64] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192
                    mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192] = 32
                    mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 224] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                    mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]
                    if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]) > mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]:
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160] + mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256] = 0
                    return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160], data=mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]), 
                if bool(stor9.length) == 1:
                    mem[0] = 9
                    idx = 0
                    t = 0
                    while idx < stor9.length.field_1 % 128:
                        mem[idx + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192] = uint256(stor9[t].field_0)
                        idx = idx + 32
                        t = t + 1
                        continue 
                    mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                    mem[64] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192
                    mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192] = 32
                    mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 224] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                    mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]
                    if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]) > mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]:
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160] + mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256] = 0
                    return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160], data=mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]), 
                _13241 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                mem[0 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                mem[64] = _13241
                mem[_13241] = 32
                if ceil32(_13241) <= _13241:
                    _20193 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                    mem[_13241 + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                    mem[_13241 + 64 len ceil32(_20193)] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(_20193)]
                    if ceil32(_20193) > _20193:
                        mem[_20193 + _13241 + 64] = 0
                    return 32, mem[_13241 + 32 len ceil32(_20193) + 32]
                _20194 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                mem[_13241 + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                mem[_13241 + 64 len ceil32(_20194)] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(_20194)]
                if ceil32(_20194) > _20194:
                    mem[_20194 + _13241 + 64] = 0
                return 32, mem[_13241 + 32 len ceil32(_20194) + 32]
            mem[0] = sha3(arg1, 8)
            mem[128] = uint256(stor8[arg1].field_0)
            idx = 128
            s = 0
            while (uint255(uint256(stor8[arg1].field_0)) * 0.5) + 96 > idx:
                mem[idx + 32] = uint256(stor8[arg1][s].field_256)
                idx = idx + 32
                s = s + 1
                continue 
            if bool(stor9.length):
                if bool(stor9.length) == uint255(stor9.length) * 0.5 < 32:
                    revert with 'NH{q', 34
                if not uint255(stor9.length) * 0.5:
                    return Array(len=2 * Mask(256, -1, uint256(stor8[arg1].field_0)), data=mem[128 len ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5)]), 
                if Mask(256, -1, uint256(stor8[arg1].field_0)):
                    if bool(stor9.length):
                        if bool(stor9.length) == uint255(stor9.length) * 0.5 < 32:
                            revert with 'NH{q', 34
                        if not bool(stor9.length):
                            mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160] = Mask(248, 8, stor9.length)
                            mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 160 len ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5)] = mem[128 len ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5)]
                            var48001 = ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5)
                            mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 160] = 32
                            mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 192] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                            mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 224 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                            var59001 = ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])
                            if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]) <= mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]:
                                return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128], data=mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 224 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]), 
                            mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + (uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 224] = 0
                            return 32, mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]) + 32], 
                        if bool(stor9.length) == 1:
                            idx = 0
                            s = 0
                            while idx < uint255(stor9.length) * 0.5:
                                mem[idx + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160] = uint256(stor9[s].field_0)
                                idx = idx + 32
                                s = s + 1
                                continue 
                            mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 160 len ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5)] = mem[128 len ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5)]
                            mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 160] = 32
                            mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 192] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                            mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 224 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                            if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]) <= mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]:
                                return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128], data=mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 224 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]), 
                            mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + (uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 224] = 0
                            return 32, mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]) + 32], 
                        var49001 = ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5)
                        mem[64] = uint255(uint256(stor8[arg1].field_0)) * 0.5
                        if ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) <= uint255(uint256(stor8[arg1].field_0)) * 0.5:
                            _12861 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                            mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                            mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 64 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                            var60001 = ceil32(_12861)
                            if ceil32(_12861) > _12861:
                                mem[_12861 + (uint255(uint256(stor8[arg1].field_0)) * 0.5) + 64] = 0
                            return 32, mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 32 len ceil32(_12861) + 32]
                        _12862 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                        mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                        mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 64 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                        var60001 = ceil32(_12862)
                        if ceil32(_12862) > _12862:
                            mem[_12862 + (uint255(uint256(stor8[arg1].field_0)) * 0.5) + 64] = 0
                        return 32, mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 32 len ceil32(_12862) + 32]
                    if bool(stor9.length) == stor9.length.field_1 % 128 < 32:
                        revert with 'NH{q', 34
                    if bool(stor9.length):
                        if bool(stor9.length) == 1:
                            idx = 0
                            s = 0
                            while idx < stor9.length.field_1 % 128:
                                mem[idx + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160] = uint256(stor9[s].field_0)
                                idx = idx + 32
                                s = s + 1
                                continue 
                            mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 160 len ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5)] = mem[128 len ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5)]
                            mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 160] = 32
                            mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 192] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                            mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 224 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                            if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]) <= mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]:
                                return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128], data=mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 224 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]), 
                            mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + (uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 224] = 0
                            return 32, mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]) + 32], 
                        var50001 = ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5)
                        mem[64] = uint255(uint256(stor8[arg1].field_0)) * 0.5
                        if ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) <= uint255(uint256(stor8[arg1].field_0)) * 0.5:
                            _12865 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                            mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                            mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 64 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                            if ceil32(_12865) > _12865:
                                mem[_12865 + (uint255(uint256(stor8[arg1].field_0)) * 0.5) + 64] = 0
                            return 32, mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 32 len ceil32(_12865) + 32]
                        _12866 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                        mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                        mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 64 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                        if ceil32(_12866) > _12866:
                            mem[_12866 + (uint255(uint256(stor8[arg1].field_0)) * 0.5) + 64] = 0
                        return 32, mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 32 len ceil32(_12866) + 32]
                    mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160] = Mask(248, 8, stor9.length)
                    mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 160 len ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5)] = mem[128 len ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5)]
                    var49001 = ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5)
                    mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 160] = 32
                    mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 192] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                    mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 224 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                    var60001 = ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])
                    if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]) <= mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]:
                        return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128], data=mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 224 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]), 
                    mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + (uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 224] = 0
                    return 32, mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]) + 32], 
                if not arg1:
                    mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] = 1
                    mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160] = '0'
                    if bool(stor9.length):
                        if bool(stor9.length) == uint255(stor9.length) * 0.5 < 32:
                            revert with 'NH{q', 34
                        if not bool(stor9.length):
                            mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 224] = Mask(248, 8, stor9.length)
                            mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 224] = '0'
                            var51001 = 32
                        else:
                            if bool(stor9.length) != 1:
                                mem[64] = 1
                                _12854 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192]
                                mem[33] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192]
                                mem[65 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 224 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192])]
                                if ceil32(_12854) > _12854:
                                    mem[_12854 + 65] = 0
                                return memory
                                  from mem[64]
                                   len ceil32(_12854) + -mem[64] + 65
                            idx = 0
                            s = 0
                            while idx < uint255(stor9.length) * 0.5:
                                mem[idx + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 224] = uint256(stor9[s].field_0)
                                idx = idx + 32
                                s = s + 1
                                continue 
                            mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 224] = '0'
                        mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 225] = 32
                        mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 257] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192]
                        mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 289 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 224 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192])]
                        if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192]) > mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192]:
                            mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 289] = 0
                        return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192], data=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 289 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192])]), 
                    if bool(stor9.length) == stor9.length.field_1 % 128 < 32:
                        revert with 'NH{q', 34
                    if not bool(stor9.length):
                        mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 224] = Mask(248, 8, stor9.length)
                    else:
                        if bool(stor9.length) != 1:
                            mem[64] = 1
                            _12858 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192]
                            mem[33] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192]
                            mem[65 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 224 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192])]
                            if ceil32(_12858) > _12858:
                                mem[_12858 + 65] = 0
                            return memory
                              from mem[64]
                               len ceil32(_12858) + -mem[64] + 65
                        idx = 0
                        s = 0
                        while idx < stor9.length.field_1 % 128:
                            mem[idx + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 224] = uint256(stor9[s].field_0)
                            idx = idx + 32
                            s = s + 1
                            continue 
                    mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 224] = '0'
                    mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 225] = 32
                    mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 257] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192]
                    mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 289 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 224 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192])]
                    if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192]) > mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192]:
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 289] = 0
                    return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192], data=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 289 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192])]), 
                s = 0
                idx = arg1
                while idx:
                    if s == -1:
                        revert with 'NH{q', 17
                    s = s + 1
                    idx = idx / 10
                    continue 
                if s > test266151307():
                    revert with 'NH{q', 65
                mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] = s
                if not s:
                    t = s
                    idx = arg1
                    while idx:
                        if t < 1:
                            revert with 'NH{q', 17
                        if 48 > !(idx % 10):
                            revert with 'NH{q', 17
                        if t - 1 >= mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]:
                            revert with 'NH{q', 50
                        mem[t + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 159 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
                        t = t - 1
                        idx = idx / 10
                        continue 
                    if not bool(stor9.length):
                        if bool(stor9.length) == stor9.length.field_1 % 128 < 32:
                            revert with 'NH{q', 34
                        if not bool(stor9.length):
                            mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192] = Mask(248, 8, stor9.length)
                            mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                            var60001 = ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])
                            mem[64] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192
                            mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192] = 32
                            mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 224] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                            mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]
                            if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]) > mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]:
                                mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160] + mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256] = 0
                            return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160], data=mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]), 
                        if bool(stor9.length) == 1:
                            mem[0] = 9
                            idx = 0
                            t = 0
                            while idx < stor9.length.field_1 % 128:
                                mem[idx + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192] = uint256(stor9[t].field_0)
                                idx = idx + 32
                                t = t + 1
                                continue 
                            mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                            mem[64] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192
                            mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192] = 32
                            mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 224] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                            mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]
                            if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]) > mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]:
                                mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160] + mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256] = 0
                            return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160], data=mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]), 
                        _20507 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                        mem[0 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                        mem[64] = _20507
                        mem[_20507] = 32
                        if ceil32(_20507) <= _20507:
                            _25217 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                            mem[_20507 + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                            mem[_20507 + 64 len ceil32(_25217)] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(_25217)]
                            if ceil32(_25217) > _25217:
                                mem[_25217 + _20507 + 64] = 0
                            return 32, mem[_20507 + 32 len ceil32(_25217) + 32]
                        _25218 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                        mem[_20507 + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                        mem[_20507 + 64 len ceil32(_25218)] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(_25218)]
                        if ceil32(_25218) > _25218:
                            mem[_25218 + _20507 + 64] = 0
                        return 32, mem[_20507 + 32 len ceil32(_25218) + 32]
                    if bool(stor9.length) == uint255(stor9.length) * 0.5 < 32:
                        revert with 'NH{q', 34
                    if not bool(stor9.length):
                        mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192] = Mask(248, 8, stor9.length)
                        mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                        var59001 = ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])
                        mem[64] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192] = 32
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 224] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]
                        if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]) > mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]:
                            mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160] + mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256] = 0
                        return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160], data=mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]), 
                    if bool(stor9.length) == 1:
                        mem[0] = 9
                        idx = 0
                        t = 0
                        while idx < uint255(stor9.length) * 0.5:
                            mem[idx + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192] = uint256(stor9[t].field_0)
                            idx = idx + 32
                            t = t + 1
                            continue 
                        mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                        mem[64] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192] = 32
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 224] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]
                        if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]) > mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]:
                            mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160] + mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256] = 0
                        return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160], data=mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]), 
                    _20459 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                    mem[0 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                    var60001 = ceil32(_20459)
                    mem[64] = _20459
                    mem[_20459] = 32
                    if ceil32(_20459) <= _20459:
                        _25213 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                        mem[_20459 + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                        mem[_20459 + 64 len ceil32(_25213)] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(_25213)]
                        if ceil32(_25213) > _25213:
                            mem[_25213 + _20459 + 64] = 0
                        return 32, mem[_20459 + 32 len ceil32(_25213) + 32]
                    _25214 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                    mem[_20459 + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                    mem[_20459 + 64 len ceil32(_25214)] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(_25214)]
                    if ceil32(_25214) > _25214:
                        mem[_25214 + _20459 + 64] = 0
                    return 32, mem[_20459 + 32 len ceil32(_25214) + 32]
                mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len s] = call.data[calldata.size len s]
                t = s
                idx = arg1
                while idx:
                    if t < 1:
                        revert with 'NH{q', 17
                    if 48 > !(idx % 10):
                        revert with 'NH{q', 17
                    if t - 1 >= mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]:
                        revert with 'NH{q', 50
                    mem[t + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 159 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
                    t = t - 1
                    idx = idx / 10
                    continue 
                if bool(stor9.length):
                    if bool(stor9.length) == uint255(stor9.length) * 0.5 < 32:
                        revert with 'NH{q', 34
                    if not bool(stor9.length):
                        mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192] = Mask(248, 8, stor9.length)
                        mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                        var60001 = ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])
                        mem[64] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192] = 32
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 224] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]
                        if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]) > mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]:
                            mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160] + mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256] = 0
                        return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160], data=mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]), 
                    if bool(stor9.length) == 1:
                        mem[0] = 9
                        idx = 0
                        t = 0
                        while idx < uint255(stor9.length) * 0.5:
                            mem[idx + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192] = uint256(stor9[t].field_0)
                            idx = idx + 32
                            t = t + 1
                            continue 
                        mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                        mem[64] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192] = 32
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 224] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]
                        if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]) > mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]:
                            mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160] + mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256] = 0
                        return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160], data=mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]), 
                    _20461 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                    mem[0 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                    mem[64] = _20461
                    mem[_20461] = 32
                    if ceil32(_20461) <= _20461:
                        _25221 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                        mem[_20461 + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                        mem[_20461 + 64 len ceil32(_25221)] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(_25221)]
                        if ceil32(_25221) > _25221:
                            mem[_25221 + _20461 + 64] = 0
                        return 32, mem[_20461 + 32 len ceil32(_25221) + 32]
                    _25222 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                    mem[_20461 + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                    mem[_20461 + 64 len ceil32(_25222)] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(_25222)]
                    if ceil32(_25222) > _25222:
                        mem[_25222 + _20461 + 64] = 0
                    return 32, mem[_20461 + 32 len ceil32(_25222) + 32]
                if bool(stor9.length) == stor9.length.field_1 % 128 < 32:
                    revert with 'NH{q', 34
                if not bool(stor9.length):
                    mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192] = Mask(248, 8, stor9.length)
                    mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                    mem[64] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192
                    mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192] = 32
                    mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 224] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                    mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]
                    if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]) > mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]:
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160] + mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256] = 0
                    return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160], data=mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]), 
                if bool(stor9.length) == 1:
                    mem[0] = 9
                    idx = 0
                    t = 0
                    while idx < stor9.length.field_1 % 128:
                        mem[idx + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192] = uint256(stor9[t].field_0)
                        idx = idx + 32
                        t = t + 1
                        continue 
                    mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                    mem[64] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192
                    mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192] = 32
                    mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 224] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                    mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]
                    if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]) > mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]:
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160] + mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256] = 0
                    return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160], data=mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]), 
                _20509 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                mem[0 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                mem[64] = _20509
                mem[_20509] = 32
                if ceil32(_20509) <= _20509:
                    _25225 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                    mem[_20509 + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                    mem[_20509 + 64 len ceil32(_25225)] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(_25225)]
                    if ceil32(_25225) > _25225:
                        mem[_25225 + _20509 + 64] = 0
                    return 32, mem[_20509 + 32 len ceil32(_25225) + 32]
                _25226 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                mem[_20509 + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                mem[_20509 + 64 len ceil32(_25226)] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(_25226)]
                if ceil32(_25226) > _25226:
                    mem[_25226 + _20509 + 64] = 0
                return 32, mem[_20509 + 32 len ceil32(_25226) + 32]
            if bool(stor9.length) == stor9.length.field_1 % 128 < 32:
                revert with 'NH{q', 34
            if not stor9.length.field_1 % 128:
                return Array(len=2 * Mask(256, -1, uint256(stor8[arg1].field_0)), data=mem[128 len ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5)]), 
            if Mask(256, -1, uint256(stor8[arg1].field_0)):
                if not bool(stor9.length):
                    if bool(stor9.length) == stor9.length.field_1 % 128 < 32:
                        revert with 'NH{q', 34
                    if not bool(stor9.length):
                        mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160] = Mask(248, 8, stor9.length)
                        mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 160 len ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5)] = mem[128 len ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5)]
                        var50001 = ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5)
                        mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 160] = 32
                        mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 192] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                        mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 224 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                        if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]) <= mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]:
                            return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128], data=mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 224 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]), 
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + (uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 224] = 0
                        return 32, mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]) + 32], 
                    if bool(stor9.length) == 1:
                        idx = 0
                        s = 0
                        while idx < stor9.length.field_1 % 128:
                            mem[idx + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160] = uint256(stor9[s].field_0)
                            idx = idx + 32
                            s = s + 1
                            continue 
                        mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 160 len ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5)] = mem[128 len ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5)]
                        mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 160] = 32
                        mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 192] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                        mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 224 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                        if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]) <= mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]:
                            return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128], data=mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 224 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]), 
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + (uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 224] = 0
                        return 32, mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]) + 32], 
                    var51001 = ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5)
                    mem[64] = uint255(uint256(stor8[arg1].field_0)) * 0.5
                    if ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) <= uint255(uint256(stor8[arg1].field_0)) * 0.5:
                        _12881 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                        mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                        mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 64 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                        if ceil32(_12881) > _12881:
                            mem[_12881 + (uint255(uint256(stor8[arg1].field_0)) * 0.5) + 64] = 0
                        return 32, mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 32 len ceil32(_12881) + 32]
                    _12882 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                    mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                    mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 64 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                    if ceil32(_12882) > _12882:
                        mem[_12882 + (uint255(uint256(stor8[arg1].field_0)) * 0.5) + 64] = 0
                    return 32, mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 32 len ceil32(_12882) + 32]
                if bool(stor9.length) == uint255(stor9.length) * 0.5 < 32:
                    revert with 'NH{q', 34
                if bool(stor9.length):
                    if bool(stor9.length) == 1:
                        idx = 0
                        s = 0
                        while idx < uint255(stor9.length) * 0.5:
                            mem[idx + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160] = uint256(stor9[s].field_0)
                            idx = idx + 32
                            s = s + 1
                            continue 
                        mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 160 len ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5)] = mem[128 len ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5)]
                        mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 160] = 32
                        mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 192] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                        mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 224 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                        if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]) <= mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]:
                            return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128], data=mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 224 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]), 
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + (uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 224] = 0
                        return 32, mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]) + 32], 
                    var50001 = ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5)
                    mem[64] = uint255(uint256(stor8[arg1].field_0)) * 0.5
                    if ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) <= uint255(uint256(stor8[arg1].field_0)) * 0.5:
                        _12877 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                        mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                        mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 64 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                        if ceil32(_12877) > _12877:
                            mem[_12877 + (uint255(uint256(stor8[arg1].field_0)) * 0.5) + 64] = 0
                        return 32, mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 32 len ceil32(_12877) + 32]
                    _12878 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                    mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                    mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 64 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                    if ceil32(_12878) > _12878:
                        mem[_12878 + (uint255(uint256(stor8[arg1].field_0)) * 0.5) + 64] = 0
                    return 32, mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 32 len ceil32(_12878) + 32]
                mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160] = Mask(248, 8, stor9.length)
                mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 160 len ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5)] = mem[128 len ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5)]
                var49001 = ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5)
                mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 160] = 32
                mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 192] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 224 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                var60001 = ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])
                if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]) <= mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]:
                    return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128], data=mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 224 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]), 
                mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + (uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 224] = 0
                return 32, mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]) + 32], 
            if not arg1:
                mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] = 1
                mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160] = '0'
                if bool(stor9.length):
                    if bool(stor9.length) == uint255(stor9.length) * 0.5 < 32:
                        revert with 'NH{q', 34
                    if not bool(stor9.length):
                        mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 224] = Mask(248, 8, stor9.length)
                    else:
                        if bool(stor9.length) != 1:
                            mem[64] = 1
                            _12870 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192]
                            mem[33] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192]
                            mem[65 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 224 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192])]
                            if ceil32(_12870) > _12870:
                                mem[_12870 + 65] = 0
                            return memory
                              from mem[64]
                               len ceil32(_12870) + -mem[64] + 65
                        idx = 0
                        s = 0
                        while idx < uint255(stor9.length) * 0.5:
                            mem[idx + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 224] = uint256(stor9[s].field_0)
                            idx = idx + 32
                            s = s + 1
                            continue 
                    mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 224] = '0'
                    mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 225] = 32
                    mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 257] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192]
                    mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 289 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 224 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192])]
                    if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192]) > mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192]:
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 289] = 0
                    return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192], data=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 289 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192])]), 
                if bool(stor9.length) == stor9.length.field_1 % 128 < 32:
                    revert with 'NH{q', 34
                if not bool(stor9.length):
                    mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 224] = Mask(248, 8, stor9.length)
                    mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 224] = '0'
                else:
                    if bool(stor9.length) != 1:
                        mem[64] = 1
                        _12874 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192]
                        mem[33] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192]
                        mem[65 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 224 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192])]
                        if ceil32(_12874) > _12874:
                            mem[_12874 + 65] = 0
                        return memory
                          from mem[64]
                           len ceil32(_12874) + -mem[64] + 65
                    idx = 0
                    s = 0
                    while idx < stor9.length.field_1 % 128:
                        mem[idx + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 224] = uint256(stor9[s].field_0)
                        idx = idx + 32
                        s = s + 1
                        continue 
                    mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 224] = '0'
                    var57001 = 32
                mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 225] = 32
                mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 257] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192]
                mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 289 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 224 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192])]
                if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192]) > mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192]:
                    mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 289] = 0
                return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192], data=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 289 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192])]), 
            s = 0
            idx = arg1
            while idx:
                if s == -1:
                    revert with 'NH{q', 17
                s = s + 1
                idx = idx / 10
                continue 
            if s > test266151307():
                revert with 'NH{q', 65
            mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] = s
            if not s:
                t = s
                idx = arg1
                while idx:
                    if t < 1:
                        revert with 'NH{q', 17
                    if 48 > !(idx % 10):
                        revert with 'NH{q', 17
                    if t - 1 >= mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]:
                        revert with 'NH{q', 50
                    mem[t + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 159 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
                    t = t - 1
                    idx = idx / 10
                    continue 
                if bool(stor9.length):
                    if bool(stor9.length) == uint255(stor9.length) * 0.5 < 32:
                        revert with 'NH{q', 34
                    if not bool(stor9.length):
                        mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192] = Mask(248, 8, stor9.length)
                        mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                        var60001 = ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])
                        mem[64] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192] = 32
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 224] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]
                        if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]) > mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]:
                            mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160] + mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256] = 0
                        return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160], data=mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]), 
                    if bool(stor9.length) == 1:
                        mem[0] = 9
                        idx = 0
                        t = 0
                        while idx < uint255(stor9.length) * 0.5:
                            mem[idx + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192] = uint256(stor9[t].field_0)
                            idx = idx + 32
                            t = t + 1
                            continue 
                        mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                        mem[64] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192] = 32
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 224] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]
                        if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]) > mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]:
                            mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160] + mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256] = 0
                        return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160], data=mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]), 
                    _20463 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                    mem[0 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                    mem[64] = _20463
                    mem[_20463] = 32
                    if ceil32(_20463) <= _20463:
                        _25229 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                        mem[_20463 + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                        mem[_20463 + 64 len ceil32(_25229)] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(_25229)]
                        if ceil32(_25229) > _25229:
                            mem[_25229 + _20463 + 64] = 0
                        return 32, mem[_20463 + 32 len ceil32(_25229) + 32]
                    _25230 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                    mem[_20463 + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                    mem[_20463 + 64 len ceil32(_25230)] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(_25230)]
                    if ceil32(_25230) > _25230:
                        mem[_25230 + _20463 + 64] = 0
                    return 32, mem[_20463 + 32 len ceil32(_25230) + 32]
                if bool(stor9.length) == stor9.length.field_1 % 128 < 32:
                    revert with 'NH{q', 34
                if not bool(stor9.length):
                    mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192] = Mask(248, 8, stor9.length)
                    mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                    mem[64] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192
                    mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192] = 32
                    mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 224] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                    mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]
                    if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]) > mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]:
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160] + mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256] = 0
                    return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160], data=mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]), 
                if bool(stor9.length) == 1:
                    mem[0] = 9
                    idx = 0
                    t = 0
                    while idx < stor9.length.field_1 % 128:
                        mem[idx + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192] = uint256(stor9[t].field_0)
                        idx = idx + 32
                        t = t + 1
                        continue 
                    mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                    mem[64] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192
                    mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192] = 32
                    mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 224] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                    mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]
                    if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]) > mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]:
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160] + mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256] = 0
                    return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160], data=mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]), 
                _20511 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                mem[0 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                mem[64] = _20511
                mem[_20511] = 32
                if ceil32(_20511) <= _20511:
                    _25233 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                    mem[_20511 + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                    mem[_20511 + 64 len ceil32(_25233)] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(_25233)]
                    if ceil32(_25233) > _25233:
                        mem[_25233 + _20511 + 64] = 0
                    return 32, mem[_20511 + 32 len ceil32(_25233) + 32]
                _25234 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                mem[_20511 + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                mem[_20511 + 64 len ceil32(_25234)] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(_25234)]
                if ceil32(_25234) > _25234:
                    mem[_25234 + _20511 + 64] = 0
                return 32, mem[_20511 + 32 len ceil32(_25234) + 32]
            mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len s] = call.data[calldata.size len s]
            t = s
            idx = arg1
            while idx:
                if t < 1:
                    revert with 'NH{q', 17
                if 48 > !(idx % 10):
                    revert with 'NH{q', 17
                if t - 1 >= mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]:
                    revert with 'NH{q', 50
                mem[t + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 159 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
                t = t - 1
                idx = idx / 10
                continue 
            if bool(stor9.length):
                if bool(stor9.length) == uint255(stor9.length) * 0.5 < 32:
                    revert with 'NH{q', 34
                if not bool(stor9.length):
                    mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192] = Mask(248, 8, stor9.length)
                    mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                    mem[64] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192
                    mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192] = 32
                    mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 224] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                    mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]
                    if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]) > mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]:
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160] + mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256] = 0
                    return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160], data=mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]), 
                if bool(stor9.length) == 1:
                    mem[0] = 9
                    idx = 0
                    t = 0
                    while idx < uint255(stor9.length) * 0.5:
                        mem[idx + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192] = uint256(stor9[t].field_0)
                        idx = idx + 32
                        t = t + 1
                        continue 
                    mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                    mem[64] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192
                    mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192] = 32
                    mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 224] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                    mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]
                    if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]) > mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]:
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160] + mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256] = 0
                    return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160], data=mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]), 
                _20465 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                mem[0 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                mem[64] = _20465
                mem[_20465] = 32
                if ceil32(_20465) <= _20465:
                    _25237 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                    mem[_20465 + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                    mem[_20465 + 64 len ceil32(_25237)] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(_25237)]
                    if ceil32(_25237) > _25237:
                        mem[_25237 + _20465 + 64] = 0
                    return 32, mem[_20465 + 32 len ceil32(_25237) + 32]
                _25238 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                mem[_20465 + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                mem[_20465 + 64 len ceil32(_25238)] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(_25238)]
                if ceil32(_25238) > _25238:
                    mem[_25238 + _20465 + 64] = 0
                return 32, mem[_20465 + 32 len ceil32(_25238) + 32]
            if bool(stor9.length) == stor9.length.field_1 % 128 < 32:
                revert with 'NH{q', 34
            if not bool(stor9.length):
                mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192] = Mask(248, 8, stor9.length)
                mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                mem[64] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192
                mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192] = 32
                mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 224] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]
                if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]) > mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]:
                    mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160] + mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256] = 0
                return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160], data=mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]), 
            if bool(stor9.length) == 1:
                mem[0] = 9
                idx = 0
                t = 0
                while idx < stor9.length.field_1 % 128:
                    mem[idx + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192] = uint256(stor9[t].field_0)
                    idx = idx + 32
                    t = t + 1
                    continue 
                mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                mem[64] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192
                mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192] = 32
                mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 224] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]
                if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]) > mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]:
                    mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160] + mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256] = 0
                return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160], data=mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]), 
            _20513 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
            mem[0 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
            mem[64] = _20513
            mem[_20513] = 32
            if ceil32(_20513) <= _20513:
                _25241 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                mem[_20513 + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                mem[_20513 + 64 len ceil32(_25241)] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(_25241)]
                if ceil32(_25241) > _25241:
                    mem[_25241 + _20513 + 64] = 0
                return 32, mem[_20513 + 32 len ceil32(_25241) + 32]
            _25242 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
            mem[_20513 + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
            mem[_20513 + 64 len ceil32(_25242)] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(_25242)]
            if ceil32(_25242) > _25242:
                mem[_25242 + _20513 + 64] = 0
            return 32, mem[_20513 + 32 len ceil32(_25242) + 32]
        if bool(stor8[arg1].field_0) == stor8[arg1].field_1 % 128 < 32:
            revert with 'NH{q', 34
        if not stor8[arg1].field_1 % 128:
            if bool(stor9.length):
                if bool(stor9.length) == uint255(stor9.length) * 0.5 < 32:
                    revert with 'NH{q', 34
                if not uint255(stor9.length) * 0.5:
                    mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192 len ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5)] = mem[128 len ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5)]
                    if ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) > uint255(uint256(stor8[arg1].field_0)) * 0.5:
                        mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192] = 0
                    return Array(len=2 * Mask(256, -1, uint256(stor8[arg1].field_0)), data=mem[128 len ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5)], mem[(2 * ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5)) + 192 len 2 * ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5)]), 
                if Mask(256, -1, uint256(stor8[arg1].field_0)):
                    if bool(stor9.length):
                        if bool(stor9.length) == uint255(stor9.length) * 0.5 < 32:
                            revert with 'NH{q', 34
                        if not bool(stor9.length):
                            mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160] = Mask(248, 8, stor9.length)
                        else:
                            if bool(stor9.length) != 1:
                                mem[64] = uint255(uint256(stor8[arg1].field_0)) * 0.5
                                if ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) <= uint255(uint256(stor8[arg1].field_0)) * 0.5:
                                    _5300 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                                    mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                                    mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 64 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                                    if ceil32(_5300) > _5300:
                                        mem[_5300 + (uint255(uint256(stor8[arg1].field_0)) * 0.5) + 64] = 0
                                    return 32, mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 32 len ceil32(_5300) + 32]
                                _5301 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                                mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                                mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 64 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                                if ceil32(_5301) > _5301:
                                    mem[_5301 + (uint255(uint256(stor8[arg1].field_0)) * 0.5) + 64] = 0
                                return 32, mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 32 len ceil32(_5301) + 32]
                            idx = 0
                            s = 0
                            while idx < uint255(stor9.length) * 0.5:
                                mem[idx + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160] = uint256(stor9[s].field_0)
                                idx = idx + 32
                                s = s + 1
                                continue 
                        mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 160 len ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5)] = mem[128 len ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5)]
                        mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 160] = 32
                        mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 192] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                        mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 224 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                        if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]) <= mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]:
                            return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128], data=mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 224 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]), 
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + (uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 224] = 0
                        return 32, mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]) + 32], 
                    if bool(stor9.length) == stor9.length.field_1 % 128 < 32:
                        revert with 'NH{q', 34
                    if not bool(stor9.length):
                        mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160] = Mask(248, 8, stor9.length)
                    else:
                        if bool(stor9.length) != 1:
                            mem[64] = uint255(uint256(stor8[arg1].field_0)) * 0.5
                            if ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) <= uint255(uint256(stor8[arg1].field_0)) * 0.5:
                                _5304 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                                mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                                mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 64 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                                if ceil32(_5304) > _5304:
                                    mem[_5304 + (uint255(uint256(stor8[arg1].field_0)) * 0.5) + 64] = 0
                                return 32, mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 32 len ceil32(_5304) + 32]
                            _5305 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                            mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                            mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 64 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                            if ceil32(_5305) > _5305:
                                mem[_5305 + (uint255(uint256(stor8[arg1].field_0)) * 0.5) + 64] = 0
                            return 32, mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 32 len ceil32(_5305) + 32]
                        idx = 0
                        s = 0
                        while idx < stor9.length.field_1 % 128:
                            mem[idx + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160] = uint256(stor9[s].field_0)
                            idx = idx + 32
                            s = s + 1
                            continue 
                    mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 160 len ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5)] = mem[128 len ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5)]
                    mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 160] = 32
                    mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 192] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                    mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 224 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                    if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]) <= mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]:
                        return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128], data=mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 224 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]), 
                    mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + (uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 224] = 0
                    return 32, mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]) + 32], 
                if not arg1:
                    mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] = 1
                    mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160] = '0'
                    if bool(stor9.length):
                        if bool(stor9.length) == uint255(stor9.length) * 0.5 < 32:
                            revert with 'NH{q', 34
                        if not bool(stor9.length):
                            mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 224] = Mask(248, 8, stor9.length)
                        else:
                            if bool(stor9.length) != 1:
                                mem[64] = 1
                                _5293 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192]
                                mem[33] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192]
                                mem[65 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 224 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192])]
                                if ceil32(_5293) > _5293:
                                    mem[_5293 + 65] = 0
                                return memory
                                  from mem[64]
                                   len ceil32(_5293) + -mem[64] + 65
                            idx = 0
                            s = 0
                            while idx < uint255(stor9.length) * 0.5:
                                mem[idx + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 224] = uint256(stor9[s].field_0)
                                idx = idx + 32
                                s = s + 1
                                continue 
                        mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 224] = '0'
                        mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 225] = 32
                        mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 257] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192]
                        mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 289 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 224 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192])]
                        if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192]) > mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192]:
                            mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 289] = 0
                        return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192], data=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 289 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192])]), 
                    if bool(stor9.length) == stor9.length.field_1 % 128 < 32:
                        revert with 'NH{q', 34
                    if not bool(stor9.length):
                        mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 224] = Mask(248, 8, stor9.length)
                    else:
                        if bool(stor9.length) != 1:
                            mem[64] = 1
                            _5297 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192]
                            mem[33] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192]
                            mem[65 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 224 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192])]
                            if ceil32(_5297) > _5297:
                                mem[_5297 + 65] = 0
                            return memory
                              from mem[64]
                               len ceil32(_5297) + -mem[64] + 65
                        idx = 0
                        s = 0
                        while idx < stor9.length.field_1 % 128:
                            mem[idx + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 224] = uint256(stor9[s].field_0)
                            idx = idx + 32
                            s = s + 1
                            continue 
                    mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 224] = '0'
                    mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 225] = 32
                    mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 257] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192]
                    mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 289 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 224 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192])]
                    if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192]) > mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192]:
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 289] = 0
                    return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192], data=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 289 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192])]), 
                s = 0
                idx = arg1
                while idx:
                    if s == -1:
                        revert with 'NH{q', 17
                    s = s + 1
                    idx = idx / 10
                    continue 
                if s > test266151307():
                    revert with 'NH{q', 65
                mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] = s
                if not s:
                    t = s
                    idx = arg1
                    while idx:
                        if t < 1:
                            revert with 'NH{q', 17
                        if 48 > !(idx % 10):
                            revert with 'NH{q', 17
                        if t - 1 >= mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]:
                            revert with 'NH{q', 50
                        mem[t + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 159 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
                        t = t - 1
                        idx = idx / 10
                        continue 
                    if bool(stor9.length):
                        if bool(stor9.length) == uint255(stor9.length) * 0.5 < 32:
                            revert with 'NH{q', 34
                        if not bool(stor9.length):
                            mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192] = Mask(248, 8, stor9.length)
                            mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                            mem[64] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192
                            mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192] = 32
                            mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 224] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                            mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]
                            if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]) > mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]:
                                mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160] + mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256] = 0
                            return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160], data=mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]), 
                        if bool(stor9.length) == 1:
                            mem[0] = 9
                            idx = 0
                            t = 0
                            while idx < uint255(stor9.length) * 0.5:
                                mem[idx + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192] = uint256(stor9[t].field_0)
                                idx = idx + 32
                                t = t + 1
                                continue 
                            mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                            mem[64] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192
                            mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192] = 32
                            mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 224] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                            mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]
                            if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]) > mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]:
                                mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160] + mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256] = 0
                            return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160], data=mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]), 
                        _13163 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                        mem[0 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                        mem[64] = _13163
                        mem[_13163] = 32
                        if ceil32(_13163) <= _13163:
                            _20197 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                            mem[_13163 + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                            mem[_13163 + 64 len ceil32(_20197)] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(_20197)]
                            if ceil32(_20197) > _20197:
                                mem[_20197 + _13163 + 64] = 0
                            return 32, mem[_13163 + 32 len ceil32(_20197) + 32]
                        _20198 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                        mem[_13163 + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                        mem[_13163 + 64 len ceil32(_20198)] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(_20198)]
                        if ceil32(_20198) > _20198:
                            mem[_20198 + _13163 + 64] = 0
                        return 32, mem[_13163 + 32 len ceil32(_20198) + 32]
                    if bool(stor9.length) == stor9.length.field_1 % 128 < 32:
                        revert with 'NH{q', 34
                    if not bool(stor9.length):
                        mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192] = Mask(248, 8, stor9.length)
                        mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                        mem[64] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192] = 32
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 224] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]
                        if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]) > mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]:
                            mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160] + mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256] = 0
                        return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160], data=mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]), 
                    if bool(stor9.length) == 1:
                        mem[0] = 9
                        idx = 0
                        t = 0
                        while idx < stor9.length.field_1 % 128:
                            mem[idx + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192] = uint256(stor9[t].field_0)
                            idx = idx + 32
                            t = t + 1
                            continue 
                        mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                        mem[64] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192] = 32
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 224] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]
                        if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]) > mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]:
                            mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160] + mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256] = 0
                        return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160], data=mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]), 
                    _13243 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                    mem[0 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                    mem[64] = _13243
                    mem[_13243] = 32
                    if ceil32(_13243) <= _13243:
                        _20201 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                        mem[_13243 + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                        mem[_13243 + 64 len ceil32(_20201)] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(_20201)]
                        if ceil32(_20201) > _20201:
                            mem[_20201 + _13243 + 64] = 0
                        return 32, mem[_13243 + 32 len ceil32(_20201) + 32]
                    _20202 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                    mem[_13243 + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                    mem[_13243 + 64 len ceil32(_20202)] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(_20202)]
                    if ceil32(_20202) > _20202:
                        mem[_20202 + _13243 + 64] = 0
                    return 32, mem[_13243 + 32 len ceil32(_20202) + 32]
                mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len s] = call.data[calldata.size len s]
                t = s
                idx = arg1
                while idx:
                    if t < 1:
                        revert with 'NH{q', 17
                    if 48 > !(idx % 10):
                        revert with 'NH{q', 17
                    if t - 1 >= mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]:
                        revert with 'NH{q', 50
                    mem[t + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 159 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
                    t = t - 1
                    idx = idx / 10
                    continue 
                if bool(stor9.length):
                    if bool(stor9.length) == uint255(stor9.length) * 0.5 < 32:
                        revert with 'NH{q', 34
                    if not bool(stor9.length):
                        mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192] = Mask(248, 8, stor9.length)
                        mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                        mem[64] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192] = 32
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 224] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]
                        if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]) > mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]:
                            mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160] + mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256] = 0
                        return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160], data=mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]), 
                    if bool(stor9.length) == 1:
                        mem[0] = 9
                        idx = 0
                        t = 0
                        while idx < uint255(stor9.length) * 0.5:
                            mem[idx + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192] = uint256(stor9[t].field_0)
                            idx = idx + 32
                            t = t + 1
                            continue 
                        mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                        mem[64] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192] = 32
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 224] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]
                        if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]) > mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]:
                            mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160] + mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256] = 0
                        return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160], data=mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]), 
                    _13165 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                    mem[0 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                    mem[64] = _13165
                    mem[_13165] = 32
                    if ceil32(_13165) <= _13165:
                        _20205 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                        mem[_13165 + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                        mem[_13165 + 64 len ceil32(_20205)] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(_20205)]
                        if ceil32(_20205) > _20205:
                            mem[_20205 + _13165 + 64] = 0
                        return 32, mem[_13165 + 32 len ceil32(_20205) + 32]
                    _20206 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                    mem[_13165 + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                    mem[_13165 + 64 len ceil32(_20206)] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(_20206)]
                    if ceil32(_20206) > _20206:
                        mem[_20206 + _13165 + 64] = 0
                    return 32, mem[_13165 + 32 len ceil32(_20206) + 32]
                if bool(stor9.length) == stor9.length.field_1 % 128 < 32:
                    revert with 'NH{q', 34
                if not bool(stor9.length):
                    mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192] = Mask(248, 8, stor9.length)
                    mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                    mem[64] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192
                    mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192] = 32
                    mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 224] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                    mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]
                    if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]) > mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]:
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160] + mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256] = 0
                    return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160], data=mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]), 
                if bool(stor9.length) == 1:
                    mem[0] = 9
                    idx = 0
                    t = 0
                    while idx < stor9.length.field_1 % 128:
                        mem[idx + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192] = uint256(stor9[t].field_0)
                        idx = idx + 32
                        t = t + 1
                        continue 
                    mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                    mem[64] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192
                    mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192] = 32
                    mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 224] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                    mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]
                    if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]) > mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]:
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160] + mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256] = 0
                    return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160], data=mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]), 
                _13245 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                mem[0 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                mem[64] = _13245
                mem[_13245] = 32
                if ceil32(_13245) <= _13245:
                    _20209 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                    mem[_13245 + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                    mem[_13245 + 64 len ceil32(_20209)] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(_20209)]
                    if ceil32(_20209) > _20209:
                        mem[_20209 + _13245 + 64] = 0
                    return 32, mem[_13245 + 32 len ceil32(_20209) + 32]
                _20210 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                mem[_13245 + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                mem[_13245 + 64 len ceil32(_20210)] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(_20210)]
                if ceil32(_20210) > _20210:
                    mem[_20210 + _13245 + 64] = 0
                return 32, mem[_13245 + 32 len ceil32(_20210) + 32]
            if bool(stor9.length) == stor9.length.field_1 % 128 < 32:
                revert with 'NH{q', 34
            if not stor9.length.field_1 % 128:
                mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192 len ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5)] = mem[128 len ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5)]
                if ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) > uint255(uint256(stor8[arg1].field_0)) * 0.5:
                    mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192] = 0
                return Array(len=2 * Mask(256, -1, uint256(stor8[arg1].field_0)), data=mem[128 len ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5)], mem[(2 * ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5)) + 192 len 2 * ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5)]), 
            if Mask(256, -1, uint256(stor8[arg1].field_0)):
                if bool(stor9.length):
                    if bool(stor9.length) == uint255(stor9.length) * 0.5 < 32:
                        revert with 'NH{q', 34
                    if not bool(stor9.length):
                        mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160] = Mask(248, 8, stor9.length)
                    else:
                        if bool(stor9.length) != 1:
                            mem[64] = uint255(uint256(stor8[arg1].field_0)) * 0.5
                            if ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) <= uint255(uint256(stor8[arg1].field_0)) * 0.5:
                                _5316 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                                mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                                mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 64 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                                if ceil32(_5316) > _5316:
                                    mem[_5316 + (uint255(uint256(stor8[arg1].field_0)) * 0.5) + 64] = 0
                                return 32, mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 32 len ceil32(_5316) + 32]
                            _5317 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                            mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                            mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 64 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                            if ceil32(_5317) > _5317:
                                mem[_5317 + (uint255(uint256(stor8[arg1].field_0)) * 0.5) + 64] = 0
                            return 32, mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 32 len ceil32(_5317) + 32]
                        idx = 0
                        s = 0
                        while idx < uint255(stor9.length) * 0.5:
                            mem[idx + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160] = uint256(stor9[s].field_0)
                            idx = idx + 32
                            s = s + 1
                            continue 
                    mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 160 len ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5)] = mem[128 len ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5)]
                    mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 160] = 32
                    mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 192] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                    mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 224 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                    if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]) <= mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]:
                        return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128], data=mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 224 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]), 
                    mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + (uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 224] = 0
                    return 32, mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]) + 32], 
                if bool(stor9.length) == stor9.length.field_1 % 128 < 32:
                    revert with 'NH{q', 34
                if not bool(stor9.length):
                    mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160] = Mask(248, 8, stor9.length)
                else:
                    if bool(stor9.length) != 1:
                        mem[64] = uint255(uint256(stor8[arg1].field_0)) * 0.5
                        if ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) <= uint255(uint256(stor8[arg1].field_0)) * 0.5:
                            _5320 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                            mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                            mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 64 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                            if ceil32(_5320) > _5320:
                                mem[_5320 + (uint255(uint256(stor8[arg1].field_0)) * 0.5) + 64] = 0
                            return 32, mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 32 len ceil32(_5320) + 32]
                        _5321 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                        mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                        mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 64 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                        if ceil32(_5321) > _5321:
                            mem[_5321 + (uint255(uint256(stor8[arg1].field_0)) * 0.5) + 64] = 0
                        return 32, mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 32 len ceil32(_5321) + 32]
                    idx = 0
                    s = 0
                    while idx < stor9.length.field_1 % 128:
                        mem[idx + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160] = uint256(stor9[s].field_0)
                        idx = idx + 32
                        s = s + 1
                        continue 
                mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 160 len ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5)] = mem[128 len ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5)]
                mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 160] = 32
                mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 192] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 224 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]) <= mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]:
                    return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128], data=mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 224 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]), 
                mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + (uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 224] = 0
                return 32, mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]) + 32], 
            if not arg1:
                mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] = 1
                mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160] = '0'
                if bool(stor9.length):
                    if bool(stor9.length) == uint255(stor9.length) * 0.5 < 32:
                        revert with 'NH{q', 34
                    if not bool(stor9.length):
                        mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 224] = Mask(248, 8, stor9.length)
                    else:
                        if bool(stor9.length) != 1:
                            mem[64] = 1
                            _5309 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192]
                            mem[33] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192]
                            mem[65 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 224 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192])]
                            if ceil32(_5309) > _5309:
                                mem[_5309 + 65] = 0
                            return memory
                              from mem[64]
                               len ceil32(_5309) + -mem[64] + 65
                        idx = 0
                        s = 0
                        while idx < uint255(stor9.length) * 0.5:
                            mem[idx + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 224] = uint256(stor9[s].field_0)
                            idx = idx + 32
                            s = s + 1
                            continue 
                    mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 224] = '0'
                    mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 225] = 32
                    mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 257] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192]
                    mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 289 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 224 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192])]
                    if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192]) > mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192]:
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 289] = 0
                    return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192], data=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 289 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192])]), 
                if bool(stor9.length) == stor9.length.field_1 % 128 < 32:
                    revert with 'NH{q', 34
                if not bool(stor9.length):
                    mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 224] = Mask(248, 8, stor9.length)
                else:
                    if bool(stor9.length) != 1:
                        mem[64] = 1
                        _5313 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192]
                        mem[33] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192]
                        mem[65 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 224 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192])]
                        if ceil32(_5313) > _5313:
                            mem[_5313 + 65] = 0
                        return memory
                          from mem[64]
                           len ceil32(_5313) + -mem[64] + 65
                    idx = 0
                    s = 0
                    while idx < stor9.length.field_1 % 128:
                        mem[idx + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 224] = uint256(stor9[s].field_0)
                        idx = idx + 32
                        s = s + 1
                        continue 
                mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 224] = '0'
                mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 225] = 32
                mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 257] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192]
                mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 289 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 224 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192])]
                if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192]) > mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192]:
                    mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 289] = 0
                return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192], data=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 289 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192])]), 
            s = 0
            idx = arg1
            while idx:
                if s == -1:
                    revert with 'NH{q', 17
                s = s + 1
                idx = idx / 10
                continue 
            if s > test266151307():
                revert with 'NH{q', 65
            mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] = s
            if not s:
                t = s
                idx = arg1
                while idx:
                    if t < 1:
                        revert with 'NH{q', 17
                    if 48 > !(idx % 10):
                        revert with 'NH{q', 17
                    if t - 1 >= mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]:
                        revert with 'NH{q', 50
                    mem[t + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 159 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
                    t = t - 1
                    idx = idx / 10
                    continue 
                if bool(stor9.length):
                    if bool(stor9.length) == uint255(stor9.length) * 0.5 < 32:
                        revert with 'NH{q', 34
                    if not bool(stor9.length):
                        mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192] = Mask(248, 8, stor9.length)
                        mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                        mem[64] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192] = 32
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 224] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]
                        if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]) > mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]:
                            mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160] + mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256] = 0
                        return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160], data=mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]), 
                    if bool(stor9.length) == 1:
                        mem[0] = 9
                        idx = 0
                        t = 0
                        while idx < uint255(stor9.length) * 0.5:
                            mem[idx + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192] = uint256(stor9[t].field_0)
                            idx = idx + 32
                            t = t + 1
                            continue 
                        mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                        mem[64] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192] = 32
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 224] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]
                        if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]) > mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]:
                            mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160] + mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256] = 0
                        return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160], data=mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]), 
                    _13167 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                    mem[0 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                    mem[64] = _13167
                    mem[_13167] = 32
                    if ceil32(_13167) <= _13167:
                        _20213 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                        mem[_13167 + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                        mem[_13167 + 64 len ceil32(_20213)] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(_20213)]
                        if ceil32(_20213) > _20213:
                            mem[_20213 + _13167 + 64] = 0
                        return 32, mem[_13167 + 32 len ceil32(_20213) + 32]
                    _20214 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                    mem[_13167 + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                    mem[_13167 + 64 len ceil32(_20214)] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(_20214)]
                    if ceil32(_20214) > _20214:
                        mem[_20214 + _13167 + 64] = 0
                    return 32, mem[_13167 + 32 len ceil32(_20214) + 32]
                if bool(stor9.length) == stor9.length.field_1 % 128 < 32:
                    revert with 'NH{q', 34
                if not bool(stor9.length):
                    mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192] = Mask(248, 8, stor9.length)
                    mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                    mem[64] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192
                    mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192] = 32
                    mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 224] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                    mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]
                    if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]) > mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]:
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160] + mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256] = 0
                    return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160], data=mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]), 
                if bool(stor9.length) == 1:
                    mem[0] = 9
                    idx = 0
                    t = 0
                    while idx < stor9.length.field_1 % 128:
                        mem[idx + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192] = uint256(stor9[t].field_0)
                        idx = idx + 32
                        t = t + 1
                        continue 
                    mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                    mem[64] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192
                    mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192] = 32
                    mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 224] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                    mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]
                    if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]) > mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]:
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160] + mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256] = 0
                    return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160], data=mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]), 
                _13247 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                mem[0 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                mem[64] = _13247
                mem[_13247] = 32
                if ceil32(_13247) <= _13247:
                    _20217 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                    mem[_13247 + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                    mem[_13247 + 64 len ceil32(_20217)] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(_20217)]
                    if ceil32(_20217) > _20217:
                        mem[_20217 + _13247 + 64] = 0
                    return 32, mem[_13247 + 32 len ceil32(_20217) + 32]
                _20218 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                mem[_13247 + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                mem[_13247 + 64 len ceil32(_20218)] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(_20218)]
                if ceil32(_20218) > _20218:
                    mem[_20218 + _13247 + 64] = 0
                return 32, mem[_13247 + 32 len ceil32(_20218) + 32]
            mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len s] = call.data[calldata.size len s]
            t = s
            idx = arg1
            while idx:
                if t < 1:
                    revert with 'NH{q', 17
                if 48 > !(idx % 10):
                    revert with 'NH{q', 17
                if t - 1 >= mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]:
                    revert with 'NH{q', 50
                mem[t + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 159 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
                t = t - 1
                idx = idx / 10
                continue 
            if bool(stor9.length):
                if bool(stor9.length) == uint255(stor9.length) * 0.5 < 32:
                    revert with 'NH{q', 34
                if not bool(stor9.length):
                    mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192] = Mask(248, 8, stor9.length)
                    mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                    mem[64] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192
                    mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192] = 32
                    mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 224] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                    mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]
                    if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]) > mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]:
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160] + mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256] = 0
                    return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160], data=mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]), 
                if bool(stor9.length) == 1:
                    mem[0] = 9
                    idx = 0
                    t = 0
                    while idx < uint255(stor9.length) * 0.5:
                        mem[idx + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192] = uint256(stor9[t].field_0)
                        idx = idx + 32
                        t = t + 1
                        continue 
                    mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                    mem[64] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192
                    mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192] = 32
                    mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 224] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                    mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]
                    if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]) > mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]:
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160] + mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256] = 0
                    return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160], data=mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]), 
                _13169 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                mem[0 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                mem[64] = _13169
                mem[_13169] = 32
                if ceil32(_13169) <= _13169:
                    _20221 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                    mem[_13169 + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                    mem[_13169 + 64 len ceil32(_20221)] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(_20221)]
                    if ceil32(_20221) > _20221:
                        mem[_20221 + _13169 + 64] = 0
                    return 32, mem[_13169 + 32 len ceil32(_20221) + 32]
                _20222 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                mem[_13169 + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                mem[_13169 + 64 len ceil32(_20222)] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(_20222)]
                if ceil32(_20222) > _20222:
                    mem[_20222 + _13169 + 64] = 0
                return 32, mem[_13169 + 32 len ceil32(_20222) + 32]
            if bool(stor9.length) == stor9.length.field_1 % 128 < 32:
                revert with 'NH{q', 34
            if not bool(stor9.length):
                mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192] = Mask(248, 8, stor9.length)
                mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                mem[64] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192
                mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192] = 32
                mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 224] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]
                if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]) > mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]:
                    mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160] + mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256] = 0
                return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160], data=mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]), 
            if bool(stor9.length) == 1:
                mem[0] = 9
                idx = 0
                t = 0
                while idx < stor9.length.field_1 % 128:
                    mem[idx + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192] = uint256(stor9[t].field_0)
                    idx = idx + 32
                    t = t + 1
                    continue 
                mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                mem[64] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192
                mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192] = 32
                mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 224] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]
                if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]) > mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]:
                    mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160] + mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256] = 0
                return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160], data=mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]), 
            _13249 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
            mem[0 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
            mem[64] = _13249
            mem[_13249] = 32
            if ceil32(_13249) <= _13249:
                _20225 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                mem[_13249 + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                mem[_13249 + 64 len ceil32(_20225)] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(_20225)]
                if ceil32(_20225) > _20225:
                    mem[_20225 + _13249 + 64] = 0
                return 32, mem[_13249 + 32 len ceil32(_20225) + 32]
            _20226 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
            mem[_13249 + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
            mem[_13249 + 64 len ceil32(_20226)] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(_20226)]
            if ceil32(_20226) > _20226:
                mem[_20226 + _13249 + 64] = 0
            return 32, mem[_13249 + 32 len ceil32(_20226) + 32]
        if 31 >= stor8[arg1].field_1 % 128:
            mem[128] = 256 * Mask(248, 0, stor8[arg1].field_8)
            if bool(stor9.length):
                if bool(stor9.length) == uint255(stor9.length) * 0.5 < 32:
                    revert with 'NH{q', 34
                if not uint255(stor9.length) * 0.5:
                    mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192 len ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5)] = mem[128 len ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5)]
                    if ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) > uint255(uint256(stor8[arg1].field_0)) * 0.5:
                        mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192] = 0
                    return Array(len=2 * Mask(256, -1, uint256(stor8[arg1].field_0)), data=mem[128 len ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5)], mem[(2 * ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5)) + 192 len 2 * ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5)]), 
                if Mask(256, -1, uint256(stor8[arg1].field_0)):
                    if bool(stor9.length):
                        if bool(stor9.length) == uint255(stor9.length) * 0.5 < 32:
                            revert with 'NH{q', 34
                        if not bool(stor9.length):
                            mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160] = Mask(248, 8, stor9.length)
                        else:
                            if bool(stor9.length) != 1:
                                mem[64] = uint255(uint256(stor8[arg1].field_0)) * 0.5
                                if ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) <= uint255(uint256(stor8[arg1].field_0)) * 0.5:
                                    _5335 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                                    mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                                    mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 64 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                                    if ceil32(_5335) > _5335:
                                        mem[_5335 + (uint255(uint256(stor8[arg1].field_0)) * 0.5) + 64] = 0
                                    return 32, mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 32 len ceil32(_5335) + 32]
                                _5336 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                                mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                                mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 64 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                                if ceil32(_5336) > _5336:
                                    mem[_5336 + (uint255(uint256(stor8[arg1].field_0)) * 0.5) + 64] = 0
                                return 32, mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 32 len ceil32(_5336) + 32]
                            idx = 0
                            s = 0
                            while idx < uint255(stor9.length) * 0.5:
                                mem[idx + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160] = uint256(stor9[s].field_0)
                                idx = idx + 32
                                s = s + 1
                                continue 
                        mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 160 len ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5)] = mem[128 len ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5)]
                        mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 160] = 32
                        mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 192] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                        mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 224 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                        if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]) <= mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]:
                            return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128], data=mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 224 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]), 
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + (uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 224] = 0
                        return 32, mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]) + 32], 
                    if bool(stor9.length) == stor9.length.field_1 % 128 < 32:
                        revert with 'NH{q', 34
                    if not bool(stor9.length):
                        mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160] = Mask(248, 8, stor9.length)
                    else:
                        if bool(stor9.length) != 1:
                            mem[64] = uint255(uint256(stor8[arg1].field_0)) * 0.5
                            if ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) <= uint255(uint256(stor8[arg1].field_0)) * 0.5:
                                _5339 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                                mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                                mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 64 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                                if ceil32(_5339) > _5339:
                                    mem[_5339 + (uint255(uint256(stor8[arg1].field_0)) * 0.5) + 64] = 0
                                return 32, mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 32 len ceil32(_5339) + 32]
                            _5340 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                            mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                            mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 64 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                            if ceil32(_5340) > _5340:
                                mem[_5340 + (uint255(uint256(stor8[arg1].field_0)) * 0.5) + 64] = 0
                            return 32, mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 32 len ceil32(_5340) + 32]
                        idx = 0
                        s = 0
                        while idx < stor9.length.field_1 % 128:
                            mem[idx + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160] = uint256(stor9[s].field_0)
                            idx = idx + 32
                            s = s + 1
                            continue 
                    mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 160 len ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5)] = mem[128 len ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5)]
                    mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 160] = 32
                    mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 192] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                    mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 224 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                    if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]) <= mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]:
                        return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128], data=mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 224 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]), 
                    mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + (uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 224] = 0
                    return 32, mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]) + 32], 
                if not arg1:
                    mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] = 1
                    mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160] = '0'
                    if bool(stor9.length):
                        if bool(stor9.length) == uint255(stor9.length) * 0.5 < 32:
                            revert with 'NH{q', 34
                        if not bool(stor9.length):
                            mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 224] = Mask(248, 8, stor9.length)
                        else:
                            if bool(stor9.length) != 1:
                                mem[64] = 1
                                _5328 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192]
                                mem[33] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192]
                                mem[65 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 224 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192])]
                                if ceil32(_5328) > _5328:
                                    mem[_5328 + 65] = 0
                                return memory
                                  from mem[64]
                                   len ceil32(_5328) + -mem[64] + 65
                            idx = 0
                            s = 0
                            while idx < uint255(stor9.length) * 0.5:
                                mem[idx + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 224] = uint256(stor9[s].field_0)
                                idx = idx + 32
                                s = s + 1
                                continue 
                        mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 224] = '0'
                        mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 225] = 32
                        mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 257] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192]
                        mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 289 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 224 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192])]
                        if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192]) > mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192]:
                            mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 289] = 0
                        return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192], data=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 289 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192])]), 
                    if bool(stor9.length) == stor9.length.field_1 % 128 < 32:
                        revert with 'NH{q', 34
                    if not bool(stor9.length):
                        mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 224] = Mask(248, 8, stor9.length)
                    else:
                        if bool(stor9.length) != 1:
                            mem[64] = 1
                            _5332 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192]
                            mem[33] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192]
                            mem[65 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 224 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192])]
                            if ceil32(_5332) > _5332:
                                mem[_5332 + 65] = 0
                            return memory
                              from mem[64]
                               len ceil32(_5332) + -mem[64] + 65
                        idx = 0
                        s = 0
                        while idx < stor9.length.field_1 % 128:
                            mem[idx + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 224] = uint256(stor9[s].field_0)
                            idx = idx + 32
                            s = s + 1
                            continue 
                    mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 224] = '0'
                    mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 225] = 32
                    mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 257] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192]
                    mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 289 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 224 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192])]
                    if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192]) > mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192]:
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 289] = 0
                    return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192], data=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 289 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192])]), 
                s = 0
                idx = arg1
                while idx:
                    if s == -1:
                        revert with 'NH{q', 17
                    s = s + 1
                    idx = idx / 10
                    continue 
                if s > test266151307():
                    revert with 'NH{q', 65
                mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] = s
                if not s:
                    t = s
                    idx = arg1
                    while idx:
                        if t < 1:
                            revert with 'NH{q', 17
                        if 48 > !(idx % 10):
                            revert with 'NH{q', 17
                        if t - 1 >= mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]:
                            revert with 'NH{q', 50
                        mem[t + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 159 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
                        t = t - 1
                        idx = idx / 10
                        continue 
                    if bool(stor9.length):
                        if bool(stor9.length) == uint255(stor9.length) * 0.5 < 32:
                            revert with 'NH{q', 34
                        if not bool(stor9.length):
                            mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192] = Mask(248, 8, stor9.length)
                            mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                            mem[64] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192
                            mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192] = 32
                            mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 224] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                            mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]
                            if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]) > mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]:
                                mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160] + mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256] = 0
                            return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160], data=mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]), 
                        if bool(stor9.length) == 1:
                            mem[0] = 9
                            idx = 0
                            t = 0
                            while idx < uint255(stor9.length) * 0.5:
                                mem[idx + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192] = uint256(stor9[t].field_0)
                                idx = idx + 32
                                t = t + 1
                                continue 
                            mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                            mem[64] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192
                            mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192] = 32
                            mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 224] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                            mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]
                            if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]) > mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]:
                                mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160] + mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256] = 0
                            return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160], data=mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]), 
                        _13171 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                        mem[0 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                        mem[64] = _13171
                        mem[_13171] = 32
                        if ceil32(_13171) <= _13171:
                            _20253 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                            mem[_13171 + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                            mem[_13171 + 64 len ceil32(_20253)] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(_20253)]
                            if ceil32(_20253) > _20253:
                                mem[_20253 + _13171 + 64] = 0
                            return 32, mem[_13171 + 32 len ceil32(_20253) + 32]
                        _20254 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                        mem[_13171 + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                        mem[_13171 + 64 len ceil32(_20254)] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(_20254)]
                        if ceil32(_20254) > _20254:
                            mem[_20254 + _13171 + 64] = 0
                        return 32, mem[_13171 + 32 len ceil32(_20254) + 32]
                    if bool(stor9.length) == stor9.length.field_1 % 128 < 32:
                        revert with 'NH{q', 34
                    if not bool(stor9.length):
                        mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192] = Mask(248, 8, stor9.length)
                        mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                        mem[64] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192] = 32
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 224] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]
                        if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]) > mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]:
                            mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160] + mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256] = 0
                        return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160], data=mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]), 
                    if bool(stor9.length) == 1:
                        mem[0] = 9
                        idx = 0
                        t = 0
                        while idx < stor9.length.field_1 % 128:
                            mem[idx + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192] = uint256(stor9[t].field_0)
                            idx = idx + 32
                            t = t + 1
                            continue 
                        mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                        mem[64] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192] = 32
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 224] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]
                        if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]) > mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]:
                            mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160] + mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256] = 0
                        return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160], data=mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]), 
                    _13267 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                    mem[0 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                    mem[64] = _13267
                    mem[_13267] = 32
                    if ceil32(_13267) <= _13267:
                        _20257 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                        mem[_13267 + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                        mem[_13267 + 64 len ceil32(_20257)] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(_20257)]
                        if ceil32(_20257) > _20257:
                            mem[_20257 + _13267 + 64] = 0
                        return 32, mem[_13267 + 32 len ceil32(_20257) + 32]
                    _20258 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                    mem[_13267 + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                    mem[_13267 + 64 len ceil32(_20258)] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(_20258)]
                    if ceil32(_20258) > _20258:
                        mem[_20258 + _13267 + 64] = 0
                    return 32, mem[_13267 + 32 len ceil32(_20258) + 32]
                mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len s] = call.data[calldata.size len s]
                t = s
                idx = arg1
                while idx:
                    if t < 1:
                        revert with 'NH{q', 17
                    if 48 > !(idx % 10):
                        revert with 'NH{q', 17
                    if t - 1 >= mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]:
                        revert with 'NH{q', 50
                    mem[t + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 159 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
                    t = t - 1
                    idx = idx / 10
                    continue 
                if bool(stor9.length):
                    if bool(stor9.length) == uint255(stor9.length) * 0.5 < 32:
                        revert with 'NH{q', 34
                    if not bool(stor9.length):
                        mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192] = Mask(248, 8, stor9.length)
                        mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                        mem[64] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192] = 32
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 224] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]
                        if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]) > mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]:
                            mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160] + mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256] = 0
                        return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160], data=mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]), 
                    if bool(stor9.length) == 1:
                        mem[0] = 9
                        idx = 0
                        t = 0
                        while idx < uint255(stor9.length) * 0.5:
                            mem[idx + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192] = uint256(stor9[t].field_0)
                            idx = idx + 32
                            t = t + 1
                            continue 
                        mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                        mem[64] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192] = 32
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 224] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]
                        if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]) > mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]:
                            mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160] + mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256] = 0
                        return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160], data=mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]), 
                    _13173 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                    mem[0 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                    mem[64] = _13173
                    mem[_13173] = 32
                    if ceil32(_13173) <= _13173:
                        _20261 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                        mem[_13173 + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                        mem[_13173 + 64 len ceil32(_20261)] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(_20261)]
                        if ceil32(_20261) > _20261:
                            mem[_20261 + _13173 + 64] = 0
                        return 32, mem[_13173 + 32 len ceil32(_20261) + 32]
                    _20262 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                    mem[_13173 + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                    mem[_13173 + 64 len ceil32(_20262)] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(_20262)]
                    if ceil32(_20262) > _20262:
                        mem[_20262 + _13173 + 64] = 0
                    return 32, mem[_13173 + 32 len ceil32(_20262) + 32]
                if bool(stor9.length) == stor9.length.field_1 % 128 < 32:
                    revert with 'NH{q', 34
                if not bool(stor9.length):
                    mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192] = Mask(248, 8, stor9.length)
                    mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                    mem[64] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192
                    mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192] = 32
                    mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 224] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                    mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]
                    if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]) > mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]:
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160] + mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256] = 0
                    return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160], data=mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]), 
                if bool(stor9.length) == 1:
                    mem[0] = 9
                    idx = 0
                    t = 0
                    while idx < stor9.length.field_1 % 128:
                        mem[idx + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192] = uint256(stor9[t].field_0)
                        idx = idx + 32
                        t = t + 1
                        continue 
                    mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                    mem[64] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192
                    mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192] = 32
                    mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 224] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                    mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]
                    if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]) > mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]:
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160] + mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256] = 0
                    return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160], data=mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]), 
                _13269 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                mem[0 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                mem[64] = _13269
                mem[_13269] = 32
                if ceil32(_13269) <= _13269:
                    _20265 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                    mem[_13269 + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                    mem[_13269 + 64 len ceil32(_20265)] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(_20265)]
                    if ceil32(_20265) > _20265:
                        mem[_20265 + _13269 + 64] = 0
                    return 32, mem[_13269 + 32 len ceil32(_20265) + 32]
                _20266 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                mem[_13269 + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                mem[_13269 + 64 len ceil32(_20266)] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(_20266)]
                if ceil32(_20266) > _20266:
                    mem[_20266 + _13269 + 64] = 0
                return 32, mem[_13269 + 32 len ceil32(_20266) + 32]
            if bool(stor9.length) == stor9.length.field_1 % 128 < 32:
                revert with 'NH{q', 34
            if not stor9.length.field_1 % 128:
                mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192 len ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5)] = mem[128 len ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5)]
                if ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) > uint255(uint256(stor8[arg1].field_0)) * 0.5:
                    mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192] = 0
                return Array(len=2 * Mask(256, -1, uint256(stor8[arg1].field_0)), data=mem[128 len ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5)], mem[(2 * ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5)) + 192 len 2 * ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5)]), 
            if Mask(256, -1, uint256(stor8[arg1].field_0)):
                if bool(stor9.length):
                    if bool(stor9.length) == uint255(stor9.length) * 0.5 < 32:
                        revert with 'NH{q', 34
                    if not bool(stor9.length):
                        mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160] = Mask(248, 8, stor9.length)
                    else:
                        if bool(stor9.length) != 1:
                            mem[64] = uint255(uint256(stor8[arg1].field_0)) * 0.5
                            if ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) <= uint255(uint256(stor8[arg1].field_0)) * 0.5:
                                _5351 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                                mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                                mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 64 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                                if ceil32(_5351) > _5351:
                                    mem[_5351 + (uint255(uint256(stor8[arg1].field_0)) * 0.5) + 64] = 0
                                return 32, mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 32 len ceil32(_5351) + 32]
                            _5352 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                            mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                            mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 64 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                            if ceil32(_5352) > _5352:
                                mem[_5352 + (uint255(uint256(stor8[arg1].field_0)) * 0.5) + 64] = 0
                            return 32, mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 32 len ceil32(_5352) + 32]
                        idx = 0
                        s = 0
                        while idx < uint255(stor9.length) * 0.5:
                            mem[idx + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160] = uint256(stor9[s].field_0)
                            idx = idx + 32
                            s = s + 1
                            continue 
                    mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 160 len ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5)] = mem[128 len ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5)]
                    mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 160] = 32
                    mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 192] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                    mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 224 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                    if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]) <= mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]:
                        return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128], data=mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 224 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]), 
                    mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + (uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 224] = 0
                    return 32, mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]) + 32], 
                if bool(stor9.length) == stor9.length.field_1 % 128 < 32:
                    revert with 'NH{q', 34
                if not bool(stor9.length):
                    mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160] = Mask(248, 8, stor9.length)
                else:
                    if bool(stor9.length) != 1:
                        mem[64] = uint255(uint256(stor8[arg1].field_0)) * 0.5
                        if ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) <= uint255(uint256(stor8[arg1].field_0)) * 0.5:
                            _5355 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                            mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                            mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 64 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                            if ceil32(_5355) > _5355:
                                mem[_5355 + (uint255(uint256(stor8[arg1].field_0)) * 0.5) + 64] = 0
                            return 32, mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 32 len ceil32(_5355) + 32]
                        _5356 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                        mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                        mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 64 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                        if ceil32(_5356) > _5356:
                            mem[_5356 + (uint255(uint256(stor8[arg1].field_0)) * 0.5) + 64] = 0
                        return 32, mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 32 len ceil32(_5356) + 32]
                    idx = 0
                    s = 0
                    while idx < stor9.length.field_1 % 128:
                        mem[idx + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160] = uint256(stor9[s].field_0)
                        idx = idx + 32
                        s = s + 1
                        continue 
                mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 160 len ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5)] = mem[128 len ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5)]
                mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 160] = 32
                mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 192] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 224 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]) <= mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]:
                    return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128], data=mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 224 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]), 
                mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + (uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 224] = 0
                return 32, mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]) + 32], 
            if not arg1:
                mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] = 1
                mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160] = '0'
                if bool(stor9.length):
                    if bool(stor9.length) == uint255(stor9.length) * 0.5 < 32:
                        revert with 'NH{q', 34
                    if not bool(stor9.length):
                        mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 224] = Mask(248, 8, stor9.length)
                    else:
                        if bool(stor9.length) != 1:
                            mem[64] = 1
                            _5344 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192]
                            mem[33] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192]
                            mem[65 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 224 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192])]
                            if ceil32(_5344) > _5344:
                                mem[_5344 + 65] = 0
                            return memory
                              from mem[64]
                               len ceil32(_5344) + -mem[64] + 65
                        idx = 0
                        s = 0
                        while idx < uint255(stor9.length) * 0.5:
                            mem[idx + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 224] = uint256(stor9[s].field_0)
                            idx = idx + 32
                            s = s + 1
                            continue 
                    mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 224] = '0'
                    mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 225] = 32
                    mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 257] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192]
                    mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 289 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 224 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192])]
                    if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192]) > mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192]:
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 289] = 0
                    return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192], data=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 289 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192])]), 
                if bool(stor9.length) == stor9.length.field_1 % 128 < 32:
                    revert with 'NH{q', 34
                if not bool(stor9.length):
                    mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 224] = Mask(248, 8, stor9.length)
                else:
                    if bool(stor9.length) != 1:
                        mem[64] = 1
                        _5348 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192]
                        mem[33] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192]
                        mem[65 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 224 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192])]
                        if ceil32(_5348) > _5348:
                            mem[_5348 + 65] = 0
                        return memory
                          from mem[64]
                           len ceil32(_5348) + -mem[64] + 65
                    idx = 0
                    s = 0
                    while idx < stor9.length.field_1 % 128:
                        mem[idx + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 224] = uint256(stor9[s].field_0)
                        idx = idx + 32
                        s = s + 1
                        continue 
                mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 224] = '0'
                mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 225] = 32
                mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 257] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192]
                mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 289 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 224 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192])]
                if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192]) > mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192]:
                    mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 289] = 0
                return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192], data=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 289 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192])]), 
            s = 0
            idx = arg1
            while idx:
                if s == -1:
                    revert with 'NH{q', 17
                s = s + 1
                idx = idx / 10
                continue 
            if s > test266151307():
                revert with 'NH{q', 65
            mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] = s
            if not s:
                t = s
                idx = arg1
                while idx:
                    if t < 1:
                        revert with 'NH{q', 17
                    if 48 > !(idx % 10):
                        revert with 'NH{q', 17
                    if t - 1 >= mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]:
                        revert with 'NH{q', 50
                    mem[t + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 159 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
                    t = t - 1
                    idx = idx / 10
                    continue 
                if bool(stor9.length):
                    if bool(stor9.length) == uint255(stor9.length) * 0.5 < 32:
                        revert with 'NH{q', 34
                    if not bool(stor9.length):
                        mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192] = Mask(248, 8, stor9.length)
                        mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                        mem[64] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192] = 32
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 224] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]
                        if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]) > mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]:
                            mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160] + mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256] = 0
                        return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160], data=mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]), 
                    if bool(stor9.length) == 1:
                        mem[0] = 9
                        idx = 0
                        t = 0
                        while idx < uint255(stor9.length) * 0.5:
                            mem[idx + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192] = uint256(stor9[t].field_0)
                            idx = idx + 32
                            t = t + 1
                            continue 
                        mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                        mem[64] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192] = 32
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 224] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]
                        if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]) > mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]:
                            mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160] + mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256] = 0
                        return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160], data=mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]), 
                    _13175 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                    mem[0 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                    mem[64] = _13175
                    mem[_13175] = 32
                    if ceil32(_13175) <= _13175:
                        _20269 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                        mem[_13175 + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                        mem[_13175 + 64 len ceil32(_20269)] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(_20269)]
                        if ceil32(_20269) > _20269:
                            mem[_20269 + _13175 + 64] = 0
                        return 32, mem[_13175 + 32 len ceil32(_20269) + 32]
                    _20270 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                    mem[_13175 + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                    mem[_13175 + 64 len ceil32(_20270)] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(_20270)]
                    if ceil32(_20270) > _20270:
                        mem[_20270 + _13175 + 64] = 0
                    return 32, mem[_13175 + 32 len ceil32(_20270) + 32]
                if bool(stor9.length) == stor9.length.field_1 % 128 < 32:
                    revert with 'NH{q', 34
                if not bool(stor9.length):
                    mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192] = Mask(248, 8, stor9.length)
                    mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                    mem[64] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192
                    mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192] = 32
                    mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 224] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                    mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]
                    if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]) > mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]:
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160] + mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256] = 0
                    return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160], data=mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]), 
                if bool(stor9.length) == 1:
                    mem[0] = 9
                    idx = 0
                    t = 0
                    while idx < stor9.length.field_1 % 128:
                        mem[idx + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192] = uint256(stor9[t].field_0)
                        idx = idx + 32
                        t = t + 1
                        continue 
                    mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                    mem[64] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192
                    mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192] = 32
                    mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 224] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                    mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]
                    if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]) > mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]:
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160] + mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256] = 0
                    return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160], data=mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]), 
                _13271 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                mem[0 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                mem[64] = _13271
                mem[_13271] = 32
                if ceil32(_13271) <= _13271:
                    _20273 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                    mem[_13271 + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                    mem[_13271 + 64 len ceil32(_20273)] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(_20273)]
                    if ceil32(_20273) > _20273:
                        mem[_20273 + _13271 + 64] = 0
                    return 32, mem[_13271 + 32 len ceil32(_20273) + 32]
                _20274 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                mem[_13271 + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                mem[_13271 + 64 len ceil32(_20274)] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(_20274)]
                if ceil32(_20274) > _20274:
                    mem[_20274 + _13271 + 64] = 0
                return 32, mem[_13271 + 32 len ceil32(_20274) + 32]
            mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len s] = call.data[calldata.size len s]
            t = s
            idx = arg1
            while idx:
                if t < 1:
                    revert with 'NH{q', 17
                if 48 > !(idx % 10):
                    revert with 'NH{q', 17
                if t - 1 >= mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]:
                    revert with 'NH{q', 50
                mem[t + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 159 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
                t = t - 1
                idx = idx / 10
                continue 
            if bool(stor9.length):
                if bool(stor9.length) == uint255(stor9.length) * 0.5 < 32:
                    revert with 'NH{q', 34
                if not bool(stor9.length):
                    mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192] = Mask(248, 8, stor9.length)
                    mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                    mem[64] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192
                    mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192] = 32
                    mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 224] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                    mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]
                    if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]) > mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]:
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160] + mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256] = 0
                    return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160], data=mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]), 
                if bool(stor9.length) == 1:
                    mem[0] = 9
                    idx = 0
                    t = 0
                    while idx < uint255(stor9.length) * 0.5:
                        mem[idx + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192] = uint256(stor9[t].field_0)
                        idx = idx + 32
                        t = t + 1
                        continue 
                    mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                    mem[64] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192
                    mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192] = 32
                    mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 224] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                    mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]
                    if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]) > mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]:
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160] + mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256] = 0
                    return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160], data=mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]), 
                _13177 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                mem[0 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                mem[64] = _13177
                mem[_13177] = 32
                if ceil32(_13177) <= _13177:
                    _20277 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                    mem[_13177 + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                    mem[_13177 + 64 len ceil32(_20277)] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(_20277)]
                    if ceil32(_20277) > _20277:
                        mem[_20277 + _13177 + 64] = 0
                    return 32, mem[_13177 + 32 len ceil32(_20277) + 32]
                _20278 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                mem[_13177 + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                mem[_13177 + 64 len ceil32(_20278)] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(_20278)]
                if ceil32(_20278) > _20278:
                    mem[_20278 + _13177 + 64] = 0
                return 32, mem[_13177 + 32 len ceil32(_20278) + 32]
            if bool(stor9.length) == stor9.length.field_1 % 128 < 32:
                revert with 'NH{q', 34
            if not bool(stor9.length):
                mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192] = Mask(248, 8, stor9.length)
                mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                mem[64] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192
                mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192] = 32
                mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 224] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]
                if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]) > mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]:
                    mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160] + mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256] = 0
                return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160], data=mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]), 
            if bool(stor9.length) == 1:
                mem[0] = 9
                idx = 0
                t = 0
                while idx < stor9.length.field_1 % 128:
                    mem[idx + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192] = uint256(stor9[t].field_0)
                    idx = idx + 32
                    t = t + 1
                    continue 
                mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                mem[64] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192
                mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192] = 32
                mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 224] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]
                if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]) > mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]:
                    mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160] + mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256] = 0
                return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160], data=mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]), 
            _13273 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
            mem[0 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
            mem[64] = _13273
            mem[_13273] = 32
            if ceil32(_13273) <= _13273:
                _20281 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                mem[_13273 + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                mem[_13273 + 64 len ceil32(_20281)] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(_20281)]
                if ceil32(_20281) > _20281:
                    mem[_20281 + _13273 + 64] = 0
                return 32, mem[_13273 + 32 len ceil32(_20281) + 32]
            _20282 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
            mem[_13273 + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
            mem[_13273 + 64 len ceil32(_20282)] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(_20282)]
            if ceil32(_20282) > _20282:
                mem[_20282 + _13273 + 64] = 0
            return 32, mem[_13273 + 32 len ceil32(_20282) + 32]
        mem[0] = sha3(arg1, 8)
        mem[128] = uint256(stor8[arg1].field_0)
        idx = 128
        s = 0
        while stor8[arg1].field_1 % 128 + 96 > idx:
            mem[idx + 32] = uint256(stor8[arg1][s].field_256)
            idx = idx + 32
            s = s + 1
            continue 
        if bool(stor9.length):
            if bool(stor9.length) == uint255(stor9.length) * 0.5 < 32:
                revert with 'NH{q', 34
            if not uint255(stor9.length) * 0.5:
                return Array(len=2 * Mask(256, -1, uint256(stor8[arg1].field_0)), data=mem[128 len ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5)]), 
            if Mask(256, -1, uint256(stor8[arg1].field_0)):
                if bool(stor9.length):
                    if bool(stor9.length) == uint255(stor9.length) * 0.5 < 32:
                        revert with 'NH{q', 34
                    if not bool(stor9.length):
                        mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160] = Mask(248, 8, stor9.length)
                        mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 160 len ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5)] = mem[128 len ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5)]
                        var49001 = ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5)
                        mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 160] = 32
                        mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 192] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                        mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 224 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                        var60001 = ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])
                        if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]) <= mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]:
                            return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128], data=mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 224 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]), 
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + (uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 224] = 0
                        return 32, mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]) + 32], 
                    if bool(stor9.length) == 1:
                        idx = 0
                        s = 0
                        while idx < uint255(stor9.length) * 0.5:
                            mem[idx + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160] = uint256(stor9[s].field_0)
                            idx = idx + 32
                            s = s + 1
                            continue 
                        mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 160 len ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5)] = mem[128 len ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5)]
                        mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 160] = 32
                        mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 192] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                        mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 224 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                        if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]) <= mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]:
                            return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128], data=mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 224 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]), 
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + (uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 224] = 0
                        return 32, mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]) + 32], 
                    var50001 = ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5)
                    mem[64] = uint255(uint256(stor8[arg1].field_0)) * 0.5
                    if ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) <= uint255(uint256(stor8[arg1].field_0)) * 0.5:
                        _12941 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                        mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                        mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 64 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                        var61001 = ceil32(_12941)
                        if ceil32(_12941) > _12941:
                            mem[_12941 + (uint255(uint256(stor8[arg1].field_0)) * 0.5) + 64] = 0
                        return 32, mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 32 len ceil32(_12941) + 32]
                    _12942 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                    mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                    mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 64 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                    var61001 = ceil32(_12942)
                    if ceil32(_12942) > _12942:
                        mem[_12942 + (uint255(uint256(stor8[arg1].field_0)) * 0.5) + 64] = 0
                    return 32, mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 32 len ceil32(_12942) + 32]
                if bool(stor9.length) == stor9.length.field_1 % 128 < 32:
                    revert with 'NH{q', 34
                if bool(stor9.length):
                    if bool(stor9.length) == 1:
                        idx = 0
                        s = 0
                        while idx < stor9.length.field_1 % 128:
                            mem[idx + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160] = uint256(stor9[s].field_0)
                            idx = idx + 32
                            s = s + 1
                            continue 
                        mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 160 len ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5)] = mem[128 len ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5)]
                        mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 160] = 32
                        mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 192] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                        mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 224 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                        if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]) <= mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]:
                            return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128], data=mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 224 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]), 
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + (uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 224] = 0
                        return 32, mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]) + 32], 
                    var51001 = ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5)
                    mem[64] = uint255(uint256(stor8[arg1].field_0)) * 0.5
                    if ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) <= uint255(uint256(stor8[arg1].field_0)) * 0.5:
                        _12945 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                        mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                        mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 64 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                        if ceil32(_12945) > _12945:
                            mem[_12945 + (uint255(uint256(stor8[arg1].field_0)) * 0.5) + 64] = 0
                        return 32, mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 32 len ceil32(_12945) + 32]
                    _12946 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                    mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                    mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 64 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                    if ceil32(_12946) > _12946:
                        mem[_12946 + (uint255(uint256(stor8[arg1].field_0)) * 0.5) + 64] = 0
                    return 32, mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 32 len ceil32(_12946) + 32]
                mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160] = Mask(248, 8, stor9.length)
                mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 160 len ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5)] = mem[128 len ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5)]
                var50001 = ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5)
                mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 160] = 32
                mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 192] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 224 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                var61001 = ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])
                if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]) <= mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]:
                    return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128], data=mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 224 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]), 
                mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + (uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 224] = 0
                return 32, mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]) + 32], 
            if not arg1:
                mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] = 1
                mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160] = '0'
                if bool(stor9.length):
                    if bool(stor9.length) == uint255(stor9.length) * 0.5 < 32:
                        revert with 'NH{q', 34
                    if not bool(stor9.length):
                        mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 224] = Mask(248, 8, stor9.length)
                        mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 224] = '0'
                        var52001 = 32
                    else:
                        if bool(stor9.length) != 1:
                            mem[64] = 1
                            _12934 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192]
                            mem[33] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192]
                            mem[65 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 224 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192])]
                            if ceil32(_12934) > _12934:
                                mem[_12934 + 65] = 0
                            return memory
                              from mem[64]
                               len ceil32(_12934) + -mem[64] + 65
                        idx = 0
                        s = 0
                        while idx < uint255(stor9.length) * 0.5:
                            mem[idx + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 224] = uint256(stor9[s].field_0)
                            idx = idx + 32
                            s = s + 1
                            continue 
                        mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 224] = '0'
                    mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 225] = 32
                    mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 257] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192]
                    mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 289 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 224 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192])]
                    if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192]) > mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192]:
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 289] = 0
                    return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192], data=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 289 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192])]), 
                if bool(stor9.length) == stor9.length.field_1 % 128 < 32:
                    revert with 'NH{q', 34
                if not bool(stor9.length):
                    mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 224] = Mask(248, 8, stor9.length)
                else:
                    if bool(stor9.length) != 1:
                        mem[64] = 1
                        _12938 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192]
                        mem[33] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192]
                        mem[65 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 224 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192])]
                        if ceil32(_12938) > _12938:
                            mem[_12938 + 65] = 0
                        return memory
                          from mem[64]
                           len ceil32(_12938) + -mem[64] + 65
                    idx = 0
                    s = 0
                    while idx < stor9.length.field_1 % 128:
                        mem[idx + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 224] = uint256(stor9[s].field_0)
                        idx = idx + 32
                        s = s + 1
                        continue 
                mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 224] = '0'
                mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 225] = 32
                mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 257] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192]
                mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 289 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 224 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192])]
                if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192]) > mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192]:
                    mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 289] = 0
                return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192], data=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 289 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192])]), 
            s = 0
            idx = arg1
            while idx:
                if s == -1:
                    revert with 'NH{q', 17
                s = s + 1
                idx = idx / 10
                continue 
            if s > test266151307():
                revert with 'NH{q', 65
            mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] = s
            if not s:
                t = s
                idx = arg1
                while idx:
                    if t < 1:
                        revert with 'NH{q', 17
                    if 48 > !(idx % 10):
                        revert with 'NH{q', 17
                    if t - 1 >= mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]:
                        revert with 'NH{q', 50
                    mem[t + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 159 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
                    t = t - 1
                    idx = idx / 10
                    continue 
                if not bool(stor9.length):
                    if bool(stor9.length) == stor9.length.field_1 % 128 < 32:
                        revert with 'NH{q', 34
                    if not bool(stor9.length):
                        mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192] = Mask(248, 8, stor9.length)
                        mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                        var61001 = ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])
                        mem[64] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192] = 32
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 224] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]
                        if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]) > mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]:
                            mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160] + mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256] = 0
                        return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160], data=mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]), 
                    if bool(stor9.length) == 1:
                        mem[0] = 9
                        idx = 0
                        t = 0
                        while idx < stor9.length.field_1 % 128:
                            mem[idx + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192] = uint256(stor9[t].field_0)
                            idx = idx + 32
                            t = t + 1
                            continue 
                        mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                        mem[64] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192] = 32
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 224] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]
                        if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]) > mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]:
                            mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160] + mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256] = 0
                        return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160], data=mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]), 
                    _20547 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                    mem[0 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                    mem[64] = _20547
                    mem[_20547] = 32
                    if ceil32(_20547) <= _20547:
                        _25281 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                        mem[_20547 + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                        mem[_20547 + 64 len ceil32(_25281)] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(_25281)]
                        if ceil32(_25281) > _25281:
                            mem[_25281 + _20547 + 64] = 0
                        return 32, mem[_20547 + 32 len ceil32(_25281) + 32]
                    _25282 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                    mem[_20547 + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                    mem[_20547 + 64 len ceil32(_25282)] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(_25282)]
                    if ceil32(_25282) > _25282:
                        mem[_25282 + _20547 + 64] = 0
                    return 32, mem[_20547 + 32 len ceil32(_25282) + 32]
                if bool(stor9.length) == uint255(stor9.length) * 0.5 < 32:
                    revert with 'NH{q', 34
                if not bool(stor9.length):
                    mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192] = Mask(248, 8, stor9.length)
                    mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                    var60001 = ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])
                    mem[64] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192
                    mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192] = 32
                    mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 224] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                    mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]
                    if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]) > mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]:
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160] + mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256] = 0
                    return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160], data=mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]), 
                if bool(stor9.length) == 1:
                    mem[0] = 9
                    idx = 0
                    t = 0
                    while idx < uint255(stor9.length) * 0.5:
                        mem[idx + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192] = uint256(stor9[t].field_0)
                        idx = idx + 32
                        t = t + 1
                        continue 
                    mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                    mem[64] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192
                    mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192] = 32
                    mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 224] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                    mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]
                    if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]) > mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]:
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160] + mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256] = 0
                    return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160], data=mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]), 
                _20467 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                mem[0 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                var61001 = ceil32(_20467)
                mem[64] = _20467
                mem[_20467] = 32
                if ceil32(_20467) <= _20467:
                    _25277 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                    mem[_20467 + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                    mem[_20467 + 64 len ceil32(_25277)] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(_25277)]
                    if ceil32(_25277) > _25277:
                        mem[_25277 + _20467 + 64] = 0
                    return 32, mem[_20467 + 32 len ceil32(_25277) + 32]
                _25278 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                mem[_20467 + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                mem[_20467 + 64 len ceil32(_25278)] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(_25278)]
                if ceil32(_25278) > _25278:
                    mem[_25278 + _20467 + 64] = 0
                return 32, mem[_20467 + 32 len ceil32(_25278) + 32]
            mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len s] = call.data[calldata.size len s]
            t = s
            idx = arg1
            while idx:
                if t < 1:
                    revert with 'NH{q', 17
                if 48 > !(idx % 10):
                    revert with 'NH{q', 17
                if t - 1 >= mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]:
                    revert with 'NH{q', 50
                mem[t + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 159 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
                t = t - 1
                idx = idx / 10
                continue 
            if bool(stor9.length):
                if bool(stor9.length) == uint255(stor9.length) * 0.5 < 32:
                    revert with 'NH{q', 34
                if not bool(stor9.length):
                    mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192] = Mask(248, 8, stor9.length)
                    mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                    var61001 = ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])
                    mem[64] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192
                    mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192] = 32
                    mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 224] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                    mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]
                    if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]) > mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]:
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160] + mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256] = 0
                    return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160], data=mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]), 
                if bool(stor9.length) == 1:
                    mem[0] = 9
                    idx = 0
                    t = 0
                    while idx < uint255(stor9.length) * 0.5:
                        mem[idx + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192] = uint256(stor9[t].field_0)
                        idx = idx + 32
                        t = t + 1
                        continue 
                    mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                    mem[64] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192
                    mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192] = 32
                    mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 224] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                    mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]
                    if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]) > mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]:
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160] + mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256] = 0
                    return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160], data=mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]), 
                _20469 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                mem[0 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                mem[64] = _20469
                mem[_20469] = 32
                if ceil32(_20469) <= _20469:
                    _25285 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                    mem[_20469 + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                    mem[_20469 + 64 len ceil32(_25285)] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(_25285)]
                    if ceil32(_25285) > _25285:
                        mem[_25285 + _20469 + 64] = 0
                    return 32, mem[_20469 + 32 len ceil32(_25285) + 32]
                _25286 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                mem[_20469 + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                mem[_20469 + 64 len ceil32(_25286)] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(_25286)]
                if ceil32(_25286) > _25286:
                    mem[_25286 + _20469 + 64] = 0
                return 32, mem[_20469 + 32 len ceil32(_25286) + 32]
            if bool(stor9.length) == stor9.length.field_1 % 128 < 32:
                revert with 'NH{q', 34
            if not bool(stor9.length):
                mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192] = Mask(248, 8, stor9.length)
                mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                mem[64] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192
                mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192] = 32
                mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 224] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]
                if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]) > mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]:
                    mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160] + mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256] = 0
                return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160], data=mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]), 
            if bool(stor9.length) == 1:
                mem[0] = 9
                idx = 0
                t = 0
                while idx < stor9.length.field_1 % 128:
                    mem[idx + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192] = uint256(stor9[t].field_0)
                    idx = idx + 32
                    t = t + 1
                    continue 
                mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                mem[64] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192
                mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192] = 32
                mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 224] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]
                if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]) > mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]:
                    mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160] + mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256] = 0
                return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160], data=mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]), 
            _20549 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
            mem[0 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
            mem[64] = _20549
            mem[_20549] = 32
            if ceil32(_20549) <= _20549:
                _25289 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                mem[_20549 + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                mem[_20549 + 64 len ceil32(_25289)] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(_25289)]
                if ceil32(_25289) > _25289:
                    mem[_25289 + _20549 + 64] = 0
                return 32, mem[_20549 + 32 len ceil32(_25289) + 32]
            _25290 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
            mem[_20549 + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
            mem[_20549 + 64 len ceil32(_25290)] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(_25290)]
            if ceil32(_25290) > _25290:
                mem[_25290 + _20549 + 64] = 0
            return 32, mem[_20549 + 32 len ceil32(_25290) + 32]
        if bool(stor9.length) == stor9.length.field_1 % 128 < 32:
            revert with 'NH{q', 34
        if not stor9.length.field_1 % 128:
            return Array(len=2 * Mask(256, -1, uint256(stor8[arg1].field_0)), data=mem[128 len ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5)]), 
        if Mask(256, -1, uint256(stor8[arg1].field_0)):
            if not bool(stor9.length):
                if bool(stor9.length) == stor9.length.field_1 % 128 < 32:
                    revert with 'NH{q', 34
                if not bool(stor9.length):
                    mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160] = Mask(248, 8, stor9.length)
                    mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 160 len ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5)] = mem[128 len ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5)]
                    var51001 = ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5)
                    mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 160] = 32
                    mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 192] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                    mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 224 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                    if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]) <= mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]:
                        return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128], data=mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 224 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]), 
                    mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + (uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 224] = 0
                    return 32, mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]) + 32], 
                if bool(stor9.length) == 1:
                    idx = 0
                    s = 0
                    while idx < stor9.length.field_1 % 128:
                        mem[idx + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160] = uint256(stor9[s].field_0)
                        idx = idx + 32
                        s = s + 1
                        continue 
                    mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 160 len ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5)] = mem[128 len ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5)]
                    mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 160] = 32
                    mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 192] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                    mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 224 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                    if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]) <= mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]:
                        return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128], data=mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 224 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]), 
                    mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + (uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 224] = 0
                    return 32, mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]) + 32], 
                var52001 = ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5)
                mem[64] = uint255(uint256(stor8[arg1].field_0)) * 0.5
                if ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) <= uint255(uint256(stor8[arg1].field_0)) * 0.5:
                    _12961 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                    mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                    mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 64 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                    if ceil32(_12961) > _12961:
                        mem[_12961 + (uint255(uint256(stor8[arg1].field_0)) * 0.5) + 64] = 0
                    return 32, mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 32 len ceil32(_12961) + 32]
                _12962 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 64 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                if ceil32(_12962) > _12962:
                    mem[_12962 + (uint255(uint256(stor8[arg1].field_0)) * 0.5) + 64] = 0
                return 32, mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 32 len ceil32(_12962) + 32]
            if bool(stor9.length) == uint255(stor9.length) * 0.5 < 32:
                revert with 'NH{q', 34
            if bool(stor9.length):
                if bool(stor9.length) == 1:
                    idx = 0
                    s = 0
                    while idx < uint255(stor9.length) * 0.5:
                        mem[idx + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160] = uint256(stor9[s].field_0)
                        idx = idx + 32
                        s = s + 1
                        continue 
                    mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 160 len ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5)] = mem[128 len ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5)]
                    mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 160] = 32
                    mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 192] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                    mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 224 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                    if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]) <= mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]:
                        return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128], data=mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 224 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]), 
                    mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + (uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 224] = 0
                    return 32, mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]) + 32], 
                var51001 = ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5)
                mem[64] = uint255(uint256(stor8[arg1].field_0)) * 0.5
                if ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) <= uint255(uint256(stor8[arg1].field_0)) * 0.5:
                    _12957 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                    mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                    mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 64 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                    if ceil32(_12957) > _12957:
                        mem[_12957 + (uint255(uint256(stor8[arg1].field_0)) * 0.5) + 64] = 0
                    return 32, mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 32 len ceil32(_12957) + 32]
                _12958 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 64 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                if ceil32(_12958) > _12958:
                    mem[_12958 + (uint255(uint256(stor8[arg1].field_0)) * 0.5) + 64] = 0
                return 32, mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 32 len ceil32(_12958) + 32]
            mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160] = Mask(248, 8, stor9.length)
            mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 160 len ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5)] = mem[128 len ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5)]
            var50001 = ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5)
            mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 160] = 32
            mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 192] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
            mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 224 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
            var61001 = ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])
            if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]) <= mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]:
                return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128], data=mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 224 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]), 
            mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + (uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 224] = 0
            return 32, mem[(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]) + 32], 
        if not arg1:
            mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] = 1
            mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160] = '0'
            if bool(stor9.length):
                if bool(stor9.length) == uint255(stor9.length) * 0.5 < 32:
                    revert with 'NH{q', 34
                if not bool(stor9.length):
                    mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 224] = Mask(248, 8, stor9.length)
                else:
                    if bool(stor9.length) != 1:
                        mem[64] = 1
                        _12950 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192]
                        mem[33] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192]
                        mem[65 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 224 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192])]
                        if ceil32(_12950) > _12950:
                            mem[_12950 + 65] = 0
                        return memory
                          from mem[64]
                           len ceil32(_12950) + -mem[64] + 65
                    idx = 0
                    s = 0
                    while idx < uint255(stor9.length) * 0.5:
                        mem[idx + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 224] = uint256(stor9[s].field_0)
                        idx = idx + 32
                        s = s + 1
                        continue 
                mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 224] = '0'
                mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 225] = 32
                mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 257] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192]
                mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 289 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 224 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192])]
                if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192]) > mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192]:
                    mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 289] = 0
                return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192], data=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + (uint255(stor9.length) * 0.5) + 289 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192])]), 
            if bool(stor9.length) == stor9.length.field_1 % 128 < 32:
                revert with 'NH{q', 34
            if not bool(stor9.length):
                mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 224] = Mask(248, 8, stor9.length)
                mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 224] = '0'
            else:
                if bool(stor9.length) != 1:
                    mem[64] = 1
                    _12954 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192]
                    mem[33] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192]
                    mem[65 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 224 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192])]
                    if ceil32(_12954) > _12954:
                        mem[_12954 + 65] = 0
                    return memory
                      from mem[64]
                       len ceil32(_12954) + -mem[64] + 65
                idx = 0
                s = 0
                while idx < stor9.length.field_1 % 128:
                    mem[idx + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 224] = uint256(stor9[s].field_0)
                    idx = idx + 32
                    s = s + 1
                    continue 
                mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 224] = '0'
                var58001 = 32
            mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 225] = 32
            mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 257] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192]
            mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 289 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 224 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192])]
            if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192]) > mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192]:
                mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 289] = 0
            return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192], data=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + stor9.length.field_1 % 128 + 289 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 192])]), 
        s = 0
        idx = arg1
        while idx:
            if s == -1:
                revert with 'NH{q', 17
            s = s + 1
            idx = idx / 10
            continue 
        if s > test266151307():
            revert with 'NH{q', 65
        mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] = s
        if not s:
            t = s
            idx = arg1
            while idx:
                if t < 1:
                    revert with 'NH{q', 17
                if 48 > !(idx % 10):
                    revert with 'NH{q', 17
                if t - 1 >= mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]:
                    revert with 'NH{q', 50
                mem[t + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 159 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
                t = t - 1
                idx = idx / 10
                continue 
            if bool(stor9.length):
                if bool(stor9.length) == uint255(stor9.length) * 0.5 < 32:
                    revert with 'NH{q', 34
                if not bool(stor9.length):
                    mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192] = Mask(248, 8, stor9.length)
                    mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                    var61001 = ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])
                    mem[64] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192
                    mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192] = 32
                    mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 224] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                    mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]
                    if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]) > mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]:
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160] + mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256] = 0
                    return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160], data=mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]), 
                if bool(stor9.length) == 1:
                    mem[0] = 9
                    idx = 0
                    t = 0
                    while idx < uint255(stor9.length) * 0.5:
                        mem[idx + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192] = uint256(stor9[t].field_0)
                        idx = idx + 32
                        t = t + 1
                        continue 
                    mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                    mem[64] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192
                    mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192] = 32
                    mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 224] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                    mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]
                    if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]) > mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]:
                        mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160] + mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256] = 0
                    return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160], data=mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]), 
                _20471 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
                mem[0 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                mem[64] = _20471
                mem[_20471] = 32
                if ceil32(_20471) <= _20471:
                    _25293 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                    mem[_20471 + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                    mem[_20471 + 64 len ceil32(_25293)] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(_25293)]
                    if ceil32(_25293) > _25293:
                        mem[_25293 + _20471 + 64] = 0
                    return 32, mem[_20471 + 32 len ceil32(_25293) + 32]
                _25294 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                mem[_20471 + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                mem[_20471 + 64 len ceil32(_25294)] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(_25294)]
                if ceil32(_25294) > _25294:
                    mem[_25294 + _20471 + 64] = 0
                return 32, mem[_20471 + 32 len ceil32(_25294) + 32]
            if bool(stor9.length) == stor9.length.field_1 % 128 < 32:
                revert with 'NH{q', 34
            if not bool(stor9.length):
                mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192] = Mask(248, 8, stor9.length)
                mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                mem[64] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192
                mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192] = 32
                mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 224] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]
                if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]) > mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]:
                    mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160] + mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256] = 0
                return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160], data=mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]), 
            if bool(stor9.length) == 1:
                mem[0] = 9
                idx = 0
                t = 0
                while idx < stor9.length.field_1 % 128:
                    mem[idx + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192] = uint256(stor9[t].field_0)
                    idx = idx + 32
                    t = t + 1
                    continue 
                mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                mem[64] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192
                mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192] = 32
                mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 224] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]
                if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]) > mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]:
                    mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160] + mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256] = 0
                return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160], data=mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]), 
            _20551 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
            mem[0 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
            mem[64] = _20551
            mem[_20551] = 32
            if ceil32(_20551) <= _20551:
                _25297 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                mem[_20551 + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                mem[_20551 + 64 len ceil32(_25297)] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(_25297)]
                if ceil32(_25297) > _25297:
                    mem[_25297 + _20551 + 64] = 0
                return 32, mem[_20551 + 32 len ceil32(_25297) + 32]
            _25298 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
            mem[_20551 + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
            mem[_20551 + 64 len ceil32(_25298)] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(_25298)]
            if ceil32(_25298) > _25298:
                mem[_25298 + _20551 + 64] = 0
            return 32, mem[_20551 + 32 len ceil32(_25298) + 32]
        mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len s] = call.data[calldata.size len s]
        t = s
        idx = arg1
        while idx:
            if t < 1:
                revert with 'NH{q', 17
            if 48 > !(idx % 10):
                revert with 'NH{q', 17
            if t - 1 >= mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]:
                revert with 'NH{q', 50
            mem[t + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 159 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
            t = t - 1
            idx = idx / 10
            continue 
        if bool(stor9.length):
            if bool(stor9.length) == uint255(stor9.length) * 0.5 < 32:
                revert with 'NH{q', 34
            if not bool(stor9.length):
                mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192] = Mask(248, 8, stor9.length)
                mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                mem[64] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192
                mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192] = 32
                mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 224] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]
                if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]) > mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]:
                    mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160] + mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256] = 0
                return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160], data=mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]), 
            if bool(stor9.length) == 1:
                mem[0] = 9
                idx = 0
                t = 0
                while idx < uint255(stor9.length) * 0.5:
                    mem[idx + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192] = uint256(stor9[t].field_0)
                    idx = idx + 32
                    t = t + 1
                    continue 
                mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
                mem[64] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192
                mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192] = 32
                mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 224] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]
                if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]) > mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]:
                    mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160] + mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256] = 0
                return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160], data=mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]), 
            _20473 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
            mem[0 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
            mem[64] = _20473
            mem[_20473] = 32
            if ceil32(_20473) <= _20473:
                _25301 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                mem[_20473 + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
                mem[_20473 + 64 len ceil32(_25301)] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(_25301)]
                if ceil32(_25301) > _25301:
                    mem[_25301 + _20473 + 64] = 0
                return 32, mem[_20473 + 32 len ceil32(_25301) + 32]
            _25302 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
            mem[_20473 + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
            mem[_20473 + 64 len ceil32(_25302)] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(_25302)]
            if ceil32(_25302) > _25302:
                mem[_25302 + _20473 + 64] = 0
            return 32, mem[_20473 + 32 len ceil32(_25302) + 32]
        if bool(stor9.length) == stor9.length.field_1 % 128 < 32:
            revert with 'NH{q', 34
        if not bool(stor9.length):
            mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192] = Mask(248, 8, stor9.length)
            mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
            mem[64] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192
            mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192] = 32
            mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 224] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
            mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]
            if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]) > mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]:
                mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160] + mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256] = 0
            return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160], data=mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]), 
        if bool(stor9.length) == 1:
            mem[0] = 9
            idx = 0
            t = 0
            while idx < stor9.length.field_1 % 128:
                mem[idx + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192] = uint256(stor9[t].field_0)
                idx = idx + 32
                t = t + 1
                continue 
            mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
            mem[64] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192
            mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 192] = 32
            mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 224] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
            mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]
            if ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]) > mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]:
                mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160] + mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256] = 0
            return Array(len=mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160], data=mem[mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128] + ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160])]), 
        _20553 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128]
        mem[0 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 160 len ceil32(mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + 128])]
        mem[64] = _20553
        mem[_20553] = 32
        if ceil32(_20553) <= _20553:
            _25305 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
            mem[_20553 + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
            mem[_20553 + 64 len ceil32(_25305)] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(_25305)]
            if ceil32(_25305) > _25305:
                mem[_25305 + _20553 + 64] = 0
            return 32, mem[_20553 + 32 len ceil32(_25305) + 32]
        _25306 = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
        mem[_20553 + 32] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 160]
        mem[_20553 + 64 len ceil32(_25306)] = mem[ceil32(uint255(uint256(stor8[arg1].field_0)) * 0.5) + ceil32(s) + 192 len ceil32(_25306)]
        if ceil32(_25306) > _25306:
            mem[_25306 + _20553 + 64] = 0
        return 32, mem[_20553 + 32 len ceil32(_25306) + 32]
    if bool(stor8[arg1].field_0) == stor8[arg1].field_1 % 128 < 32:
        revert with 'NH{q', 34
    mem[96] = stor8[arg1].field_1 % 128
    if bool(stor8[arg1].field_0):
        if bool(stor8[arg1].field_0) == uint255(uint256(stor8[arg1].field_0)) * 0.5 < 32:
            revert with 'NH{q', 34
        if not Mask(256, -1, uint256(stor8[arg1].field_0)):
            if bool(stor9.length):
                if bool(stor9.length) == uint255(stor9.length) * 0.5 < 32:
                    revert with 'NH{q', 34
                if not uint255(stor9.length) * 0.5:
                    mem[ceil32(stor8[arg1].field_1 % 128) + 192 len ceil32(stor8[arg1].field_1 % 128)] = mem[128 len ceil32(stor8[arg1].field_1 % 128)]
                    if ceil32(stor8[arg1].field_1 % 128) > stor8[arg1].field_1 % 128:
                        mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + 192] = 0
                    return Array(len=stor8[arg1].field_0 % 128, data=mem[128 len ceil32(stor8[arg1].field_1 % 128)], mem[(2 * ceil32(stor8[arg1].field_1 % 128)) + 192 len 2 * ceil32(stor8[arg1].field_1 % 128)]), 
                if stor8[arg1].field_1 % 128:
                    if bool(stor9.length):
                        if bool(stor9.length) == uint255(stor9.length) * 0.5 < 32:
                            revert with 'NH{q', 34
                        if not bool(stor9.length):
                            mem[ceil32(stor8[arg1].field_1 % 128) + 160] = Mask(248, 8, stor9.length)
                        else:
                            if bool(stor9.length) != 1:
                                mem[64] = stor8[arg1].field_1 % 128
                                if ceil32(stor8[arg1].field_1 % 128) <= stor8[arg1].field_1 % 128:
                                    _5367 = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                                    mem[stor8[arg1].field_1 % 128 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                                    mem[stor8[arg1].field_1 % 128 + 64 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                                    if ceil32(_5367) > _5367:
                                        mem[_5367 + stor8[arg1].field_1 % 128 + 64] = 0
                                    return 32, mem[stor8[arg1].field_1 % 128 + 32 len ceil32(_5367) + 32]
                                _5368 = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                                mem[stor8[arg1].field_1 % 128 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                                mem[stor8[arg1].field_1 % 128 + 64 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                                if ceil32(_5368) > _5368:
                                    mem[_5368 + stor8[arg1].field_1 % 128 + 64] = 0
                                return 32, mem[stor8[arg1].field_1 % 128 + 32 len ceil32(_5368) + 32]
                            idx = 0
                            s = 0
                            while idx < uint255(stor9.length) * 0.5:
                                mem[idx + ceil32(stor8[arg1].field_1 % 128) + 160] = uint256(stor9[s].field_0)
                                idx = idx + 32
                                s = s + 1
                                continue 
                        mem[ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 160 len ceil32(stor8[arg1].field_1 % 128)] = mem[128 len ceil32(stor8[arg1].field_1 % 128)]
                        mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 160] = 32
                        mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 192] = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                        mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 224 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                        if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128]) <= mem[ceil32(stor8[arg1].field_1 % 128) + 128]:
                            return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + 128], data=mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 224 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]), 
                        mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 224] = 0
                        return 32, mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128]) + 32], 
                    if bool(stor9.length) == stor9.length.field_1 % 128 < 32:
                        revert with 'NH{q', 34
                    if not bool(stor9.length):
                        mem[ceil32(stor8[arg1].field_1 % 128) + 160] = Mask(248, 8, stor9.length)
                    else:
                        if bool(stor9.length) != 1:
                            mem[64] = stor8[arg1].field_1 % 128
                            if ceil32(stor8[arg1].field_1 % 128) <= stor8[arg1].field_1 % 128:
                                _5371 = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                                mem[stor8[arg1].field_1 % 128 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                                mem[stor8[arg1].field_1 % 128 + 64 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                                if ceil32(_5371) > _5371:
                                    mem[_5371 + stor8[arg1].field_1 % 128 + 64] = 0
                                return 32, mem[stor8[arg1].field_1 % 128 + 32 len ceil32(_5371) + 32]
                            _5372 = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                            mem[stor8[arg1].field_1 % 128 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                            mem[stor8[arg1].field_1 % 128 + 64 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                            if ceil32(_5372) > _5372:
                                mem[_5372 + stor8[arg1].field_1 % 128 + 64] = 0
                            return 32, mem[stor8[arg1].field_1 % 128 + 32 len ceil32(_5372) + 32]
                        idx = 0
                        s = 0
                        while idx < stor9.length.field_1 % 128:
                            mem[idx + ceil32(stor8[arg1].field_1 % 128) + 160] = uint256(stor9[s].field_0)
                            idx = idx + 32
                            s = s + 1
                            continue 
                    mem[ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 160 len ceil32(stor8[arg1].field_1 % 128)] = mem[128 len ceil32(stor8[arg1].field_1 % 128)]
                    mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 160] = 32
                    mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 192] = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                    mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 224 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                    if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128]) <= mem[ceil32(stor8[arg1].field_1 % 128) + 128]:
                        return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + 128], data=mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 224 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]), 
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 224] = 0
                    return 32, mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128]) + 32], 
                if not arg1:
                    mem[ceil32(stor8[arg1].field_1 % 128) + 128] = 1
                    mem[ceil32(stor8[arg1].field_1 % 128) + 160] = '0'
                    if bool(stor9.length):
                        if bool(stor9.length) == uint255(stor9.length) * 0.5 < 32:
                            revert with 'NH{q', 34
                        if not bool(stor9.length):
                            mem[ceil32(stor8[arg1].field_1 % 128) + 224] = Mask(248, 8, stor9.length)
                        else:
                            if bool(stor9.length) != 1:
                                mem[64] = 1
                                _5360 = mem[ceil32(stor8[arg1].field_1 % 128) + 192]
                                mem[33] = mem[ceil32(stor8[arg1].field_1 % 128) + 192]
                                mem[65 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192])] = mem[ceil32(stor8[arg1].field_1 % 128) + 224 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192])]
                                if ceil32(_5360) > _5360:
                                    mem[_5360 + 65] = 0
                                return memory
                                  from mem[64]
                                   len ceil32(_5360) + -mem[64] + 65
                            idx = 0
                            s = 0
                            while idx < uint255(stor9.length) * 0.5:
                                mem[idx + ceil32(stor8[arg1].field_1 % 128) + 224] = uint256(stor9[s].field_0)
                                idx = idx + 32
                                s = s + 1
                                continue 
                        mem[ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 224] = '0'
                        mem[ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 225] = 32
                        mem[ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 257] = mem[ceil32(stor8[arg1].field_1 % 128) + 192]
                        mem[ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 289 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192])] = mem[ceil32(stor8[arg1].field_1 % 128) + 224 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192])]
                        if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192]) > mem[ceil32(stor8[arg1].field_1 % 128) + 192]:
                            mem[mem[ceil32(stor8[arg1].field_1 % 128) + 192] + ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 289] = 0
                        return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + 192], data=mem[ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 289 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192])]), 
                    if bool(stor9.length) == stor9.length.field_1 % 128 < 32:
                        revert with 'NH{q', 34
                    if not bool(stor9.length):
                        mem[ceil32(stor8[arg1].field_1 % 128) + 224] = Mask(248, 8, stor9.length)
                    else:
                        if bool(stor9.length) != 1:
                            mem[64] = 1
                            _5364 = mem[ceil32(stor8[arg1].field_1 % 128) + 192]
                            mem[33] = mem[ceil32(stor8[arg1].field_1 % 128) + 192]
                            mem[65 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192])] = mem[ceil32(stor8[arg1].field_1 % 128) + 224 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192])]
                            if ceil32(_5364) > _5364:
                                mem[_5364 + 65] = 0
                            return memory
                              from mem[64]
                               len ceil32(_5364) + -mem[64] + 65
                        idx = 0
                        s = 0
                        while idx < stor9.length.field_1 % 128:
                            mem[idx + ceil32(stor8[arg1].field_1 % 128) + 224] = uint256(stor9[s].field_0)
                            idx = idx + 32
                            s = s + 1
                            continue 
                    mem[ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 224] = '0'
                    mem[ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 225] = 32
                    mem[ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 257] = mem[ceil32(stor8[arg1].field_1 % 128) + 192]
                    mem[ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 289 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192])] = mem[ceil32(stor8[arg1].field_1 % 128) + 224 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192])]
                    if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192]) > mem[ceil32(stor8[arg1].field_1 % 128) + 192]:
                        mem[mem[ceil32(stor8[arg1].field_1 % 128) + 192] + ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 289] = 0
                    return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + 192], data=mem[ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 289 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192])]), 
                s = 0
                idx = arg1
                while idx:
                    if s == -1:
                        revert with 'NH{q', 17
                    s = s + 1
                    idx = idx / 10
                    continue 
                if s > test266151307():
                    revert with 'NH{q', 65
                mem[ceil32(stor8[arg1].field_1 % 128) + 128] = s
                if not s:
                    t = s
                    idx = arg1
                    while idx:
                        if t < 1:
                            revert with 'NH{q', 17
                        if 48 > !(idx % 10):
                            revert with 'NH{q', 17
                        if t - 1 >= mem[ceil32(stor8[arg1].field_1 % 128) + 128]:
                            revert with 'NH{q', 50
                        mem[t + ceil32(stor8[arg1].field_1 % 128) + 159 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
                        t = t - 1
                        idx = idx / 10
                        continue 
                    if bool(stor9.length):
                        if bool(stor9.length) == uint255(stor9.length) * 0.5 < 32:
                            revert with 'NH{q', 34
                        if not bool(stor9.length):
                            mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192] = Mask(248, 8, stor9.length)
                            mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                            mem[64] = mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192
                            mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192] = 32
                            mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 224] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                            mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]
                            if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]) > mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]:
                                mem[mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160] + mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256] = 0
                            return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160], data=mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]), 
                        if bool(stor9.length) == 1:
                            mem[0] = 9
                            idx = 0
                            t = 0
                            while idx < uint255(stor9.length) * 0.5:
                                mem[idx + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192] = uint256(stor9[t].field_0)
                                idx = idx + 32
                                t = t + 1
                                continue 
                            mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                            mem[64] = mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192
                            mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192] = 32
                            mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 224] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                            mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]
                            if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]) > mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]:
                                mem[mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160] + mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256] = 0
                            return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160], data=mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]), 
                        _13179 = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                        mem[0 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                        mem[64] = _13179
                        mem[_13179] = 32
                        if ceil32(_13179) <= _13179:
                            _20285 = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                            mem[_13179 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                            mem[_13179 + 64 len ceil32(_20285)] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(_20285)]
                            if ceil32(_20285) > _20285:
                                mem[_20285 + _13179 + 64] = 0
                            return 32, mem[_13179 + 32 len ceil32(_20285) + 32]
                        _20286 = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                        mem[_13179 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                        mem[_13179 + 64 len ceil32(_20286)] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(_20286)]
                        if ceil32(_20286) > _20286:
                            mem[_20286 + _13179 + 64] = 0
                        return 32, mem[_13179 + 32 len ceil32(_20286) + 32]
                    if bool(stor9.length) == stor9.length.field_1 % 128 < 32:
                        revert with 'NH{q', 34
                    if not bool(stor9.length):
                        mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192] = Mask(248, 8, stor9.length)
                        mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                        mem[64] = mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192
                        mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192] = 32
                        mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 224] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                        mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]
                        if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]) > mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]:
                            mem[mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160] + mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256] = 0
                        return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160], data=mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]), 
                    if bool(stor9.length) == 1:
                        mem[0] = 9
                        idx = 0
                        t = 0
                        while idx < stor9.length.field_1 % 128:
                            mem[idx + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192] = uint256(stor9[t].field_0)
                            idx = idx + 32
                            t = t + 1
                            continue 
                        mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                        mem[64] = mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192
                        mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192] = 32
                        mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 224] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                        mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]
                        if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]) > mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]:
                            mem[mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160] + mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256] = 0
                        return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160], data=mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]), 
                    _13275 = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                    mem[0 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                    mem[64] = _13275
                    mem[_13275] = 32
                    if ceil32(_13275) <= _13275:
                        _20289 = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                        mem[_13275 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                        mem[_13275 + 64 len ceil32(_20289)] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(_20289)]
                        if ceil32(_20289) > _20289:
                            mem[_20289 + _13275 + 64] = 0
                        return 32, mem[_13275 + 32 len ceil32(_20289) + 32]
                    _20290 = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                    mem[_13275 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                    mem[_13275 + 64 len ceil32(_20290)] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(_20290)]
                    if ceil32(_20290) > _20290:
                        mem[_20290 + _13275 + 64] = 0
                    return 32, mem[_13275 + 32 len ceil32(_20290) + 32]
                mem[ceil32(stor8[arg1].field_1 % 128) + 160 len s] = call.data[calldata.size len s]
                t = s
                idx = arg1
                while idx:
                    if t < 1:
                        revert with 'NH{q', 17
                    if 48 > !(idx % 10):
                        revert with 'NH{q', 17
                    if t - 1 >= mem[ceil32(stor8[arg1].field_1 % 128) + 128]:
                        revert with 'NH{q', 50
                    mem[t + ceil32(stor8[arg1].field_1 % 128) + 159 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
                    t = t - 1
                    idx = idx / 10
                    continue 
                if bool(stor9.length):
                    if bool(stor9.length) == uint255(stor9.length) * 0.5 < 32:
                        revert with 'NH{q', 34
                    if not bool(stor9.length):
                        mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192] = Mask(248, 8, stor9.length)
                        mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                        mem[64] = mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192
                        mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192] = 32
                        mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 224] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                        mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]
                        if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]) > mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]:
                            mem[mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160] + mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256] = 0
                        return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160], data=mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]), 
                    if bool(stor9.length) == 1:
                        mem[0] = 9
                        idx = 0
                        t = 0
                        while idx < uint255(stor9.length) * 0.5:
                            mem[idx + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192] = uint256(stor9[t].field_0)
                            idx = idx + 32
                            t = t + 1
                            continue 
                        mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                        mem[64] = mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192
                        mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192] = 32
                        mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 224] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                        mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]
                        if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]) > mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]:
                            mem[mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160] + mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256] = 0
                        return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160], data=mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]), 
                    _13181 = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                    mem[0 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                    mem[64] = _13181
                    mem[_13181] = 32
                    if ceil32(_13181) <= _13181:
                        _20293 = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                        mem[_13181 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                        mem[_13181 + 64 len ceil32(_20293)] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(_20293)]
                        if ceil32(_20293) > _20293:
                            mem[_20293 + _13181 + 64] = 0
                        return 32, mem[_13181 + 32 len ceil32(_20293) + 32]
                    _20294 = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                    mem[_13181 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                    mem[_13181 + 64 len ceil32(_20294)] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(_20294)]
                    if ceil32(_20294) > _20294:
                        mem[_20294 + _13181 + 64] = 0
                    return 32, mem[_13181 + 32 len ceil32(_20294) + 32]
                if bool(stor9.length) == stor9.length.field_1 % 128 < 32:
                    revert with 'NH{q', 34
                if not bool(stor9.length):
                    mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192] = Mask(248, 8, stor9.length)
                    mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                    mem[64] = mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192] = 32
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 224] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]
                    if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]) > mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]:
                        mem[mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160] + mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256] = 0
                    return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160], data=mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]), 
                if bool(stor9.length) == 1:
                    mem[0] = 9
                    idx = 0
                    t = 0
                    while idx < stor9.length.field_1 % 128:
                        mem[idx + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192] = uint256(stor9[t].field_0)
                        idx = idx + 32
                        t = t + 1
                        continue 
                    mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                    mem[64] = mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192] = 32
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 224] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]
                    if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]) > mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]:
                        mem[mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160] + mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256] = 0
                    return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160], data=mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]), 
                _13277 = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                mem[0 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                mem[64] = _13277
                mem[_13277] = 32
                if ceil32(_13277) <= _13277:
                    _20297 = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                    mem[_13277 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                    mem[_13277 + 64 len ceil32(_20297)] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(_20297)]
                    if ceil32(_20297) > _20297:
                        mem[_20297 + _13277 + 64] = 0
                    return 32, mem[_13277 + 32 len ceil32(_20297) + 32]
                _20298 = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                mem[_13277 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                mem[_13277 + 64 len ceil32(_20298)] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(_20298)]
                if ceil32(_20298) > _20298:
                    mem[_20298 + _13277 + 64] = 0
                return 32, mem[_13277 + 32 len ceil32(_20298) + 32]
            if bool(stor9.length) == stor9.length.field_1 % 128 < 32:
                revert with 'NH{q', 34
            if not stor9.length.field_1 % 128:
                mem[ceil32(stor8[arg1].field_1 % 128) + 192 len ceil32(stor8[arg1].field_1 % 128)] = mem[128 len ceil32(stor8[arg1].field_1 % 128)]
                if ceil32(stor8[arg1].field_1 % 128) > stor8[arg1].field_1 % 128:
                    mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + 192] = 0
                return Array(len=stor8[arg1].field_0 % 128, data=mem[128 len ceil32(stor8[arg1].field_1 % 128)], mem[(2 * ceil32(stor8[arg1].field_1 % 128)) + 192 len 2 * ceil32(stor8[arg1].field_1 % 128)]), 
            if stor8[arg1].field_1 % 128:
                if bool(stor9.length):
                    if bool(stor9.length) == uint255(stor9.length) * 0.5 < 32:
                        revert with 'NH{q', 34
                    if not bool(stor9.length):
                        mem[ceil32(stor8[arg1].field_1 % 128) + 160] = Mask(248, 8, stor9.length)
                    else:
                        if bool(stor9.length) != 1:
                            mem[64] = stor8[arg1].field_1 % 128
                            if ceil32(stor8[arg1].field_1 % 128) <= stor8[arg1].field_1 % 128:
                                _5383 = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                                mem[stor8[arg1].field_1 % 128 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                                mem[stor8[arg1].field_1 % 128 + 64 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                                if ceil32(_5383) > _5383:
                                    mem[_5383 + stor8[arg1].field_1 % 128 + 64] = 0
                                return 32, mem[stor8[arg1].field_1 % 128 + 32 len ceil32(_5383) + 32]
                            _5384 = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                            mem[stor8[arg1].field_1 % 128 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                            mem[stor8[arg1].field_1 % 128 + 64 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                            if ceil32(_5384) > _5384:
                                mem[_5384 + stor8[arg1].field_1 % 128 + 64] = 0
                            return 32, mem[stor8[arg1].field_1 % 128 + 32 len ceil32(_5384) + 32]
                        idx = 0
                        s = 0
                        while idx < uint255(stor9.length) * 0.5:
                            mem[idx + ceil32(stor8[arg1].field_1 % 128) + 160] = uint256(stor9[s].field_0)
                            idx = idx + 32
                            s = s + 1
                            continue 
                    mem[ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 160 len ceil32(stor8[arg1].field_1 % 128)] = mem[128 len ceil32(stor8[arg1].field_1 % 128)]
                    mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 160] = 32
                    mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 192] = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                    mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 224 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                    if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128]) <= mem[ceil32(stor8[arg1].field_1 % 128) + 128]:
                        return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + 128], data=mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 224 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]), 
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 224] = 0
                    return 32, mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128]) + 32], 
                if bool(stor9.length) == stor9.length.field_1 % 128 < 32:
                    revert with 'NH{q', 34
                if not bool(stor9.length):
                    mem[ceil32(stor8[arg1].field_1 % 128) + 160] = Mask(248, 8, stor9.length)
                else:
                    if bool(stor9.length) != 1:
                        mem[64] = stor8[arg1].field_1 % 128
                        if ceil32(stor8[arg1].field_1 % 128) <= stor8[arg1].field_1 % 128:
                            _5387 = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                            mem[stor8[arg1].field_1 % 128 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                            mem[stor8[arg1].field_1 % 128 + 64 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                            if ceil32(_5387) > _5387:
                                mem[_5387 + stor8[arg1].field_1 % 128 + 64] = 0
                            return 32, mem[stor8[arg1].field_1 % 128 + 32 len ceil32(_5387) + 32]
                        _5388 = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                        mem[stor8[arg1].field_1 % 128 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                        mem[stor8[arg1].field_1 % 128 + 64 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                        if ceil32(_5388) > _5388:
                            mem[_5388 + stor8[arg1].field_1 % 128 + 64] = 0
                        return 32, mem[stor8[arg1].field_1 % 128 + 32 len ceil32(_5388) + 32]
                    idx = 0
                    s = 0
                    while idx < stor9.length.field_1 % 128:
                        mem[idx + ceil32(stor8[arg1].field_1 % 128) + 160] = uint256(stor9[s].field_0)
                        idx = idx + 32
                        s = s + 1
                        continue 
                mem[ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 160 len ceil32(stor8[arg1].field_1 % 128)] = mem[128 len ceil32(stor8[arg1].field_1 % 128)]
                mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 160] = 32
                mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 192] = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 224 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128]) <= mem[ceil32(stor8[arg1].field_1 % 128) + 128]:
                    return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + 128], data=mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 224 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]), 
                mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 224] = 0
                return 32, mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128]) + 32], 
            if not arg1:
                mem[ceil32(stor8[arg1].field_1 % 128) + 128] = 1
                mem[ceil32(stor8[arg1].field_1 % 128) + 160] = '0'
                if bool(stor9.length):
                    if bool(stor9.length) == uint255(stor9.length) * 0.5 < 32:
                        revert with 'NH{q', 34
                    if not bool(stor9.length):
                        mem[ceil32(stor8[arg1].field_1 % 128) + 224] = Mask(248, 8, stor9.length)
                    else:
                        if bool(stor9.length) != 1:
                            mem[64] = 1
                            _5376 = mem[ceil32(stor8[arg1].field_1 % 128) + 192]
                            mem[33] = mem[ceil32(stor8[arg1].field_1 % 128) + 192]
                            mem[65 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192])] = mem[ceil32(stor8[arg1].field_1 % 128) + 224 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192])]
                            if ceil32(_5376) > _5376:
                                mem[_5376 + 65] = 0
                            return memory
                              from mem[64]
                               len ceil32(_5376) + -mem[64] + 65
                        idx = 0
                        s = 0
                        while idx < uint255(stor9.length) * 0.5:
                            mem[idx + ceil32(stor8[arg1].field_1 % 128) + 224] = uint256(stor9[s].field_0)
                            idx = idx + 32
                            s = s + 1
                            continue 
                    mem[ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 224] = '0'
                    mem[ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 225] = 32
                    mem[ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 257] = mem[ceil32(stor8[arg1].field_1 % 128) + 192]
                    mem[ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 289 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192])] = mem[ceil32(stor8[arg1].field_1 % 128) + 224 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192])]
                    if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192]) > mem[ceil32(stor8[arg1].field_1 % 128) + 192]:
                        mem[mem[ceil32(stor8[arg1].field_1 % 128) + 192] + ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 289] = 0
                    return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + 192], data=mem[ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 289 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192])]), 
                if bool(stor9.length) == stor9.length.field_1 % 128 < 32:
                    revert with 'NH{q', 34
                if not bool(stor9.length):
                    mem[ceil32(stor8[arg1].field_1 % 128) + 224] = Mask(248, 8, stor9.length)
                else:
                    if bool(stor9.length) != 1:
                        mem[64] = 1
                        _5380 = mem[ceil32(stor8[arg1].field_1 % 128) + 192]
                        mem[33] = mem[ceil32(stor8[arg1].field_1 % 128) + 192]
                        mem[65 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192])] = mem[ceil32(stor8[arg1].field_1 % 128) + 224 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192])]
                        if ceil32(_5380) > _5380:
                            mem[_5380 + 65] = 0
                        return memory
                          from mem[64]
                           len ceil32(_5380) + -mem[64] + 65
                    idx = 0
                    s = 0
                    while idx < stor9.length.field_1 % 128:
                        mem[idx + ceil32(stor8[arg1].field_1 % 128) + 224] = uint256(stor9[s].field_0)
                        idx = idx + 32
                        s = s + 1
                        continue 
                mem[ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 224] = '0'
                mem[ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 225] = 32
                mem[ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 257] = mem[ceil32(stor8[arg1].field_1 % 128) + 192]
                mem[ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 289 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192])] = mem[ceil32(stor8[arg1].field_1 % 128) + 224 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192])]
                if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192]) > mem[ceil32(stor8[arg1].field_1 % 128) + 192]:
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + 192] + ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 289] = 0
                return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + 192], data=mem[ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 289 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192])]), 
            s = 0
            idx = arg1
            while idx:
                if s == -1:
                    revert with 'NH{q', 17
                s = s + 1
                idx = idx / 10
                continue 
            if s > test266151307():
                revert with 'NH{q', 65
            mem[ceil32(stor8[arg1].field_1 % 128) + 128] = s
            if not s:
                t = s
                idx = arg1
                while idx:
                    if t < 1:
                        revert with 'NH{q', 17
                    if 48 > !(idx % 10):
                        revert with 'NH{q', 17
                    if t - 1 >= mem[ceil32(stor8[arg1].field_1 % 128) + 128]:
                        revert with 'NH{q', 50
                    mem[t + ceil32(stor8[arg1].field_1 % 128) + 159 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
                    t = t - 1
                    idx = idx / 10
                    continue 
                if bool(stor9.length):
                    if bool(stor9.length) == uint255(stor9.length) * 0.5 < 32:
                        revert with 'NH{q', 34
                    if not bool(stor9.length):
                        mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192] = Mask(248, 8, stor9.length)
                        mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                        mem[64] = mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192
                        mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192] = 32
                        mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 224] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                        mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]
                        if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]) > mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]:
                            mem[mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160] + mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256] = 0
                        return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160], data=mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]), 
                    if bool(stor9.length) == 1:
                        mem[0] = 9
                        idx = 0
                        t = 0
                        while idx < uint255(stor9.length) * 0.5:
                            mem[idx + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192] = uint256(stor9[t].field_0)
                            idx = idx + 32
                            t = t + 1
                            continue 
                        mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                        mem[64] = mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192
                        mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192] = 32
                        mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 224] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                        mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]
                        if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]) > mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]:
                            mem[mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160] + mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256] = 0
                        return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160], data=mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]), 
                    _13183 = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                    mem[0 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                    mem[64] = _13183
                    mem[_13183] = 32
                    if ceil32(_13183) <= _13183:
                        _20301 = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                        mem[_13183 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                        mem[_13183 + 64 len ceil32(_20301)] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(_20301)]
                        if ceil32(_20301) > _20301:
                            mem[_20301 + _13183 + 64] = 0
                        return 32, mem[_13183 + 32 len ceil32(_20301) + 32]
                    _20302 = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                    mem[_13183 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                    mem[_13183 + 64 len ceil32(_20302)] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(_20302)]
                    if ceil32(_20302) > _20302:
                        mem[_20302 + _13183 + 64] = 0
                    return 32, mem[_13183 + 32 len ceil32(_20302) + 32]
                if bool(stor9.length) == stor9.length.field_1 % 128 < 32:
                    revert with 'NH{q', 34
                if not bool(stor9.length):
                    mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192] = Mask(248, 8, stor9.length)
                    mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                    mem[64] = mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192] = 32
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 224] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]
                    if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]) > mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]:
                        mem[mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160] + mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256] = 0
                    return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160], data=mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]), 
                if bool(stor9.length) == 1:
                    mem[0] = 9
                    idx = 0
                    t = 0
                    while idx < stor9.length.field_1 % 128:
                        mem[idx + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192] = uint256(stor9[t].field_0)
                        idx = idx + 32
                        t = t + 1
                        continue 
                    mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                    mem[64] = mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192] = 32
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 224] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]
                    if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]) > mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]:
                        mem[mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160] + mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256] = 0
                    return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160], data=mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]), 
                _13279 = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                mem[0 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                mem[64] = _13279
                mem[_13279] = 32
                if ceil32(_13279) <= _13279:
                    _20305 = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                    mem[_13279 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                    mem[_13279 + 64 len ceil32(_20305)] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(_20305)]
                    if ceil32(_20305) > _20305:
                        mem[_20305 + _13279 + 64] = 0
                    return 32, mem[_13279 + 32 len ceil32(_20305) + 32]
                _20306 = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                mem[_13279 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                mem[_13279 + 64 len ceil32(_20306)] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(_20306)]
                if ceil32(_20306) > _20306:
                    mem[_20306 + _13279 + 64] = 0
                return 32, mem[_13279 + 32 len ceil32(_20306) + 32]
            mem[ceil32(stor8[arg1].field_1 % 128) + 160 len s] = call.data[calldata.size len s]
            t = s
            idx = arg1
            while idx:
                if t < 1:
                    revert with 'NH{q', 17
                if 48 > !(idx % 10):
                    revert with 'NH{q', 17
                if t - 1 >= mem[ceil32(stor8[arg1].field_1 % 128) + 128]:
                    revert with 'NH{q', 50
                mem[t + ceil32(stor8[arg1].field_1 % 128) + 159 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
                t = t - 1
                idx = idx / 10
                continue 
            if bool(stor9.length):
                if bool(stor9.length) == uint255(stor9.length) * 0.5 < 32:
                    revert with 'NH{q', 34
                if not bool(stor9.length):
                    mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192] = Mask(248, 8, stor9.length)
                    mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                    mem[64] = mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192] = 32
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 224] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]
                    if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]) > mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]:
                        mem[mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160] + mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256] = 0
                    return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160], data=mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]), 
                if bool(stor9.length) == 1:
                    mem[0] = 9
                    idx = 0
                    t = 0
                    while idx < uint255(stor9.length) * 0.5:
                        mem[idx + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192] = uint256(stor9[t].field_0)
                        idx = idx + 32
                        t = t + 1
                        continue 
                    mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                    mem[64] = mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192] = 32
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 224] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]
                    if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]) > mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]:
                        mem[mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160] + mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256] = 0
                    return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160], data=mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]), 
                _13185 = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                mem[0 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                mem[64] = _13185
                mem[_13185] = 32
                if ceil32(_13185) <= _13185:
                    _20309 = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                    mem[_13185 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                    mem[_13185 + 64 len ceil32(_20309)] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(_20309)]
                    if ceil32(_20309) > _20309:
                        mem[_20309 + _13185 + 64] = 0
                    return 32, mem[_13185 + 32 len ceil32(_20309) + 32]
                _20310 = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                mem[_13185 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                mem[_13185 + 64 len ceil32(_20310)] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(_20310)]
                if ceil32(_20310) > _20310:
                    mem[_20310 + _13185 + 64] = 0
                return 32, mem[_13185 + 32 len ceil32(_20310) + 32]
            if bool(stor9.length) == stor9.length.field_1 % 128 < 32:
                revert with 'NH{q', 34
            if not bool(stor9.length):
                mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192] = Mask(248, 8, stor9.length)
                mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                mem[64] = mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192
                mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192] = 32
                mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 224] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]
                if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]) > mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]:
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160] + mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256] = 0
                return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160], data=mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]), 
            if bool(stor9.length) == 1:
                mem[0] = 9
                idx = 0
                t = 0
                while idx < stor9.length.field_1 % 128:
                    mem[idx + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192] = uint256(stor9[t].field_0)
                    idx = idx + 32
                    t = t + 1
                    continue 
                mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                mem[64] = mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192
                mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192] = 32
                mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 224] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]
                if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]) > mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]:
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160] + mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256] = 0
                return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160], data=mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]), 
            _13281 = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
            mem[0 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
            mem[64] = _13281
            mem[_13281] = 32
            if ceil32(_13281) <= _13281:
                _20313 = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                mem[_13281 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                mem[_13281 + 64 len ceil32(_20313)] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(_20313)]
                if ceil32(_20313) > _20313:
                    mem[_20313 + _13281 + 64] = 0
                return 32, mem[_13281 + 32 len ceil32(_20313) + 32]
            _20314 = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
            mem[_13281 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
            mem[_13281 + 64 len ceil32(_20314)] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(_20314)]
            if ceil32(_20314) > _20314:
                mem[_20314 + _13281 + 64] = 0
            return 32, mem[_13281 + 32 len ceil32(_20314) + 32]
        if 31 >= uint255(uint256(stor8[arg1].field_0)) * 0.5:
            mem[128] = 256 * Mask(248, 0, stor8[arg1].field_8)
            if bool(stor9.length):
                if bool(stor9.length) == uint255(stor9.length) * 0.5 < 32:
                    revert with 'NH{q', 34
                if not uint255(stor9.length) * 0.5:
                    mem[ceil32(stor8[arg1].field_1 % 128) + 192 len ceil32(stor8[arg1].field_1 % 128)] = mem[128 len ceil32(stor8[arg1].field_1 % 128)]
                    if ceil32(stor8[arg1].field_1 % 128) > stor8[arg1].field_1 % 128:
                        mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + 192] = 0
                    return Array(len=stor8[arg1].field_0 % 128, data=mem[128 len ceil32(stor8[arg1].field_1 % 128)], mem[(2 * ceil32(stor8[arg1].field_1 % 128)) + 192 len 2 * ceil32(stor8[arg1].field_1 % 128)]), 
                if stor8[arg1].field_1 % 128:
                    if bool(stor9.length):
                        if bool(stor9.length) == uint255(stor9.length) * 0.5 < 32:
                            revert with 'NH{q', 34
                        if not bool(stor9.length):
                            mem[ceil32(stor8[arg1].field_1 % 128) + 160] = Mask(248, 8, stor9.length)
                        else:
                            if bool(stor9.length) != 1:
                                mem[64] = stor8[arg1].field_1 % 128
                                if ceil32(stor8[arg1].field_1 % 128) <= stor8[arg1].field_1 % 128:
                                    _5402 = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                                    mem[stor8[arg1].field_1 % 128 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                                    mem[stor8[arg1].field_1 % 128 + 64 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                                    if ceil32(_5402) > _5402:
                                        mem[_5402 + stor8[arg1].field_1 % 128 + 64] = 0
                                    return 32, mem[stor8[arg1].field_1 % 128 + 32 len ceil32(_5402) + 32]
                                _5403 = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                                mem[stor8[arg1].field_1 % 128 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                                mem[stor8[arg1].field_1 % 128 + 64 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                                if ceil32(_5403) > _5403:
                                    mem[_5403 + stor8[arg1].field_1 % 128 + 64] = 0
                                return 32, mem[stor8[arg1].field_1 % 128 + 32 len ceil32(_5403) + 32]
                            idx = 0
                            s = 0
                            while idx < uint255(stor9.length) * 0.5:
                                mem[idx + ceil32(stor8[arg1].field_1 % 128) + 160] = uint256(stor9[s].field_0)
                                idx = idx + 32
                                s = s + 1
                                continue 
                        mem[ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 160 len ceil32(stor8[arg1].field_1 % 128)] = mem[128 len ceil32(stor8[arg1].field_1 % 128)]
                        mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 160] = 32
                        mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 192] = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                        mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 224 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                        if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128]) <= mem[ceil32(stor8[arg1].field_1 % 128) + 128]:
                            return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + 128], data=mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 224 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]), 
                        mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 224] = 0
                        return 32, mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128]) + 32], 
                    if bool(stor9.length) == stor9.length.field_1 % 128 < 32:
                        revert with 'NH{q', 34
                    if not bool(stor9.length):
                        mem[ceil32(stor8[arg1].field_1 % 128) + 160] = Mask(248, 8, stor9.length)
                    else:
                        if bool(stor9.length) != 1:
                            mem[64] = stor8[arg1].field_1 % 128
                            if ceil32(stor8[arg1].field_1 % 128) <= stor8[arg1].field_1 % 128:
                                _5406 = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                                mem[stor8[arg1].field_1 % 128 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                                mem[stor8[arg1].field_1 % 128 + 64 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                                if ceil32(_5406) > _5406:
                                    mem[_5406 + stor8[arg1].field_1 % 128 + 64] = 0
                                return 32, mem[stor8[arg1].field_1 % 128 + 32 len ceil32(_5406) + 32]
                            _5407 = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                            mem[stor8[arg1].field_1 % 128 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                            mem[stor8[arg1].field_1 % 128 + 64 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                            if ceil32(_5407) > _5407:
                                mem[_5407 + stor8[arg1].field_1 % 128 + 64] = 0
                            return 32, mem[stor8[arg1].field_1 % 128 + 32 len ceil32(_5407) + 32]
                        idx = 0
                        s = 0
                        while idx < stor9.length.field_1 % 128:
                            mem[idx + ceil32(stor8[arg1].field_1 % 128) + 160] = uint256(stor9[s].field_0)
                            idx = idx + 32
                            s = s + 1
                            continue 
                    mem[ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 160 len ceil32(stor8[arg1].field_1 % 128)] = mem[128 len ceil32(stor8[arg1].field_1 % 128)]
                    mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 160] = 32
                    mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 192] = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                    mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 224 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                    if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128]) <= mem[ceil32(stor8[arg1].field_1 % 128) + 128]:
                        return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + 128], data=mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 224 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]), 
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 224] = 0
                    return 32, mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128]) + 32], 
                if not arg1:
                    mem[ceil32(stor8[arg1].field_1 % 128) + 128] = 1
                    mem[ceil32(stor8[arg1].field_1 % 128) + 160] = '0'
                    if bool(stor9.length):
                        if bool(stor9.length) == uint255(stor9.length) * 0.5 < 32:
                            revert with 'NH{q', 34
                        if not bool(stor9.length):
                            mem[ceil32(stor8[arg1].field_1 % 128) + 224] = Mask(248, 8, stor9.length)
                        else:
                            if bool(stor9.length) != 1:
                                mem[64] = 1
                                _5395 = mem[ceil32(stor8[arg1].field_1 % 128) + 192]
                                mem[33] = mem[ceil32(stor8[arg1].field_1 % 128) + 192]
                                mem[65 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192])] = mem[ceil32(stor8[arg1].field_1 % 128) + 224 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192])]
                                if ceil32(_5395) > _5395:
                                    mem[_5395 + 65] = 0
                                return memory
                                  from mem[64]
                                   len ceil32(_5395) + -mem[64] + 65
                            idx = 0
                            s = 0
                            while idx < uint255(stor9.length) * 0.5:
                                mem[idx + ceil32(stor8[arg1].field_1 % 128) + 224] = uint256(stor9[s].field_0)
                                idx = idx + 32
                                s = s + 1
                                continue 
                        mem[ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 224] = '0'
                        mem[ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 225] = 32
                        mem[ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 257] = mem[ceil32(stor8[arg1].field_1 % 128) + 192]
                        mem[ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 289 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192])] = mem[ceil32(stor8[arg1].field_1 % 128) + 224 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192])]
                        if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192]) > mem[ceil32(stor8[arg1].field_1 % 128) + 192]:
                            mem[mem[ceil32(stor8[arg1].field_1 % 128) + 192] + ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 289] = 0
                        return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + 192], data=mem[ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 289 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192])]), 
                    if bool(stor9.length) == stor9.length.field_1 % 128 < 32:
                        revert with 'NH{q', 34
                    if not bool(stor9.length):
                        mem[ceil32(stor8[arg1].field_1 % 128) + 224] = Mask(248, 8, stor9.length)
                    else:
                        if bool(stor9.length) != 1:
                            mem[64] = 1
                            _5399 = mem[ceil32(stor8[arg1].field_1 % 128) + 192]
                            mem[33] = mem[ceil32(stor8[arg1].field_1 % 128) + 192]
                            mem[65 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192])] = mem[ceil32(stor8[arg1].field_1 % 128) + 224 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192])]
                            if ceil32(_5399) > _5399:
                                mem[_5399 + 65] = 0
                            return memory
                              from mem[64]
                               len ceil32(_5399) + -mem[64] + 65
                        idx = 0
                        s = 0
                        while idx < stor9.length.field_1 % 128:
                            mem[idx + ceil32(stor8[arg1].field_1 % 128) + 224] = uint256(stor9[s].field_0)
                            idx = idx + 32
                            s = s + 1
                            continue 
                    mem[ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 224] = '0'
                    mem[ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 225] = 32
                    mem[ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 257] = mem[ceil32(stor8[arg1].field_1 % 128) + 192]
                    mem[ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 289 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192])] = mem[ceil32(stor8[arg1].field_1 % 128) + 224 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192])]
                    if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192]) > mem[ceil32(stor8[arg1].field_1 % 128) + 192]:
                        mem[mem[ceil32(stor8[arg1].field_1 % 128) + 192] + ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 289] = 0
                    return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + 192], data=mem[ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 289 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192])]), 
                s = 0
                idx = arg1
                while idx:
                    if s == -1:
                        revert with 'NH{q', 17
                    s = s + 1
                    idx = idx / 10
                    continue 
                if s > test266151307():
                    revert with 'NH{q', 65
                mem[ceil32(stor8[arg1].field_1 % 128) + 128] = s
                if not s:
                    t = s
                    idx = arg1
                    while idx:
                        if t < 1:
                            revert with 'NH{q', 17
                        if 48 > !(idx % 10):
                            revert with 'NH{q', 17
                        if t - 1 >= mem[ceil32(stor8[arg1].field_1 % 128) + 128]:
                            revert with 'NH{q', 50
                        mem[t + ceil32(stor8[arg1].field_1 % 128) + 159 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
                        t = t - 1
                        idx = idx / 10
                        continue 
                    if bool(stor9.length):
                        if bool(stor9.length) == uint255(stor9.length) * 0.5 < 32:
                            revert with 'NH{q', 34
                        if not bool(stor9.length):
                            mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192] = Mask(248, 8, stor9.length)
                            mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                            mem[64] = mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192
                            mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192] = 32
                            mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 224] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                            mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]
                            if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]) > mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]:
                                mem[mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160] + mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256] = 0
                            return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160], data=mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]), 
                        if bool(stor9.length) == 1:
                            mem[0] = 9
                            idx = 0
                            t = 0
                            while idx < uint255(stor9.length) * 0.5:
                                mem[idx + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192] = uint256(stor9[t].field_0)
                                idx = idx + 32
                                t = t + 1
                                continue 
                            mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                            mem[64] = mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192
                            mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192] = 32
                            mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 224] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                            mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]
                            if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]) > mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]:
                                mem[mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160] + mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256] = 0
                            return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160], data=mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]), 
                        _13187 = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                        mem[0 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                        mem[64] = _13187
                        mem[_13187] = 32
                        if ceil32(_13187) <= _13187:
                            _20341 = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                            mem[_13187 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                            mem[_13187 + 64 len ceil32(_20341)] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(_20341)]
                            if ceil32(_20341) > _20341:
                                mem[_20341 + _13187 + 64] = 0
                            return 32, mem[_13187 + 32 len ceil32(_20341) + 32]
                        _20342 = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                        mem[_13187 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                        mem[_13187 + 64 len ceil32(_20342)] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(_20342)]
                        if ceil32(_20342) > _20342:
                            mem[_20342 + _13187 + 64] = 0
                        return 32, mem[_13187 + 32 len ceil32(_20342) + 32]
                    if bool(stor9.length) == stor9.length.field_1 % 128 < 32:
                        revert with 'NH{q', 34
                    if not bool(stor9.length):
                        mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192] = Mask(248, 8, stor9.length)
                        mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                        mem[64] = mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192
                        mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192] = 32
                        mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 224] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                        mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]
                        if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]) > mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]:
                            mem[mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160] + mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256] = 0
                        return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160], data=mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]), 
                    if bool(stor9.length) == 1:
                        mem[0] = 9
                        idx = 0
                        t = 0
                        while idx < stor9.length.field_1 % 128:
                            mem[idx + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192] = uint256(stor9[t].field_0)
                            idx = idx + 32
                            t = t + 1
                            continue 
                        mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                        mem[64] = mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192
                        mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192] = 32
                        mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 224] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                        mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]
                        if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]) > mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]:
                            mem[mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160] + mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256] = 0
                        return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160], data=mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]), 
                    _13299 = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                    mem[0 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                    mem[64] = _13299
                    mem[_13299] = 32
                    if ceil32(_13299) <= _13299:
                        _20345 = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                        mem[_13299 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                        mem[_13299 + 64 len ceil32(_20345)] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(_20345)]
                        if ceil32(_20345) > _20345:
                            mem[_20345 + _13299 + 64] = 0
                        return 32, mem[_13299 + 32 len ceil32(_20345) + 32]
                    _20346 = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                    mem[_13299 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                    mem[_13299 + 64 len ceil32(_20346)] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(_20346)]
                    if ceil32(_20346) > _20346:
                        mem[_20346 + _13299 + 64] = 0
                    return 32, mem[_13299 + 32 len ceil32(_20346) + 32]
                mem[ceil32(stor8[arg1].field_1 % 128) + 160 len s] = call.data[calldata.size len s]
                t = s
                idx = arg1
                while idx:
                    if t < 1:
                        revert with 'NH{q', 17
                    if 48 > !(idx % 10):
                        revert with 'NH{q', 17
                    if t - 1 >= mem[ceil32(stor8[arg1].field_1 % 128) + 128]:
                        revert with 'NH{q', 50
                    mem[t + ceil32(stor8[arg1].field_1 % 128) + 159 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
                    t = t - 1
                    idx = idx / 10
                    continue 
                if bool(stor9.length):
                    if bool(stor9.length) == uint255(stor9.length) * 0.5 < 32:
                        revert with 'NH{q', 34
                    if not bool(stor9.length):
                        mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192] = Mask(248, 8, stor9.length)
                        mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                        mem[64] = mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192
                        mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192] = 32
                        mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 224] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                        mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]
                        if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]) > mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]:
                            mem[mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160] + mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256] = 0
                        return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160], data=mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]), 
                    if bool(stor9.length) == 1:
                        mem[0] = 9
                        idx = 0
                        t = 0
                        while idx < uint255(stor9.length) * 0.5:
                            mem[idx + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192] = uint256(stor9[t].field_0)
                            idx = idx + 32
                            t = t + 1
                            continue 
                        mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                        mem[64] = mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192
                        mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192] = 32
                        mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 224] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                        mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]
                        if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]) > mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]:
                            mem[mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160] + mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256] = 0
                        return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160], data=mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]), 
                    _13189 = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                    mem[0 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                    mem[64] = _13189
                    mem[_13189] = 32
                    if ceil32(_13189) <= _13189:
                        _20349 = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                        mem[_13189 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                        mem[_13189 + 64 len ceil32(_20349)] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(_20349)]
                        if ceil32(_20349) > _20349:
                            mem[_20349 + _13189 + 64] = 0
                        return 32, mem[_13189 + 32 len ceil32(_20349) + 32]
                    _20350 = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                    mem[_13189 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                    mem[_13189 + 64 len ceil32(_20350)] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(_20350)]
                    if ceil32(_20350) > _20350:
                        mem[_20350 + _13189 + 64] = 0
                    return 32, mem[_13189 + 32 len ceil32(_20350) + 32]
                if bool(stor9.length) == stor9.length.field_1 % 128 < 32:
                    revert with 'NH{q', 34
                if not bool(stor9.length):
                    mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192] = Mask(248, 8, stor9.length)
                    mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                    mem[64] = mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192] = 32
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 224] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]
                    if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]) > mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]:
                        mem[mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160] + mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256] = 0
                    return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160], data=mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]), 
                if bool(stor9.length) == 1:
                    mem[0] = 9
                    idx = 0
                    t = 0
                    while idx < stor9.length.field_1 % 128:
                        mem[idx + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192] = uint256(stor9[t].field_0)
                        idx = idx + 32
                        t = t + 1
                        continue 
                    mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                    mem[64] = mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192] = 32
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 224] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]
                    if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]) > mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]:
                        mem[mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160] + mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256] = 0
                    return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160], data=mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]), 
                _13301 = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                mem[0 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                mem[64] = _13301
                mem[_13301] = 32
                if ceil32(_13301) <= _13301:
                    _20353 = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                    mem[_13301 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                    mem[_13301 + 64 len ceil32(_20353)] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(_20353)]
                    if ceil32(_20353) > _20353:
                        mem[_20353 + _13301 + 64] = 0
                    return 32, mem[_13301 + 32 len ceil32(_20353) + 32]
                _20354 = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                mem[_13301 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                mem[_13301 + 64 len ceil32(_20354)] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(_20354)]
                if ceil32(_20354) > _20354:
                    mem[_20354 + _13301 + 64] = 0
                return 32, mem[_13301 + 32 len ceil32(_20354) + 32]
            if bool(stor9.length) == stor9.length.field_1 % 128 < 32:
                revert with 'NH{q', 34
            if not stor9.length.field_1 % 128:
                mem[ceil32(stor8[arg1].field_1 % 128) + 192 len ceil32(stor8[arg1].field_1 % 128)] = mem[128 len ceil32(stor8[arg1].field_1 % 128)]
                if ceil32(stor8[arg1].field_1 % 128) > stor8[arg1].field_1 % 128:
                    mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + 192] = 0
                return Array(len=stor8[arg1].field_0 % 128, data=mem[128 len ceil32(stor8[arg1].field_1 % 128)], mem[(2 * ceil32(stor8[arg1].field_1 % 128)) + 192 len 2 * ceil32(stor8[arg1].field_1 % 128)]), 
            if stor8[arg1].field_1 % 128:
                if bool(stor9.length):
                    if bool(stor9.length) == uint255(stor9.length) * 0.5 < 32:
                        revert with 'NH{q', 34
                    if not bool(stor9.length):
                        mem[ceil32(stor8[arg1].field_1 % 128) + 160] = Mask(248, 8, stor9.length)
                    else:
                        if bool(stor9.length) != 1:
                            mem[64] = stor8[arg1].field_1 % 128
                            if ceil32(stor8[arg1].field_1 % 128) <= stor8[arg1].field_1 % 128:
                                _5418 = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                                mem[stor8[arg1].field_1 % 128 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                                mem[stor8[arg1].field_1 % 128 + 64 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                                if ceil32(_5418) > _5418:
                                    mem[_5418 + stor8[arg1].field_1 % 128 + 64] = 0
                                return 32, mem[stor8[arg1].field_1 % 128 + 32 len ceil32(_5418) + 32]
                            _5419 = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                            mem[stor8[arg1].field_1 % 128 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                            mem[stor8[arg1].field_1 % 128 + 64 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                            if ceil32(_5419) > _5419:
                                mem[_5419 + stor8[arg1].field_1 % 128 + 64] = 0
                            return 32, mem[stor8[arg1].field_1 % 128 + 32 len ceil32(_5419) + 32]
                        idx = 0
                        s = 0
                        while idx < uint255(stor9.length) * 0.5:
                            mem[idx + ceil32(stor8[arg1].field_1 % 128) + 160] = uint256(stor9[s].field_0)
                            idx = idx + 32
                            s = s + 1
                            continue 
                    mem[ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 160 len ceil32(stor8[arg1].field_1 % 128)] = mem[128 len ceil32(stor8[arg1].field_1 % 128)]
                    mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 160] = 32
                    mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 192] = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                    mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 224 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                    if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128]) <= mem[ceil32(stor8[arg1].field_1 % 128) + 128]:
                        return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + 128], data=mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 224 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]), 
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 224] = 0
                    return 32, mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128]) + 32], 
                if bool(stor9.length) == stor9.length.field_1 % 128 < 32:
                    revert with 'NH{q', 34
                if not bool(stor9.length):
                    mem[ceil32(stor8[arg1].field_1 % 128) + 160] = Mask(248, 8, stor9.length)
                else:
                    if bool(stor9.length) != 1:
                        mem[64] = stor8[arg1].field_1 % 128
                        if ceil32(stor8[arg1].field_1 % 128) <= stor8[arg1].field_1 % 128:
                            _5422 = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                            mem[stor8[arg1].field_1 % 128 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                            mem[stor8[arg1].field_1 % 128 + 64 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                            if ceil32(_5422) > _5422:
                                mem[_5422 + stor8[arg1].field_1 % 128 + 64] = 0
                            return 32, mem[stor8[arg1].field_1 % 128 + 32 len ceil32(_5422) + 32]
                        _5423 = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                        mem[stor8[arg1].field_1 % 128 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                        mem[stor8[arg1].field_1 % 128 + 64 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                        if ceil32(_5423) > _5423:
                            mem[_5423 + stor8[arg1].field_1 % 128 + 64] = 0
                        return 32, mem[stor8[arg1].field_1 % 128 + 32 len ceil32(_5423) + 32]
                    idx = 0
                    s = 0
                    while idx < stor9.length.field_1 % 128:
                        mem[idx + ceil32(stor8[arg1].field_1 % 128) + 160] = uint256(stor9[s].field_0)
                        idx = idx + 32
                        s = s + 1
                        continue 
                mem[ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 160 len ceil32(stor8[arg1].field_1 % 128)] = mem[128 len ceil32(stor8[arg1].field_1 % 128)]
                mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 160] = 32
                mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 192] = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 224 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128]) <= mem[ceil32(stor8[arg1].field_1 % 128) + 128]:
                    return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + 128], data=mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 224 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]), 
                mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 224] = 0
                return 32, mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128]) + 32], 
            if not arg1:
                mem[ceil32(stor8[arg1].field_1 % 128) + 128] = 1
                mem[ceil32(stor8[arg1].field_1 % 128) + 160] = '0'
                if bool(stor9.length):
                    if bool(stor9.length) == uint255(stor9.length) * 0.5 < 32:
                        revert with 'NH{q', 34
                    if not bool(stor9.length):
                        mem[ceil32(stor8[arg1].field_1 % 128) + 224] = Mask(248, 8, stor9.length)
                    else:
                        if bool(stor9.length) != 1:
                            mem[64] = 1
                            _5411 = mem[ceil32(stor8[arg1].field_1 % 128) + 192]
                            mem[33] = mem[ceil32(stor8[arg1].field_1 % 128) + 192]
                            mem[65 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192])] = mem[ceil32(stor8[arg1].field_1 % 128) + 224 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192])]
                            if ceil32(_5411) > _5411:
                                mem[_5411 + 65] = 0
                            return memory
                              from mem[64]
                               len ceil32(_5411) + -mem[64] + 65
                        idx = 0
                        s = 0
                        while idx < uint255(stor9.length) * 0.5:
                            mem[idx + ceil32(stor8[arg1].field_1 % 128) + 224] = uint256(stor9[s].field_0)
                            idx = idx + 32
                            s = s + 1
                            continue 
                    mem[ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 224] = '0'
                    mem[ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 225] = 32
                    mem[ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 257] = mem[ceil32(stor8[arg1].field_1 % 128) + 192]
                    mem[ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 289 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192])] = mem[ceil32(stor8[arg1].field_1 % 128) + 224 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192])]
                    if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192]) > mem[ceil32(stor8[arg1].field_1 % 128) + 192]:
                        mem[mem[ceil32(stor8[arg1].field_1 % 128) + 192] + ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 289] = 0
                    return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + 192], data=mem[ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 289 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192])]), 
                if bool(stor9.length) == stor9.length.field_1 % 128 < 32:
                    revert with 'NH{q', 34
                if not bool(stor9.length):
                    mem[ceil32(stor8[arg1].field_1 % 128) + 224] = Mask(248, 8, stor9.length)
                else:
                    if bool(stor9.length) != 1:
                        mem[64] = 1
                        _5415 = mem[ceil32(stor8[arg1].field_1 % 128) + 192]
                        mem[33] = mem[ceil32(stor8[arg1].field_1 % 128) + 192]
                        mem[65 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192])] = mem[ceil32(stor8[arg1].field_1 % 128) + 224 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192])]
                        if ceil32(_5415) > _5415:
                            mem[_5415 + 65] = 0
                        return memory
                          from mem[64]
                           len ceil32(_5415) + -mem[64] + 65
                    idx = 0
                    s = 0
                    while idx < stor9.length.field_1 % 128:
                        mem[idx + ceil32(stor8[arg1].field_1 % 128) + 224] = uint256(stor9[s].field_0)
                        idx = idx + 32
                        s = s + 1
                        continue 
                mem[ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 224] = '0'
                mem[ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 225] = 32
                mem[ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 257] = mem[ceil32(stor8[arg1].field_1 % 128) + 192]
                mem[ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 289 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192])] = mem[ceil32(stor8[arg1].field_1 % 128) + 224 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192])]
                if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192]) > mem[ceil32(stor8[arg1].field_1 % 128) + 192]:
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + 192] + ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 289] = 0
                return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + 192], data=mem[ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 289 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192])]), 
            s = 0
            idx = arg1
            while idx:
                if s == -1:
                    revert with 'NH{q', 17
                s = s + 1
                idx = idx / 10
                continue 
            if s > test266151307():
                revert with 'NH{q', 65
            mem[ceil32(stor8[arg1].field_1 % 128) + 128] = s
            if not s:
                t = s
                idx = arg1
                while idx:
                    if t < 1:
                        revert with 'NH{q', 17
                    if 48 > !(idx % 10):
                        revert with 'NH{q', 17
                    if t - 1 >= mem[ceil32(stor8[arg1].field_1 % 128) + 128]:
                        revert with 'NH{q', 50
                    mem[t + ceil32(stor8[arg1].field_1 % 128) + 159 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
                    t = t - 1
                    idx = idx / 10
                    continue 
                if bool(stor9.length):
                    if bool(stor9.length) == uint255(stor9.length) * 0.5 < 32:
                        revert with 'NH{q', 34
                    if not bool(stor9.length):
                        mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192] = Mask(248, 8, stor9.length)
                        mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                        mem[64] = mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192
                        mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192] = 32
                        mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 224] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                        mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]
                        if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]) > mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]:
                            mem[mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160] + mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256] = 0
                        return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160], data=mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]), 
                    if bool(stor9.length) == 1:
                        mem[0] = 9
                        idx = 0
                        t = 0
                        while idx < uint255(stor9.length) * 0.5:
                            mem[idx + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192] = uint256(stor9[t].field_0)
                            idx = idx + 32
                            t = t + 1
                            continue 
                        mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                        mem[64] = mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192
                        mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192] = 32
                        mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 224] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                        mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]
                        if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]) > mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]:
                            mem[mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160] + mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256] = 0
                        return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160], data=mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]), 
                    _13191 = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                    mem[0 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                    mem[64] = _13191
                    mem[_13191] = 32
                    if ceil32(_13191) <= _13191:
                        _20357 = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                        mem[_13191 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                        mem[_13191 + 64 len ceil32(_20357)] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(_20357)]
                        if ceil32(_20357) > _20357:
                            mem[_20357 + _13191 + 64] = 0
                        return 32, mem[_13191 + 32 len ceil32(_20357) + 32]
                    _20358 = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                    mem[_13191 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                    mem[_13191 + 64 len ceil32(_20358)] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(_20358)]
                    if ceil32(_20358) > _20358:
                        mem[_20358 + _13191 + 64] = 0
                    return 32, mem[_13191 + 32 len ceil32(_20358) + 32]
                if bool(stor9.length) == stor9.length.field_1 % 128 < 32:
                    revert with 'NH{q', 34
                if not bool(stor9.length):
                    mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192] = Mask(248, 8, stor9.length)
                    mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                    mem[64] = mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192] = 32
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 224] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]
                    if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]) > mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]:
                        mem[mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160] + mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256] = 0
                    return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160], data=mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]), 
                if bool(stor9.length) == 1:
                    mem[0] = 9
                    idx = 0
                    t = 0
                    while idx < stor9.length.field_1 % 128:
                        mem[idx + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192] = uint256(stor9[t].field_0)
                        idx = idx + 32
                        t = t + 1
                        continue 
                    mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                    mem[64] = mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192] = 32
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 224] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]
                    if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]) > mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]:
                        mem[mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160] + mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256] = 0
                    return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160], data=mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]), 
                _13303 = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                mem[0 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                mem[64] = _13303
                mem[_13303] = 32
                if ceil32(_13303) <= _13303:
                    _20361 = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                    mem[_13303 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                    mem[_13303 + 64 len ceil32(_20361)] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(_20361)]
                    if ceil32(_20361) > _20361:
                        mem[_20361 + _13303 + 64] = 0
                    return 32, mem[_13303 + 32 len ceil32(_20361) + 32]
                _20362 = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                mem[_13303 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                mem[_13303 + 64 len ceil32(_20362)] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(_20362)]
                if ceil32(_20362) > _20362:
                    mem[_20362 + _13303 + 64] = 0
                return 32, mem[_13303 + 32 len ceil32(_20362) + 32]
            mem[ceil32(stor8[arg1].field_1 % 128) + 160 len s] = call.data[calldata.size len s]
            t = s
            idx = arg1
            while idx:
                if t < 1:
                    revert with 'NH{q', 17
                if 48 > !(idx % 10):
                    revert with 'NH{q', 17
                if t - 1 >= mem[ceil32(stor8[arg1].field_1 % 128) + 128]:
                    revert with 'NH{q', 50
                mem[t + ceil32(stor8[arg1].field_1 % 128) + 159 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
                t = t - 1
                idx = idx / 10
                continue 
            if bool(stor9.length):
                if bool(stor9.length) == uint255(stor9.length) * 0.5 < 32:
                    revert with 'NH{q', 34
                if not bool(stor9.length):
                    mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192] = Mask(248, 8, stor9.length)
                    mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                    mem[64] = mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192] = 32
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 224] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]
                    if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]) > mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]:
                        mem[mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160] + mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256] = 0
                    return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160], data=mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]), 
                if bool(stor9.length) == 1:
                    mem[0] = 9
                    idx = 0
                    t = 0
                    while idx < uint255(stor9.length) * 0.5:
                        mem[idx + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192] = uint256(stor9[t].field_0)
                        idx = idx + 32
                        t = t + 1
                        continue 
                    mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                    mem[64] = mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192] = 32
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 224] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]
                    if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]) > mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]:
                        mem[mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160] + mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256] = 0
                    return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160], data=mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]), 
                _13193 = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                mem[0 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                mem[64] = _13193
                mem[_13193] = 32
                if ceil32(_13193) <= _13193:
                    _20365 = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                    mem[_13193 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                    mem[_13193 + 64 len ceil32(_20365)] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(_20365)]
                    if ceil32(_20365) > _20365:
                        mem[_20365 + _13193 + 64] = 0
                    return 32, mem[_13193 + 32 len ceil32(_20365) + 32]
                _20366 = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                mem[_13193 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                mem[_13193 + 64 len ceil32(_20366)] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(_20366)]
                if ceil32(_20366) > _20366:
                    mem[_20366 + _13193 + 64] = 0
                return 32, mem[_13193 + 32 len ceil32(_20366) + 32]
            if bool(stor9.length) == stor9.length.field_1 % 128 < 32:
                revert with 'NH{q', 34
            if not bool(stor9.length):
                mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192] = Mask(248, 8, stor9.length)
                mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                mem[64] = mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192
                mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192] = 32
                mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 224] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]
                if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]) > mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]:
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160] + mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256] = 0
                return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160], data=mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]), 
            if bool(stor9.length) == 1:
                mem[0] = 9
                idx = 0
                t = 0
                while idx < stor9.length.field_1 % 128:
                    mem[idx + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192] = uint256(stor9[t].field_0)
                    idx = idx + 32
                    t = t + 1
                    continue 
                mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                mem[64] = mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192
                mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192] = 32
                mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 224] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]
                if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]) > mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]:
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160] + mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256] = 0
                return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160], data=mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]), 
            _13305 = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
            mem[0 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
            mem[64] = _13305
            mem[_13305] = 32
            if ceil32(_13305) <= _13305:
                _20369 = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                mem[_13305 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                mem[_13305 + 64 len ceil32(_20369)] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(_20369)]
                if ceil32(_20369) > _20369:
                    mem[_20369 + _13305 + 64] = 0
                return 32, mem[_13305 + 32 len ceil32(_20369) + 32]
            _20370 = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
            mem[_13305 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
            mem[_13305 + 64 len ceil32(_20370)] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(_20370)]
            if ceil32(_20370) > _20370:
                mem[_20370 + _13305 + 64] = 0
            return 32, mem[_13305 + 32 len ceil32(_20370) + 32]
        mem[0] = sha3(arg1, 8)
        mem[128] = uint256(stor8[arg1].field_0)
        idx = 128
        s = 0
        while (uint255(uint256(stor8[arg1].field_0)) * 0.5) + 96 > idx:
            mem[idx + 32] = uint256(stor8[arg1][s].field_256)
            idx = idx + 32
            s = s + 1
            continue 
        if bool(stor9.length):
            if bool(stor9.length) == uint255(stor9.length) * 0.5 < 32:
                revert with 'NH{q', 34
            if not uint255(stor9.length) * 0.5:
                return Array(len=stor8[arg1].field_0 % 128, data=mem[128 len ceil32(stor8[arg1].field_1 % 128)])
            if stor8[arg1].field_1 % 128:
                if bool(stor9.length):
                    if bool(stor9.length) == uint255(stor9.length) * 0.5 < 32:
                        revert with 'NH{q', 34
                    if not bool(stor9.length):
                        mem[ceil32(stor8[arg1].field_1 % 128) + 160] = Mask(248, 8, stor9.length)
                        mem[ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 160 len ceil32(stor8[arg1].field_1 % 128)] = mem[128 len ceil32(stor8[arg1].field_1 % 128)]
                        var49001 = ceil32(stor8[arg1].field_1 % 128)
                        mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 160] = 32
                        mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 192] = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                        mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 224 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                        var60001 = ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])
                        if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128]) <= mem[ceil32(stor8[arg1].field_1 % 128) + 128]:
                            return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + 128], data=mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 224 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]), 
                        mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 224] = 0
                        return 32, mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128]) + 32], 
                    if bool(stor9.length) == 1:
                        idx = 0
                        s = 0
                        while idx < uint255(stor9.length) * 0.5:
                            mem[idx + ceil32(stor8[arg1].field_1 % 128) + 160] = uint256(stor9[s].field_0)
                            idx = idx + 32
                            s = s + 1
                            continue 
                        mem[ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 160 len ceil32(stor8[arg1].field_1 % 128)] = mem[128 len ceil32(stor8[arg1].field_1 % 128)]
                        mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 160] = 32
                        mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 192] = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                        mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 224 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                        if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128]) <= mem[ceil32(stor8[arg1].field_1 % 128) + 128]:
                            return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + 128], data=mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 224 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]), 
                        mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 224] = 0
                        return 32, mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128]) + 32], 
                    var50001 = ceil32(stor8[arg1].field_1 % 128)
                    mem[64] = stor8[arg1].field_1 % 128
                    if ceil32(stor8[arg1].field_1 % 128) <= stor8[arg1].field_1 % 128:
                        _13021 = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                        mem[stor8[arg1].field_1 % 128 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                        mem[stor8[arg1].field_1 % 128 + 64 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                        var61001 = ceil32(_13021)
                        if ceil32(_13021) > _13021:
                            mem[_13021 + stor8[arg1].field_1 % 128 + 64] = 0
                        return 32, mem[stor8[arg1].field_1 % 128 + 32 len ceil32(_13021) + 32]
                    _13022 = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                    mem[stor8[arg1].field_1 % 128 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                    mem[stor8[arg1].field_1 % 128 + 64 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                    var61001 = ceil32(_13022)
                    if ceil32(_13022) > _13022:
                        mem[_13022 + stor8[arg1].field_1 % 128 + 64] = 0
                    return 32, mem[stor8[arg1].field_1 % 128 + 32 len ceil32(_13022) + 32]
                if bool(stor9.length) == stor9.length.field_1 % 128 < 32:
                    revert with 'NH{q', 34
                if bool(stor9.length):
                    if bool(stor9.length) == 1:
                        idx = 0
                        s = 0
                        while idx < stor9.length.field_1 % 128:
                            mem[idx + ceil32(stor8[arg1].field_1 % 128) + 160] = uint256(stor9[s].field_0)
                            idx = idx + 32
                            s = s + 1
                            continue 
                        mem[ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 160 len ceil32(stor8[arg1].field_1 % 128)] = mem[128 len ceil32(stor8[arg1].field_1 % 128)]
                        mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 160] = 32
                        mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 192] = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                        mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 224 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                        if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128]) <= mem[ceil32(stor8[arg1].field_1 % 128) + 128]:
                            return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + 128], data=mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 224 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]), 
                        mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 224] = 0
                        return 32, mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128]) + 32], 
                    var51001 = ceil32(stor8[arg1].field_1 % 128)
                    mem[64] = stor8[arg1].field_1 % 128
                    if ceil32(stor8[arg1].field_1 % 128) <= stor8[arg1].field_1 % 128:
                        _13025 = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                        mem[stor8[arg1].field_1 % 128 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                        mem[stor8[arg1].field_1 % 128 + 64 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                        if ceil32(_13025) > _13025:
                            mem[_13025 + stor8[arg1].field_1 % 128 + 64] = 0
                        return 32, mem[stor8[arg1].field_1 % 128 + 32 len ceil32(_13025) + 32]
                    _13026 = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                    mem[stor8[arg1].field_1 % 128 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                    mem[stor8[arg1].field_1 % 128 + 64 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                    if ceil32(_13026) > _13026:
                        mem[_13026 + stor8[arg1].field_1 % 128 + 64] = 0
                    return 32, mem[stor8[arg1].field_1 % 128 + 32 len ceil32(_13026) + 32]
                mem[ceil32(stor8[arg1].field_1 % 128) + 160] = Mask(248, 8, stor9.length)
                mem[ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 160 len ceil32(stor8[arg1].field_1 % 128)] = mem[128 len ceil32(stor8[arg1].field_1 % 128)]
                var50001 = ceil32(stor8[arg1].field_1 % 128)
                mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 160] = 32
                mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 192] = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 224 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                var61001 = ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])
                if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128]) <= mem[ceil32(stor8[arg1].field_1 % 128) + 128]:
                    return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + 128], data=mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 224 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]), 
                mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 224] = 0
                return 32, mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128]) + 32], 
            if not arg1:
                mem[ceil32(stor8[arg1].field_1 % 128) + 128] = 1
                mem[ceil32(stor8[arg1].field_1 % 128) + 160] = '0'
                if bool(stor9.length):
                    if bool(stor9.length) == uint255(stor9.length) * 0.5 < 32:
                        revert with 'NH{q', 34
                    if not bool(stor9.length):
                        mem[ceil32(stor8[arg1].field_1 % 128) + 224] = Mask(248, 8, stor9.length)
                        mem[ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 224] = '0'
                        var52001 = 32
                    else:
                        if bool(stor9.length) != 1:
                            mem[64] = 1
                            _13014 = mem[ceil32(stor8[arg1].field_1 % 128) + 192]
                            mem[33] = mem[ceil32(stor8[arg1].field_1 % 128) + 192]
                            mem[65 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192])] = mem[ceil32(stor8[arg1].field_1 % 128) + 224 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192])]
                            if ceil32(_13014) > _13014:
                                mem[_13014 + 65] = 0
                            return memory
                              from mem[64]
                               len ceil32(_13014) + -mem[64] + 65
                        idx = 0
                        s = 0
                        while idx < uint255(stor9.length) * 0.5:
                            mem[idx + ceil32(stor8[arg1].field_1 % 128) + 224] = uint256(stor9[s].field_0)
                            idx = idx + 32
                            s = s + 1
                            continue 
                        mem[ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 224] = '0'
                    mem[ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 225] = 32
                    mem[ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 257] = mem[ceil32(stor8[arg1].field_1 % 128) + 192]
                    mem[ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 289 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192])] = mem[ceil32(stor8[arg1].field_1 % 128) + 224 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192])]
                    if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192]) > mem[ceil32(stor8[arg1].field_1 % 128) + 192]:
                        mem[mem[ceil32(stor8[arg1].field_1 % 128) + 192] + ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 289] = 0
                    return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + 192], data=mem[ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 289 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192])]), 
                if bool(stor9.length) == stor9.length.field_1 % 128 < 32:
                    revert with 'NH{q', 34
                if not bool(stor9.length):
                    mem[ceil32(stor8[arg1].field_1 % 128) + 224] = Mask(248, 8, stor9.length)
                else:
                    if bool(stor9.length) != 1:
                        mem[64] = 1
                        _13018 = mem[ceil32(stor8[arg1].field_1 % 128) + 192]
                        mem[33] = mem[ceil32(stor8[arg1].field_1 % 128) + 192]
                        mem[65 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192])] = mem[ceil32(stor8[arg1].field_1 % 128) + 224 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192])]
                        if ceil32(_13018) > _13018:
                            mem[_13018 + 65] = 0
                        return memory
                          from mem[64]
                           len ceil32(_13018) + -mem[64] + 65
                    idx = 0
                    s = 0
                    while idx < stor9.length.field_1 % 128:
                        mem[idx + ceil32(stor8[arg1].field_1 % 128) + 224] = uint256(stor9[s].field_0)
                        idx = idx + 32
                        s = s + 1
                        continue 
                mem[ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 224] = '0'
                mem[ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 225] = 32
                mem[ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 257] = mem[ceil32(stor8[arg1].field_1 % 128) + 192]
                mem[ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 289 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192])] = mem[ceil32(stor8[arg1].field_1 % 128) + 224 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192])]
                if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192]) > mem[ceil32(stor8[arg1].field_1 % 128) + 192]:
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + 192] + ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 289] = 0
                return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + 192], data=mem[ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 289 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192])]), 
            s = 0
            idx = arg1
            while idx:
                if s == -1:
                    revert with 'NH{q', 17
                s = s + 1
                idx = idx / 10
                continue 
            if s > test266151307():
                revert with 'NH{q', 65
            mem[ceil32(stor8[arg1].field_1 % 128) + 128] = s
            if not s:
                t = s
                idx = arg1
                while idx:
                    if t < 1:
                        revert with 'NH{q', 17
                    if 48 > !(idx % 10):
                        revert with 'NH{q', 17
                    if t - 1 >= mem[ceil32(stor8[arg1].field_1 % 128) + 128]:
                        revert with 'NH{q', 50
                    mem[t + ceil32(stor8[arg1].field_1 % 128) + 159 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
                    t = t - 1
                    idx = idx / 10
                    continue 
                if not bool(stor9.length):
                    if bool(stor9.length) == stor9.length.field_1 % 128 < 32:
                        revert with 'NH{q', 34
                    if not bool(stor9.length):
                        mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192] = Mask(248, 8, stor9.length)
                        mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                        var61001 = ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])
                        mem[64] = mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192
                        mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192] = 32
                        mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 224] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                        mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]
                        if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]) > mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]:
                            mem[mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160] + mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256] = 0
                        return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160], data=mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]), 
                    if bool(stor9.length) == 1:
                        mem[0] = 9
                        idx = 0
                        t = 0
                        while idx < stor9.length.field_1 % 128:
                            mem[idx + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192] = uint256(stor9[t].field_0)
                            idx = idx + 32
                            t = t + 1
                            continue 
                        mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                        mem[64] = mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192
                        mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192] = 32
                        mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 224] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                        mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]
                        if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]) > mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]:
                            mem[mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160] + mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256] = 0
                        return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160], data=mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]), 
                    _20587 = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                    mem[0 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                    mem[64] = _20587
                    mem[_20587] = 32
                    if ceil32(_20587) <= _20587:
                        _25345 = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                        mem[_20587 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                        mem[_20587 + 64 len ceil32(_25345)] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(_25345)]
                        if ceil32(_25345) > _25345:
                            mem[_25345 + _20587 + 64] = 0
                        return 32, mem[_20587 + 32 len ceil32(_25345) + 32]
                    _25346 = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                    mem[_20587 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                    mem[_20587 + 64 len ceil32(_25346)] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(_25346)]
                    if ceil32(_25346) > _25346:
                        mem[_25346 + _20587 + 64] = 0
                    return 32, mem[_20587 + 32 len ceil32(_25346) + 32]
                if bool(stor9.length) == uint255(stor9.length) * 0.5 < 32:
                    revert with 'NH{q', 34
                if not bool(stor9.length):
                    mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192] = Mask(248, 8, stor9.length)
                    mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                    var60001 = ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])
                    mem[64] = mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192] = 32
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 224] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]
                    if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]) > mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]:
                        mem[mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160] + mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256] = 0
                    return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160], data=mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]), 
                if bool(stor9.length) == 1:
                    mem[0] = 9
                    idx = 0
                    t = 0
                    while idx < uint255(stor9.length) * 0.5:
                        mem[idx + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192] = uint256(stor9[t].field_0)
                        idx = idx + 32
                        t = t + 1
                        continue 
                    mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                    mem[64] = mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192] = 32
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 224] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]
                    if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]) > mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]:
                        mem[mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160] + mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256] = 0
                    return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160], data=mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]), 
                _20475 = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                mem[0 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                var61001 = ceil32(_20475)
                mem[64] = _20475
                mem[_20475] = 32
                if ceil32(_20475) <= _20475:
                    _25341 = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                    mem[_20475 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                    mem[_20475 + 64 len ceil32(_25341)] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(_25341)]
                    if ceil32(_25341) > _25341:
                        mem[_25341 + _20475 + 64] = 0
                    return 32, mem[_20475 + 32 len ceil32(_25341) + 32]
                _25342 = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                mem[_20475 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                mem[_20475 + 64 len ceil32(_25342)] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(_25342)]
                if ceil32(_25342) > _25342:
                    mem[_25342 + _20475 + 64] = 0
                return 32, mem[_20475 + 32 len ceil32(_25342) + 32]
            mem[ceil32(stor8[arg1].field_1 % 128) + 160 len s] = call.data[calldata.size len s]
            t = s
            idx = arg1
            while idx:
                if t < 1:
                    revert with 'NH{q', 17
                if 48 > !(idx % 10):
                    revert with 'NH{q', 17
                if t - 1 >= mem[ceil32(stor8[arg1].field_1 % 128) + 128]:
                    revert with 'NH{q', 50
                mem[t + ceil32(stor8[arg1].field_1 % 128) + 159 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
                t = t - 1
                idx = idx / 10
                continue 
            if bool(stor9.length):
                if bool(stor9.length) == uint255(stor9.length) * 0.5 < 32:
                    revert with 'NH{q', 34
                if not bool(stor9.length):
                    mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192] = Mask(248, 8, stor9.length)
                    mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                    var61001 = ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])
                    mem[64] = mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192] = 32
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 224] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]
                    if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]) > mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]:
                        mem[mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160] + mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256] = 0
                    return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160], data=mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]), 
                if bool(stor9.length) == 1:
                    mem[0] = 9
                    idx = 0
                    t = 0
                    while idx < uint255(stor9.length) * 0.5:
                        mem[idx + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192] = uint256(stor9[t].field_0)
                        idx = idx + 32
                        t = t + 1
                        continue 
                    mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                    mem[64] = mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192] = 32
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 224] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]
                    if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]) > mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]:
                        mem[mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160] + mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256] = 0
                    return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160], data=mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]), 
                _20477 = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                mem[0 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                mem[64] = _20477
                mem[_20477] = 32
                if ceil32(_20477) <= _20477:
                    _25349 = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                    mem[_20477 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                    mem[_20477 + 64 len ceil32(_25349)] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(_25349)]
                    if ceil32(_25349) > _25349:
                        mem[_25349 + _20477 + 64] = 0
                    return 32, mem[_20477 + 32 len ceil32(_25349) + 32]
                _25350 = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                mem[_20477 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                mem[_20477 + 64 len ceil32(_25350)] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(_25350)]
                if ceil32(_25350) > _25350:
                    mem[_25350 + _20477 + 64] = 0
                return 32, mem[_20477 + 32 len ceil32(_25350) + 32]
            if bool(stor9.length) == stor9.length.field_1 % 128 < 32:
                revert with 'NH{q', 34
            if not bool(stor9.length):
                mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192] = Mask(248, 8, stor9.length)
                mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                mem[64] = mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192
                mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192] = 32
                mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 224] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]
                if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]) > mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]:
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160] + mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256] = 0
                return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160], data=mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]), 
            if bool(stor9.length) == 1:
                mem[0] = 9
                idx = 0
                t = 0
                while idx < stor9.length.field_1 % 128:
                    mem[idx + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192] = uint256(stor9[t].field_0)
                    idx = idx + 32
                    t = t + 1
                    continue 
                mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                mem[64] = mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192
                mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192] = 32
                mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 224] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]
                if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]) > mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]:
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160] + mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256] = 0
                return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160], data=mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]), 
            _20589 = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
            mem[0 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
            mem[64] = _20589
            mem[_20589] = 32
            if ceil32(_20589) <= _20589:
                _25353 = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                mem[_20589 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                mem[_20589 + 64 len ceil32(_25353)] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(_25353)]
                if ceil32(_25353) > _25353:
                    mem[_25353 + _20589 + 64] = 0
                return 32, mem[_20589 + 32 len ceil32(_25353) + 32]
            _25354 = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
            mem[_20589 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
            mem[_20589 + 64 len ceil32(_25354)] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(_25354)]
            if ceil32(_25354) > _25354:
                mem[_25354 + _20589 + 64] = 0
            return 32, mem[_20589 + 32 len ceil32(_25354) + 32]
        if bool(stor9.length) == stor9.length.field_1 % 128 < 32:
            revert with 'NH{q', 34
        if not stor9.length.field_1 % 128:
            return Array(len=stor8[arg1].field_0 % 128, data=mem[128 len ceil32(stor8[arg1].field_1 % 128)])
        if stor8[arg1].field_1 % 128:
            if not bool(stor9.length):
                if bool(stor9.length) == stor9.length.field_1 % 128 < 32:
                    revert with 'NH{q', 34
                if not bool(stor9.length):
                    mem[ceil32(stor8[arg1].field_1 % 128) + 160] = Mask(248, 8, stor9.length)
                    mem[ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 160 len ceil32(stor8[arg1].field_1 % 128)] = mem[128 len ceil32(stor8[arg1].field_1 % 128)]
                    var51001 = ceil32(stor8[arg1].field_1 % 128)
                    mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 160] = 32
                    mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 192] = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                    mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 224 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                    if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128]) <= mem[ceil32(stor8[arg1].field_1 % 128) + 128]:
                        return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + 128], data=mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 224 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]), 
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 224] = 0
                    return 32, mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128]) + 32], 
                if bool(stor9.length) == 1:
                    idx = 0
                    s = 0
                    while idx < stor9.length.field_1 % 128:
                        mem[idx + ceil32(stor8[arg1].field_1 % 128) + 160] = uint256(stor9[s].field_0)
                        idx = idx + 32
                        s = s + 1
                        continue 
                    mem[ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 160 len ceil32(stor8[arg1].field_1 % 128)] = mem[128 len ceil32(stor8[arg1].field_1 % 128)]
                    mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 160] = 32
                    mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 192] = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                    mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 224 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                    if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128]) <= mem[ceil32(stor8[arg1].field_1 % 128) + 128]:
                        return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + 128], data=mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 224 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]), 
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 224] = 0
                    return 32, mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128]) + 32], 
                var52001 = ceil32(stor8[arg1].field_1 % 128)
                mem[64] = stor8[arg1].field_1 % 128
                if ceil32(stor8[arg1].field_1 % 128) <= stor8[arg1].field_1 % 128:
                    _13041 = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                    mem[stor8[arg1].field_1 % 128 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                    mem[stor8[arg1].field_1 % 128 + 64 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                    if ceil32(_13041) > _13041:
                        mem[_13041 + stor8[arg1].field_1 % 128 + 64] = 0
                    return 32, mem[stor8[arg1].field_1 % 128 + 32 len ceil32(_13041) + 32]
                _13042 = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                mem[stor8[arg1].field_1 % 128 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                mem[stor8[arg1].field_1 % 128 + 64 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                if ceil32(_13042) > _13042:
                    mem[_13042 + stor8[arg1].field_1 % 128 + 64] = 0
                return 32, mem[stor8[arg1].field_1 % 128 + 32 len ceil32(_13042) + 32]
            if bool(stor9.length) == uint255(stor9.length) * 0.5 < 32:
                revert with 'NH{q', 34
            if bool(stor9.length):
                if bool(stor9.length) == 1:
                    idx = 0
                    s = 0
                    while idx < uint255(stor9.length) * 0.5:
                        mem[idx + ceil32(stor8[arg1].field_1 % 128) + 160] = uint256(stor9[s].field_0)
                        idx = idx + 32
                        s = s + 1
                        continue 
                    mem[ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 160 len ceil32(stor8[arg1].field_1 % 128)] = mem[128 len ceil32(stor8[arg1].field_1 % 128)]
                    mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 160] = 32
                    mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 192] = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                    mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 224 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                    if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128]) <= mem[ceil32(stor8[arg1].field_1 % 128) + 128]:
                        return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + 128], data=mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 224 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]), 
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 224] = 0
                    return 32, mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128]) + 32], 
                var51001 = ceil32(stor8[arg1].field_1 % 128)
                mem[64] = stor8[arg1].field_1 % 128
                if ceil32(stor8[arg1].field_1 % 128) <= stor8[arg1].field_1 % 128:
                    _13037 = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                    mem[stor8[arg1].field_1 % 128 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                    mem[stor8[arg1].field_1 % 128 + 64 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                    if ceil32(_13037) > _13037:
                        mem[_13037 + stor8[arg1].field_1 % 128 + 64] = 0
                    return 32, mem[stor8[arg1].field_1 % 128 + 32 len ceil32(_13037) + 32]
                _13038 = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                mem[stor8[arg1].field_1 % 128 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                mem[stor8[arg1].field_1 % 128 + 64 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                if ceil32(_13038) > _13038:
                    mem[_13038 + stor8[arg1].field_1 % 128 + 64] = 0
                return 32, mem[stor8[arg1].field_1 % 128 + 32 len ceil32(_13038) + 32]
            mem[ceil32(stor8[arg1].field_1 % 128) + 160] = Mask(248, 8, stor9.length)
            mem[ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 160 len ceil32(stor8[arg1].field_1 % 128)] = mem[128 len ceil32(stor8[arg1].field_1 % 128)]
            var50001 = ceil32(stor8[arg1].field_1 % 128)
            mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 160] = 32
            mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 192] = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
            mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 224 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
            var61001 = ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])
            if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128]) <= mem[ceil32(stor8[arg1].field_1 % 128) + 128]:
                return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + 128], data=mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 224 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]), 
            mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 224] = 0
            return 32, mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128]) + 32], 
        if not arg1:
            mem[ceil32(stor8[arg1].field_1 % 128) + 128] = 1
            mem[ceil32(stor8[arg1].field_1 % 128) + 160] = '0'
            if bool(stor9.length):
                if bool(stor9.length) == uint255(stor9.length) * 0.5 < 32:
                    revert with 'NH{q', 34
                if not bool(stor9.length):
                    mem[ceil32(stor8[arg1].field_1 % 128) + 224] = Mask(248, 8, stor9.length)
                else:
                    if bool(stor9.length) != 1:
                        mem[64] = 1
                        _13030 = mem[ceil32(stor8[arg1].field_1 % 128) + 192]
                        mem[33] = mem[ceil32(stor8[arg1].field_1 % 128) + 192]
                        mem[65 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192])] = mem[ceil32(stor8[arg1].field_1 % 128) + 224 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192])]
                        if ceil32(_13030) > _13030:
                            mem[_13030 + 65] = 0
                        return memory
                          from mem[64]
                           len ceil32(_13030) + -mem[64] + 65
                    idx = 0
                    s = 0
                    while idx < uint255(stor9.length) * 0.5:
                        mem[idx + ceil32(stor8[arg1].field_1 % 128) + 224] = uint256(stor9[s].field_0)
                        idx = idx + 32
                        s = s + 1
                        continue 
                mem[ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 224] = '0'
                mem[ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 225] = 32
                mem[ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 257] = mem[ceil32(stor8[arg1].field_1 % 128) + 192]
                mem[ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 289 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192])] = mem[ceil32(stor8[arg1].field_1 % 128) + 224 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192])]
                if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192]) > mem[ceil32(stor8[arg1].field_1 % 128) + 192]:
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + 192] + ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 289] = 0
                return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + 192], data=mem[ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 289 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192])]), 
            if bool(stor9.length) == stor9.length.field_1 % 128 < 32:
                revert with 'NH{q', 34
            if not bool(stor9.length):
                mem[ceil32(stor8[arg1].field_1 % 128) + 224] = Mask(248, 8, stor9.length)
                mem[ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 224] = '0'
            else:
                if bool(stor9.length) != 1:
                    mem[64] = 1
                    _13034 = mem[ceil32(stor8[arg1].field_1 % 128) + 192]
                    mem[33] = mem[ceil32(stor8[arg1].field_1 % 128) + 192]
                    mem[65 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192])] = mem[ceil32(stor8[arg1].field_1 % 128) + 224 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192])]
                    if ceil32(_13034) > _13034:
                        mem[_13034 + 65] = 0
                    return memory
                      from mem[64]
                       len ceil32(_13034) + -mem[64] + 65
                idx = 0
                s = 0
                while idx < stor9.length.field_1 % 128:
                    mem[idx + ceil32(stor8[arg1].field_1 % 128) + 224] = uint256(stor9[s].field_0)
                    idx = idx + 32
                    s = s + 1
                    continue 
                mem[ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 224] = '0'
                var58001 = 32
            mem[ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 225] = 32
            mem[ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 257] = mem[ceil32(stor8[arg1].field_1 % 128) + 192]
            mem[ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 289 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192])] = mem[ceil32(stor8[arg1].field_1 % 128) + 224 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192])]
            if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192]) > mem[ceil32(stor8[arg1].field_1 % 128) + 192]:
                mem[mem[ceil32(stor8[arg1].field_1 % 128) + 192] + ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 289] = 0
            return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + 192], data=mem[ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 289 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192])]), 
        s = 0
        idx = arg1
        while idx:
            if s == -1:
                revert with 'NH{q', 17
            s = s + 1
            idx = idx / 10
            continue 
        if s > test266151307():
            revert with 'NH{q', 65
        mem[ceil32(stor8[arg1].field_1 % 128) + 128] = s
        if not s:
            t = s
            idx = arg1
            while idx:
                if t < 1:
                    revert with 'NH{q', 17
                if 48 > !(idx % 10):
                    revert with 'NH{q', 17
                if t - 1 >= mem[ceil32(stor8[arg1].field_1 % 128) + 128]:
                    revert with 'NH{q', 50
                mem[t + ceil32(stor8[arg1].field_1 % 128) + 159 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
                t = t - 1
                idx = idx / 10
                continue 
            if bool(stor9.length):
                if bool(stor9.length) == uint255(stor9.length) * 0.5 < 32:
                    revert with 'NH{q', 34
                if not bool(stor9.length):
                    mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192] = Mask(248, 8, stor9.length)
                    mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                    var61001 = ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])
                    mem[64] = mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192] = 32
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 224] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]
                    if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]) > mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]:
                        mem[mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160] + mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256] = 0
                    return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160], data=mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]), 
                if bool(stor9.length) == 1:
                    mem[0] = 9
                    idx = 0
                    t = 0
                    while idx < uint255(stor9.length) * 0.5:
                        mem[idx + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192] = uint256(stor9[t].field_0)
                        idx = idx + 32
                        t = t + 1
                        continue 
                    mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                    mem[64] = mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192] = 32
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 224] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]
                    if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]) > mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]:
                        mem[mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160] + mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256] = 0
                    return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160], data=mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]), 
                _20479 = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                mem[0 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                mem[64] = _20479
                mem[_20479] = 32
                if ceil32(_20479) <= _20479:
                    _25357 = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                    mem[_20479 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                    mem[_20479 + 64 len ceil32(_25357)] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(_25357)]
                    if ceil32(_25357) > _25357:
                        mem[_25357 + _20479 + 64] = 0
                    return 32, mem[_20479 + 32 len ceil32(_25357) + 32]
                _25358 = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                mem[_20479 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                mem[_20479 + 64 len ceil32(_25358)] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(_25358)]
                if ceil32(_25358) > _25358:
                    mem[_25358 + _20479 + 64] = 0
                return 32, mem[_20479 + 32 len ceil32(_25358) + 32]
            if bool(stor9.length) == stor9.length.field_1 % 128 < 32:
                revert with 'NH{q', 34
            if not bool(stor9.length):
                mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192] = Mask(248, 8, stor9.length)
                mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                mem[64] = mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192
                mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192] = 32
                mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 224] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]
                if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]) > mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]:
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160] + mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256] = 0
                return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160], data=mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]), 
            if bool(stor9.length) == 1:
                mem[0] = 9
                idx = 0
                t = 0
                while idx < stor9.length.field_1 % 128:
                    mem[idx + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192] = uint256(stor9[t].field_0)
                    idx = idx + 32
                    t = t + 1
                    continue 
                mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                mem[64] = mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192
                mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192] = 32
                mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 224] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]
                if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]) > mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]:
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160] + mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256] = 0
                return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160], data=mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]), 
            _20591 = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
            mem[0 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
            mem[64] = _20591
            mem[_20591] = 32
            if ceil32(_20591) <= _20591:
                _25361 = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                mem[_20591 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                mem[_20591 + 64 len ceil32(_25361)] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(_25361)]
                if ceil32(_25361) > _25361:
                    mem[_25361 + _20591 + 64] = 0
                return 32, mem[_20591 + 32 len ceil32(_25361) + 32]
            _25362 = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
            mem[_20591 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
            mem[_20591 + 64 len ceil32(_25362)] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(_25362)]
            if ceil32(_25362) > _25362:
                mem[_25362 + _20591 + 64] = 0
            return 32, mem[_20591 + 32 len ceil32(_25362) + 32]
        mem[ceil32(stor8[arg1].field_1 % 128) + 160 len s] = call.data[calldata.size len s]
        t = s
        idx = arg1
        while idx:
            if t < 1:
                revert with 'NH{q', 17
            if 48 > !(idx % 10):
                revert with 'NH{q', 17
            if t - 1 >= mem[ceil32(stor8[arg1].field_1 % 128) + 128]:
                revert with 'NH{q', 50
            mem[t + ceil32(stor8[arg1].field_1 % 128) + 159 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
            t = t - 1
            idx = idx / 10
            continue 
        if bool(stor9.length):
            if bool(stor9.length) == uint255(stor9.length) * 0.5 < 32:
                revert with 'NH{q', 34
            if not bool(stor9.length):
                mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192] = Mask(248, 8, stor9.length)
                mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                mem[64] = mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192
                mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192] = 32
                mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 224] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]
                if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]) > mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]:
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160] + mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256] = 0
                return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160], data=mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]), 
            if bool(stor9.length) == 1:
                mem[0] = 9
                idx = 0
                t = 0
                while idx < uint255(stor9.length) * 0.5:
                    mem[idx + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192] = uint256(stor9[t].field_0)
                    idx = idx + 32
                    t = t + 1
                    continue 
                mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                mem[64] = mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192
                mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192] = 32
                mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 224] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]
                if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]) > mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]:
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160] + mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256] = 0
                return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160], data=mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]), 
            _20481 = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
            mem[0 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
            mem[64] = _20481
            mem[_20481] = 32
            if ceil32(_20481) <= _20481:
                _25365 = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                mem[_20481 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                mem[_20481 + 64 len ceil32(_25365)] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(_25365)]
                if ceil32(_25365) > _25365:
                    mem[_25365 + _20481 + 64] = 0
                return 32, mem[_20481 + 32 len ceil32(_25365) + 32]
            _25366 = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
            mem[_20481 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
            mem[_20481 + 64 len ceil32(_25366)] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(_25366)]
            if ceil32(_25366) > _25366:
                mem[_25366 + _20481 + 64] = 0
            return 32, mem[_20481 + 32 len ceil32(_25366) + 32]
        if bool(stor9.length) == stor9.length.field_1 % 128 < 32:
            revert with 'NH{q', 34
        if not bool(stor9.length):
            mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192] = Mask(248, 8, stor9.length)
            mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
            mem[64] = mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192
            mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192] = 32
            mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 224] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
            mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]
            if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]) > mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]:
                mem[mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160] + mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256] = 0
            return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160], data=mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]), 
        if bool(stor9.length) == 1:
            mem[0] = 9
            idx = 0
            t = 0
            while idx < stor9.length.field_1 % 128:
                mem[idx + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192] = uint256(stor9[t].field_0)
                idx = idx + 32
                t = t + 1
                continue 
            mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
            mem[64] = mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192
            mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192] = 32
            mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 224] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
            mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]
            if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]) > mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]:
                mem[mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160] + mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256] = 0
            return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160], data=mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]), 
        _20593 = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
        mem[0 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
        mem[64] = _20593
        mem[_20593] = 32
        if ceil32(_20593) <= _20593:
            _25369 = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
            mem[_20593 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
            mem[_20593 + 64 len ceil32(_25369)] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(_25369)]
            if ceil32(_25369) > _25369:
                mem[_25369 + _20593 + 64] = 0
            return 32, mem[_20593 + 32 len ceil32(_25369) + 32]
        _25370 = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
        mem[_20593 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
        mem[_20593 + 64 len ceil32(_25370)] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(_25370)]
        if ceil32(_25370) > _25370:
            mem[_25370 + _20593 + 64] = 0
        return 32, mem[_20593 + 32 len ceil32(_25370) + 32]
    if bool(stor8[arg1].field_0) == stor8[arg1].field_1 % 128 < 32:
        revert with 'NH{q', 34
    if not stor8[arg1].field_1 % 128:
        if bool(stor9.length):
            if bool(stor9.length) == uint255(stor9.length) * 0.5 < 32:
                revert with 'NH{q', 34
            if not uint255(stor9.length) * 0.5:
                mem[ceil32(stor8[arg1].field_1 % 128) + 192 len ceil32(stor8[arg1].field_1 % 128)] = mem[128 len ceil32(stor8[arg1].field_1 % 128)]
                if ceil32(stor8[arg1].field_1 % 128) > stor8[arg1].field_1 % 128:
                    mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + 192] = 0
                return Array(len=stor8[arg1].field_0 % 128, data=mem[128 len ceil32(stor8[arg1].field_1 % 128)], mem[(2 * ceil32(stor8[arg1].field_1 % 128)) + 192 len 2 * ceil32(stor8[arg1].field_1 % 128)]), 
            if stor8[arg1].field_1 % 128:
                if bool(stor9.length):
                    if bool(stor9.length) == uint255(stor9.length) * 0.5 < 32:
                        revert with 'NH{q', 34
                    if not bool(stor9.length):
                        mem[ceil32(stor8[arg1].field_1 % 128) + 160] = Mask(248, 8, stor9.length)
                    else:
                        if bool(stor9.length) != 1:
                            mem[64] = stor8[arg1].field_1 % 128
                            if ceil32(stor8[arg1].field_1 % 128) <= stor8[arg1].field_1 % 128:
                                _5434 = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                                mem[stor8[arg1].field_1 % 128 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                                mem[stor8[arg1].field_1 % 128 + 64 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                                if ceil32(_5434) > _5434:
                                    mem[_5434 + stor8[arg1].field_1 % 128 + 64] = 0
                                return 32, mem[stor8[arg1].field_1 % 128 + 32 len ceil32(_5434) + 32]
                            _5435 = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                            mem[stor8[arg1].field_1 % 128 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                            mem[stor8[arg1].field_1 % 128 + 64 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                            if ceil32(_5435) > _5435:
                                mem[_5435 + stor8[arg1].field_1 % 128 + 64] = 0
                            return 32, mem[stor8[arg1].field_1 % 128 + 32 len ceil32(_5435) + 32]
                        idx = 0
                        s = 0
                        while idx < uint255(stor9.length) * 0.5:
                            mem[idx + ceil32(stor8[arg1].field_1 % 128) + 160] = uint256(stor9[s].field_0)
                            idx = idx + 32
                            s = s + 1
                            continue 
                    mem[ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 160 len ceil32(stor8[arg1].field_1 % 128)] = mem[128 len ceil32(stor8[arg1].field_1 % 128)]
                    mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 160] = 32
                    mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 192] = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                    mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 224 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                    if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128]) <= mem[ceil32(stor8[arg1].field_1 % 128) + 128]:
                        return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + 128], data=mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 224 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]), 
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 224] = 0
                    return 32, mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128]) + 32], 
                if bool(stor9.length) == stor9.length.field_1 % 128 < 32:
                    revert with 'NH{q', 34
                if not bool(stor9.length):
                    mem[ceil32(stor8[arg1].field_1 % 128) + 160] = Mask(248, 8, stor9.length)
                else:
                    if bool(stor9.length) != 1:
                        mem[64] = stor8[arg1].field_1 % 128
                        if ceil32(stor8[arg1].field_1 % 128) <= stor8[arg1].field_1 % 128:
                            _5438 = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                            mem[stor8[arg1].field_1 % 128 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                            mem[stor8[arg1].field_1 % 128 + 64 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                            if ceil32(_5438) > _5438:
                                mem[_5438 + stor8[arg1].field_1 % 128 + 64] = 0
                            return 32, mem[stor8[arg1].field_1 % 128 + 32 len ceil32(_5438) + 32]
                        _5439 = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                        mem[stor8[arg1].field_1 % 128 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                        mem[stor8[arg1].field_1 % 128 + 64 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                        if ceil32(_5439) > _5439:
                            mem[_5439 + stor8[arg1].field_1 % 128 + 64] = 0
                        return 32, mem[stor8[arg1].field_1 % 128 + 32 len ceil32(_5439) + 32]
                    idx = 0
                    s = 0
                    while idx < stor9.length.field_1 % 128:
                        mem[idx + ceil32(stor8[arg1].field_1 % 128) + 160] = uint256(stor9[s].field_0)
                        idx = idx + 32
                        s = s + 1
                        continue 
                mem[ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 160 len ceil32(stor8[arg1].field_1 % 128)] = mem[128 len ceil32(stor8[arg1].field_1 % 128)]
                mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 160] = 32
                mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 192] = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 224 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128]) <= mem[ceil32(stor8[arg1].field_1 % 128) + 128]:
                    return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + 128], data=mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 224 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]), 
                mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 224] = 0
                return 32, mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128]) + 32], 
            if not arg1:
                mem[ceil32(stor8[arg1].field_1 % 128) + 128] = 1
                mem[ceil32(stor8[arg1].field_1 % 128) + 160] = '0'
                if bool(stor9.length):
                    if bool(stor9.length) == uint255(stor9.length) * 0.5 < 32:
                        revert with 'NH{q', 34
                    if not bool(stor9.length):
                        mem[ceil32(stor8[arg1].field_1 % 128) + 224] = Mask(248, 8, stor9.length)
                    else:
                        if bool(stor9.length) != 1:
                            mem[64] = 1
                            _5427 = mem[ceil32(stor8[arg1].field_1 % 128) + 192]
                            mem[33] = mem[ceil32(stor8[arg1].field_1 % 128) + 192]
                            mem[65 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192])] = mem[ceil32(stor8[arg1].field_1 % 128) + 224 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192])]
                            if ceil32(_5427) > _5427:
                                mem[_5427 + 65] = 0
                            return memory
                              from mem[64]
                               len ceil32(_5427) + -mem[64] + 65
                        idx = 0
                        s = 0
                        while idx < uint255(stor9.length) * 0.5:
                            mem[idx + ceil32(stor8[arg1].field_1 % 128) + 224] = uint256(stor9[s].field_0)
                            idx = idx + 32
                            s = s + 1
                            continue 
                    mem[ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 224] = '0'
                    mem[ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 225] = 32
                    mem[ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 257] = mem[ceil32(stor8[arg1].field_1 % 128) + 192]
                    mem[ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 289 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192])] = mem[ceil32(stor8[arg1].field_1 % 128) + 224 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192])]
                    if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192]) > mem[ceil32(stor8[arg1].field_1 % 128) + 192]:
                        mem[mem[ceil32(stor8[arg1].field_1 % 128) + 192] + ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 289] = 0
                    return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + 192], data=mem[ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 289 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192])]), 
                if bool(stor9.length) == stor9.length.field_1 % 128 < 32:
                    revert with 'NH{q', 34
                if not bool(stor9.length):
                    mem[ceil32(stor8[arg1].field_1 % 128) + 224] = Mask(248, 8, stor9.length)
                else:
                    if bool(stor9.length) != 1:
                        mem[64] = 1
                        _5431 = mem[ceil32(stor8[arg1].field_1 % 128) + 192]
                        mem[33] = mem[ceil32(stor8[arg1].field_1 % 128) + 192]
                        mem[65 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192])] = mem[ceil32(stor8[arg1].field_1 % 128) + 224 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192])]
                        if ceil32(_5431) > _5431:
                            mem[_5431 + 65] = 0
                        return memory
                          from mem[64]
                           len ceil32(_5431) + -mem[64] + 65
                    idx = 0
                    s = 0
                    while idx < stor9.length.field_1 % 128:
                        mem[idx + ceil32(stor8[arg1].field_1 % 128) + 224] = uint256(stor9[s].field_0)
                        idx = idx + 32
                        s = s + 1
                        continue 
                mem[ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 224] = '0'
                mem[ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 225] = 32
                mem[ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 257] = mem[ceil32(stor8[arg1].field_1 % 128) + 192]
                mem[ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 289 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192])] = mem[ceil32(stor8[arg1].field_1 % 128) + 224 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192])]
                if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192]) > mem[ceil32(stor8[arg1].field_1 % 128) + 192]:
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + 192] + ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 289] = 0
                return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + 192], data=mem[ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 289 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192])]), 
            s = 0
            idx = arg1
            while idx:
                if s == -1:
                    revert with 'NH{q', 17
                s = s + 1
                idx = idx / 10
                continue 
            if s > test266151307():
                revert with 'NH{q', 65
            mem[ceil32(stor8[arg1].field_1 % 128) + 128] = s
            if not s:
                t = s
                idx = arg1
                while idx:
                    if t < 1:
                        revert with 'NH{q', 17
                    if 48 > !(idx % 10):
                        revert with 'NH{q', 17
                    if t - 1 >= mem[ceil32(stor8[arg1].field_1 % 128) + 128]:
                        revert with 'NH{q', 50
                    mem[t + ceil32(stor8[arg1].field_1 % 128) + 159 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
                    t = t - 1
                    idx = idx / 10
                    continue 
                if bool(stor9.length):
                    if bool(stor9.length) == uint255(stor9.length) * 0.5 < 32:
                        revert with 'NH{q', 34
                    if not bool(stor9.length):
                        mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192] = Mask(248, 8, stor9.length)
                        mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                        mem[64] = mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192
                        mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192] = 32
                        mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 224] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                        mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]
                        if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]) > mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]:
                            mem[mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160] + mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256] = 0
                        return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160], data=mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]), 
                    if bool(stor9.length) == 1:
                        mem[0] = 9
                        idx = 0
                        t = 0
                        while idx < uint255(stor9.length) * 0.5:
                            mem[idx + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192] = uint256(stor9[t].field_0)
                            idx = idx + 32
                            t = t + 1
                            continue 
                        mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                        mem[64] = mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192
                        mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192] = 32
                        mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 224] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                        mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]
                        if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]) > mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]:
                            mem[mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160] + mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256] = 0
                        return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160], data=mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]), 
                    _13195 = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                    mem[0 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                    mem[64] = _13195
                    mem[_13195] = 32
                    if ceil32(_13195) <= _13195:
                        _20373 = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                        mem[_13195 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                        mem[_13195 + 64 len ceil32(_20373)] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(_20373)]
                        if ceil32(_20373) > _20373:
                            mem[_20373 + _13195 + 64] = 0
                        return 32, mem[_13195 + 32 len ceil32(_20373) + 32]
                    _20374 = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                    mem[_13195 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                    mem[_13195 + 64 len ceil32(_20374)] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(_20374)]
                    if ceil32(_20374) > _20374:
                        mem[_20374 + _13195 + 64] = 0
                    return 32, mem[_13195 + 32 len ceil32(_20374) + 32]
                if bool(stor9.length) == stor9.length.field_1 % 128 < 32:
                    revert with 'NH{q', 34
                if not bool(stor9.length):
                    mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192] = Mask(248, 8, stor9.length)
                    mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                    mem[64] = mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192] = 32
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 224] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]
                    if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]) > mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]:
                        mem[mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160] + mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256] = 0
                    return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160], data=mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]), 
                if bool(stor9.length) == 1:
                    mem[0] = 9
                    idx = 0
                    t = 0
                    while idx < stor9.length.field_1 % 128:
                        mem[idx + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192] = uint256(stor9[t].field_0)
                        idx = idx + 32
                        t = t + 1
                        continue 
                    mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                    mem[64] = mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192] = 32
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 224] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]
                    if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]) > mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]:
                        mem[mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160] + mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256] = 0
                    return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160], data=mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]), 
                _13307 = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                mem[0 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                mem[64] = _13307
                mem[_13307] = 32
                if ceil32(_13307) <= _13307:
                    _20377 = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                    mem[_13307 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                    mem[_13307 + 64 len ceil32(_20377)] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(_20377)]
                    if ceil32(_20377) > _20377:
                        mem[_20377 + _13307 + 64] = 0
                    return 32, mem[_13307 + 32 len ceil32(_20377) + 32]
                _20378 = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                mem[_13307 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                mem[_13307 + 64 len ceil32(_20378)] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(_20378)]
                if ceil32(_20378) > _20378:
                    mem[_20378 + _13307 + 64] = 0
                return 32, mem[_13307 + 32 len ceil32(_20378) + 32]
            mem[ceil32(stor8[arg1].field_1 % 128) + 160 len s] = call.data[calldata.size len s]
            t = s
            idx = arg1
            while idx:
                if t < 1:
                    revert with 'NH{q', 17
                if 48 > !(idx % 10):
                    revert with 'NH{q', 17
                if t - 1 >= mem[ceil32(stor8[arg1].field_1 % 128) + 128]:
                    revert with 'NH{q', 50
                mem[t + ceil32(stor8[arg1].field_1 % 128) + 159 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
                t = t - 1
                idx = idx / 10
                continue 
            if bool(stor9.length):
                if bool(stor9.length) == uint255(stor9.length) * 0.5 < 32:
                    revert with 'NH{q', 34
                if not bool(stor9.length):
                    mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192] = Mask(248, 8, stor9.length)
                    mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                    mem[64] = mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192] = 32
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 224] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]
                    if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]) > mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]:
                        mem[mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160] + mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256] = 0
                    return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160], data=mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]), 
                if bool(stor9.length) == 1:
                    mem[0] = 9
                    idx = 0
                    t = 0
                    while idx < uint255(stor9.length) * 0.5:
                        mem[idx + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192] = uint256(stor9[t].field_0)
                        idx = idx + 32
                        t = t + 1
                        continue 
                    mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                    mem[64] = mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192] = 32
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 224] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]
                    if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]) > mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]:
                        mem[mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160] + mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256] = 0
                    return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160], data=mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]), 
                _13197 = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                mem[0 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                mem[64] = _13197
                mem[_13197] = 32
                if ceil32(_13197) <= _13197:
                    _20381 = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                    mem[_13197 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                    mem[_13197 + 64 len ceil32(_20381)] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(_20381)]
                    if ceil32(_20381) > _20381:
                        mem[_20381 + _13197 + 64] = 0
                    return 32, mem[_13197 + 32 len ceil32(_20381) + 32]
                _20382 = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                mem[_13197 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                mem[_13197 + 64 len ceil32(_20382)] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(_20382)]
                if ceil32(_20382) > _20382:
                    mem[_20382 + _13197 + 64] = 0
                return 32, mem[_13197 + 32 len ceil32(_20382) + 32]
            if bool(stor9.length) == stor9.length.field_1 % 128 < 32:
                revert with 'NH{q', 34
            if not bool(stor9.length):
                mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192] = Mask(248, 8, stor9.length)
                mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                mem[64] = mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192
                mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192] = 32
                mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 224] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]
                if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]) > mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]:
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160] + mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256] = 0
                return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160], data=mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]), 
            if bool(stor9.length) == 1:
                mem[0] = 9
                idx = 0
                t = 0
                while idx < stor9.length.field_1 % 128:
                    mem[idx + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192] = uint256(stor9[t].field_0)
                    idx = idx + 32
                    t = t + 1
                    continue 
                mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                mem[64] = mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192
                mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192] = 32
                mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 224] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]
                if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]) > mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]:
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160] + mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256] = 0
                return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160], data=mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]), 
            _13309 = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
            mem[0 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
            mem[64] = _13309
            mem[_13309] = 32
            if ceil32(_13309) <= _13309:
                _20385 = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                mem[_13309 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                mem[_13309 + 64 len ceil32(_20385)] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(_20385)]
                if ceil32(_20385) > _20385:
                    mem[_20385 + _13309 + 64] = 0
                return 32, mem[_13309 + 32 len ceil32(_20385) + 32]
            _20386 = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
            mem[_13309 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
            mem[_13309 + 64 len ceil32(_20386)] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(_20386)]
            if ceil32(_20386) > _20386:
                mem[_20386 + _13309 + 64] = 0
            return 32, mem[_13309 + 32 len ceil32(_20386) + 32]
        if bool(stor9.length) == stor9.length.field_1 % 128 < 32:
            revert with 'NH{q', 34
        if not stor9.length.field_1 % 128:
            mem[ceil32(stor8[arg1].field_1 % 128) + 192 len ceil32(stor8[arg1].field_1 % 128)] = mem[128 len ceil32(stor8[arg1].field_1 % 128)]
            if ceil32(stor8[arg1].field_1 % 128) > stor8[arg1].field_1 % 128:
                mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + 192] = 0
            return Array(len=stor8[arg1].field_0 % 128, data=mem[128 len ceil32(stor8[arg1].field_1 % 128)], mem[(2 * ceil32(stor8[arg1].field_1 % 128)) + 192 len 2 * ceil32(stor8[arg1].field_1 % 128)]), 
        if stor8[arg1].field_1 % 128:
            if bool(stor9.length):
                if bool(stor9.length) == uint255(stor9.length) * 0.5 < 32:
                    revert with 'NH{q', 34
                if not bool(stor9.length):
                    mem[ceil32(stor8[arg1].field_1 % 128) + 160] = Mask(248, 8, stor9.length)
                else:
                    if bool(stor9.length) != 1:
                        mem[64] = stor8[arg1].field_1 % 128
                        if ceil32(stor8[arg1].field_1 % 128) <= stor8[arg1].field_1 % 128:
                            _5450 = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                            mem[stor8[arg1].field_1 % 128 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                            mem[stor8[arg1].field_1 % 128 + 64 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                            if ceil32(_5450) > _5450:
                                mem[_5450 + stor8[arg1].field_1 % 128 + 64] = 0
                            return 32, mem[stor8[arg1].field_1 % 128 + 32 len ceil32(_5450) + 32]
                        _5451 = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                        mem[stor8[arg1].field_1 % 128 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                        mem[stor8[arg1].field_1 % 128 + 64 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                        if ceil32(_5451) > _5451:
                            mem[_5451 + stor8[arg1].field_1 % 128 + 64] = 0
                        return 32, mem[stor8[arg1].field_1 % 128 + 32 len ceil32(_5451) + 32]
                    idx = 0
                    s = 0
                    while idx < uint255(stor9.length) * 0.5:
                        mem[idx + ceil32(stor8[arg1].field_1 % 128) + 160] = uint256(stor9[s].field_0)
                        idx = idx + 32
                        s = s + 1
                        continue 
                mem[ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 160 len ceil32(stor8[arg1].field_1 % 128)] = mem[128 len ceil32(stor8[arg1].field_1 % 128)]
                mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 160] = 32
                mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 192] = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 224 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128]) <= mem[ceil32(stor8[arg1].field_1 % 128) + 128]:
                    return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + 128], data=mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 224 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]), 
                mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 224] = 0
                return 32, mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128]) + 32], 
            if bool(stor9.length) == stor9.length.field_1 % 128 < 32:
                revert with 'NH{q', 34
            if not bool(stor9.length):
                mem[ceil32(stor8[arg1].field_1 % 128) + 160] = Mask(248, 8, stor9.length)
            else:
                if bool(stor9.length) != 1:
                    mem[64] = stor8[arg1].field_1 % 128
                    if ceil32(stor8[arg1].field_1 % 128) <= stor8[arg1].field_1 % 128:
                        _5454 = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                        mem[stor8[arg1].field_1 % 128 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                        mem[stor8[arg1].field_1 % 128 + 64 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                        if ceil32(_5454) > _5454:
                            mem[_5454 + stor8[arg1].field_1 % 128 + 64] = 0
                        return 32, mem[stor8[arg1].field_1 % 128 + 32 len ceil32(_5454) + 32]
                    _5455 = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                    mem[stor8[arg1].field_1 % 128 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                    mem[stor8[arg1].field_1 % 128 + 64 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                    if ceil32(_5455) > _5455:
                        mem[_5455 + stor8[arg1].field_1 % 128 + 64] = 0
                    return 32, mem[stor8[arg1].field_1 % 128 + 32 len ceil32(_5455) + 32]
                idx = 0
                s = 0
                while idx < stor9.length.field_1 % 128:
                    mem[idx + ceil32(stor8[arg1].field_1 % 128) + 160] = uint256(stor9[s].field_0)
                    idx = idx + 32
                    s = s + 1
                    continue 
            mem[ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 160 len ceil32(stor8[arg1].field_1 % 128)] = mem[128 len ceil32(stor8[arg1].field_1 % 128)]
            mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 160] = 32
            mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 192] = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
            mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 224 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
            if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128]) <= mem[ceil32(stor8[arg1].field_1 % 128) + 128]:
                return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + 128], data=mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 224 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]), 
            mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 224] = 0
            return 32, mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128]) + 32], 
        if not arg1:
            mem[ceil32(stor8[arg1].field_1 % 128) + 128] = 1
            mem[ceil32(stor8[arg1].field_1 % 128) + 160] = '0'
            if bool(stor9.length):
                if bool(stor9.length) == uint255(stor9.length) * 0.5 < 32:
                    revert with 'NH{q', 34
                if not bool(stor9.length):
                    mem[ceil32(stor8[arg1].field_1 % 128) + 224] = Mask(248, 8, stor9.length)
                else:
                    if bool(stor9.length) != 1:
                        mem[64] = 1
                        _5443 = mem[ceil32(stor8[arg1].field_1 % 128) + 192]
                        mem[33] = mem[ceil32(stor8[arg1].field_1 % 128) + 192]
                        mem[65 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192])] = mem[ceil32(stor8[arg1].field_1 % 128) + 224 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192])]
                        if ceil32(_5443) > _5443:
                            mem[_5443 + 65] = 0
                        return memory
                          from mem[64]
                           len ceil32(_5443) + -mem[64] + 65
                    idx = 0
                    s = 0
                    while idx < uint255(stor9.length) * 0.5:
                        mem[idx + ceil32(stor8[arg1].field_1 % 128) + 224] = uint256(stor9[s].field_0)
                        idx = idx + 32
                        s = s + 1
                        continue 
                mem[ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 224] = '0'
                mem[ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 225] = 32
                mem[ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 257] = mem[ceil32(stor8[arg1].field_1 % 128) + 192]
                mem[ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 289 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192])] = mem[ceil32(stor8[arg1].field_1 % 128) + 224 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192])]
                if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192]) > mem[ceil32(stor8[arg1].field_1 % 128) + 192]:
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + 192] + ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 289] = 0
                return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + 192], data=mem[ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 289 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192])]), 
            if bool(stor9.length) == stor9.length.field_1 % 128 < 32:
                revert with 'NH{q', 34
            if not bool(stor9.length):
                mem[ceil32(stor8[arg1].field_1 % 128) + 224] = Mask(248, 8, stor9.length)
            else:
                if bool(stor9.length) != 1:
                    mem[64] = 1
                    _5447 = mem[ceil32(stor8[arg1].field_1 % 128) + 192]
                    mem[33] = mem[ceil32(stor8[arg1].field_1 % 128) + 192]
                    mem[65 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192])] = mem[ceil32(stor8[arg1].field_1 % 128) + 224 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192])]
                    if ceil32(_5447) > _5447:
                        mem[_5447 + 65] = 0
                    return memory
                      from mem[64]
                       len ceil32(_5447) + -mem[64] + 65
                idx = 0
                s = 0
                while idx < stor9.length.field_1 % 128:
                    mem[idx + ceil32(stor8[arg1].field_1 % 128) + 224] = uint256(stor9[s].field_0)
                    idx = idx + 32
                    s = s + 1
                    continue 
            mem[ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 224] = '0'
            mem[ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 225] = 32
            mem[ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 257] = mem[ceil32(stor8[arg1].field_1 % 128) + 192]
            mem[ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 289 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192])] = mem[ceil32(stor8[arg1].field_1 % 128) + 224 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192])]
            if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192]) > mem[ceil32(stor8[arg1].field_1 % 128) + 192]:
                mem[mem[ceil32(stor8[arg1].field_1 % 128) + 192] + ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 289] = 0
            return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + 192], data=mem[ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 289 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192])]), 
        s = 0
        idx = arg1
        while idx:
            if s == -1:
                revert with 'NH{q', 17
            s = s + 1
            idx = idx / 10
            continue 
        if s > test266151307():
            revert with 'NH{q', 65
        mem[ceil32(stor8[arg1].field_1 % 128) + 128] = s
        if not s:
            t = s
            idx = arg1
            while idx:
                if t < 1:
                    revert with 'NH{q', 17
                if 48 > !(idx % 10):
                    revert with 'NH{q', 17
                if t - 1 >= mem[ceil32(stor8[arg1].field_1 % 128) + 128]:
                    revert with 'NH{q', 50
                mem[t + ceil32(stor8[arg1].field_1 % 128) + 159 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
                t = t - 1
                idx = idx / 10
                continue 
            if bool(stor9.length):
                if bool(stor9.length) == uint255(stor9.length) * 0.5 < 32:
                    revert with 'NH{q', 34
                if not bool(stor9.length):
                    mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192] = Mask(248, 8, stor9.length)
                    mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                    mem[64] = mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192] = 32
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 224] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]
                    if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]) > mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]:
                        mem[mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160] + mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256] = 0
                    return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160], data=mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]), 
                if bool(stor9.length) == 1:
                    mem[0] = 9
                    idx = 0
                    t = 0
                    while idx < uint255(stor9.length) * 0.5:
                        mem[idx + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192] = uint256(stor9[t].field_0)
                        idx = idx + 32
                        t = t + 1
                        continue 
                    mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                    mem[64] = mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192] = 32
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 224] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]
                    if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]) > mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]:
                        mem[mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160] + mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256] = 0
                    return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160], data=mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]), 
                _13199 = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                mem[0 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                mem[64] = _13199
                mem[_13199] = 32
                if ceil32(_13199) <= _13199:
                    _20389 = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                    mem[_13199 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                    mem[_13199 + 64 len ceil32(_20389)] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(_20389)]
                    if ceil32(_20389) > _20389:
                        mem[_20389 + _13199 + 64] = 0
                    return 32, mem[_13199 + 32 len ceil32(_20389) + 32]
                _20390 = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                mem[_13199 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                mem[_13199 + 64 len ceil32(_20390)] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(_20390)]
                if ceil32(_20390) > _20390:
                    mem[_20390 + _13199 + 64] = 0
                return 32, mem[_13199 + 32 len ceil32(_20390) + 32]
            if bool(stor9.length) == stor9.length.field_1 % 128 < 32:
                revert with 'NH{q', 34
            if not bool(stor9.length):
                mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192] = Mask(248, 8, stor9.length)
                mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                mem[64] = mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192
                mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192] = 32
                mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 224] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]
                if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]) > mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]:
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160] + mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256] = 0
                return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160], data=mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]), 
            if bool(stor9.length) == 1:
                mem[0] = 9
                idx = 0
                t = 0
                while idx < stor9.length.field_1 % 128:
                    mem[idx + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192] = uint256(stor9[t].field_0)
                    idx = idx + 32
                    t = t + 1
                    continue 
                mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                mem[64] = mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192
                mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192] = 32
                mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 224] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]
                if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]) > mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]:
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160] + mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256] = 0
                return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160], data=mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]), 
            _13311 = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
            mem[0 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
            mem[64] = _13311
            mem[_13311] = 32
            if ceil32(_13311) <= _13311:
                _20393 = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                mem[_13311 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                mem[_13311 + 64 len ceil32(_20393)] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(_20393)]
                if ceil32(_20393) > _20393:
                    mem[_20393 + _13311 + 64] = 0
                return 32, mem[_13311 + 32 len ceil32(_20393) + 32]
            _20394 = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
            mem[_13311 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
            mem[_13311 + 64 len ceil32(_20394)] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(_20394)]
            if ceil32(_20394) > _20394:
                mem[_20394 + _13311 + 64] = 0
            return 32, mem[_13311 + 32 len ceil32(_20394) + 32]
        mem[ceil32(stor8[arg1].field_1 % 128) + 160 len s] = call.data[calldata.size len s]
        t = s
        idx = arg1
        while idx:
            if t < 1:
                revert with 'NH{q', 17
            if 48 > !(idx % 10):
                revert with 'NH{q', 17
            if t - 1 >= mem[ceil32(stor8[arg1].field_1 % 128) + 128]:
                revert with 'NH{q', 50
            mem[t + ceil32(stor8[arg1].field_1 % 128) + 159 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
            t = t - 1
            idx = idx / 10
            continue 
        if bool(stor9.length):
            if bool(stor9.length) == uint255(stor9.length) * 0.5 < 32:
                revert with 'NH{q', 34
            if not bool(stor9.length):
                mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192] = Mask(248, 8, stor9.length)
                mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                mem[64] = mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192
                mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192] = 32
                mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 224] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]
                if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]) > mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]:
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160] + mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256] = 0
                return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160], data=mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]), 
            if bool(stor9.length) == 1:
                mem[0] = 9
                idx = 0
                t = 0
                while idx < uint255(stor9.length) * 0.5:
                    mem[idx + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192] = uint256(stor9[t].field_0)
                    idx = idx + 32
                    t = t + 1
                    continue 
                mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                mem[64] = mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192
                mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192] = 32
                mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 224] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]
                if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]) > mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]:
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160] + mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256] = 0
                return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160], data=mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]), 
            _13201 = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
            mem[0 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
            mem[64] = _13201
            mem[_13201] = 32
            if ceil32(_13201) <= _13201:
                _20397 = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                mem[_13201 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                mem[_13201 + 64 len ceil32(_20397)] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(_20397)]
                if ceil32(_20397) > _20397:
                    mem[_20397 + _13201 + 64] = 0
                return 32, mem[_13201 + 32 len ceil32(_20397) + 32]
            _20398 = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
            mem[_13201 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
            mem[_13201 + 64 len ceil32(_20398)] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(_20398)]
            if ceil32(_20398) > _20398:
                mem[_20398 + _13201 + 64] = 0
            return 32, mem[_13201 + 32 len ceil32(_20398) + 32]
        if bool(stor9.length) == stor9.length.field_1 % 128 < 32:
            revert with 'NH{q', 34
        if not bool(stor9.length):
            mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192] = Mask(248, 8, stor9.length)
            mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
            mem[64] = mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192
            mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192] = 32
            mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 224] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
            mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]
            if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]) > mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]:
                mem[mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160] + mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256] = 0
            return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160], data=mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]), 
        if bool(stor9.length) == 1:
            mem[0] = 9
            idx = 0
            t = 0
            while idx < stor9.length.field_1 % 128:
                mem[idx + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192] = uint256(stor9[t].field_0)
                idx = idx + 32
                t = t + 1
                continue 
            mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
            mem[64] = mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192
            mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192] = 32
            mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 224] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
            mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]
            if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]) > mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]:
                mem[mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160] + mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256] = 0
            return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160], data=mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]), 
        _13313 = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
        mem[0 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
        mem[64] = _13313
        mem[_13313] = 32
        if ceil32(_13313) <= _13313:
            _20401 = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
            mem[_13313 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
            mem[_13313 + 64 len ceil32(_20401)] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(_20401)]
            if ceil32(_20401) > _20401:
                mem[_20401 + _13313 + 64] = 0
            return 32, mem[_13313 + 32 len ceil32(_20401) + 32]
        _20402 = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
        mem[_13313 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
        mem[_13313 + 64 len ceil32(_20402)] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(_20402)]
        if ceil32(_20402) > _20402:
            mem[_20402 + _13313 + 64] = 0
        return 32, mem[_13313 + 32 len ceil32(_20402) + 32]
    if 31 >= stor8[arg1].field_1 % 128:
        mem[128] = 256 * Mask(248, 0, stor8[arg1].field_8)
        if bool(stor9.length):
            if bool(stor9.length) == uint255(stor9.length) * 0.5 < 32:
                revert with 'NH{q', 34
            if not uint255(stor9.length) * 0.5:
                mem[ceil32(stor8[arg1].field_1 % 128) + 192 len ceil32(stor8[arg1].field_1 % 128)] = mem[128 len ceil32(stor8[arg1].field_1 % 128)]
                if ceil32(stor8[arg1].field_1 % 128) > stor8[arg1].field_1 % 128:
                    mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + 192] = 0
                return Array(len=stor8[arg1].field_0 % 128, data=mem[128 len ceil32(stor8[arg1].field_1 % 128)], mem[(2 * ceil32(stor8[arg1].field_1 % 128)) + 192 len 2 * ceil32(stor8[arg1].field_1 % 128)]), 
            if stor8[arg1].field_1 % 128:
                if bool(stor9.length):
                    if bool(stor9.length) == uint255(stor9.length) * 0.5 < 32:
                        revert with 'NH{q', 34
                    if not bool(stor9.length):
                        mem[ceil32(stor8[arg1].field_1 % 128) + 160] = Mask(248, 8, stor9.length)
                    else:
                        if bool(stor9.length) != 1:
                            mem[64] = stor8[arg1].field_1 % 128
                            if ceil32(stor8[arg1].field_1 % 128) <= stor8[arg1].field_1 % 128:
                                _5469 = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                                mem[stor8[arg1].field_1 % 128 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                                mem[stor8[arg1].field_1 % 128 + 64 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                                if ceil32(_5469) > _5469:
                                    mem[_5469 + stor8[arg1].field_1 % 128 + 64] = 0
                                return 32, mem[stor8[arg1].field_1 % 128 + 32 len ceil32(_5469) + 32]
                            _5470 = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                            mem[stor8[arg1].field_1 % 128 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                            mem[stor8[arg1].field_1 % 128 + 64 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                            if ceil32(_5470) > _5470:
                                mem[_5470 + stor8[arg1].field_1 % 128 + 64] = 0
                            return 32, mem[stor8[arg1].field_1 % 128 + 32 len ceil32(_5470) + 32]
                        idx = 0
                        s = 0
                        while idx < uint255(stor9.length) * 0.5:
                            mem[idx + ceil32(stor8[arg1].field_1 % 128) + 160] = uint256(stor9[s].field_0)
                            idx = idx + 32
                            s = s + 1
                            continue 
                    mem[ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 160 len ceil32(stor8[arg1].field_1 % 128)] = mem[128 len ceil32(stor8[arg1].field_1 % 128)]
                    mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 160] = 32
                    mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 192] = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                    mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 224 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                    if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128]) <= mem[ceil32(stor8[arg1].field_1 % 128) + 128]:
                        return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + 128], data=mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 224 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]), 
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 224] = 0
                    return 32, mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128]) + 32], 
                if bool(stor9.length) == stor9.length.field_1 % 128 < 32:
                    revert with 'NH{q', 34
                if not bool(stor9.length):
                    mem[ceil32(stor8[arg1].field_1 % 128) + 160] = Mask(248, 8, stor9.length)
                else:
                    if bool(stor9.length) != 1:
                        mem[64] = stor8[arg1].field_1 % 128
                        if ceil32(stor8[arg1].field_1 % 128) <= stor8[arg1].field_1 % 128:
                            _5473 = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                            mem[stor8[arg1].field_1 % 128 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                            mem[stor8[arg1].field_1 % 128 + 64 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                            if ceil32(_5473) > _5473:
                                mem[_5473 + stor8[arg1].field_1 % 128 + 64] = 0
                            return 32, mem[stor8[arg1].field_1 % 128 + 32 len ceil32(_5473) + 32]
                        _5474 = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                        mem[stor8[arg1].field_1 % 128 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                        mem[stor8[arg1].field_1 % 128 + 64 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                        if ceil32(_5474) > _5474:
                            mem[_5474 + stor8[arg1].field_1 % 128 + 64] = 0
                        return 32, mem[stor8[arg1].field_1 % 128 + 32 len ceil32(_5474) + 32]
                    idx = 0
                    s = 0
                    while idx < stor9.length.field_1 % 128:
                        mem[idx + ceil32(stor8[arg1].field_1 % 128) + 160] = uint256(stor9[s].field_0)
                        idx = idx + 32
                        s = s + 1
                        continue 
                mem[ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 160 len ceil32(stor8[arg1].field_1 % 128)] = mem[128 len ceil32(stor8[arg1].field_1 % 128)]
                mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 160] = 32
                mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 192] = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 224 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128]) <= mem[ceil32(stor8[arg1].field_1 % 128) + 128]:
                    return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + 128], data=mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 224 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]), 
                mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 224] = 0
                return 32, mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128]) + 32], 
            if not arg1:
                mem[ceil32(stor8[arg1].field_1 % 128) + 128] = 1
                mem[ceil32(stor8[arg1].field_1 % 128) + 160] = '0'
                if bool(stor9.length):
                    if bool(stor9.length) == uint255(stor9.length) * 0.5 < 32:
                        revert with 'NH{q', 34
                    if not bool(stor9.length):
                        mem[ceil32(stor8[arg1].field_1 % 128) + 224] = Mask(248, 8, stor9.length)
                    else:
                        if bool(stor9.length) != 1:
                            mem[64] = 1
                            _5462 = mem[ceil32(stor8[arg1].field_1 % 128) + 192]
                            mem[33] = mem[ceil32(stor8[arg1].field_1 % 128) + 192]
                            mem[65 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192])] = mem[ceil32(stor8[arg1].field_1 % 128) + 224 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192])]
                            if ceil32(_5462) > _5462:
                                mem[_5462 + 65] = 0
                            return memory
                              from mem[64]
                               len ceil32(_5462) + -mem[64] + 65
                        idx = 0
                        s = 0
                        while idx < uint255(stor9.length) * 0.5:
                            mem[idx + ceil32(stor8[arg1].field_1 % 128) + 224] = uint256(stor9[s].field_0)
                            idx = idx + 32
                            s = s + 1
                            continue 
                    mem[ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 224] = '0'
                    mem[ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 225] = 32
                    mem[ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 257] = mem[ceil32(stor8[arg1].field_1 % 128) + 192]
                    mem[ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 289 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192])] = mem[ceil32(stor8[arg1].field_1 % 128) + 224 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192])]
                    if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192]) > mem[ceil32(stor8[arg1].field_1 % 128) + 192]:
                        mem[mem[ceil32(stor8[arg1].field_1 % 128) + 192] + ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 289] = 0
                    return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + 192], data=mem[ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 289 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192])]), 
                if bool(stor9.length) == stor9.length.field_1 % 128 < 32:
                    revert with 'NH{q', 34
                if not bool(stor9.length):
                    mem[ceil32(stor8[arg1].field_1 % 128) + 224] = Mask(248, 8, stor9.length)
                else:
                    if bool(stor9.length) != 1:
                        mem[64] = 1
                        _5466 = mem[ceil32(stor8[arg1].field_1 % 128) + 192]
                        mem[33] = mem[ceil32(stor8[arg1].field_1 % 128) + 192]
                        mem[65 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192])] = mem[ceil32(stor8[arg1].field_1 % 128) + 224 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192])]
                        if ceil32(_5466) > _5466:
                            mem[_5466 + 65] = 0
                        return memory
                          from mem[64]
                           len ceil32(_5466) + -mem[64] + 65
                    idx = 0
                    s = 0
                    while idx < stor9.length.field_1 % 128:
                        mem[idx + ceil32(stor8[arg1].field_1 % 128) + 224] = uint256(stor9[s].field_0)
                        idx = idx + 32
                        s = s + 1
                        continue 
                mem[ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 224] = '0'
                mem[ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 225] = 32
                mem[ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 257] = mem[ceil32(stor8[arg1].field_1 % 128) + 192]
                mem[ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 289 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192])] = mem[ceil32(stor8[arg1].field_1 % 128) + 224 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192])]
                if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192]) > mem[ceil32(stor8[arg1].field_1 % 128) + 192]:
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + 192] + ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 289] = 0
                return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + 192], data=mem[ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 289 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192])]), 
            s = 0
            idx = arg1
            while idx:
                if s == -1:
                    revert with 'NH{q', 17
                s = s + 1
                idx = idx / 10
                continue 
            if s > test266151307():
                revert with 'NH{q', 65
            mem[ceil32(stor8[arg1].field_1 % 128) + 128] = s
            if not s:
                t = s
                idx = arg1
                while idx:
                    if t < 1:
                        revert with 'NH{q', 17
                    if 48 > !(idx % 10):
                        revert with 'NH{q', 17
                    if t - 1 >= mem[ceil32(stor8[arg1].field_1 % 128) + 128]:
                        revert with 'NH{q', 50
                    mem[t + ceil32(stor8[arg1].field_1 % 128) + 159 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
                    t = t - 1
                    idx = idx / 10
                    continue 
                if bool(stor9.length):
                    if bool(stor9.length) == uint255(stor9.length) * 0.5 < 32:
                        revert with 'NH{q', 34
                    if not bool(stor9.length):
                        mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192] = Mask(248, 8, stor9.length)
                        mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                        mem[64] = mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192
                        mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192] = 32
                        mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 224] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                        mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]
                        if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]) > mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]:
                            mem[mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160] + mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256] = 0
                        return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160], data=mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]), 
                    if bool(stor9.length) == 1:
                        mem[0] = 9
                        idx = 0
                        t = 0
                        while idx < uint255(stor9.length) * 0.5:
                            mem[idx + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192] = uint256(stor9[t].field_0)
                            idx = idx + 32
                            t = t + 1
                            continue 
                        mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                        mem[64] = mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192
                        mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192] = 32
                        mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 224] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                        mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]
                        if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]) > mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]:
                            mem[mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160] + mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256] = 0
                        return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160], data=mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]), 
                    _13203 = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                    mem[0 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                    mem[64] = _13203
                    mem[_13203] = 32
                    if ceil32(_13203) <= _13203:
                        _20429 = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                        mem[_13203 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                        mem[_13203 + 64 len ceil32(_20429)] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(_20429)]
                        if ceil32(_20429) > _20429:
                            mem[_20429 + _13203 + 64] = 0
                        return 32, mem[_13203 + 32 len ceil32(_20429) + 32]
                    _20430 = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                    mem[_13203 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                    mem[_13203 + 64 len ceil32(_20430)] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(_20430)]
                    if ceil32(_20430) > _20430:
                        mem[_20430 + _13203 + 64] = 0
                    return 32, mem[_13203 + 32 len ceil32(_20430) + 32]
                if bool(stor9.length) == stor9.length.field_1 % 128 < 32:
                    revert with 'NH{q', 34
                if not bool(stor9.length):
                    mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192] = Mask(248, 8, stor9.length)
                    mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                    mem[64] = mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192] = 32
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 224] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]
                    if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]) > mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]:
                        mem[mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160] + mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256] = 0
                    return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160], data=mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]), 
                if bool(stor9.length) == 1:
                    mem[0] = 9
                    idx = 0
                    t = 0
                    while idx < stor9.length.field_1 % 128:
                        mem[idx + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192] = uint256(stor9[t].field_0)
                        idx = idx + 32
                        t = t + 1
                        continue 
                    mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                    mem[64] = mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192] = 32
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 224] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]
                    if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]) > mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]:
                        mem[mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160] + mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256] = 0
                    return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160], data=mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]), 
                _13331 = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                mem[0 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                mem[64] = _13331
                mem[_13331] = 32
                if ceil32(_13331) <= _13331:
                    _20433 = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                    mem[_13331 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                    mem[_13331 + 64 len ceil32(_20433)] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(_20433)]
                    if ceil32(_20433) > _20433:
                        mem[_20433 + _13331 + 64] = 0
                    return 32, mem[_13331 + 32 len ceil32(_20433) + 32]
                _20434 = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                mem[_13331 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                mem[_13331 + 64 len ceil32(_20434)] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(_20434)]
                if ceil32(_20434) > _20434:
                    mem[_20434 + _13331 + 64] = 0
                return 32, mem[_13331 + 32 len ceil32(_20434) + 32]
            mem[ceil32(stor8[arg1].field_1 % 128) + 160 len s] = call.data[calldata.size len s]
            t = s
            idx = arg1
            while idx:
                if t < 1:
                    revert with 'NH{q', 17
                if 48 > !(idx % 10):
                    revert with 'NH{q', 17
                if t - 1 >= mem[ceil32(stor8[arg1].field_1 % 128) + 128]:
                    revert with 'NH{q', 50
                mem[t + ceil32(stor8[arg1].field_1 % 128) + 159 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
                t = t - 1
                idx = idx / 10
                continue 
            if bool(stor9.length):
                if bool(stor9.length) == uint255(stor9.length) * 0.5 < 32:
                    revert with 'NH{q', 34
                if not bool(stor9.length):
                    mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192] = Mask(248, 8, stor9.length)
                    mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                    mem[64] = mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192] = 32
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 224] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]
                    if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]) > mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]:
                        mem[mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160] + mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256] = 0
                    return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160], data=mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]), 
                if bool(stor9.length) == 1:
                    mem[0] = 9
                    idx = 0
                    t = 0
                    while idx < uint255(stor9.length) * 0.5:
                        mem[idx + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192] = uint256(stor9[t].field_0)
                        idx = idx + 32
                        t = t + 1
                        continue 
                    mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                    mem[64] = mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192] = 32
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 224] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]
                    if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]) > mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]:
                        mem[mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160] + mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256] = 0
                    return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160], data=mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]), 
                _13205 = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                mem[0 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                mem[64] = _13205
                mem[_13205] = 32
                if ceil32(_13205) <= _13205:
                    _20437 = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                    mem[_13205 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                    mem[_13205 + 64 len ceil32(_20437)] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(_20437)]
                    if ceil32(_20437) > _20437:
                        mem[_20437 + _13205 + 64] = 0
                    return 32, mem[_13205 + 32 len ceil32(_20437) + 32]
                _20438 = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                mem[_13205 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                mem[_13205 + 64 len ceil32(_20438)] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(_20438)]
                if ceil32(_20438) > _20438:
                    mem[_20438 + _13205 + 64] = 0
                return 32, mem[_13205 + 32 len ceil32(_20438) + 32]
            if bool(stor9.length) == stor9.length.field_1 % 128 < 32:
                revert with 'NH{q', 34
            if not bool(stor9.length):
                mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192] = Mask(248, 8, stor9.length)
                mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                mem[64] = mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192
                mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192] = 32
                mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 224] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]
                if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]) > mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]:
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160] + mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256] = 0
                return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160], data=mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]), 
            if bool(stor9.length) == 1:
                mem[0] = 9
                idx = 0
                t = 0
                while idx < stor9.length.field_1 % 128:
                    mem[idx + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192] = uint256(stor9[t].field_0)
                    idx = idx + 32
                    t = t + 1
                    continue 
                mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                mem[64] = mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192
                mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192] = 32
                mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 224] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]
                if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]) > mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]:
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160] + mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256] = 0
                return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160], data=mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]), 
            _13333 = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
            mem[0 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
            mem[64] = _13333
            mem[_13333] = 32
            if ceil32(_13333) <= _13333:
                _20441 = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                mem[_13333 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                mem[_13333 + 64 len ceil32(_20441)] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(_20441)]
                if ceil32(_20441) > _20441:
                    mem[_20441 + _13333 + 64] = 0
                return 32, mem[_13333 + 32 len ceil32(_20441) + 32]
            _20442 = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
            mem[_13333 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
            mem[_13333 + 64 len ceil32(_20442)] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(_20442)]
            if ceil32(_20442) > _20442:
                mem[_20442 + _13333 + 64] = 0
            return 32, mem[_13333 + 32 len ceil32(_20442) + 32]
        if bool(stor9.length) == stor9.length.field_1 % 128 < 32:
            revert with 'NH{q', 34
        if not stor9.length.field_1 % 128:
            mem[ceil32(stor8[arg1].field_1 % 128) + 192 len ceil32(stor8[arg1].field_1 % 128)] = mem[128 len ceil32(stor8[arg1].field_1 % 128)]
            if ceil32(stor8[arg1].field_1 % 128) > stor8[arg1].field_1 % 128:
                mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + 192] = 0
            return Array(len=stor8[arg1].field_0 % 128, data=mem[128 len ceil32(stor8[arg1].field_1 % 128)], mem[(2 * ceil32(stor8[arg1].field_1 % 128)) + 192 len 2 * ceil32(stor8[arg1].field_1 % 128)]), 
        if stor8[arg1].field_1 % 128:
            if bool(stor9.length):
                if bool(stor9.length) == uint255(stor9.length) * 0.5 < 32:
                    revert with 'NH{q', 34
                if not bool(stor9.length):
                    mem[ceil32(stor8[arg1].field_1 % 128) + 160] = Mask(248, 8, stor9.length)
                else:
                    if bool(stor9.length) != 1:
                        mem[64] = stor8[arg1].field_1 % 128
                        if ceil32(stor8[arg1].field_1 % 128) <= stor8[arg1].field_1 % 128:
                            _5485 = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                            mem[stor8[arg1].field_1 % 128 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                            mem[stor8[arg1].field_1 % 128 + 64 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                            if ceil32(_5485) > _5485:
                                mem[_5485 + stor8[arg1].field_1 % 128 + 64] = 0
                            return 32, mem[stor8[arg1].field_1 % 128 + 32 len ceil32(_5485) + 32]
                        _5486 = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                        mem[stor8[arg1].field_1 % 128 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                        mem[stor8[arg1].field_1 % 128 + 64 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                        if ceil32(_5486) > _5486:
                            mem[_5486 + stor8[arg1].field_1 % 128 + 64] = 0
                        return 32, mem[stor8[arg1].field_1 % 128 + 32 len ceil32(_5486) + 32]
                    idx = 0
                    s = 0
                    while idx < uint255(stor9.length) * 0.5:
                        mem[idx + ceil32(stor8[arg1].field_1 % 128) + 160] = uint256(stor9[s].field_0)
                        idx = idx + 32
                        s = s + 1
                        continue 
                mem[ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 160 len ceil32(stor8[arg1].field_1 % 128)] = mem[128 len ceil32(stor8[arg1].field_1 % 128)]
                mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 160] = 32
                mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 192] = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 224 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128]) <= mem[ceil32(stor8[arg1].field_1 % 128) + 128]:
                    return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + 128], data=mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 224 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]), 
                mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 224] = 0
                return 32, mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128]) + 32], 
            if bool(stor9.length) == stor9.length.field_1 % 128 < 32:
                revert with 'NH{q', 34
            if not bool(stor9.length):
                mem[ceil32(stor8[arg1].field_1 % 128) + 160] = Mask(248, 8, stor9.length)
            else:
                if bool(stor9.length) != 1:
                    mem[64] = stor8[arg1].field_1 % 128
                    if ceil32(stor8[arg1].field_1 % 128) <= stor8[arg1].field_1 % 128:
                        _5489 = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                        mem[stor8[arg1].field_1 % 128 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                        mem[stor8[arg1].field_1 % 128 + 64 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                        if ceil32(_5489) > _5489:
                            mem[_5489 + stor8[arg1].field_1 % 128 + 64] = 0
                        return 32, mem[stor8[arg1].field_1 % 128 + 32 len ceil32(_5489) + 32]
                    _5490 = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                    mem[stor8[arg1].field_1 % 128 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                    mem[stor8[arg1].field_1 % 128 + 64 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                    if ceil32(_5490) > _5490:
                        mem[_5490 + stor8[arg1].field_1 % 128 + 64] = 0
                    return 32, mem[stor8[arg1].field_1 % 128 + 32 len ceil32(_5490) + 32]
                idx = 0
                s = 0
                while idx < stor9.length.field_1 % 128:
                    mem[idx + ceil32(stor8[arg1].field_1 % 128) + 160] = uint256(stor9[s].field_0)
                    idx = idx + 32
                    s = s + 1
                    continue 
            mem[ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 160 len ceil32(stor8[arg1].field_1 % 128)] = mem[128 len ceil32(stor8[arg1].field_1 % 128)]
            mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 160] = 32
            mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 192] = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
            mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 224 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
            if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128]) <= mem[ceil32(stor8[arg1].field_1 % 128) + 128]:
                return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + 128], data=mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 224 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]), 
            mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 224] = 0
            return 32, mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128]) + 32], 
        if not arg1:
            mem[ceil32(stor8[arg1].field_1 % 128) + 128] = 1
            mem[ceil32(stor8[arg1].field_1 % 128) + 160] = '0'
            if bool(stor9.length):
                if bool(stor9.length) == uint255(stor9.length) * 0.5 < 32:
                    revert with 'NH{q', 34
                if not bool(stor9.length):
                    mem[ceil32(stor8[arg1].field_1 % 128) + 224] = Mask(248, 8, stor9.length)
                else:
                    if bool(stor9.length) != 1:
                        mem[64] = 1
                        _5478 = mem[ceil32(stor8[arg1].field_1 % 128) + 192]
                        mem[33] = mem[ceil32(stor8[arg1].field_1 % 128) + 192]
                        mem[65 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192])] = mem[ceil32(stor8[arg1].field_1 % 128) + 224 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192])]
                        if ceil32(_5478) > _5478:
                            mem[_5478 + 65] = 0
                        return memory
                          from mem[64]
                           len ceil32(_5478) + -mem[64] + 65
                    idx = 0
                    s = 0
                    while idx < uint255(stor9.length) * 0.5:
                        mem[idx + ceil32(stor8[arg1].field_1 % 128) + 224] = uint256(stor9[s].field_0)
                        idx = idx + 32
                        s = s + 1
                        continue 
                mem[ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 224] = '0'
                mem[ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 225] = 32
                mem[ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 257] = mem[ceil32(stor8[arg1].field_1 % 128) + 192]
                mem[ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 289 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192])] = mem[ceil32(stor8[arg1].field_1 % 128) + 224 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192])]
                if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192]) > mem[ceil32(stor8[arg1].field_1 % 128) + 192]:
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + 192] + ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 289] = 0
                return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + 192], data=mem[ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 289 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192])]), 
            if bool(stor9.length) == stor9.length.field_1 % 128 < 32:
                revert with 'NH{q', 34
            if not bool(stor9.length):
                mem[ceil32(stor8[arg1].field_1 % 128) + 224] = Mask(248, 8, stor9.length)
            else:
                if bool(stor9.length) != 1:
                    mem[64] = 1
                    _5482 = mem[ceil32(stor8[arg1].field_1 % 128) + 192]
                    mem[33] = mem[ceil32(stor8[arg1].field_1 % 128) + 192]
                    mem[65 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192])] = mem[ceil32(stor8[arg1].field_1 % 128) + 224 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192])]
                    if ceil32(_5482) > _5482:
                        mem[_5482 + 65] = 0
                    return memory
                      from mem[64]
                       len ceil32(_5482) + -mem[64] + 65
                idx = 0
                s = 0
                while idx < stor9.length.field_1 % 128:
                    mem[idx + ceil32(stor8[arg1].field_1 % 128) + 224] = uint256(stor9[s].field_0)
                    idx = idx + 32
                    s = s + 1
                    continue 
            mem[ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 224] = '0'
            mem[ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 225] = 32
            mem[ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 257] = mem[ceil32(stor8[arg1].field_1 % 128) + 192]
            mem[ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 289 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192])] = mem[ceil32(stor8[arg1].field_1 % 128) + 224 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192])]
            if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192]) > mem[ceil32(stor8[arg1].field_1 % 128) + 192]:
                mem[mem[ceil32(stor8[arg1].field_1 % 128) + 192] + ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 289] = 0
            return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + 192], data=mem[ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 289 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192])]), 
        s = 0
        idx = arg1
        while idx:
            if s == -1:
                revert with 'NH{q', 17
            s = s + 1
            idx = idx / 10
            continue 
        if s > test266151307():
            revert with 'NH{q', 65
        mem[ceil32(stor8[arg1].field_1 % 128) + 128] = s
        if not s:
            t = s
            idx = arg1
            while idx:
                if t < 1:
                    revert with 'NH{q', 17
                if 48 > !(idx % 10):
                    revert with 'NH{q', 17
                if t - 1 >= mem[ceil32(stor8[arg1].field_1 % 128) + 128]:
                    revert with 'NH{q', 50
                mem[t + ceil32(stor8[arg1].field_1 % 128) + 159 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
                t = t - 1
                idx = idx / 10
                continue 
            if bool(stor9.length):
                if bool(stor9.length) == uint255(stor9.length) * 0.5 < 32:
                    revert with 'NH{q', 34
                if not bool(stor9.length):
                    mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192] = Mask(248, 8, stor9.length)
                    mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                    mem[64] = mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192] = 32
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 224] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]
                    if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]) > mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]:
                        mem[mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160] + mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256] = 0
                    return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160], data=mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]), 
                if bool(stor9.length) == 1:
                    mem[0] = 9
                    idx = 0
                    t = 0
                    while idx < uint255(stor9.length) * 0.5:
                        mem[idx + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192] = uint256(stor9[t].field_0)
                        idx = idx + 32
                        t = t + 1
                        continue 
                    mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                    mem[64] = mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192] = 32
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 224] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]
                    if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]) > mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]:
                        mem[mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160] + mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256] = 0
                    return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160], data=mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]), 
                _13207 = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                mem[0 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                mem[64] = _13207
                mem[_13207] = 32
                if ceil32(_13207) <= _13207:
                    _20445 = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                    mem[_13207 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                    mem[_13207 + 64 len ceil32(_20445)] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(_20445)]
                    if ceil32(_20445) > _20445:
                        mem[_20445 + _13207 + 64] = 0
                    return 32, mem[_13207 + 32 len ceil32(_20445) + 32]
                _20446 = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                mem[_13207 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                mem[_13207 + 64 len ceil32(_20446)] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(_20446)]
                if ceil32(_20446) > _20446:
                    mem[_20446 + _13207 + 64] = 0
                return 32, mem[_13207 + 32 len ceil32(_20446) + 32]
            if bool(stor9.length) == stor9.length.field_1 % 128 < 32:
                revert with 'NH{q', 34
            if not bool(stor9.length):
                mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192] = Mask(248, 8, stor9.length)
                mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                mem[64] = mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192
                mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192] = 32
                mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 224] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]
                if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]) > mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]:
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160] + mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256] = 0
                return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160], data=mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]), 
            if bool(stor9.length) == 1:
                mem[0] = 9
                idx = 0
                t = 0
                while idx < stor9.length.field_1 % 128:
                    mem[idx + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192] = uint256(stor9[t].field_0)
                    idx = idx + 32
                    t = t + 1
                    continue 
                mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                mem[64] = mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192
                mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192] = 32
                mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 224] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]
                if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]) > mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]:
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160] + mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256] = 0
                return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160], data=mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]), 
            _13335 = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
            mem[0 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
            mem[64] = _13335
            mem[_13335] = 32
            if ceil32(_13335) <= _13335:
                _20449 = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                mem[_13335 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                mem[_13335 + 64 len ceil32(_20449)] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(_20449)]
                if ceil32(_20449) > _20449:
                    mem[_20449 + _13335 + 64] = 0
                return 32, mem[_13335 + 32 len ceil32(_20449) + 32]
            _20450 = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
            mem[_13335 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
            mem[_13335 + 64 len ceil32(_20450)] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(_20450)]
            if ceil32(_20450) > _20450:
                mem[_20450 + _13335 + 64] = 0
            return 32, mem[_13335 + 32 len ceil32(_20450) + 32]
        mem[ceil32(stor8[arg1].field_1 % 128) + 160 len s] = call.data[calldata.size len s]
        t = s
        idx = arg1
        while idx:
            if t < 1:
                revert with 'NH{q', 17
            if 48 > !(idx % 10):
                revert with 'NH{q', 17
            if t - 1 >= mem[ceil32(stor8[arg1].field_1 % 128) + 128]:
                revert with 'NH{q', 50
            mem[t + ceil32(stor8[arg1].field_1 % 128) + 159 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
            t = t - 1
            idx = idx / 10
            continue 
        if bool(stor9.length):
            if bool(stor9.length) == uint255(stor9.length) * 0.5 < 32:
                revert with 'NH{q', 34
            if not bool(stor9.length):
                mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192] = Mask(248, 8, stor9.length)
                mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                mem[64] = mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192
                mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192] = 32
                mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 224] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]
                if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]) > mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]:
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160] + mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256] = 0
                return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160], data=mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]), 
            if bool(stor9.length) == 1:
                mem[0] = 9
                idx = 0
                t = 0
                while idx < uint255(stor9.length) * 0.5:
                    mem[idx + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192] = uint256(stor9[t].field_0)
                    idx = idx + 32
                    t = t + 1
                    continue 
                mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                mem[64] = mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192
                mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192] = 32
                mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 224] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]
                if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]) > mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]:
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160] + mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256] = 0
                return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160], data=mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]), 
            _13209 = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
            mem[0 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
            mem[64] = _13209
            mem[_13209] = 32
            if ceil32(_13209) <= _13209:
                _20453 = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                mem[_13209 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                mem[_13209 + 64 len ceil32(_20453)] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(_20453)]
                if ceil32(_20453) > _20453:
                    mem[_20453 + _13209 + 64] = 0
                return 32, mem[_13209 + 32 len ceil32(_20453) + 32]
            _20454 = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
            mem[_13209 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
            mem[_13209 + 64 len ceil32(_20454)] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(_20454)]
            if ceil32(_20454) > _20454:
                mem[_20454 + _13209 + 64] = 0
            return 32, mem[_13209 + 32 len ceil32(_20454) + 32]
        if bool(stor9.length) == stor9.length.field_1 % 128 < 32:
            revert with 'NH{q', 34
        if not bool(stor9.length):
            mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192] = Mask(248, 8, stor9.length)
            mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
            mem[64] = mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192
            mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192] = 32
            mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 224] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
            mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]
            if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]) > mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]:
                mem[mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160] + mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256] = 0
            return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160], data=mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]), 
        if bool(stor9.length) == 1:
            mem[0] = 9
            idx = 0
            t = 0
            while idx < stor9.length.field_1 % 128:
                mem[idx + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192] = uint256(stor9[t].field_0)
                idx = idx + 32
                t = t + 1
                continue 
            mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
            mem[64] = mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192
            mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192] = 32
            mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 224] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
            mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]
            if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]) > mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]:
                mem[mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160] + mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256] = 0
            return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160], data=mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]), 
        _13337 = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
        mem[0 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
        mem[64] = _13337
        mem[_13337] = 32
        if ceil32(_13337) <= _13337:
            _20457 = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
            mem[_13337 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
            mem[_13337 + 64 len ceil32(_20457)] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(_20457)]
            if ceil32(_20457) > _20457:
                mem[_20457 + _13337 + 64] = 0
            return 32, mem[_13337 + 32 len ceil32(_20457) + 32]
        _20458 = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
        mem[_13337 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
        mem[_13337 + 64 len ceil32(_20458)] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(_20458)]
        if ceil32(_20458) > _20458:
            mem[_20458 + _13337 + 64] = 0
        return 32, mem[_13337 + 32 len ceil32(_20458) + 32]
    mem[0] = sha3(arg1, 8)
    mem[128] = uint256(stor8[arg1].field_0)
    idx = 128
    s = 0
    while stor8[arg1].field_1 % 128 + 96 > idx:
        mem[idx + 32] = uint256(stor8[arg1][s].field_256)
        idx = idx + 32
        s = s + 1
        continue 
    if bool(stor9.length):
        if bool(stor9.length) == uint255(stor9.length) * 0.5 < 32:
            revert with 'NH{q', 34
        if not uint255(stor9.length) * 0.5:
            return Array(len=stor8[arg1].field_0 % 128, data=mem[128 len ceil32(stor8[arg1].field_1 % 128)])
        if stor8[arg1].field_1 % 128:
            if bool(stor9.length):
                if bool(stor9.length) == uint255(stor9.length) * 0.5 < 32:
                    revert with 'NH{q', 34
                if not bool(stor9.length):
                    mem[ceil32(stor8[arg1].field_1 % 128) + 160] = Mask(248, 8, stor9.length)
                    mem[ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 160 len ceil32(stor8[arg1].field_1 % 128)] = mem[128 len ceil32(stor8[arg1].field_1 % 128)]
                    var50001 = ceil32(stor8[arg1].field_1 % 128)
                    mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 160] = 32
                    mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 192] = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                    mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 224 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                    var61001 = ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])
                    if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128]) <= mem[ceil32(stor8[arg1].field_1 % 128) + 128]:
                        return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + 128], data=mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 224 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]), 
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 224] = 0
                    return 32, mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128]) + 32], 
                if bool(stor9.length) == 1:
                    idx = 0
                    s = 0
                    while idx < uint255(stor9.length) * 0.5:
                        mem[idx + ceil32(stor8[arg1].field_1 % 128) + 160] = uint256(stor9[s].field_0)
                        idx = idx + 32
                        s = s + 1
                        continue 
                    mem[ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 160 len ceil32(stor8[arg1].field_1 % 128)] = mem[128 len ceil32(stor8[arg1].field_1 % 128)]
                    mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 160] = 32
                    mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 192] = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                    mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 224 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                    if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128]) <= mem[ceil32(stor8[arg1].field_1 % 128) + 128]:
                        return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + 128], data=mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 224 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]), 
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 224] = 0
                    return 32, mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128]) + 32], 
                var51001 = ceil32(stor8[arg1].field_1 % 128)
                mem[64] = stor8[arg1].field_1 % 128
                if ceil32(stor8[arg1].field_1 % 128) <= stor8[arg1].field_1 % 128:
                    _13101 = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                    mem[stor8[arg1].field_1 % 128 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                    mem[stor8[arg1].field_1 % 128 + 64 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                    var62001 = ceil32(_13101)
                    if ceil32(_13101) > _13101:
                        mem[_13101 + stor8[arg1].field_1 % 128 + 64] = 0
                    return 32, mem[stor8[arg1].field_1 % 128 + 32 len ceil32(_13101) + 32]
                _13102 = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                mem[stor8[arg1].field_1 % 128 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                mem[stor8[arg1].field_1 % 128 + 64 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                var62001 = ceil32(_13102)
                if ceil32(_13102) > _13102:
                    mem[_13102 + stor8[arg1].field_1 % 128 + 64] = 0
                return 32, mem[stor8[arg1].field_1 % 128 + 32 len ceil32(_13102) + 32]
            if bool(stor9.length) == stor9.length.field_1 % 128 < 32:
                revert with 'NH{q', 34
            if bool(stor9.length):
                if bool(stor9.length) == 1:
                    idx = 0
                    s = 0
                    while idx < stor9.length.field_1 % 128:
                        mem[idx + ceil32(stor8[arg1].field_1 % 128) + 160] = uint256(stor9[s].field_0)
                        idx = idx + 32
                        s = s + 1
                        continue 
                    mem[ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 160 len ceil32(stor8[arg1].field_1 % 128)] = mem[128 len ceil32(stor8[arg1].field_1 % 128)]
                    mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 160] = 32
                    mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 192] = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                    mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 224 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                    if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128]) <= mem[ceil32(stor8[arg1].field_1 % 128) + 128]:
                        return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + 128], data=mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 224 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]), 
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 224] = 0
                    return 32, mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128]) + 32], 
                var52001 = ceil32(stor8[arg1].field_1 % 128)
                mem[64] = stor8[arg1].field_1 % 128
                if ceil32(stor8[arg1].field_1 % 128) <= stor8[arg1].field_1 % 128:
                    _13105 = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                    mem[stor8[arg1].field_1 % 128 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                    mem[stor8[arg1].field_1 % 128 + 64 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                    if ceil32(_13105) > _13105:
                        mem[_13105 + stor8[arg1].field_1 % 128 + 64] = 0
                    return 32, mem[stor8[arg1].field_1 % 128 + 32 len ceil32(_13105) + 32]
                _13106 = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                mem[stor8[arg1].field_1 % 128 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                mem[stor8[arg1].field_1 % 128 + 64 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                if ceil32(_13106) > _13106:
                    mem[_13106 + stor8[arg1].field_1 % 128 + 64] = 0
                return 32, mem[stor8[arg1].field_1 % 128 + 32 len ceil32(_13106) + 32]
            mem[ceil32(stor8[arg1].field_1 % 128) + 160] = Mask(248, 8, stor9.length)
            mem[ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 160 len ceil32(stor8[arg1].field_1 % 128)] = mem[128 len ceil32(stor8[arg1].field_1 % 128)]
            var51001 = ceil32(stor8[arg1].field_1 % 128)
            mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 160] = 32
            mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 192] = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
            mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 224 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
            var62001 = ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])
            if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128]) <= mem[ceil32(stor8[arg1].field_1 % 128) + 128]:
                return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + 128], data=mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 224 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]), 
            mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 224] = 0
            return 32, mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128]) + 32], 
        if not arg1:
            mem[ceil32(stor8[arg1].field_1 % 128) + 128] = 1
            mem[ceil32(stor8[arg1].field_1 % 128) + 160] = '0'
            if bool(stor9.length):
                if bool(stor9.length) == uint255(stor9.length) * 0.5 < 32:
                    revert with 'NH{q', 34
                if not bool(stor9.length):
                    mem[ceil32(stor8[arg1].field_1 % 128) + 224] = Mask(248, 8, stor9.length)
                    mem[ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 224] = '0'
                    var53001 = 32
                else:
                    if bool(stor9.length) != 1:
                        mem[64] = 1
                        _13094 = mem[ceil32(stor8[arg1].field_1 % 128) + 192]
                        mem[33] = mem[ceil32(stor8[arg1].field_1 % 128) + 192]
                        mem[65 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192])] = mem[ceil32(stor8[arg1].field_1 % 128) + 224 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192])]
                        if ceil32(_13094) > _13094:
                            mem[_13094 + 65] = 0
                        return memory
                          from mem[64]
                           len ceil32(_13094) + -mem[64] + 65
                    idx = 0
                    s = 0
                    while idx < uint255(stor9.length) * 0.5:
                        mem[idx + ceil32(stor8[arg1].field_1 % 128) + 224] = uint256(stor9[s].field_0)
                        idx = idx + 32
                        s = s + 1
                        continue 
                    mem[ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 224] = '0'
                mem[ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 225] = 32
                mem[ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 257] = mem[ceil32(stor8[arg1].field_1 % 128) + 192]
                mem[ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 289 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192])] = mem[ceil32(stor8[arg1].field_1 % 128) + 224 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192])]
                if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192]) > mem[ceil32(stor8[arg1].field_1 % 128) + 192]:
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + 192] + ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 289] = 0
                return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + 192], data=mem[ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 289 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192])]), 
            if bool(stor9.length) == stor9.length.field_1 % 128 < 32:
                revert with 'NH{q', 34
            if not bool(stor9.length):
                mem[ceil32(stor8[arg1].field_1 % 128) + 224] = Mask(248, 8, stor9.length)
            else:
                if bool(stor9.length) != 1:
                    mem[64] = 1
                    _13098 = mem[ceil32(stor8[arg1].field_1 % 128) + 192]
                    mem[33] = mem[ceil32(stor8[arg1].field_1 % 128) + 192]
                    mem[65 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192])] = mem[ceil32(stor8[arg1].field_1 % 128) + 224 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192])]
                    if ceil32(_13098) > _13098:
                        mem[_13098 + 65] = 0
                    return memory
                      from mem[64]
                       len ceil32(_13098) + -mem[64] + 65
                idx = 0
                s = 0
                while idx < stor9.length.field_1 % 128:
                    mem[idx + ceil32(stor8[arg1].field_1 % 128) + 224] = uint256(stor9[s].field_0)
                    idx = idx + 32
                    s = s + 1
                    continue 
            mem[ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 224] = '0'
            mem[ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 225] = 32
            mem[ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 257] = mem[ceil32(stor8[arg1].field_1 % 128) + 192]
            mem[ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 289 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192])] = mem[ceil32(stor8[arg1].field_1 % 128) + 224 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192])]
            if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192]) > mem[ceil32(stor8[arg1].field_1 % 128) + 192]:
                mem[mem[ceil32(stor8[arg1].field_1 % 128) + 192] + ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 289] = 0
            return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + 192], data=mem[ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 289 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192])]), 
        s = 0
        idx = arg1
        while idx:
            if s == -1:
                revert with 'NH{q', 17
            s = s + 1
            idx = idx / 10
            continue 
        if s > test266151307():
            revert with 'NH{q', 65
        mem[ceil32(stor8[arg1].field_1 % 128) + 128] = s
        if not s:
            t = s
            idx = arg1
            while idx:
                if t < 1:
                    revert with 'NH{q', 17
                if 48 > !(idx % 10):
                    revert with 'NH{q', 17
                if t - 1 >= mem[ceil32(stor8[arg1].field_1 % 128) + 128]:
                    revert with 'NH{q', 50
                mem[t + ceil32(stor8[arg1].field_1 % 128) + 159 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
                t = t - 1
                idx = idx / 10
                continue 
            if not bool(stor9.length):
                if bool(stor9.length) == stor9.length.field_1 % 128 < 32:
                    revert with 'NH{q', 34
                if not bool(stor9.length):
                    mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192] = Mask(248, 8, stor9.length)
                    mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                    var62001 = ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])
                    mem[64] = mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192] = 32
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 224] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]
                    if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]) > mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]:
                        mem[mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160] + mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256] = 0
                    return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160], data=mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]), 
                if bool(stor9.length) == 1:
                    mem[0] = 9
                    idx = 0
                    t = 0
                    while idx < stor9.length.field_1 % 128:
                        mem[idx + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192] = uint256(stor9[t].field_0)
                        idx = idx + 32
                        t = t + 1
                        continue 
                    mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                    mem[64] = mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192] = 32
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 224] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]
                    if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]) > mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]:
                        mem[mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160] + mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256] = 0
                    return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160], data=mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]), 
                _20627 = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                mem[0 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                mem[64] = _20627
                mem[_20627] = 32
                if ceil32(_20627) <= _20627:
                    _25409 = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                    mem[_20627 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                    mem[_20627 + 64 len ceil32(_25409)] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(_25409)]
                    if ceil32(_25409) > _25409:
                        mem[_25409 + _20627 + 64] = 0
                    return 32, mem[_20627 + 32 len ceil32(_25409) + 32]
                _25410 = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                mem[_20627 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                mem[_20627 + 64 len ceil32(_25410)] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(_25410)]
                if ceil32(_25410) > _25410:
                    mem[_25410 + _20627 + 64] = 0
                return 32, mem[_20627 + 32 len ceil32(_25410) + 32]
            if bool(stor9.length) == uint255(stor9.length) * 0.5 < 32:
                revert with 'NH{q', 34
            if not bool(stor9.length):
                mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192] = Mask(248, 8, stor9.length)
                mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                var61001 = ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])
                mem[64] = mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192
                mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192] = 32
                mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 224] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]
                if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]) > mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]:
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160] + mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256] = 0
                return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160], data=mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]), 
            if bool(stor9.length) == 1:
                mem[0] = 9
                idx = 0
                t = 0
                while idx < uint255(stor9.length) * 0.5:
                    mem[idx + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192] = uint256(stor9[t].field_0)
                    idx = idx + 32
                    t = t + 1
                    continue 
                mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                mem[64] = mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192
                mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192] = 32
                mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 224] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]
                if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]) > mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]:
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160] + mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256] = 0
                return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160], data=mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]), 
            _20483 = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
            mem[0 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
            var62001 = ceil32(_20483)
            mem[64] = _20483
            mem[_20483] = 32
            if ceil32(_20483) <= _20483:
                _25405 = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                mem[_20483 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                mem[_20483 + 64 len ceil32(_25405)] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(_25405)]
                if ceil32(_25405) > _25405:
                    mem[_25405 + _20483 + 64] = 0
                return 32, mem[_20483 + 32 len ceil32(_25405) + 32]
            _25406 = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
            mem[_20483 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
            mem[_20483 + 64 len ceil32(_25406)] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(_25406)]
            if ceil32(_25406) > _25406:
                mem[_25406 + _20483 + 64] = 0
            return 32, mem[_20483 + 32 len ceil32(_25406) + 32]
        mem[ceil32(stor8[arg1].field_1 % 128) + 160 len s] = call.data[calldata.size len s]
        t = s
        idx = arg1
        while idx:
            if t < 1:
                revert with 'NH{q', 17
            if 48 > !(idx % 10):
                revert with 'NH{q', 17
            if t - 1 >= mem[ceil32(stor8[arg1].field_1 % 128) + 128]:
                revert with 'NH{q', 50
            mem[t + ceil32(stor8[arg1].field_1 % 128) + 159 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
            t = t - 1
            idx = idx / 10
            continue 
        if bool(stor9.length):
            if bool(stor9.length) == uint255(stor9.length) * 0.5 < 32:
                revert with 'NH{q', 34
            if not bool(stor9.length):
                mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192] = Mask(248, 8, stor9.length)
                mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                var62001 = ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])
                mem[64] = mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192
                mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192] = 32
                mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 224] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]
                if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]) > mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]:
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160] + mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256] = 0
                return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160], data=mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]), 
            if bool(stor9.length) == 1:
                mem[0] = 9
                idx = 0
                t = 0
                while idx < uint255(stor9.length) * 0.5:
                    mem[idx + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192] = uint256(stor9[t].field_0)
                    idx = idx + 32
                    t = t + 1
                    continue 
                mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                mem[64] = mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192
                mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192] = 32
                mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 224] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]
                if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]) > mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]:
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160] + mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256] = 0
                return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160], data=mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]), 
            _20485 = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
            mem[0 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
            mem[64] = _20485
            mem[_20485] = 32
            if ceil32(_20485) <= _20485:
                _25413 = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                mem[_20485 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                mem[_20485 + 64 len ceil32(_25413)] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(_25413)]
                if ceil32(_25413) > _25413:
                    mem[_25413 + _20485 + 64] = 0
                return 32, mem[_20485 + 32 len ceil32(_25413) + 32]
            _25414 = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
            mem[_20485 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
            mem[_20485 + 64 len ceil32(_25414)] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(_25414)]
            if ceil32(_25414) > _25414:
                mem[_25414 + _20485 + 64] = 0
            return 32, mem[_20485 + 32 len ceil32(_25414) + 32]
        if bool(stor9.length) == stor9.length.field_1 % 128 < 32:
            revert with 'NH{q', 34
        if not bool(stor9.length):
            mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192] = Mask(248, 8, stor9.length)
            mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
            mem[64] = mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192
            mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192] = 32
            mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 224] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
            mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]
            if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]) > mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]:
                mem[mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160] + mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256] = 0
            return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160], data=mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]), 
        if bool(stor9.length) == 1:
            mem[0] = 9
            idx = 0
            t = 0
            while idx < stor9.length.field_1 % 128:
                mem[idx + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192] = uint256(stor9[t].field_0)
                idx = idx + 32
                t = t + 1
                continue 
            mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
            mem[64] = mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192
            mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192] = 32
            mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 224] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
            mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]
            if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]) > mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]:
                mem[mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160] + mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256] = 0
            return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160], data=mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]), 
        _20629 = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
        mem[0 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
        mem[64] = _20629
        mem[_20629] = 32
        if ceil32(_20629) <= _20629:
            _25417 = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
            mem[_20629 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
            mem[_20629 + 64 len ceil32(_25417)] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(_25417)]
            if ceil32(_25417) > _25417:
                mem[_25417 + _20629 + 64] = 0
            return 32, mem[_20629 + 32 len ceil32(_25417) + 32]
        _25418 = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
        mem[_20629 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
        mem[_20629 + 64 len ceil32(_25418)] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(_25418)]
        if ceil32(_25418) > _25418:
            mem[_25418 + _20629 + 64] = 0
        return 32, mem[_20629 + 32 len ceil32(_25418) + 32]
    if bool(stor9.length) == stor9.length.field_1 % 128 < 32:
        revert with 'NH{q', 34
    if not stor9.length.field_1 % 128:
        return Array(len=stor8[arg1].field_0 % 128, data=mem[128 len ceil32(stor8[arg1].field_1 % 128)])
    if stor8[arg1].field_1 % 128:
        if not bool(stor9.length):
            if bool(stor9.length) == stor9.length.field_1 % 128 < 32:
                revert with 'NH{q', 34
            if not bool(stor9.length):
                mem[ceil32(stor8[arg1].field_1 % 128) + 160] = Mask(248, 8, stor9.length)
                mem[ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 160 len ceil32(stor8[arg1].field_1 % 128)] = mem[128 len ceil32(stor8[arg1].field_1 % 128)]
                var52001 = ceil32(stor8[arg1].field_1 % 128)
                mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 160] = 32
                mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 192] = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 224 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128]) <= mem[ceil32(stor8[arg1].field_1 % 128) + 128]:
                    return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + 128], data=mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 224 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]), 
                mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 224] = 0
                return 32, mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128]) + 32], 
            if bool(stor9.length) == 1:
                idx = 0
                s = 0
                while idx < stor9.length.field_1 % 128:
                    mem[idx + ceil32(stor8[arg1].field_1 % 128) + 160] = uint256(stor9[s].field_0)
                    idx = idx + 32
                    s = s + 1
                    continue 
                mem[ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 160 len ceil32(stor8[arg1].field_1 % 128)] = mem[128 len ceil32(stor8[arg1].field_1 % 128)]
                mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 160] = 32
                mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 192] = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 224 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128]) <= mem[ceil32(stor8[arg1].field_1 % 128) + 128]:
                    return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + 128], data=mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 224 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]), 
                mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 224] = 0
                return 32, mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128]) + 32], 
            var53001 = ceil32(stor8[arg1].field_1 % 128)
            mem[64] = stor8[arg1].field_1 % 128
            if ceil32(stor8[arg1].field_1 % 128) <= stor8[arg1].field_1 % 128:
                _13121 = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                mem[stor8[arg1].field_1 % 128 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                mem[stor8[arg1].field_1 % 128 + 64 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                if ceil32(_13121) > _13121:
                    mem[_13121 + stor8[arg1].field_1 % 128 + 64] = 0
                return 32, mem[stor8[arg1].field_1 % 128 + 32 len ceil32(_13121) + 32]
            _13122 = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
            mem[stor8[arg1].field_1 % 128 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
            mem[stor8[arg1].field_1 % 128 + 64 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
            if ceil32(_13122) > _13122:
                mem[_13122 + stor8[arg1].field_1 % 128 + 64] = 0
            return 32, mem[stor8[arg1].field_1 % 128 + 32 len ceil32(_13122) + 32]
        if bool(stor9.length) == uint255(stor9.length) * 0.5 < 32:
            revert with 'NH{q', 34
        if bool(stor9.length):
            if bool(stor9.length) == 1:
                idx = 0
                s = 0
                while idx < uint255(stor9.length) * 0.5:
                    mem[idx + ceil32(stor8[arg1].field_1 % 128) + 160] = uint256(stor9[s].field_0)
                    idx = idx + 32
                    s = s + 1
                    continue 
                mem[ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 160 len ceil32(stor8[arg1].field_1 % 128)] = mem[128 len ceil32(stor8[arg1].field_1 % 128)]
                mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 160] = 32
                mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 192] = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 224 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128]) <= mem[ceil32(stor8[arg1].field_1 % 128) + 128]:
                    return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + 128], data=mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 224 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]), 
                mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 224] = 0
                return 32, mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128]) + 32], 
            var52001 = ceil32(stor8[arg1].field_1 % 128)
            mem[64] = stor8[arg1].field_1 % 128
            if ceil32(stor8[arg1].field_1 % 128) <= stor8[arg1].field_1 % 128:
                _13117 = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                mem[stor8[arg1].field_1 % 128 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
                mem[stor8[arg1].field_1 % 128 + 64 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                if ceil32(_13117) > _13117:
                    mem[_13117 + stor8[arg1].field_1 % 128 + 64] = 0
                return 32, mem[stor8[arg1].field_1 % 128 + 32 len ceil32(_13117) + 32]
            _13118 = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
            mem[stor8[arg1].field_1 % 128 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
            mem[stor8[arg1].field_1 % 128 + 64 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
            if ceil32(_13118) > _13118:
                mem[_13118 + stor8[arg1].field_1 % 128 + 64] = 0
            return 32, mem[stor8[arg1].field_1 % 128 + 32 len ceil32(_13118) + 32]
        mem[ceil32(stor8[arg1].field_1 % 128) + 160] = Mask(248, 8, stor9.length)
        mem[ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 160 len ceil32(stor8[arg1].field_1 % 128)] = mem[128 len ceil32(stor8[arg1].field_1 % 128)]
        var51001 = ceil32(stor8[arg1].field_1 % 128)
        mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 160] = 32
        mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 192] = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
        mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 224 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
        var62001 = ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])
        if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128]) <= mem[ceil32(stor8[arg1].field_1 % 128) + 128]:
            return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + 128], data=mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 224 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]), 
        mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 224] = 0
        return 32, mem[stor8[arg1].field_1 % 128 + ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128]) + 32], 
    if not arg1:
        mem[ceil32(stor8[arg1].field_1 % 128) + 128] = 1
        mem[ceil32(stor8[arg1].field_1 % 128) + 160] = '0'
        if bool(stor9.length):
            if bool(stor9.length) == uint255(stor9.length) * 0.5 < 32:
                revert with 'NH{q', 34
            if not bool(stor9.length):
                mem[ceil32(stor8[arg1].field_1 % 128) + 224] = Mask(248, 8, stor9.length)
            else:
                if bool(stor9.length) != 1:
                    mem[64] = 1
                    _13110 = mem[ceil32(stor8[arg1].field_1 % 128) + 192]
                    mem[33] = mem[ceil32(stor8[arg1].field_1 % 128) + 192]
                    mem[65 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192])] = mem[ceil32(stor8[arg1].field_1 % 128) + 224 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192])]
                    if ceil32(_13110) > _13110:
                        mem[_13110 + 65] = 0
                    return memory
                      from mem[64]
                       len ceil32(_13110) + -mem[64] + 65
                idx = 0
                s = 0
                while idx < uint255(stor9.length) * 0.5:
                    mem[idx + ceil32(stor8[arg1].field_1 % 128) + 224] = uint256(stor9[s].field_0)
                    idx = idx + 32
                    s = s + 1
                    continue 
            mem[ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 224] = '0'
            mem[ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 225] = 32
            mem[ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 257] = mem[ceil32(stor8[arg1].field_1 % 128) + 192]
            mem[ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 289 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192])] = mem[ceil32(stor8[arg1].field_1 % 128) + 224 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192])]
            if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192]) > mem[ceil32(stor8[arg1].field_1 % 128) + 192]:
                mem[mem[ceil32(stor8[arg1].field_1 % 128) + 192] + ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 289] = 0
            return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + 192], data=mem[ceil32(stor8[arg1].field_1 % 128) + (uint255(stor9.length) * 0.5) + 289 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192])]), 
        if bool(stor9.length) == stor9.length.field_1 % 128 < 32:
            revert with 'NH{q', 34
        if not bool(stor9.length):
            mem[ceil32(stor8[arg1].field_1 % 128) + 224] = Mask(248, 8, stor9.length)
            mem[ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 224] = '0'
        else:
            if bool(stor9.length) != 1:
                mem[64] = 1
                _13114 = mem[ceil32(stor8[arg1].field_1 % 128) + 192]
                mem[33] = mem[ceil32(stor8[arg1].field_1 % 128) + 192]
                mem[65 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192])] = mem[ceil32(stor8[arg1].field_1 % 128) + 224 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192])]
                if ceil32(_13114) > _13114:
                    mem[_13114 + 65] = 0
                return memory
                  from mem[64]
                   len ceil32(_13114) + -mem[64] + 65
            idx = 0
            s = 0
            while idx < stor9.length.field_1 % 128:
                mem[idx + ceil32(stor8[arg1].field_1 % 128) + 224] = uint256(stor9[s].field_0)
                idx = idx + 32
                s = s + 1
                continue 
            mem[ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 224] = '0'
            var59001 = 32
        mem[ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 225] = 32
        mem[ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 257] = mem[ceil32(stor8[arg1].field_1 % 128) + 192]
        mem[ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 289 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192])] = mem[ceil32(stor8[arg1].field_1 % 128) + 224 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192])]
        if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192]) > mem[ceil32(stor8[arg1].field_1 % 128) + 192]:
            mem[mem[ceil32(stor8[arg1].field_1 % 128) + 192] + ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 289] = 0
        return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + 192], data=mem[ceil32(stor8[arg1].field_1 % 128) + stor9.length.field_1 % 128 + 289 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 192])]), 
    s = 0
    idx = arg1
    while idx:
        if s == -1:
            revert with 'NH{q', 17
        s = s + 1
        idx = idx / 10
        continue 
    if s > test266151307():
        revert with 'NH{q', 65
    mem[ceil32(stor8[arg1].field_1 % 128) + 128] = s
    if not s:
        t = s
        idx = arg1
        while idx:
            if t < 1:
                revert with 'NH{q', 17
            if 48 > !(idx % 10):
                revert with 'NH{q', 17
            if t - 1 >= mem[ceil32(stor8[arg1].field_1 % 128) + 128]:
                revert with 'NH{q', 50
            mem[t + ceil32(stor8[arg1].field_1 % 128) + 159 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
            t = t - 1
            idx = idx / 10
            continue 
        if bool(stor9.length):
            if bool(stor9.length) == uint255(stor9.length) * 0.5 < 32:
                revert with 'NH{q', 34
            if not bool(stor9.length):
                mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192] = Mask(248, 8, stor9.length)
                mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                var62001 = ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])
                mem[64] = mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192
                mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192] = 32
                mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 224] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]
                if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]) > mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]:
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160] + mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256] = 0
                return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160], data=mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]), 
            if bool(stor9.length) == 1:
                mem[0] = 9
                idx = 0
                t = 0
                while idx < uint255(stor9.length) * 0.5:
                    mem[idx + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192] = uint256(stor9[t].field_0)
                    idx = idx + 32
                    t = t + 1
                    continue 
                mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
                mem[64] = mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192
                mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192] = 32
                mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 224] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]
                if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]) > mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]:
                    mem[mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160] + mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256] = 0
                return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160], data=mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]), 
            _20487 = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
            mem[0 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
            mem[64] = _20487
            mem[_20487] = 32
            if ceil32(_20487) <= _20487:
                _25421 = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                mem[_20487 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
                mem[_20487 + 64 len ceil32(_25421)] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(_25421)]
                if ceil32(_25421) > _25421:
                    mem[_25421 + _20487 + 64] = 0
                return 32, mem[_20487 + 32 len ceil32(_25421) + 32]
            _25422 = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
            mem[_20487 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
            mem[_20487 + 64 len ceil32(_25422)] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(_25422)]
            if ceil32(_25422) > _25422:
                mem[_25422 + _20487 + 64] = 0
            return 32, mem[_20487 + 32 len ceil32(_25422) + 32]
        if bool(stor9.length) == stor9.length.field_1 % 128 < 32:
            revert with 'NH{q', 34
        if not bool(stor9.length):
            mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192] = Mask(248, 8, stor9.length)
            mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
            mem[64] = mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192
            mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192] = 32
            mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 224] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
            mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]
            if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]) > mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]:
                mem[mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160] + mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256] = 0
            return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160], data=mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]), 
        if bool(stor9.length) == 1:
            mem[0] = 9
            idx = 0
            t = 0
            while idx < stor9.length.field_1 % 128:
                mem[idx + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192] = uint256(stor9[t].field_0)
                idx = idx + 32
                t = t + 1
                continue 
            mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
            mem[64] = mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192
            mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192] = 32
            mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 224] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
            mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]
            if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]) > mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]:
                mem[mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160] + mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256] = 0
            return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160], data=mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]), 
        _20631 = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
        mem[0 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
        mem[64] = _20631
        mem[_20631] = 32
        if ceil32(_20631) <= _20631:
            _25425 = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
            mem[_20631 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
            mem[_20631 + 64 len ceil32(_25425)] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(_25425)]
            if ceil32(_25425) > _25425:
                mem[_25425 + _20631 + 64] = 0
            return 32, mem[_20631 + 32 len ceil32(_25425) + 32]
        _25426 = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
        mem[_20631 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
        mem[_20631 + 64 len ceil32(_25426)] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(_25426)]
        if ceil32(_25426) > _25426:
            mem[_25426 + _20631 + 64] = 0
        return 32, mem[_20631 + 32 len ceil32(_25426) + 32]
    mem[ceil32(stor8[arg1].field_1 % 128) + 160 len s] = call.data[calldata.size len s]
    t = s
    idx = arg1
    while idx:
        if t < 1:
            revert with 'NH{q', 17
        if 48 > !(idx % 10):
            revert with 'NH{q', 17
        if t - 1 >= mem[ceil32(stor8[arg1].field_1 % 128) + 128]:
            revert with 'NH{q', 50
        mem[t + ceil32(stor8[arg1].field_1 % 128) + 159 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
        t = t - 1
        idx = idx / 10
        continue 
    if bool(stor9.length):
        if bool(stor9.length) == uint255(stor9.length) * 0.5 < 32:
            revert with 'NH{q', 34
        if not bool(stor9.length):
            mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192] = Mask(248, 8, stor9.length)
            mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
            mem[64] = mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192
            mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192] = 32
            mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 224] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
            mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]
            if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]) > mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]:
                mem[mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160] + mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256] = 0
            return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160], data=mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]), 
        if bool(stor9.length) == 1:
            mem[0] = 9
            idx = 0
            t = 0
            while idx < uint255(stor9.length) * 0.5:
                mem[idx + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192] = uint256(stor9[t].field_0)
                idx = idx + 32
                t = t + 1
                continue 
            mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
            mem[64] = mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192
            mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 192] = 32
            mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 224] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
            mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]
            if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]) > mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]:
                mem[mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160] + mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256] = 0
            return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160], data=mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + (uint255(stor9.length) * 0.5) + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]), 
        _20489 = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
        mem[0 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
        mem[64] = _20489
        mem[_20489] = 32
        if ceil32(_20489) <= _20489:
            _25429 = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
            mem[_20489 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
            mem[_20489 + 64 len ceil32(_25429)] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(_25429)]
            if ceil32(_25429) > _25429:
                mem[_25429 + _20489 + 64] = 0
            return 32, mem[_20489 + 32 len ceil32(_25429) + 32]
        _25430 = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
        mem[_20489 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
        mem[_20489 + 64 len ceil32(_25430)] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(_25430)]
        if ceil32(_25430) > _25430:
            mem[_25430 + _20489 + 64] = 0
        return 32, mem[_20489 + 32 len ceil32(_25430) + 32]
    if bool(stor9.length) == stor9.length.field_1 % 128 < 32:
        revert with 'NH{q', 34
    if not bool(stor9.length):
        mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192] = Mask(248, 8, stor9.length)
        mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
        mem[64] = mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192
        mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192] = 32
        mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 224] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
        mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]
        if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]) > mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]:
            mem[mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160] + mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256] = 0
        return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160], data=mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]), 
    if bool(stor9.length) == 1:
        mem[0] = 9
        idx = 0
        t = 0
        while idx < stor9.length.field_1 % 128:
            mem[idx + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192] = uint256(stor9[t].field_0)
            idx = idx + 32
            t = t + 1
            continue 
        mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
        mem[64] = mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192
        mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 192] = 32
        mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 224] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
        mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]
        if ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]) > mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]:
            mem[mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160] + mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256] = 0
        return Array(len=mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160], data=mem[mem[ceil32(stor8[arg1].field_1 % 128) + 128] + ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + stor9.length.field_1 % 128 + 256 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160])]), 
    _20633 = mem[ceil32(stor8[arg1].field_1 % 128) + 128]
    mem[0 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])] = mem[ceil32(stor8[arg1].field_1 % 128) + 160 len ceil32(mem[ceil32(stor8[arg1].field_1 % 128) + 128])]
    mem[64] = _20633
    mem[_20633] = 32
    if ceil32(_20633) <= _20633:
        _25433 = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
        mem[_20633 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
        mem[_20633 + 64 len ceil32(_25433)] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(_25433)]
        if ceil32(_25433) > _25433:
            mem[_25433 + _20633 + 64] = 0
        return 32, mem[_20633 + 32 len ceil32(_25433) + 32]
    _25434 = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
    mem[_20633 + 32] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 160]
    mem[_20633 + 64 len ceil32(_25434)] = mem[ceil32(stor8[arg1].field_1 % 128) + ceil32(s) + 192 len ceil32(_25434)]
    if ceil32(_25434) > _25434:
        mem[_25434 + _20633 + 64] = 0
    return 32, mem[_20633 + 32 len ceil32(_25434) + 32]
}



}
