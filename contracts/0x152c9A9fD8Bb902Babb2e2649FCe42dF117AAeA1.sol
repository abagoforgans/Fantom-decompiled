contract main {




// =====================  Runtime code  =====================


#
#  - deposit(address arg1, uint256 arg2)
#  - earn()
#
const controllerFeeUL = 300

const controllerFeeMax = 10000

const sub_3caf1def(?) = 10000

const sub_48d7041e(?) = 800

const buyBackRateMax = 10000

const withdrawFeeFactorMax = 10000

const buyBackAddress = 57005

const sub_7c717c09(?) = 9500

const withdrawFeeFactorLL = 9950

const sub_868f8135(?) = 500

const sub_a613a28a(?) = 10000

const buyBackRateUL = 800

const slippageFactorUL = 995

const entranceFeeFactorLL = 9950

const entranceFeeFactorMax = 10000


address owner;
uint256 stor1;
uint8 paused;
uint8 sub_0ddea8c3; offset 8
uint8 isAutoComp; offset 16
uint32 stor2;
address farmContractAddress; offset 24
uint256 stor2;
uint256 pid;
address wantAddress;
address token0Address;
address token1Address;
address earnedAddress;
uint32 stor8;
address uniRouterAddress;
uint256 stor8;
address sub_cb971847Address;
uint256 sub_1b61e055;
address sub_7edd3da5Address;
uint32 stor12;
address sub_88f9e800Address;
uint256 stor12;
address sub_b3ed4599Address;
address govAddress;
uint256 lastEarnBlock;
uint256 stor16; offset 32
uint256 wantLockedTotal;
big480 stor16;
uint256 sharesTotal;
uint256 controllerFee;
uint256 buyBackRate;
uint256 sub_c52b971f;
address sub_285f3d55Address;
uint256 entranceFeeFactor;
uint256 sub_25c7ce6b;
uint256 withdrawFeeFactor;
uint256 sub_c7095c4b;
uint256 sub_9ccccc15;
mapping of uint256 stor27;
uint256 slippageFactor;
array of address sub_67eed8e0;
array of address earnedToToken0Path;
array of address earnedToToken1Path;
array of struct token0ToEarnedPath;
array of struct token1ToEarnedPath;
array of address sub_6597b04f;
array of address sub_6b99e24b;

function token1ToEarnedPath(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 < token1ToEarnedPath.length
    return token1ToEarnedPath[arg1].field_0
}

function sub_0ddea8c3(?) payable {
    return bool(sub_0ddea8c3)
}

function lastEarnBlock() payable {
    return lastEarnBlock
}

function entranceFeeFactor() payable {
    return entranceFeeFactor
}

function buyBackRate() payable {
    return buyBackRate
}

function sub_1b61e055(?) payable {
    return sub_1b61e055
}

function sub_25c7ce6b(?) payable {
    return sub_25c7ce6b
}

function sub_285f3d55(?) payable {
    return sub_285f3d55Address
}

function wantLockedTotal() payable {
    return wantLockedTotal
}

function sharesTotal() payable {
    return sharesTotal
}

function govAddress() payable {
    return govAddress
}

function paused() payable {
    return bool(paused)
}

function sub_6597b04f(?) payable {
    require calldata.size - 4 >= 32
    require arg1 < sub_6597b04f.length
    return sub_6597b04f[arg1]
}

function sub_67eed8e0(?) payable {
    require calldata.size - 4 >= 32
    require arg1 < sub_67eed8e0.length
    return sub_67eed8e0[arg1]
}

function withdrawFeeFactor() payable {
    return withdrawFeeFactor
}

function uniRouterAddress() payable {
    return address(uniRouterAddress)
}

function sub_6b99e24b(?) payable {
    require calldata.size - 4 >= 32
    require arg1 < sub_6b99e24b.length
    return sub_6b99e24b[arg1]
}

function sub_7edd3da5(?) payable {
    return sub_7edd3da5Address
}

function token0Address() payable {
    return token0Address
}

function controllerFee() payable {
    return controllerFee
}

function sub_88f9e800(?) payable {
    return address(sub_88f9e800Address)
}

function owner() payable {
    return owner
}

function earnedToToken1Path(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 < earnedToToken1Path.length
    return earnedToToken1Path[arg1]
}

function sub_9ccccc15(?) payable {
    return sub_9ccccc15
}

function farmContractAddress() payable {
    return farmContractAddress
}

function sub_b3ed4599(?) payable {
    return sub_b3ed4599Address
}

function token0ToEarnedPath(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 < token0ToEarnedPath.length
    return token0ToEarnedPath[arg1].field_0
}

function sub_c52b971f(?) payable {
    return sub_c52b971f
}

function sub_c7095c4b(?) payable {
    return sub_c7095c4b
}

function earnedToToken0Path(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 < earnedToToken0Path.length
    return earnedToToken0Path[arg1]
}

function sub_cb971847(?) payable {
    return sub_cb971847Address
}

function token1Address() payable {
    return token1Address
}

function isAutoComp() payable {
    return bool(isAutoComp)
}

function earnedAddress() payable {
    return earnedAddress
}

function wantAddress() payable {
    return wantAddress
}

function pid() payable {
    return pid
}

function slippageFactor() payable {
    return slippageFactor
}

function _fallback() payable {
    revert
}

function setGov(address arg1) payable {
    require calldata.size - 4 >= 32
    if govAddress != msg.sender:
        revert with 0, 'Not authorised'
    govAddress = arg1
}

function renounceOwnership() payable {
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    emit OwnershipTransferred(owner, 0);
    owner = 0
}

function setBuybackRouterAddress(address arg1) payable {
    require calldata.size - 4 >= 32
    if govAddress != msg.sender:
        revert with 0, 'Not authorised'
    sub_cb971847Address = arg1
}

function pause() payable {
    if govAddress != msg.sender:
        revert with 0, 'Not authorised'
    if paused:
        revert with 0, 'Pausable: paused'
    paused = 1
    emit Paused(msg.sender);
}

function unpause() payable {
    if govAddress != msg.sender:
        revert with 0, 'Not authorised'
    if not paused:
        revert with 0, 'Pausable: not paused'
    paused = 0
    emit Unpaused(msg.sender);
}

function sub_bbcb2058(?) payable {
    require calldata.size - 4 >= 32
    if govAddress != msg.sender:
        revert with 0, 'Not authorised'
    if arg1 >= 500:
        revert with 0, 'too high'
    sub_9ccccc15 = arg1
}

function setControllerFee(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if govAddress != msg.sender:
        revert with 0, 'Not authorised'
    if arg1 > 300:
        revert with 0, 'too high'
    controllerFee = arg1
}

function setbuyBackRate(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if govAddress != msg.sender:
        revert with 0, 'Not authorised'
    if buyBackRate > 800:
        revert with 0, 'too high'
    buyBackRate = arg1
}

function sub_41924a5f(?) payable {
    require calldata.size - 4 >= 64
    if govAddress != msg.sender:
        revert with 0, 'Not authorised'
    if arg1 + buyBackRate > 800:
        revert with 0, 'too high'
    sub_c52b971f = arg1
    sub_285f3d55Address = arg2
}

function setDepositFeeFactor(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if govAddress != msg.sender:
        revert with 0, 'Not authorised'
    if arg1 <= 9500:
        revert with 0, '!safe - too low'
    if arg1 > 10000:
        revert with 0, '!safe - too high'
    sub_25c7ce6b = arg1
}

function setEntranceFeeFactor(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if govAddress != msg.sender:
        revert with 0, 'Not authorised'
    if arg1 <= 9950:
        revert with 0, '!safe - too low'
    if arg1 > 10000:
        revert with 0, '!safe - too high'
    entranceFeeFactor = arg1
}

function setWithdrawFeeFactor(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if govAddress != msg.sender:
        revert with 0, 'Not authorised'
    if arg1 <= 9950:
        revert with 0, '!safe - too low'
    if arg1 > 10000:
        revert with 0, '!safe - too high'
    withdrawFeeFactor = arg1
}

function transferOwnership(address arg1) payable {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    38,
                    0xfe4f776e61626c653a206e6577206f776e657220697320746865207a65726f20616464726573,
                    mem[202 len 26]
    emit OwnershipTransferred(owner, arg1);
    owner = arg1
}

function inCaseTokensGetStuck(address arg1, uint256 arg2, address arg3) payable {
    require calldata.size - 4 >= 96
    if govAddress != msg.sender:
        revert with 0, 'Not authorised'
    if arg1 == earnedAddress:
        revert with 0, '!safe'
    if arg1 == wantAddress:
        revert with 0, '!safe'
    if eth.balance(this.address) < 0:
        revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[366 len 26]
    if ext_code.size(arg1) <= 0:
        revert with 0, 'Address: call to non-contract'
    mem[260 len 64] = unknown_0xa9059cbb(?????), address(arg3) << 64, 0, Mask(224, 32, arg2) >> 32
    mem[324 len 0] = 0
    call arg1 with:
         gas gas_remaining wei
        args Mask(224, 32, arg2) << 224, mem[324 len 4]
    if not return_data.size:
        if not ext_call.success:
            revert with unknown_0xa9059cbb(?????), address(arg3) << 64, 0, arg2
        if not unknown_0xa9059cbb(?????), address(arg3) << 64:
            revert with 0, 32, 42, 0x775361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565, mem[370 len 22]
    else:
        mem[292 len return_data.size] = ext_call.return_data[0 len return_data.size]
        if not ext_call.success:
            if return_data.size > 0:
                revert with ext_call.return_data[0 len return_data.size]
            revert with 0, 'SafeERC20: low-level call failed'
        if return_data.size > 0:
            require return_data.size >= 32
            if not mem[292]:
                revert with 0, 
                            32,
                            42,
                            0x775361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                            mem[ceil32(return_data.size) + 371 len 22]
}

function farm() payable {
    if stor1 == 2:
        revert with 0, 'ReentrancyGuard: reentrant call'
    stor1 = 2
    if not isAutoComp:
        revert with 0, '!isAutoComp'
    require ext_code.size(wantAddress)
    staticcall wantAddress.0x70a08231 with:
            gas gas_remaining wei
           args this.address
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if wantLockedTotal + ext_call.return_data[0] < wantLockedTotal:
        revert with 0, 'SafeMath: addition overflow'
    wantLockedTotal += ext_call.return_data[0]
    require ext_code.size(wantAddress)
    staticcall wantAddress.0xdd62ed3e with:
            gas gas_remaining wei
           args address(this.address), farmContractAddress
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if 2 * ext_call.return_data[0] < ext_call.return_data[0]:
        revert with 0, 'SafeMath: addition overflow'
    if eth.balance(this.address) < 0:
        revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[366 len 26]
    if ext_code.size(wantAddress) <= 0:
        revert with 0, 'Address: call to non-contract'
    mem[260 len 64] = approve(address arg1, uint256 arg2), Mask(224, 0, stor2.field_0), uint32(stor2.field_0), Mask(224, 31, ext_call.return_data[0]) >> 31
    mem[324 len 0] = 0
    call wantAddress with:
       funct uint32(stor2.field_0)
         gas gas_remaining wei
        args Mask(224, 31, ext_call.return_data[0]) << 225, mem[324 len 4]
    if not return_data.size:
        if not ext_call.success:
            revert with approve(address arg1, uint256 arg2), Mask(224, 0, stor2.field_0), uint32(stor2.field_0), 2 * ext_call.return_data[0]
        if not approve(address arg1, uint256 arg2), Mask(224, 0, stor2.field_0):
            revert with 0, 32, 42, 0x775361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565, mem[370 len 22]
    else:
        mem[292 len return_data.size] = ext_call.return_data[0 len return_data.size]
        if not ext_call.success:
            if return_data.size > 0:
                revert with ext_call.return_data[0 len return_data.size]
            revert with 0, 'SafeERC20: low-level call failed'
        if return_data.size > 0:
            require return_data.size >= 32
            if not mem[292]:
                revert with 0, 
                            32,
                            42,
                            0x775361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                            mem[ceil32(return_data.size) + 371 len 22]
    require ext_code.size(farmContractAddress)
    call farmContractAddress.deposit(uint256 arg1, uint256 arg2) with:
         gas gas_remaining wei
        args pid, ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    stor1 = 1
}

function withdraw(address arg1, uint256 arg2) payable {
    require calldata.size - 4 >= 64
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if stor1 == 2:
        revert with 0, 'ReentrancyGuard: reentrant call'
    stor1 = 2
    if arg2 <= 0:
        revert with 0, '_wantAmt <= 0'
    if not arg2:
        if wantLockedTotal <= 0:
            revert with 0, 'SafeMath: division by zero'
        require wantLockedTotal
        if 0 / wantLockedTotal <= sharesTotal:
            sharesTotal -= 0 / wantLockedTotal
            if sub_9ccccc15 <= 0:
                if withdrawFeeFactor >= 10000:
                    if not isAutoComp:
                        require ext_code.size(wantAddress)
                        staticcall wantAddress.0x70a08231 with:
                                gas gas_remaining wei
                               args this.address
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if arg2 <= ext_call.return_data[0]:
                            if wantLockedTotal >= arg2:
                                if arg2 > wantLockedTotal:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                wantLockedTotal -= arg2
                                if eth.balance(this.address) < 0:
                                    revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[558 len 26]
                                if ext_code.size(wantAddress) <= 0:
                                    revert with 0, 'Address: call to non-contract'
                                mem[452 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 32, arg2) >> 32
                                mem[516 len 0] = 0
                                call wantAddress with:
                                   funct uint32(stor12)
                                     gas gas_remaining wei
                                    args Mask(224, 32, arg2) << 224, mem[516 len 4]
                            else:
                                if wantLockedTotal > wantLockedTotal:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                wantLockedTotal = 0
                                if eth.balance(this.address) < 0:
                                    revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[558 len 26]
                                if ext_code.size(wantAddress) <= 0:
                                    revert with 0, 'Address: call to non-contract'
                                mem[452 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                mem[516 len 0] = 0
                                call wantAddress with:
                                   funct uint32(stor12)
                                     gas gas_remaining wei
                                    args Mask(480, 0, stor16.field_0), mem[516 len 4]
                        else:
                            if wantLockedTotal >= ext_call.return_data[0]:
                                if ext_call.return_data[0] > wantLockedTotal:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                wantLockedTotal -= ext_call.return_data[0]
                                if eth.balance(this.address) < 0:
                                    revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[558 len 26]
                                if ext_code.size(wantAddress) <= 0:
                                    revert with 0, 'Address: call to non-contract'
                                mem[452 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), ext_call.return_data[0 len 28]
                                mem[516 len 0] = 0
                                call wantAddress with:
                                   funct uint32(stor12)
                                     gas gas_remaining wei
                                    args Mask(480, -256, ext_call.return_data[0 len 28]) << 256, mem[516 len 4]
                            else:
                                if wantLockedTotal > wantLockedTotal:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                wantLockedTotal = 0
                                if eth.balance(this.address) < 0:
                                    revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[558 len 26]
                                if ext_code.size(wantAddress) <= 0:
                                    revert with 0, 'Address: call to non-contract'
                                mem[452 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                mem[516 len 0] = 0
                                call wantAddress with:
                                   funct uint32(stor12)
                                     gas gas_remaining wei
                                    args Mask(480, 0, stor16.field_0), mem[516 len 4]
                    else:
                        require ext_code.size(farmContractAddress)
                        call farmContractAddress.withdraw(uint256 arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args pid, arg2
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require ext_code.size(wantAddress)
                        staticcall wantAddress.0x70a08231 with:
                                gas gas_remaining wei
                               args this.address
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if arg2 <= ext_call.return_data[0]:
                            if wantLockedTotal >= arg2:
                                if arg2 > wantLockedTotal:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                wantLockedTotal -= arg2
                                if eth.balance(this.address) < 0:
                                    revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[558 len 26]
                                if ext_code.size(wantAddress) <= 0:
                                    revert with 0, 'Address: call to non-contract'
                                mem[452 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 32, arg2) >> 32
                                call wantAddress with:
                                   funct uint32(stor12)
                                     gas gas_remaining wei
                                    args Mask(224, 32, arg2) << 224, mem[516 len 4]
                            else:
                                if wantLockedTotal > wantLockedTotal:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                wantLockedTotal = 0
                                if eth.balance(this.address) < 0:
                                    revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[558 len 26]
                                if ext_code.size(wantAddress) <= 0:
                                    revert with 0, 'Address: call to non-contract'
                                mem[452 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                call wantAddress with:
                                   funct uint32(stor12)
                                     gas gas_remaining wei
                                    args Mask(480, 0, stor16.field_0), mem[516 len 4]
                        else:
                            if wantLockedTotal >= ext_call.return_data[0]:
                                if ext_call.return_data[0] > wantLockedTotal:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                wantLockedTotal -= ext_call.return_data[0]
                                if eth.balance(this.address) < 0:
                                    revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[558 len 26]
                                if ext_code.size(wantAddress) <= 0:
                                    revert with 0, 'Address: call to non-contract'
                                mem[452 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), ext_call.return_data[0 len 28]
                                mem[516 len 0] = 0
                                call wantAddress with:
                                   funct uint32(stor12)
                                     gas gas_remaining wei
                                    args Mask(480, -256, ext_call.return_data[0 len 28]) << 256, mem[516 len 4]
                            else:
                                if wantLockedTotal > wantLockedTotal:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                wantLockedTotal = 0
                                if eth.balance(this.address) < 0:
                                    revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[558 len 26]
                                if ext_code.size(wantAddress) <= 0:
                                    revert with 0, 'Address: call to non-contract'
                                mem[452 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                mem[516 len 0] = 0
                                call wantAddress with:
                                   funct uint32(stor12)
                                     gas gas_remaining wei
                                    args Mask(480, 0, stor16.field_0), mem[516 len 4]
                    if not return_data.size:
                        require not ext_call.success
                        revert with 'SafeMath: division by zero'
                    mem[484 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not ext_call.success:
                        if return_data.size > 0:
                            revert with ext_call.return_data[0 len return_data.size]
                        revert with 0, 'SafeERC20: low-level call failed'
                    if return_data.size > 0:
                        require return_data.size >= 32
                        if not mem[484]:
                            revert with 0, 
                                        32,
                                        42,
                                        0x775361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                        mem[ceil32(return_data.size) + 563 len 22]
                else:
                    if not arg2:
                        if not isAutoComp:
                            require ext_code.size(wantAddress)
                            staticcall wantAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if 0 <= ext_call.return_data[0]:
                                if wantLockedTotal >= 0:
                                    if 0 > wantLockedTotal:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                    if ext_code.size(wantAddress) <= 0:
                                        revert with 0, 'Address: call to non-contract'
                                    mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), 0
                                    mem[580 len 0] = 0
                                    call wantAddress with:
                                       funct uint32(stor12)
                                         gas gas_remaining wei
                                        args Mask(480, -256, unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), 0) << 256, mem[580 len 4]
                                else:
                                    if wantLockedTotal > wantLockedTotal:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    wantLockedTotal = 0
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                    if ext_code.size(wantAddress) <= 0:
                                        revert with 0, 'Address: call to non-contract'
                                    mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                    mem[580 len 0] = 0
                                    call wantAddress with:
                                       funct uint32(stor12)
                                         gas gas_remaining wei
                                        args Mask(480, 0, stor16.field_0), mem[580 len 4]
                            else:
                                if wantLockedTotal >= ext_call.return_data[0]:
                                    if ext_call.return_data[0] > wantLockedTotal:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    wantLockedTotal -= ext_call.return_data[0]
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                    if ext_code.size(wantAddress) <= 0:
                                        revert with 0, 'Address: call to non-contract'
                                    mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), ext_call.return_data[0 len 28]
                                    mem[580 len 0] = 0
                                    call wantAddress with:
                                       funct uint32(stor12)
                                         gas gas_remaining wei
                                        args Mask(480, -256, ext_call.return_data[0 len 28]) << 256, mem[580 len 4]
                                else:
                                    if wantLockedTotal > wantLockedTotal:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    wantLockedTotal = 0
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                    if ext_code.size(wantAddress) <= 0:
                                        revert with 0, 'Address: call to non-contract'
                                    mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                    mem[580 len 0] = 0
                                    call wantAddress with:
                                       funct uint32(stor12)
                                         gas gas_remaining wei
                                        args Mask(480, 0, stor16.field_0), mem[580 len 4]
                        else:
                            require ext_code.size(farmContractAddress)
                            call farmContractAddress.withdraw(uint256 arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args pid, 0
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require ext_code.size(wantAddress)
                            staticcall wantAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if 0 <= ext_call.return_data[0]:
                                if wantLockedTotal >= 0:
                                    if 0 > wantLockedTotal:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                    if ext_code.size(wantAddress) <= 0:
                                        revert with 0, 'Address: call to non-contract'
                                    mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), 0
                                    call wantAddress with:
                                       funct uint32(stor12)
                                         gas gas_remaining wei
                                        args 0, mem[580 len 4]
                                else:
                                    if wantLockedTotal > wantLockedTotal:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    wantLockedTotal = 0
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                    if ext_code.size(wantAddress) <= 0:
                                        revert with 0, 'Address: call to non-contract'
                                    mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                    mem[580 len 0] = 0
                                    call wantAddress with:
                                       funct uint32(stor12)
                                         gas gas_remaining wei
                                        args Mask(480, 0, stor16.field_0), mem[580 len 4]
                            else:
                                if wantLockedTotal >= ext_call.return_data[0]:
                                    if ext_call.return_data[0] > wantLockedTotal:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    wantLockedTotal -= ext_call.return_data[0]
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                    if ext_code.size(wantAddress) <= 0:
                                        revert with 0, 'Address: call to non-contract'
                                    mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), ext_call.return_data[0 len 28]
                                    mem[580 len 0] = 0
                                    call wantAddress with:
                                       funct uint32(stor12)
                                         gas gas_remaining wei
                                        args Mask(480, -256, ext_call.return_data[0 len 28]) << 256, mem[580 len 4]
                                else:
                                    if wantLockedTotal > wantLockedTotal:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    wantLockedTotal = 0
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                    if ext_code.size(wantAddress) <= 0:
                                        revert with 0, 'Address: call to non-contract'
                                    mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                    mem[580 len 0] = 0
                                    call wantAddress with:
                                       funct uint32(stor12)
                                         gas gas_remaining wei
                                        args Mask(480, 0, stor16.field_0), mem[580 len 4]
                    else:
                        require arg2
                        if arg2 * withdrawFeeFactor / arg2 != withdrawFeeFactor:
                            revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                        if not isAutoComp:
                            require ext_code.size(wantAddress)
                            staticcall wantAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if arg2 * withdrawFeeFactor / 10000 <= ext_call.return_data[0]:
                                if wantLockedTotal < arg2 * withdrawFeeFactor / 10000:
                                    if wantLockedTotal > wantLockedTotal:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    wantLockedTotal = 0
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                    if ext_code.size(wantAddress) <= 0:
                                        revert with 0, 'Address: call to non-contract'
                                    mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                    call wantAddress with:
                                       funct uint32(stor12)
                                         gas gas_remaining wei
                                        args Mask(480, 0, stor16.field_0), mem[580 len 4]
                                else:
                                    if arg2 * withdrawFeeFactor / 10000 > wantLockedTotal:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    wantLockedTotal -= arg2 * withdrawFeeFactor / 10000
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                    if ext_code.size(wantAddress) <= 0:
                                        revert with 0, 'Address: call to non-contract'
                                    mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 32, arg2 * withdrawFeeFactor / 10000) >> 32
                                    mem[580 len 0] = 0
                                    call wantAddress with:
                                       funct uint32(stor12)
                                         gas gas_remaining wei
                                        args Mask(224, 32, arg2 * withdrawFeeFactor / 10000) << 224, mem[580 len 4]
                            else:
                                if wantLockedTotal >= ext_call.return_data[0]:
                                    if ext_call.return_data[0] > wantLockedTotal:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    wantLockedTotal -= ext_call.return_data[0]
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                    if ext_code.size(wantAddress) <= 0:
                                        revert with 0, 'Address: call to non-contract'
                                    mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), ext_call.return_data[0 len 28]
                                    call wantAddress with:
                                       funct uint32(stor12)
                                         gas gas_remaining wei
                                        args Mask(480, -256, ext_call.return_data[0 len 28]) << 256, mem[580 len 4]
                                else:
                                    if wantLockedTotal > wantLockedTotal:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    wantLockedTotal = 0
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                    if ext_code.size(wantAddress) <= 0:
                                        revert with 0, 'Address: call to non-contract'
                                    mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                    mem[580 len 0] = 0
                                    call wantAddress with:
                                       funct uint32(stor12)
                                         gas gas_remaining wei
                                        args Mask(480, 0, stor16.field_0), mem[580 len 4]
                        else:
                            require ext_code.size(farmContractAddress)
                            call farmContractAddress.withdraw(uint256 arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args pid, arg2 * withdrawFeeFactor / 10000
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require ext_code.size(wantAddress)
                            staticcall wantAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if arg2 * withdrawFeeFactor / 10000 <= ext_call.return_data[0]:
                                if wantLockedTotal < arg2 * withdrawFeeFactor / 10000:
                                    if wantLockedTotal > wantLockedTotal:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    wantLockedTotal = 0
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                    if ext_code.size(wantAddress) <= 0:
                                        revert with 0, 'Address: call to non-contract'
                                    mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                    call wantAddress with:
                                       funct uint32(stor12)
                                         gas gas_remaining wei
                                        args Mask(480, 0, stor16.field_0), mem[580 len 4]
                                else:
                                    if arg2 * withdrawFeeFactor / 10000 > wantLockedTotal:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    wantLockedTotal -= arg2 * withdrawFeeFactor / 10000
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                    if ext_code.size(wantAddress) <= 0:
                                        revert with 0, 'Address: call to non-contract'
                                    mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 32, arg2 * withdrawFeeFactor / 10000) >> 32
                                    mem[580 len 0] = 0
                                    call wantAddress with:
                                       funct uint32(stor12)
                                         gas gas_remaining wei
                                        args Mask(224, 32, arg2 * withdrawFeeFactor / 10000) << 224, mem[580 len 4]
                            else:
                                if wantLockedTotal >= ext_call.return_data[0]:
                                    if ext_call.return_data[0] > wantLockedTotal:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    wantLockedTotal -= ext_call.return_data[0]
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                    if ext_code.size(wantAddress) <= 0:
                                        revert with 0, 'Address: call to non-contract'
                                    mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), ext_call.return_data[0 len 28]
                                    mem[580 len 0] = 0
                                    call wantAddress with:
                                       funct uint32(stor12)
                                         gas gas_remaining wei
                                        args Mask(480, -256, ext_call.return_data[0 len 28]) << 256, mem[580 len 4]
                                else:
                                    if wantLockedTotal > wantLockedTotal:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    wantLockedTotal = 0
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                    if ext_code.size(wantAddress) <= 0:
                                        revert with 0, 'Address: call to non-contract'
                                    mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                    mem[580 len 0] = 0
                                    call wantAddress with:
                                       funct uint32(stor12)
                                         gas gas_remaining wei
                                        args Mask(480, 0, stor16.field_0), mem[580 len 4]
                    if not return_data.size:
                        require not ext_call.success
                        revert with 'SafeMath: division by zero'
                    mem[548 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not ext_call.success:
                        if return_data.size > 0:
                            revert with ext_call.return_data[0 len return_data.size]
                        revert with 0, 'SafeERC20: low-level call failed'
                    if return_data.size > 0:
                        require return_data.size >= 32
                        if not mem[548]:
                            revert with 0, 
                                        32,
                                        42,
                                        0x775361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                        mem[ceil32(return_data.size) + 627 len 22]
            else:
                if stor27[address(arg1)] + sub_c7095c4b < stor27[address(arg1)]:
                    revert with 0, 'SafeMath: addition overflow'
                if stor27[address(arg1)] + sub_c7095c4b <= block.timestamp:
                    if withdrawFeeFactor >= 10000:
                        if not isAutoComp:
                            require ext_code.size(wantAddress)
                            staticcall wantAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if arg2 > ext_call.return_data[0]:
                                if wantLockedTotal >= ext_call.return_data[0]:
                                    if ext_call.return_data[0] > wantLockedTotal:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    wantLockedTotal -= ext_call.return_data[0]
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[558 len 26]
                                    if ext_code.size(wantAddress) <= 0:
                                        revert with 0, 'Address: call to non-contract'
                                    mem[452 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), ext_call.return_data[0 len 28]
                                    call wantAddress with:
                                       funct uint32(stor12)
                                         gas gas_remaining wei
                                        args Mask(480, -256, ext_call.return_data[0 len 28]) << 256, mem[516 len 4]
                                else:
                                    if wantLockedTotal > wantLockedTotal:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    wantLockedTotal = 0
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[558 len 26]
                                    if ext_code.size(wantAddress) <= 0:
                                        revert with 0, 'Address: call to non-contract'
                                    mem[452 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                    call wantAddress with:
                                       funct uint32(stor12)
                                         gas gas_remaining wei
                                        args Mask(480, 0, stor16.field_0), mem[516 len 4]
                            else:
                                if wantLockedTotal >= arg2:
                                    if arg2 > wantLockedTotal:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    wantLockedTotal -= arg2
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[558 len 26]
                                    if ext_code.size(wantAddress) <= 0:
                                        revert with 0, 'Address: call to non-contract'
                                    mem[452 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 32, arg2) >> 32
                                    mem[516 len 0] = 0
                                    call wantAddress with:
                                       funct uint32(stor12)
                                         gas gas_remaining wei
                                        args Mask(224, 32, arg2) << 224, mem[516 len 4]
                                else:
                                    if wantLockedTotal > wantLockedTotal:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    wantLockedTotal = 0
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[558 len 26]
                                    if ext_code.size(wantAddress) <= 0:
                                        revert with 0, 'Address: call to non-contract'
                                    mem[452 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                    mem[516 len 0] = 0
                                    call wantAddress with:
                                       funct uint32(stor12)
                                         gas gas_remaining wei
                                        args Mask(480, 0, stor16.field_0), mem[516 len 4]
                        else:
                            require ext_code.size(farmContractAddress)
                            call farmContractAddress.withdraw(uint256 arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args pid, arg2
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require ext_code.size(wantAddress)
                            staticcall wantAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if arg2 <= ext_call.return_data[0]:
                                if wantLockedTotal >= arg2:
                                    if arg2 > wantLockedTotal:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    wantLockedTotal -= arg2
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[558 len 26]
                                    if ext_code.size(wantAddress) <= 0:
                                        revert with 0, 'Address: call to non-contract'
                                    mem[452 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 32, arg2) >> 32
                                    mem[516 len 0] = 0
                                    call wantAddress with:
                                       funct uint32(stor12)
                                         gas gas_remaining wei
                                        args Mask(224, 32, arg2) << 224, mem[516 len 4]
                                else:
                                    if wantLockedTotal > wantLockedTotal:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    wantLockedTotal = 0
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[558 len 26]
                                    if ext_code.size(wantAddress) <= 0:
                                        revert with 0, 'Address: call to non-contract'
                                    mem[452 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                    mem[516 len 0] = 0
                                    call wantAddress with:
                                       funct uint32(stor12)
                                         gas gas_remaining wei
                                        args Mask(480, 0, stor16.field_0), mem[516 len 4]
                            else:
                                if wantLockedTotal < ext_call.return_data[0]:
                                    if wantLockedTotal > wantLockedTotal:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    wantLockedTotal = 0
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[558 len 26]
                                    if ext_code.size(wantAddress) <= 0:
                                        revert with 0, 'Address: call to non-contract'
                                    mem[452 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                    call wantAddress with:
                                       funct uint32(stor12)
                                         gas gas_remaining wei
                                        args Mask(480, 0, stor16.field_0), mem[516 len 4]
                                else:
                                    if ext_call.return_data[0] > wantLockedTotal:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    wantLockedTotal -= ext_call.return_data[0]
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[558 len 26]
                                    if ext_code.size(wantAddress) <= 0:
                                        revert with 0, 'Address: call to non-contract'
                                    mem[452 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), ext_call.return_data[0 len 28]
                                    mem[516 len 0] = 0
                                    call wantAddress with:
                                       funct uint32(stor12)
                                         gas gas_remaining wei
                                        args Mask(480, -256, ext_call.return_data[0 len 28]) << 256, mem[516 len 4]
                        if not return_data.size:
                            require not ext_call.success
                            revert with 'SafeMath: division by zero'
                        mem[484 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size > 0:
                                revert with ext_call.return_data[0 len return_data.size]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if return_data.size > 0:
                            require return_data.size >= 32
                            if not mem[484]:
                                revert with 0, 
                                            32,
                                            42,
                                            0x775361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                            mem[ceil32(return_data.size) + 563 len 22]
                    else:
                        if not arg2:
                            if not isAutoComp:
                                require ext_code.size(wantAddress)
                                staticcall wantAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if 0 <= ext_call.return_data[0]:
                                    if wantLockedTotal >= 0:
                                        if 0 > wantLockedTotal:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                        if ext_code.size(wantAddress) <= 0:
                                            revert with 0, 'Address: call to non-contract'
                                        mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), 0
                                        call wantAddress with:
                                           funct uint32(stor12)
                                             gas gas_remaining wei
                                            args 0, mem[580 len 4]
                                    else:
                                        if wantLockedTotal > wantLockedTotal:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        wantLockedTotal = 0
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                        if ext_code.size(wantAddress) <= 0:
                                            revert with 0, 'Address: call to non-contract'
                                        mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                        mem[580 len 0] = 0
                                        call wantAddress with:
                                           funct uint32(stor12)
                                             gas gas_remaining wei
                                            args Mask(480, 0, stor16.field_0), mem[580 len 4]
                                else:
                                    if wantLockedTotal < ext_call.return_data[0]:
                                        if wantLockedTotal > wantLockedTotal:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        wantLockedTotal = 0
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                        if ext_code.size(wantAddress) <= 0:
                                            revert with 0, 'Address: call to non-contract'
                                        mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                        call wantAddress with:
                                           funct uint32(stor12)
                                             gas gas_remaining wei
                                            args Mask(480, 0, stor16.field_0), mem[580 len 4]
                                    else:
                                        if ext_call.return_data[0] > wantLockedTotal:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        wantLockedTotal -= ext_call.return_data[0]
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                        if ext_code.size(wantAddress) <= 0:
                                            revert with 0, 'Address: call to non-contract'
                                        mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), ext_call.return_data[0 len 28]
                                        mem[580 len 0] = 0
                                        call wantAddress with:
                                           funct uint32(stor12)
                                             gas gas_remaining wei
                                            args Mask(480, -256, ext_call.return_data[0 len 28]) << 256, mem[580 len 4]
                            else:
                                require ext_code.size(farmContractAddress)
                                call farmContractAddress.withdraw(uint256 arg1, uint256 arg2) with:
                                     gas gas_remaining wei
                                    args pid, 0
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(wantAddress)
                                staticcall wantAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if 0 <= ext_call.return_data[0]:
                                    if wantLockedTotal >= 0:
                                        if 0 > wantLockedTotal:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                        if ext_code.size(wantAddress) <= 0:
                                            revert with 0, 'Address: call to non-contract'
                                        mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), 0
                                        mem[580 len 0] = 0
                                        call wantAddress with:
                                           funct uint32(stor12)
                                             gas gas_remaining wei
                                            args Mask(480, -256, unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), 0) << 256, mem[580 len 4]
                                    else:
                                        if wantLockedTotal > wantLockedTotal:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        wantLockedTotal = 0
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                        if ext_code.size(wantAddress) <= 0:
                                            revert with 0, 'Address: call to non-contract'
                                        mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                        mem[580 len 0] = 0
                                        call wantAddress with:
                                           funct uint32(stor12)
                                             gas gas_remaining wei
                                            args Mask(480, 0, stor16.field_0), mem[580 len 4]
                                else:
                                    if wantLockedTotal < ext_call.return_data[0]:
                                        if wantLockedTotal > wantLockedTotal:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        wantLockedTotal = 0
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                        if ext_code.size(wantAddress) <= 0:
                                            revert with 0, 'Address: call to non-contract'
                                        mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                        call wantAddress with:
                                           funct uint32(stor12)
                                             gas gas_remaining wei
                                            args Mask(480, 0, stor16.field_0), mem[580 len 4]
                                    else:
                                        if ext_call.return_data[0] > wantLockedTotal:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        wantLockedTotal -= ext_call.return_data[0]
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                        if ext_code.size(wantAddress) <= 0:
                                            revert with 0, 'Address: call to non-contract'
                                        mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), ext_call.return_data[0 len 28]
                                        mem[580 len 0] = 0
                                        call wantAddress with:
                                           funct uint32(stor12)
                                             gas gas_remaining wei
                                            args Mask(480, -256, ext_call.return_data[0 len 28]) << 256, mem[580 len 4]
                        else:
                            require arg2
                            if arg2 * withdrawFeeFactor / arg2 != withdrawFeeFactor:
                                revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                            if not isAutoComp:
                                require ext_code.size(wantAddress)
                                staticcall wantAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if arg2 * withdrawFeeFactor / 10000 <= ext_call.return_data[0]:
                                    if wantLockedTotal < arg2 * withdrawFeeFactor / 10000:
                                        if wantLockedTotal > wantLockedTotal:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        wantLockedTotal = 0
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                        if ext_code.size(wantAddress) <= 0:
                                            revert with 0, 'Address: call to non-contract'
                                        mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                        call wantAddress with:
                                           funct uint32(stor12)
                                             gas gas_remaining wei
                                            args Mask(480, 0, stor16.field_0), mem[580 len 4]
                                    else:
                                        if arg2 * withdrawFeeFactor / 10000 > wantLockedTotal:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        wantLockedTotal -= arg2 * withdrawFeeFactor / 10000
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                        if ext_code.size(wantAddress) <= 0:
                                            revert with 0, 'Address: call to non-contract'
                                        mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 32, arg2 * withdrawFeeFactor / 10000) >> 32
                                        mem[580 len 0] = 0
                                        call wantAddress with:
                                           funct uint32(stor12)
                                             gas gas_remaining wei
                                            args Mask(224, 32, arg2 * withdrawFeeFactor / 10000) << 224, mem[580 len 4]
                                else:
                                    if wantLockedTotal < ext_call.return_data[0]:
                                        if wantLockedTotal > wantLockedTotal:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        wantLockedTotal = 0
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                        if ext_code.size(wantAddress) <= 0:
                                            revert with 0, 'Address: call to non-contract'
                                        mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                        call wantAddress with:
                                           funct uint32(stor12)
                                             gas gas_remaining wei
                                            args Mask(480, 0, stor16.field_0), mem[580 len 4]
                                    else:
                                        if ext_call.return_data[0] > wantLockedTotal:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        wantLockedTotal -= ext_call.return_data[0]
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                        if ext_code.size(wantAddress) <= 0:
                                            revert with 0, 'Address: call to non-contract'
                                        mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), ext_call.return_data[0 len 28]
                                        mem[580 len 0] = 0
                                        call wantAddress with:
                                           funct uint32(stor12)
                                             gas gas_remaining wei
                                            args Mask(480, -256, ext_call.return_data[0 len 28]) << 256, mem[580 len 4]
                            else:
                                require ext_code.size(farmContractAddress)
                                call farmContractAddress.withdraw(uint256 arg1, uint256 arg2) with:
                                     gas gas_remaining wei
                                    args pid, arg2 * withdrawFeeFactor / 10000
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(wantAddress)
                                staticcall wantAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if arg2 * withdrawFeeFactor / 10000 <= ext_call.return_data[0]:
                                    if wantLockedTotal < arg2 * withdrawFeeFactor / 10000:
                                        if wantLockedTotal > wantLockedTotal:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        wantLockedTotal = 0
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                        if ext_code.size(wantAddress) <= 0:
                                            revert with 0, 'Address: call to non-contract'
                                        mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                        call wantAddress with:
                                           funct uint32(stor12)
                                             gas gas_remaining wei
                                            args Mask(480, 0, stor16.field_0), mem[580 len 4]
                                    else:
                                        if arg2 * withdrawFeeFactor / 10000 > wantLockedTotal:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        wantLockedTotal -= arg2 * withdrawFeeFactor / 10000
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                        if ext_code.size(wantAddress) <= 0:
                                            revert with 0, 'Address: call to non-contract'
                                        mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 32, arg2 * withdrawFeeFactor / 10000) >> 32
                                        mem[580 len 0] = 0
                                        call wantAddress with:
                                           funct uint32(stor12)
                                             gas gas_remaining wei
                                            args Mask(224, 32, arg2 * withdrawFeeFactor / 10000) << 224, mem[580 len 4]
                                else:
                                    if wantLockedTotal >= ext_call.return_data[0]:
                                        if ext_call.return_data[0] > wantLockedTotal:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        wantLockedTotal -= ext_call.return_data[0]
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                        if ext_code.size(wantAddress) <= 0:
                                            revert with 0, 'Address: call to non-contract'
                                        mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), ext_call.return_data[0 len 28]
                                        call wantAddress with:
                                           funct uint32(stor12)
                                             gas gas_remaining wei
                                            args Mask(480, -256, ext_call.return_data[0 len 28]) << 256, mem[580 len 4]
                                    else:
                                        if wantLockedTotal > wantLockedTotal:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        wantLockedTotal = 0
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                        if ext_code.size(wantAddress) <= 0:
                                            revert with 0, 'Address: call to non-contract'
                                        mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                        mem[580 len 0] = 0
                                        call wantAddress with:
                                           funct uint32(stor12)
                                             gas gas_remaining wei
                                            args Mask(480, 0, stor16.field_0), mem[580 len 4]
                        if not return_data.size:
                            require not ext_call.success
                            revert with 'SafeMath: division by zero'
                        mem[548 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size > 0:
                                revert with ext_call.return_data[0 len return_data.size]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if return_data.size > 0:
                            require return_data.size >= 32
                            if not mem[548]:
                                revert with 0, 
                                            32,
                                            42,
                                            0x775361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                            mem[ceil32(return_data.size) + 627 len 22]
                else:
                    if not arg2:
                        if withdrawFeeFactor >= 10000:
                            if isAutoComp:
                                require ext_code.size(farmContractAddress)
                                call farmContractAddress.withdraw(uint256 arg1, uint256 arg2) with:
                                     gas gas_remaining wei
                                    args pid, arg2
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                            require ext_code.size(wantAddress)
                            staticcall wantAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if arg2 <= ext_call.return_data[0]:
                                if wantLockedTotal >= arg2:
                                    if arg2 > wantLockedTotal:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    wantLockedTotal -= arg2
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                    if ext_code.size(wantAddress) <= 0:
                                        revert with 0, 'Address: call to non-contract'
                                    mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 32, arg2) >> 32
                                    mem[580 len 0] = 0
                                    call wantAddress with:
                                       funct uint32(stor12)
                                         gas gas_remaining wei
                                        args Mask(224, 32, arg2) << 224, mem[580 len 4]
                                else:
                                    if wantLockedTotal > wantLockedTotal:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    wantLockedTotal = 0
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                    if ext_code.size(wantAddress) <= 0:
                                        revert with 0, 'Address: call to non-contract'
                                    mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                    mem[580 len 0] = 0
                                    call wantAddress with:
                                       funct uint32(stor12)
                                         gas gas_remaining wei
                                        args Mask(480, 0, stor16.field_0), mem[580 len 4]
                            else:
                                if wantLockedTotal >= ext_call.return_data[0]:
                                    if ext_call.return_data[0] > wantLockedTotal:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    wantLockedTotal -= ext_call.return_data[0]
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                    if ext_code.size(wantAddress) <= 0:
                                        revert with 0, 'Address: call to non-contract'
                                    mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), ext_call.return_data[0 len 28]
                                    mem[580 len 0] = 0
                                    call wantAddress with:
                                       funct uint32(stor12)
                                         gas gas_remaining wei
                                        args Mask(480, -256, ext_call.return_data[0 len 28]) << 256, mem[580 len 4]
                                else:
                                    if wantLockedTotal > wantLockedTotal:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    wantLockedTotal = 0
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                    if ext_code.size(wantAddress) <= 0:
                                        revert with 0, 'Address: call to non-contract'
                                    mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                    mem[580 len 0] = 0
                                    call wantAddress with:
                                       funct uint32(stor12)
                                         gas gas_remaining wei
                                        args Mask(480, 0, stor16.field_0), mem[580 len 4]
                            if not return_data.size:
                                require not ext_call.success
                                revert with 'SafeMath: division by zero'
                            mem[548 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                if return_data.size > 0:
                                    revert with ext_call.return_data[0 len return_data.size]
                                revert with 0, 'SafeERC20: low-level call failed'
                            if return_data.size > 0:
                                require return_data.size >= 32
                                if not mem[548]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x775361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[ceil32(return_data.size) + 627 len 22]
                        else:
                            if not arg2:
                                if not isAutoComp:
                                    require ext_code.size(wantAddress)
                                    staticcall wantAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if 0 <= ext_call.return_data[0]:
                                        if wantLockedTotal >= 0:
                                            if 0 > wantLockedTotal:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                            if ext_code.size(wantAddress) <= 0:
                                                revert with 0, 'Address: call to non-contract'
                                            mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), 0
                                            call wantAddress with:
                                               funct uint32(stor12)
                                                 gas gas_remaining wei
                                                args 0, mem[644 len 4]
                                        else:
                                            if wantLockedTotal > wantLockedTotal:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            wantLockedTotal = 0
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                            if ext_code.size(wantAddress) <= 0:
                                                revert with 0, 'Address: call to non-contract'
                                            mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                            mem[644 len 0] = 0
                                            call wantAddress with:
                                               funct uint32(stor12)
                                                 gas gas_remaining wei
                                                args Mask(480, 0, stor16.field_0), mem[644 len 4]
                                    else:
                                        if wantLockedTotal >= ext_call.return_data[0]:
                                            if ext_call.return_data[0] > wantLockedTotal:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            wantLockedTotal -= ext_call.return_data[0]
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                            if ext_code.size(wantAddress) <= 0:
                                                revert with 0, 'Address: call to non-contract'
                                            mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), ext_call.return_data[0 len 28]
                                            mem[644 len 0] = 0
                                            call wantAddress with:
                                               funct uint32(stor12)
                                                 gas gas_remaining wei
                                                args Mask(480, -256, ext_call.return_data[0 len 28]) << 256, mem[644 len 4]
                                        else:
                                            if wantLockedTotal > wantLockedTotal:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            wantLockedTotal = 0
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                            if ext_code.size(wantAddress) <= 0:
                                                revert with 0, 'Address: call to non-contract'
                                            mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                            mem[644 len 0] = 0
                                            call wantAddress with:
                                               funct uint32(stor12)
                                                 gas gas_remaining wei
                                                args Mask(480, 0, stor16.field_0), mem[644 len 4]
                                else:
                                    require ext_code.size(farmContractAddress)
                                    call farmContractAddress.withdraw(uint256 arg1, uint256 arg2) with:
                                         gas gas_remaining wei
                                        args pid, 0
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(wantAddress)
                                    staticcall wantAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if 0 <= ext_call.return_data[0]:
                                        if wantLockedTotal >= 0:
                                            if 0 > wantLockedTotal:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                            if ext_code.size(wantAddress) <= 0:
                                                revert with 0, 'Address: call to non-contract'
                                            mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), 0
                                            call wantAddress with:
                                               funct uint32(stor12)
                                                 gas gas_remaining wei
                                                args 0, mem[644 len 4]
                                        else:
                                            if wantLockedTotal > wantLockedTotal:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            wantLockedTotal = 0
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                            if ext_code.size(wantAddress) <= 0:
                                                revert with 0, 'Address: call to non-contract'
                                            mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                            call wantAddress with:
                                               funct uint32(stor12)
                                                 gas gas_remaining wei
                                                args Mask(480, 0, stor16.field_0), mem[644 len 4]
                                    else:
                                        if wantLockedTotal >= ext_call.return_data[0]:
                                            if ext_call.return_data[0] > wantLockedTotal:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            wantLockedTotal -= ext_call.return_data[0]
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                            if ext_code.size(wantAddress) <= 0:
                                                revert with 0, 'Address: call to non-contract'
                                            mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), ext_call.return_data[0 len 28]
                                            mem[644 len 0] = 0
                                            call wantAddress with:
                                               funct uint32(stor12)
                                                 gas gas_remaining wei
                                                args Mask(480, -256, ext_call.return_data[0 len 28]) << 256, mem[644 len 4]
                                        else:
                                            if wantLockedTotal > wantLockedTotal:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            wantLockedTotal = 0
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                            if ext_code.size(wantAddress) <= 0:
                                                revert with 0, 'Address: call to non-contract'
                                            mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                            mem[644 len 0] = 0
                                            call wantAddress with:
                                               funct uint32(stor12)
                                                 gas gas_remaining wei
                                                args Mask(480, 0, stor16.field_0), mem[644 len 4]
                            else:
                                require arg2
                                if arg2 * withdrawFeeFactor / arg2 != withdrawFeeFactor:
                                    revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                                if isAutoComp:
                                    require ext_code.size(farmContractAddress)
                                    call farmContractAddress.withdraw(uint256 arg1, uint256 arg2) with:
                                         gas gas_remaining wei
                                        args pid, arg2 * withdrawFeeFactor / 10000
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(wantAddress)
                                staticcall wantAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if arg2 * withdrawFeeFactor / 10000 <= ext_call.return_data[0]:
                                    if wantLockedTotal >= arg2 * withdrawFeeFactor / 10000:
                                        if arg2 * withdrawFeeFactor / 10000 > wantLockedTotal:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        wantLockedTotal -= arg2 * withdrawFeeFactor / 10000
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                        if ext_code.size(wantAddress) <= 0:
                                            revert with 0, 'Address: call to non-contract'
                                        mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 32, arg2 * withdrawFeeFactor / 10000) >> 32
                                        mem[644 len 0] = 0
                                        call wantAddress with:
                                           funct uint32(stor12)
                                             gas gas_remaining wei
                                            args Mask(224, 32, arg2 * withdrawFeeFactor / 10000) << 224, mem[644 len 4]
                                    else:
                                        if wantLockedTotal > wantLockedTotal:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        wantLockedTotal = 0
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                        if ext_code.size(wantAddress) <= 0:
                                            revert with 0, 'Address: call to non-contract'
                                        mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                        mem[644 len 0] = 0
                                        call wantAddress with:
                                           funct uint32(stor12)
                                             gas gas_remaining wei
                                            args Mask(480, 0, stor16.field_0), mem[644 len 4]
                                else:
                                    if wantLockedTotal >= ext_call.return_data[0]:
                                        if ext_call.return_data[0] > wantLockedTotal:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        wantLockedTotal -= ext_call.return_data[0]
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                        if ext_code.size(wantAddress) <= 0:
                                            revert with 0, 'Address: call to non-contract'
                                        mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), ext_call.return_data[0 len 28]
                                        mem[644 len 0] = 0
                                        call wantAddress with:
                                           funct uint32(stor12)
                                             gas gas_remaining wei
                                            args Mask(480, -256, ext_call.return_data[0 len 28]) << 256, mem[644 len 4]
                                    else:
                                        if wantLockedTotal > wantLockedTotal:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        wantLockedTotal = 0
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                        if ext_code.size(wantAddress) <= 0:
                                            revert with 0, 'Address: call to non-contract'
                                        mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                        mem[644 len 0] = 0
                                        call wantAddress with:
                                           funct uint32(stor12)
                                             gas gas_remaining wei
                                            args Mask(480, 0, stor16.field_0), mem[644 len 4]
                            if not return_data.size:
                                require not ext_call.success
                                revert with 'SafeMath: division by zero'
                            mem[612 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                if return_data.size > 0:
                                    revert with ext_call.return_data[0 len return_data.size]
                                revert with 0, 'SafeERC20: low-level call failed'
                            if return_data.size > 0:
                                require return_data.size >= 32
                                if not mem[612]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x775361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[ceil32(return_data.size) + 691 len 22]
                    else:
                        require arg2
                        if arg2 * sub_9ccccc15 / arg2 != sub_9ccccc15:
                            revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                        if withdrawFeeFactor >= 10000:
                            if arg2 * sub_9ccccc15 / 10000 <= 0:
                                if not isAutoComp:
                                    require ext_code.size(wantAddress)
                                    staticcall wantAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if arg2 <= ext_call.return_data[0]:
                                        if wantLockedTotal < arg2:
                                            if wantLockedTotal > wantLockedTotal:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            wantLockedTotal = 0
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                            if ext_code.size(wantAddress) <= 0:
                                                revert with 0, 'Address: call to non-contract'
                                            mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                            call wantAddress with:
                                               funct uint32(stor12)
                                                 gas gas_remaining wei
                                                args Mask(480, 0, stor16.field_0), mem[580 len 4]
                                        else:
                                            if arg2 > wantLockedTotal:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            wantLockedTotal -= arg2
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                            if ext_code.size(wantAddress) <= 0:
                                                revert with 0, 'Address: call to non-contract'
                                            mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 32, arg2) >> 32
                                            mem[580 len 0] = 0
                                            call wantAddress with:
                                               funct uint32(stor12)
                                                 gas gas_remaining wei
                                                args Mask(224, 32, arg2) << 224, mem[580 len 4]
                                    else:
                                        if wantLockedTotal >= ext_call.return_data[0]:
                                            if ext_call.return_data[0] > wantLockedTotal:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            wantLockedTotal -= ext_call.return_data[0]
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                            if ext_code.size(wantAddress) <= 0:
                                                revert with 0, 'Address: call to non-contract'
                                            mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), ext_call.return_data[0 len 28]
                                            mem[580 len 0] = 0
                                            call wantAddress with:
                                               funct uint32(stor12)
                                                 gas gas_remaining wei
                                                args Mask(480, -256, ext_call.return_data[0 len 28]) << 256, mem[580 len 4]
                                        else:
                                            if wantLockedTotal > wantLockedTotal:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            wantLockedTotal = 0
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                            if ext_code.size(wantAddress) <= 0:
                                                revert with 0, 'Address: call to non-contract'
                                            mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                            mem[580 len 0] = 0
                                            call wantAddress with:
                                               funct uint32(stor12)
                                                 gas gas_remaining wei
                                                args Mask(480, 0, stor16.field_0), mem[580 len 4]
                                else:
                                    require ext_code.size(farmContractAddress)
                                    call farmContractAddress.withdraw(uint256 arg1, uint256 arg2) with:
                                         gas gas_remaining wei
                                        args pid, arg2
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(wantAddress)
                                    staticcall wantAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if arg2 <= ext_call.return_data[0]:
                                        if wantLockedTotal >= arg2:
                                            if arg2 > wantLockedTotal:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            wantLockedTotal -= arg2
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                            if ext_code.size(wantAddress) <= 0:
                                                revert with 0, 'Address: call to non-contract'
                                            mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 32, arg2) >> 32
                                            mem[580 len 0] = 0
                                            call wantAddress with:
                                               funct uint32(stor12)
                                                 gas gas_remaining wei
                                                args Mask(224, 32, arg2) << 224, mem[580 len 4]
                                        else:
                                            if wantLockedTotal > wantLockedTotal:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            wantLockedTotal = 0
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                            if ext_code.size(wantAddress) <= 0:
                                                revert with 0, 'Address: call to non-contract'
                                            mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                            mem[580 len 0] = 0
                                            call wantAddress with:
                                               funct uint32(stor12)
                                                 gas gas_remaining wei
                                                args Mask(480, 0, stor16.field_0), mem[580 len 4]
                                    else:
                                        if wantLockedTotal < ext_call.return_data[0]:
                                            if wantLockedTotal > wantLockedTotal:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            wantLockedTotal = 0
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                            if ext_code.size(wantAddress) <= 0:
                                                revert with 0, 'Address: call to non-contract'
                                            mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                            call wantAddress with:
                                               funct uint32(stor12)
                                                 gas gas_remaining wei
                                                args Mask(480, 0, stor16.field_0), mem[580 len 4]
                                        else:
                                            if ext_call.return_data[0] > wantLockedTotal:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            wantLockedTotal -= ext_call.return_data[0]
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                            if ext_code.size(wantAddress) <= 0:
                                                revert with 0, 'Address: call to non-contract'
                                            mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), ext_call.return_data[0 len 28]
                                            mem[580 len 0] = 0
                                            call wantAddress with:
                                               funct uint32(stor12)
                                                 gas gas_remaining wei
                                                args Mask(480, -256, ext_call.return_data[0 len 28]) << 256, mem[580 len 4]
                            else:
                                if not isAutoComp:
                                    require ext_code.size(wantAddress)
                                    staticcall wantAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if arg2 - (arg2 * sub_9ccccc15 / 10000) > ext_call.return_data[0]:
                                        if wantLockedTotal >= ext_call.return_data[0]:
                                            if ext_call.return_data[0] > wantLockedTotal:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            wantLockedTotal -= ext_call.return_data[0]
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                            if ext_code.size(wantAddress) <= 0:
                                                revert with 0, 'Address: call to non-contract'
                                            mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), ext_call.return_data[0 len 28]
                                            call wantAddress with:
                                               funct uint32(stor12)
                                                 gas gas_remaining wei
                                                args Mask(480, -256, ext_call.return_data[0 len 28]) << 256, mem[580 len 4]
                                        else:
                                            if wantLockedTotal > wantLockedTotal:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            wantLockedTotal = 0
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                            if ext_code.size(wantAddress) <= 0:
                                                revert with 0, 'Address: call to non-contract'
                                            mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                            call wantAddress with:
                                               funct uint32(stor12)
                                                 gas gas_remaining wei
                                                args Mask(480, 0, stor16.field_0), mem[580 len 4]
                                    else:
                                        if wantLockedTotal >= arg2 - (arg2 * sub_9ccccc15 / 10000):
                                            if arg2 - (arg2 * sub_9ccccc15 / 10000) > wantLockedTotal:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            wantLockedTotal = wantLockedTotal - arg2 + (arg2 * sub_9ccccc15 / 10000)
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                            if ext_code.size(wantAddress) <= 0:
                                                revert with 0, 'Address: call to non-contract'
                                            mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 32, arg2 - (arg2 * sub_9ccccc15 / 10000)) >> 32
                                            mem[580 len 0] = 0
                                            call wantAddress with:
                                               funct uint32(stor12)
                                                 gas gas_remaining wei
                                                args Mask(224, 32, arg2 - (arg2 * sub_9ccccc15 / 10000)) << 224, mem[580 len 4]
                                        else:
                                            if wantLockedTotal > wantLockedTotal:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            wantLockedTotal = 0
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                            if ext_code.size(wantAddress) <= 0:
                                                revert with 0, 'Address: call to non-contract'
                                            mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                            mem[580 len 0] = 0
                                            call wantAddress with:
                                               funct uint32(stor12)
                                                 gas gas_remaining wei
                                                args Mask(480, 0, stor16.field_0), mem[580 len 4]
                                else:
                                    require ext_code.size(farmContractAddress)
                                    call farmContractAddress.withdraw(uint256 arg1, uint256 arg2) with:
                                         gas gas_remaining wei
                                        args pid, arg2 - (arg2 * sub_9ccccc15 / 10000)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(wantAddress)
                                    staticcall wantAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if arg2 - (arg2 * sub_9ccccc15 / 10000) <= ext_call.return_data[0]:
                                        if wantLockedTotal >= arg2 - (arg2 * sub_9ccccc15 / 10000):
                                            if arg2 - (arg2 * sub_9ccccc15 / 10000) > wantLockedTotal:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            wantLockedTotal = wantLockedTotal - arg2 + (arg2 * sub_9ccccc15 / 10000)
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                            if ext_code.size(wantAddress) <= 0:
                                                revert with 0, 'Address: call to non-contract'
                                            mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 32, arg2 - (arg2 * sub_9ccccc15 / 10000)) >> 32
                                            call wantAddress with:
                                               funct uint32(stor12)
                                                 gas gas_remaining wei
                                                args Mask(224, 32, arg2 - (arg2 * sub_9ccccc15 / 10000)) << 224, mem[580 len 4]
                                        else:
                                            if wantLockedTotal > wantLockedTotal:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            wantLockedTotal = 0
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                            if ext_code.size(wantAddress) <= 0:
                                                revert with 0, 'Address: call to non-contract'
                                            mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                            mem[580 len 0] = 0
                                            call wantAddress with:
                                               funct uint32(stor12)
                                                 gas gas_remaining wei
                                                args Mask(480, 0, stor16.field_0), mem[580 len 4]
                                    else:
                                        if wantLockedTotal >= ext_call.return_data[0]:
                                            if ext_call.return_data[0] > wantLockedTotal:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            wantLockedTotal -= ext_call.return_data[0]
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                            if ext_code.size(wantAddress) <= 0:
                                                revert with 0, 'Address: call to non-contract'
                                            mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), ext_call.return_data[0 len 28]
                                            call wantAddress with:
                                               funct uint32(stor12)
                                                 gas gas_remaining wei
                                                args Mask(480, -256, ext_call.return_data[0 len 28]) << 256, mem[580 len 4]
                                        else:
                                            if wantLockedTotal > wantLockedTotal:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            wantLockedTotal = 0
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                            if ext_code.size(wantAddress) <= 0:
                                                revert with 0, 'Address: call to non-contract'
                                            mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                            mem[580 len 0] = 0
                                            call wantAddress with:
                                               funct uint32(stor12)
                                                 gas gas_remaining wei
                                                args Mask(480, 0, stor16.field_0), mem[580 len 4]
                            if not return_data.size:
                                require not ext_call.success
                                revert with 'SafeMath: division by zero'
                            mem[548 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                if return_data.size > 0:
                                    revert with ext_call.return_data[0 len return_data.size]
                                revert with 0, 'SafeERC20: low-level call failed'
                            if return_data.size > 0:
                                require return_data.size >= 32
                                if not mem[548]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x775361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[ceil32(return_data.size) + 627 len 22]
                        else:
                            if not arg2:
                                if arg2 * sub_9ccccc15 / 10000 <= 0:
                                    if not isAutoComp:
                                        require ext_code.size(wantAddress)
                                        staticcall wantAddress.0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if 0 <= ext_call.return_data[0]:
                                            if wantLockedTotal >= 0:
                                                if 0 > wantLockedTotal:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if eth.balance(this.address) < 0:
                                                    revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                                if ext_code.size(wantAddress) <= 0:
                                                    revert with 0, 'Address: call to non-contract'
                                                mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), 0
                                                call wantAddress with:
                                                   funct uint32(stor12)
                                                     gas gas_remaining wei
                                                    args 0, mem[644 len 4]
                                            else:
                                                if wantLockedTotal > wantLockedTotal:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                wantLockedTotal = 0
                                                if eth.balance(this.address) < 0:
                                                    revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                                if ext_code.size(wantAddress) <= 0:
                                                    revert with 0, 'Address: call to non-contract'
                                                mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                                mem[644 len 0] = 0
                                                call wantAddress with:
                                                   funct uint32(stor12)
                                                     gas gas_remaining wei
                                                    args Mask(480, 0, stor16.field_0), mem[644 len 4]
                                        else:
                                            if wantLockedTotal < ext_call.return_data[0]:
                                                if wantLockedTotal > wantLockedTotal:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                wantLockedTotal = 0
                                                if eth.balance(this.address) < 0:
                                                    revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                                if ext_code.size(wantAddress) <= 0:
                                                    revert with 0, 'Address: call to non-contract'
                                                mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                                call wantAddress with:
                                                   funct uint32(stor12)
                                                     gas gas_remaining wei
                                                    args Mask(480, 0, stor16.field_0), mem[644 len 4]
                                            else:
                                                if ext_call.return_data[0] > wantLockedTotal:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                wantLockedTotal -= ext_call.return_data[0]
                                                if eth.balance(this.address) < 0:
                                                    revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                                if ext_code.size(wantAddress) <= 0:
                                                    revert with 0, 'Address: call to non-contract'
                                                mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), ext_call.return_data[0 len 28]
                                                mem[644 len 0] = 0
                                                call wantAddress with:
                                                   funct uint32(stor12)
                                                     gas gas_remaining wei
                                                    args Mask(480, -256, ext_call.return_data[0 len 28]) << 256, mem[644 len 4]
                                    else:
                                        require ext_code.size(farmContractAddress)
                                        call farmContractAddress.withdraw(uint256 arg1, uint256 arg2) with:
                                             gas gas_remaining wei
                                            args pid, 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require ext_code.size(wantAddress)
                                        staticcall wantAddress.0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if 0 <= ext_call.return_data[0]:
                                            if wantLockedTotal >= 0:
                                                if 0 > wantLockedTotal:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if eth.balance(this.address) < 0:
                                                    revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                                if ext_code.size(wantAddress) <= 0:
                                                    revert with 0, 'Address: call to non-contract'
                                                mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), 0
                                                mem[644 len 0] = 0
                                                call wantAddress with:
                                                   funct uint32(stor12)
                                                     gas gas_remaining wei
                                                    args Mask(480, -256, unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), 0) << 256, mem[644 len 4]
                                            else:
                                                if wantLockedTotal > wantLockedTotal:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                wantLockedTotal = 0
                                                if eth.balance(this.address) < 0:
                                                    revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                                if ext_code.size(wantAddress) <= 0:
                                                    revert with 0, 'Address: call to non-contract'
                                                mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                                call wantAddress with:
                                                   funct uint32(stor12)
                                                     gas gas_remaining wei
                                                    args Mask(480, 0, stor16.field_0), mem[644 len 4]
                                        else:
                                            if wantLockedTotal >= ext_call.return_data[0]:
                                                if ext_call.return_data[0] > wantLockedTotal:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                wantLockedTotal -= ext_call.return_data[0]
                                                if eth.balance(this.address) < 0:
                                                    revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                                if ext_code.size(wantAddress) <= 0:
                                                    revert with 0, 'Address: call to non-contract'
                                                mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), ext_call.return_data[0 len 28]
                                                call wantAddress with:
                                                   funct uint32(stor12)
                                                     gas gas_remaining wei
                                                    args Mask(480, -256, ext_call.return_data[0 len 28]) << 256, mem[644 len 4]
                                            else:
                                                if wantLockedTotal > wantLockedTotal:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                wantLockedTotal = 0
                                                if eth.balance(this.address) < 0:
                                                    revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                                if ext_code.size(wantAddress) <= 0:
                                                    revert with 0, 'Address: call to non-contract'
                                                mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                                mem[644 len 0] = 0
                                                call wantAddress with:
                                                   funct uint32(stor12)
                                                     gas gas_remaining wei
                                                    args Mask(480, 0, stor16.field_0), mem[644 len 4]
                                else:
                                    if not isAutoComp:
                                        require ext_code.size(wantAddress)
                                        staticcall wantAddress.0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if -arg2 * sub_9ccccc15 / 10000 <= ext_call.return_data[0]:
                                            if wantLockedTotal >= -arg2 * sub_9ccccc15 / 10000:
                                                if -arg2 * sub_9ccccc15 / 10000 > wantLockedTotal:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                wantLockedTotal += arg2 * sub_9ccccc15 / 10000
                                                if eth.balance(this.address) < 0:
                                                    revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                                if ext_code.size(wantAddress) <= 0:
                                                    revert with 0, 'Address: call to non-contract'
                                                mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 32, -arg2 * sub_9ccccc15 / 10000) >> 32
                                                mem[644 len 0] = 0
                                                call wantAddress with:
                                                   funct uint32(stor12)
                                                     gas gas_remaining wei
                                                    args Mask(224, 32, -arg2 * sub_9ccccc15 / 10000) << 224, mem[644 len 4]
                                            else:
                                                if wantLockedTotal > wantLockedTotal:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                wantLockedTotal = 0
                                                if eth.balance(this.address) < 0:
                                                    revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                                if ext_code.size(wantAddress) <= 0:
                                                    revert with 0, 'Address: call to non-contract'
                                                mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                                mem[644 len 0] = 0
                                                call wantAddress with:
                                                   funct uint32(stor12)
                                                     gas gas_remaining wei
                                                    args Mask(480, 0, stor16.field_0), mem[644 len 4]
                                        else:
                                            if wantLockedTotal >= ext_call.return_data[0]:
                                                if ext_call.return_data[0] > wantLockedTotal:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                wantLockedTotal -= ext_call.return_data[0]
                                                if eth.balance(this.address) < 0:
                                                    revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                                if ext_code.size(wantAddress) <= 0:
                                                    revert with 0, 'Address: call to non-contract'
                                                mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), ext_call.return_data[0 len 28]
                                                mem[644 len 0] = 0
                                                call wantAddress with:
                                                   funct uint32(stor12)
                                                     gas gas_remaining wei
                                                    args Mask(480, -256, ext_call.return_data[0 len 28]) << 256, mem[644 len 4]
                                            else:
                                                if wantLockedTotal > wantLockedTotal:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                wantLockedTotal = 0
                                                if eth.balance(this.address) < 0:
                                                    revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                                if ext_code.size(wantAddress) <= 0:
                                                    revert with 0, 'Address: call to non-contract'
                                                mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                                mem[644 len 0] = 0
                                                call wantAddress with:
                                                   funct uint32(stor12)
                                                     gas gas_remaining wei
                                                    args Mask(480, 0, stor16.field_0), mem[644 len 4]
                                    else:
                                        require ext_code.size(farmContractAddress)
                                        call farmContractAddress.withdraw(uint256 arg1, uint256 arg2) with:
                                             gas gas_remaining wei
                                            args pid, -arg2 * sub_9ccccc15 / 10000
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require ext_code.size(wantAddress)
                                        staticcall wantAddress.0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if -arg2 * sub_9ccccc15 / 10000 <= ext_call.return_data[0]:
                                            if wantLockedTotal >= -arg2 * sub_9ccccc15 / 10000:
                                                if -arg2 * sub_9ccccc15 / 10000 > wantLockedTotal:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                wantLockedTotal += arg2 * sub_9ccccc15 / 10000
                                                if eth.balance(this.address) < 0:
                                                    revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                                if ext_code.size(wantAddress) <= 0:
                                                    revert with 0, 'Address: call to non-contract'
                                                mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 32, -arg2 * sub_9ccccc15 / 10000) >> 32
                                                call wantAddress with:
                                                   funct uint32(stor12)
                                                     gas gas_remaining wei
                                                    args Mask(224, 32, -arg2 * sub_9ccccc15 / 10000) << 224, mem[644 len 4]
                                            else:
                                                if wantLockedTotal > wantLockedTotal:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                wantLockedTotal = 0
                                                if eth.balance(this.address) < 0:
                                                    revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                                if ext_code.size(wantAddress) <= 0:
                                                    revert with 0, 'Address: call to non-contract'
                                                mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                                call wantAddress with:
                                                   funct uint32(stor12)
                                                     gas gas_remaining wei
                                                    args Mask(480, 0, stor16.field_0), mem[644 len 4]
                                        else:
                                            if wantLockedTotal >= ext_call.return_data[0]:
                                                if ext_call.return_data[0] > wantLockedTotal:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                wantLockedTotal -= ext_call.return_data[0]
                                                if eth.balance(this.address) < 0:
                                                    revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                                if ext_code.size(wantAddress) <= 0:
                                                    revert with 0, 'Address: call to non-contract'
                                                mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), ext_call.return_data[0 len 28]
                                                call wantAddress with:
                                                   funct uint32(stor12)
                                                     gas gas_remaining wei
                                                    args Mask(480, -256, ext_call.return_data[0 len 28]) << 256, mem[644 len 4]
                                            else:
                                                if wantLockedTotal > wantLockedTotal:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                wantLockedTotal = 0
                                                if eth.balance(this.address) < 0:
                                                    revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                                if ext_code.size(wantAddress) <= 0:
                                                    revert with 0, 'Address: call to non-contract'
                                                mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                                mem[644 len 0] = 0
                                                call wantAddress with:
                                                   funct uint32(stor12)
                                                     gas gas_remaining wei
                                                    args Mask(480, 0, stor16.field_0), mem[644 len 4]
                            else:
                                require arg2
                                if arg2 * withdrawFeeFactor / arg2 != withdrawFeeFactor:
                                    revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                                if arg2 * sub_9ccccc15 / 10000 <= 0:
                                    if isAutoComp:
                                        require ext_code.size(farmContractAddress)
                                        call farmContractAddress.withdraw(uint256 arg1, uint256 arg2) with:
                                             gas gas_remaining wei
                                            args pid, arg2 * withdrawFeeFactor / 10000
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(wantAddress)
                                    staticcall wantAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if arg2 * withdrawFeeFactor / 10000 <= ext_call.return_data[0]:
                                        if wantLockedTotal >= arg2 * withdrawFeeFactor / 10000:
                                            if arg2 * withdrawFeeFactor / 10000 > wantLockedTotal:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            wantLockedTotal -= arg2 * withdrawFeeFactor / 10000
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                            if ext_code.size(wantAddress) <= 0:
                                                revert with 0, 'Address: call to non-contract'
                                            mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 32, arg2 * withdrawFeeFactor / 10000) >> 32
                                            mem[644 len 0] = 0
                                            call wantAddress with:
                                               funct uint32(stor12)
                                                 gas gas_remaining wei
                                                args Mask(224, 32, arg2 * withdrawFeeFactor / 10000) << 224, mem[644 len 4]
                                        else:
                                            if wantLockedTotal > wantLockedTotal:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            wantLockedTotal = 0
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                            if ext_code.size(wantAddress) <= 0:
                                                revert with 0, 'Address: call to non-contract'
                                            mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                            mem[644 len 0] = 0
                                            call wantAddress with:
                                               funct uint32(stor12)
                                                 gas gas_remaining wei
                                                args Mask(480, 0, stor16.field_0), mem[644 len 4]
                                    else:
                                        if wantLockedTotal < ext_call.return_data[0]:
                                            if wantLockedTotal > wantLockedTotal:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            wantLockedTotal = 0
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                            if ext_code.size(wantAddress) <= 0:
                                                revert with 0, 'Address: call to non-contract'
                                            mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                            call wantAddress with:
                                               funct uint32(stor12)
                                                 gas gas_remaining wei
                                                args Mask(480, 0, stor16.field_0), mem[644 len 4]
                                        else:
                                            if ext_call.return_data[0] > wantLockedTotal:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            wantLockedTotal -= ext_call.return_data[0]
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                            if ext_code.size(wantAddress) <= 0:
                                                revert with 0, 'Address: call to non-contract'
                                            mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), ext_call.return_data[0 len 28]
                                            mem[644 len 0] = 0
                                            call wantAddress with:
                                               funct uint32(stor12)
                                                 gas gas_remaining wei
                                                args Mask(480, -256, ext_call.return_data[0 len 28]) << 256, mem[644 len 4]
                                else:
                                    if not isAutoComp:
                                        require ext_code.size(wantAddress)
                                        staticcall wantAddress.0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if (arg2 * withdrawFeeFactor / 10000) - (arg2 * sub_9ccccc15 / 10000) > ext_call.return_data[0]:
                                            if wantLockedTotal >= ext_call.return_data[0]:
                                                if ext_call.return_data[0] > wantLockedTotal:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                wantLockedTotal -= ext_call.return_data[0]
                                                if eth.balance(this.address) < 0:
                                                    revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                                if ext_code.size(wantAddress) <= 0:
                                                    revert with 0, 'Address: call to non-contract'
                                                mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), ext_call.return_data[0 len 28]
                                                call wantAddress with:
                                                   funct uint32(stor12)
                                                     gas gas_remaining wei
                                                    args Mask(480, -256, ext_call.return_data[0 len 28]) << 256, mem[644 len 4]
                                            else:
                                                if wantLockedTotal > wantLockedTotal:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                wantLockedTotal = 0
                                                if eth.balance(this.address) < 0:
                                                    revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                                if ext_code.size(wantAddress) <= 0:
                                                    revert with 0, 'Address: call to non-contract'
                                                mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                                call wantAddress with:
                                                   funct uint32(stor12)
                                                     gas gas_remaining wei
                                                    args Mask(480, 0, stor16.field_0), mem[644 len 4]
                                        else:
                                            if wantLockedTotal < (arg2 * withdrawFeeFactor / 10000) - (arg2 * sub_9ccccc15 / 10000):
                                                if wantLockedTotal > wantLockedTotal:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                wantLockedTotal = 0
                                                if eth.balance(this.address) < 0:
                                                    revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                                if ext_code.size(wantAddress) <= 0:
                                                    revert with 0, 'Address: call to non-contract'
                                                mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                                call wantAddress with:
                                                   funct uint32(stor12)
                                                     gas gas_remaining wei
                                                    args Mask(480, 0, stor16.field_0), mem[644 len 4]
                                            else:
                                                if (arg2 * withdrawFeeFactor / 10000) - (arg2 * sub_9ccccc15 / 10000) > wantLockedTotal:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                wantLockedTotal = wantLockedTotal - (arg2 * withdrawFeeFactor / 10000) + (arg2 * sub_9ccccc15 / 10000)
                                                if eth.balance(this.address) < 0:
                                                    revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                                if ext_code.size(wantAddress) <= 0:
                                                    revert with 0, 'Address: call to non-contract'
                                                mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 32, (arg2 * withdrawFeeFactor / 10000) - (arg2 * sub_9ccccc15 / 10000)) >> 32
                                                mem[644 len 0] = 0
                                                call wantAddress with:
                                                   funct uint32(stor12)
                                                     gas gas_remaining wei
                                                    args Mask(224, 32, (arg2 * withdrawFeeFactor / 10000) - (arg2 * sub_9ccccc15 / 10000)) << 224, mem[644 len 4]
                                    else:
                                        require ext_code.size(farmContractAddress)
                                        call farmContractAddress.withdraw(uint256 arg1, uint256 arg2) with:
                                             gas gas_remaining wei
                                            args pid, (arg2 * withdrawFeeFactor / 10000) - (arg2 * sub_9ccccc15 / 10000)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require ext_code.size(wantAddress)
                                        staticcall wantAddress.0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if (arg2 * withdrawFeeFactor / 10000) - (arg2 * sub_9ccccc15 / 10000) > ext_call.return_data[0]:
                                            if wantLockedTotal >= ext_call.return_data[0]:
                                                if ext_call.return_data[0] > wantLockedTotal:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                wantLockedTotal -= ext_call.return_data[0]
                                                if eth.balance(this.address) < 0:
                                                    revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                                if ext_code.size(wantAddress) <= 0:
                                                    revert with 0, 'Address: call to non-contract'
                                                mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), ext_call.return_data[0 len 28]
                                                call wantAddress with:
                                                   funct uint32(stor12)
                                                     gas gas_remaining wei
                                                    args Mask(480, -256, ext_call.return_data[0 len 28]) << 256, mem[644 len 4]
                                            else:
                                                if wantLockedTotal > wantLockedTotal:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                wantLockedTotal = 0
                                                if eth.balance(this.address) < 0:
                                                    revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                                if ext_code.size(wantAddress) <= 0:
                                                    revert with 0, 'Address: call to non-contract'
                                                mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                                call wantAddress with:
                                                   funct uint32(stor12)
                                                     gas gas_remaining wei
                                                    args Mask(480, 0, stor16.field_0), mem[644 len 4]
                                        else:
                                            if wantLockedTotal >= (arg2 * withdrawFeeFactor / 10000) - (arg2 * sub_9ccccc15 / 10000):
                                                if (arg2 * withdrawFeeFactor / 10000) - (arg2 * sub_9ccccc15 / 10000) > wantLockedTotal:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                wantLockedTotal = wantLockedTotal - (arg2 * withdrawFeeFactor / 10000) + (arg2 * sub_9ccccc15 / 10000)
                                                if eth.balance(this.address) < 0:
                                                    revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                                if ext_code.size(wantAddress) <= 0:
                                                    revert with 0, 'Address: call to non-contract'
                                                mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 32, (arg2 * withdrawFeeFactor / 10000) - (arg2 * sub_9ccccc15 / 10000)) >> 32
                                                call wantAddress with:
                                                   funct uint32(stor12)
                                                     gas gas_remaining wei
                                                    args Mask(224, 32, (arg2 * withdrawFeeFactor / 10000) - (arg2 * sub_9ccccc15 / 10000)) << 224, mem[644 len 4]
                                            else:
                                                if wantLockedTotal > wantLockedTotal:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                wantLockedTotal = 0
                                                if eth.balance(this.address) < 0:
                                                    revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                                if ext_code.size(wantAddress) <= 0:
                                                    revert with 0, 'Address: call to non-contract'
                                                mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                                mem[644 len 0] = 0
                                                call wantAddress with:
                                                   funct uint32(stor12)
                                                     gas gas_remaining wei
                                                    args Mask(480, 0, stor16.field_0), mem[644 len 4]
                            if not return_data.size:
                                require not ext_call.success
                                revert with 'SafeMath: division by zero'
                            mem[612 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                if return_data.size > 0:
                                    revert with ext_call.return_data[0 len return_data.size]
                                revert with 0, 'SafeERC20: low-level call failed'
                            if return_data.size > 0:
                                require return_data.size >= 32
                                if not mem[612]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x775361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[ceil32(return_data.size) + 691 len 22]
            stor1 = 1
            return (0 / wantLockedTotal)
        if sharesTotal > sharesTotal:
            revert with 0, 'SafeMath: subtraction overflow'
        sharesTotal = 0
        if sub_9ccccc15 <= 0:
            if withdrawFeeFactor >= 10000:
                if not isAutoComp:
                    require ext_code.size(wantAddress)
                    staticcall wantAddress.0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if arg2 > ext_call.return_data[0]:
                        if wantLockedTotal >= ext_call.return_data[0]:
                            if ext_call.return_data[0] > wantLockedTotal:
                                revert with 0, 'SafeMath: subtraction overflow'
                            wantLockedTotal -= ext_call.return_data[0]
                            if eth.balance(this.address) < 0:
                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[558 len 26]
                            if ext_code.size(wantAddress) <= 0:
                                revert with 0, 'Address: call to non-contract'
                            mem[452 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), ext_call.return_data[0 len 28]
                            call wantAddress with:
                               funct uint32(stor12)
                                 gas gas_remaining wei
                                args Mask(480, -256, ext_call.return_data[0 len 28]) << 256, mem[516 len 4]
                        else:
                            if wantLockedTotal > wantLockedTotal:
                                revert with 0, 'SafeMath: subtraction overflow'
                            wantLockedTotal = 0
                            if eth.balance(this.address) < 0:
                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[558 len 26]
                            if ext_code.size(wantAddress) <= 0:
                                revert with 0, 'Address: call to non-contract'
                            mem[452 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                            call wantAddress with:
                               funct uint32(stor12)
                                 gas gas_remaining wei
                                args Mask(480, 0, stor16.field_0), mem[516 len 4]
                    else:
                        if wantLockedTotal < arg2:
                            if wantLockedTotal > wantLockedTotal:
                                revert with 0, 'SafeMath: subtraction overflow'
                            wantLockedTotal = 0
                            if eth.balance(this.address) < 0:
                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[558 len 26]
                            if ext_code.size(wantAddress) <= 0:
                                revert with 0, 'Address: call to non-contract'
                            mem[452 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                            call wantAddress with:
                               funct uint32(stor12)
                                 gas gas_remaining wei
                                args Mask(480, 0, stor16.field_0), mem[516 len 4]
                        else:
                            if arg2 > wantLockedTotal:
                                revert with 0, 'SafeMath: subtraction overflow'
                            wantLockedTotal -= arg2
                            if eth.balance(this.address) < 0:
                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[558 len 26]
                            if ext_code.size(wantAddress) <= 0:
                                revert with 0, 'Address: call to non-contract'
                            mem[452 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 32, arg2) >> 32
                            mem[516 len 0] = 0
                            call wantAddress with:
                               funct uint32(stor12)
                                 gas gas_remaining wei
                                args Mask(224, 32, arg2) << 224, mem[516 len 4]
                else:
                    require ext_code.size(farmContractAddress)
                    call farmContractAddress.withdraw(uint256 arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args pid, arg2
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require ext_code.size(wantAddress)
                    staticcall wantAddress.0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if arg2 <= ext_call.return_data[0]:
                        if wantLockedTotal >= arg2:
                            if arg2 > wantLockedTotal:
                                revert with 0, 'SafeMath: subtraction overflow'
                            wantLockedTotal -= arg2
                            if eth.balance(this.address) < 0:
                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[558 len 26]
                            if ext_code.size(wantAddress) <= 0:
                                revert with 0, 'Address: call to non-contract'
                            mem[452 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 32, arg2) >> 32
                            call wantAddress with:
                               funct uint32(stor12)
                                 gas gas_remaining wei
                                args Mask(224, 32, arg2) << 224, mem[516 len 4]
                        else:
                            if wantLockedTotal > wantLockedTotal:
                                revert with 0, 'SafeMath: subtraction overflow'
                            wantLockedTotal = 0
                            if eth.balance(this.address) < 0:
                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[558 len 26]
                            if ext_code.size(wantAddress) <= 0:
                                revert with 0, 'Address: call to non-contract'
                            mem[452 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                            mem[516 len 0] = 0
                            call wantAddress with:
                               funct uint32(stor12)
                                 gas gas_remaining wei
                                args Mask(480, 0, stor16.field_0), mem[516 len 4]
                    else:
                        if wantLockedTotal >= ext_call.return_data[0]:
                            if ext_call.return_data[0] > wantLockedTotal:
                                revert with 0, 'SafeMath: subtraction overflow'
                            wantLockedTotal -= ext_call.return_data[0]
                            if eth.balance(this.address) < 0:
                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[558 len 26]
                            if ext_code.size(wantAddress) <= 0:
                                revert with 0, 'Address: call to non-contract'
                            mem[452 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), ext_call.return_data[0 len 28]
                            call wantAddress with:
                               funct uint32(stor12)
                                 gas gas_remaining wei
                                args Mask(480, -256, ext_call.return_data[0 len 28]) << 256, mem[516 len 4]
                        else:
                            if wantLockedTotal > wantLockedTotal:
                                revert with 0, 'SafeMath: subtraction overflow'
                            wantLockedTotal = 0
                            if eth.balance(this.address) < 0:
                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[558 len 26]
                            if ext_code.size(wantAddress) <= 0:
                                revert with 0, 'Address: call to non-contract'
                            mem[452 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                            mem[516 len 0] = 0
                            call wantAddress with:
                               funct uint32(stor12)
                                 gas gas_remaining wei
                                args Mask(480, 0, stor16.field_0), mem[516 len 4]
                if not return_data.size:
                    require not ext_call.success
                    revert with 'SafeMath: division by zero'
                mem[484 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not ext_call.success:
                    if return_data.size > 0:
                        revert with ext_call.return_data[0 len return_data.size]
                    revert with 0, 'SafeERC20: low-level call failed'
                if return_data.size > 0:
                    require return_data.size >= 32
                    if not mem[484]:
                        revert with 0, 
                                    32,
                                    42,
                                    0x775361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                    mem[ceil32(return_data.size) + 563 len 22]
            else:
                if not arg2:
                    if not isAutoComp:
                        require ext_code.size(wantAddress)
                        staticcall wantAddress.0x70a08231 with:
                                gas gas_remaining wei
                               args this.address
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if 0 <= ext_call.return_data[0]:
                            if wantLockedTotal >= 0:
                                if 0 > wantLockedTotal:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if eth.balance(this.address) < 0:
                                    revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                if ext_code.size(wantAddress) <= 0:
                                    revert with 0, 'Address: call to non-contract'
                                mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), 0
                                call wantAddress with:
                                   funct uint32(stor12)
                                     gas gas_remaining wei
                                    args 0, mem[580 len 4]
                            else:
                                if wantLockedTotal > wantLockedTotal:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                wantLockedTotal = 0
                                if eth.balance(this.address) < 0:
                                    revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                if ext_code.size(wantAddress) <= 0:
                                    revert with 0, 'Address: call to non-contract'
                                mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                call wantAddress with:
                                   funct uint32(stor12)
                                     gas gas_remaining wei
                                    args Mask(480, 0, stor16.field_0), mem[580 len 4]
                        else:
                            if wantLockedTotal >= ext_call.return_data[0]:
                                if ext_call.return_data[0] > wantLockedTotal:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                wantLockedTotal -= ext_call.return_data[0]
                                if eth.balance(this.address) < 0:
                                    revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                if ext_code.size(wantAddress) <= 0:
                                    revert with 0, 'Address: call to non-contract'
                                mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), ext_call.return_data[0 len 28]
                                mem[580 len 0] = 0
                                call wantAddress with:
                                   funct uint32(stor12)
                                     gas gas_remaining wei
                                    args Mask(480, -256, ext_call.return_data[0 len 28]) << 256, mem[580 len 4]
                            else:
                                if wantLockedTotal > wantLockedTotal:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                wantLockedTotal = 0
                                if eth.balance(this.address) < 0:
                                    revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                if ext_code.size(wantAddress) <= 0:
                                    revert with 0, 'Address: call to non-contract'
                                mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                mem[580 len 0] = 0
                                call wantAddress with:
                                   funct uint32(stor12)
                                     gas gas_remaining wei
                                    args Mask(480, 0, stor16.field_0), mem[580 len 4]
                    else:
                        require ext_code.size(farmContractAddress)
                        call farmContractAddress.withdraw(uint256 arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args pid, 0
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require ext_code.size(wantAddress)
                        staticcall wantAddress.0x70a08231 with:
                                gas gas_remaining wei
                               args this.address
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if 0 <= ext_call.return_data[0]:
                            if wantLockedTotal >= 0:
                                if 0 > wantLockedTotal:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if eth.balance(this.address) < 0:
                                    revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                if ext_code.size(wantAddress) <= 0:
                                    revert with 0, 'Address: call to non-contract'
                                mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), 0
                                call wantAddress with:
                                   funct uint32(stor12)
                                     gas gas_remaining wei
                                    args 0, mem[580 len 4]
                            else:
                                if wantLockedTotal > wantLockedTotal:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                wantLockedTotal = 0
                                if eth.balance(this.address) < 0:
                                    revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                if ext_code.size(wantAddress) <= 0:
                                    revert with 0, 'Address: call to non-contract'
                                mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                call wantAddress with:
                                   funct uint32(stor12)
                                     gas gas_remaining wei
                                    args Mask(480, 0, stor16.field_0), mem[580 len 4]
                        else:
                            if wantLockedTotal >= ext_call.return_data[0]:
                                if ext_call.return_data[0] > wantLockedTotal:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                wantLockedTotal -= ext_call.return_data[0]
                                if eth.balance(this.address) < 0:
                                    revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                if ext_code.size(wantAddress) <= 0:
                                    revert with 0, 'Address: call to non-contract'
                                mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), ext_call.return_data[0 len 28]
                                call wantAddress with:
                                   funct uint32(stor12)
                                     gas gas_remaining wei
                                    args Mask(480, -256, ext_call.return_data[0 len 28]) << 256, mem[580 len 4]
                            else:
                                if wantLockedTotal > wantLockedTotal:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                wantLockedTotal = 0
                                if eth.balance(this.address) < 0:
                                    revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                if ext_code.size(wantAddress) <= 0:
                                    revert with 0, 'Address: call to non-contract'
                                mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                call wantAddress with:
                                   funct uint32(stor12)
                                     gas gas_remaining wei
                                    args Mask(480, 0, stor16.field_0), mem[580 len 4]
                else:
                    require arg2
                    if arg2 * withdrawFeeFactor / arg2 != withdrawFeeFactor:
                        revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                    if not isAutoComp:
                        require ext_code.size(wantAddress)
                        staticcall wantAddress.0x70a08231 with:
                                gas gas_remaining wei
                               args this.address
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if arg2 * withdrawFeeFactor / 10000 <= ext_call.return_data[0]:
                            if wantLockedTotal >= arg2 * withdrawFeeFactor / 10000:
                                if arg2 * withdrawFeeFactor / 10000 > wantLockedTotal:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                wantLockedTotal -= arg2 * withdrawFeeFactor / 10000
                                if eth.balance(this.address) < 0:
                                    revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                if ext_code.size(wantAddress) <= 0:
                                    revert with 0, 'Address: call to non-contract'
                                mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 32, arg2 * withdrawFeeFactor / 10000) >> 32
                                mem[580 len 0] = 0
                                call wantAddress with:
                                   funct uint32(stor12)
                                     gas gas_remaining wei
                                    args Mask(224, 32, arg2 * withdrawFeeFactor / 10000) << 224, mem[580 len 4]
                            else:
                                if wantLockedTotal > wantLockedTotal:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                wantLockedTotal = 0
                                if eth.balance(this.address) < 0:
                                    revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                if ext_code.size(wantAddress) <= 0:
                                    revert with 0, 'Address: call to non-contract'
                                mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                mem[580 len 0] = 0
                                call wantAddress with:
                                   funct uint32(stor12)
                                     gas gas_remaining wei
                                    args Mask(480, 0, stor16.field_0), mem[580 len 4]
                        else:
                            if wantLockedTotal < ext_call.return_data[0]:
                                if wantLockedTotal > wantLockedTotal:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                wantLockedTotal = 0
                                if eth.balance(this.address) < 0:
                                    revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                if ext_code.size(wantAddress) <= 0:
                                    revert with 0, 'Address: call to non-contract'
                                mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                call wantAddress with:
                                   funct uint32(stor12)
                                     gas gas_remaining wei
                                    args Mask(480, 0, stor16.field_0), mem[580 len 4]
                            else:
                                if ext_call.return_data[0] > wantLockedTotal:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                wantLockedTotal -= ext_call.return_data[0]
                                if eth.balance(this.address) < 0:
                                    revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                if ext_code.size(wantAddress) <= 0:
                                    revert with 0, 'Address: call to non-contract'
                                mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), ext_call.return_data[0 len 28]
                                mem[580 len 0] = 0
                                call wantAddress with:
                                   funct uint32(stor12)
                                     gas gas_remaining wei
                                    args Mask(480, -256, ext_call.return_data[0 len 28]) << 256, mem[580 len 4]
                    else:
                        require ext_code.size(farmContractAddress)
                        call farmContractAddress.withdraw(uint256 arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args pid, arg2 * withdrawFeeFactor / 10000
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require ext_code.size(wantAddress)
                        staticcall wantAddress.0x70a08231 with:
                                gas gas_remaining wei
                               args this.address
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if arg2 * withdrawFeeFactor / 10000 <= ext_call.return_data[0]:
                            if wantLockedTotal >= arg2 * withdrawFeeFactor / 10000:
                                if arg2 * withdrawFeeFactor / 10000 > wantLockedTotal:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                wantLockedTotal -= arg2 * withdrawFeeFactor / 10000
                                if eth.balance(this.address) < 0:
                                    revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                if ext_code.size(wantAddress) <= 0:
                                    revert with 0, 'Address: call to non-contract'
                                mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 32, arg2 * withdrawFeeFactor / 10000) >> 32
                                mem[580 len 0] = 0
                                call wantAddress with:
                                   funct uint32(stor12)
                                     gas gas_remaining wei
                                    args Mask(224, 32, arg2 * withdrawFeeFactor / 10000) << 224, mem[580 len 4]
                            else:
                                if wantLockedTotal > wantLockedTotal:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                wantLockedTotal = 0
                                if eth.balance(this.address) < 0:
                                    revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                if ext_code.size(wantAddress) <= 0:
                                    revert with 0, 'Address: call to non-contract'
                                mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                mem[580 len 0] = 0
                                call wantAddress with:
                                   funct uint32(stor12)
                                     gas gas_remaining wei
                                    args Mask(480, 0, stor16.field_0), mem[580 len 4]
                        else:
                            if wantLockedTotal >= ext_call.return_data[0]:
                                if ext_call.return_data[0] > wantLockedTotal:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                wantLockedTotal -= ext_call.return_data[0]
                                if eth.balance(this.address) < 0:
                                    revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                if ext_code.size(wantAddress) <= 0:
                                    revert with 0, 'Address: call to non-contract'
                                mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), ext_call.return_data[0 len 28]
                                mem[580 len 0] = 0
                                call wantAddress with:
                                   funct uint32(stor12)
                                     gas gas_remaining wei
                                    args Mask(480, -256, ext_call.return_data[0 len 28]) << 256, mem[580 len 4]
                            else:
                                if wantLockedTotal > wantLockedTotal:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                wantLockedTotal = 0
                                if eth.balance(this.address) < 0:
                                    revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                if ext_code.size(wantAddress) <= 0:
                                    revert with 0, 'Address: call to non-contract'
                                mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                mem[580 len 0] = 0
                                call wantAddress with:
                                   funct uint32(stor12)
                                     gas gas_remaining wei
                                    args Mask(480, 0, stor16.field_0), mem[580 len 4]
                if not return_data.size:
                    require not ext_call.success
                    revert with 'SafeMath: division by zero'
                mem[548 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not ext_call.success:
                    if return_data.size > 0:
                        revert with ext_call.return_data[0 len return_data.size]
                    revert with 0, 'SafeERC20: low-level call failed'
                if return_data.size > 0:
                    require return_data.size >= 32
                    if not mem[548]:
                        revert with 0, 
                                    32,
                                    42,
                                    0x775361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                    mem[ceil32(return_data.size) + 627 len 22]
        else:
            if stor27[address(arg1)] + sub_c7095c4b < stor27[address(arg1)]:
                revert with 0, 'SafeMath: addition overflow'
            if stor27[address(arg1)] + sub_c7095c4b <= block.timestamp:
                if withdrawFeeFactor >= 10000:
                    if not isAutoComp:
                        require ext_code.size(wantAddress)
                        staticcall wantAddress.0x70a08231 with:
                                gas gas_remaining wei
                               args this.address
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if arg2 <= ext_call.return_data[0]:
                            if wantLockedTotal >= arg2:
                                if arg2 > wantLockedTotal:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                wantLockedTotal -= arg2
                                if eth.balance(this.address) < 0:
                                    revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[558 len 26]
                                if ext_code.size(wantAddress) <= 0:
                                    revert with 0, 'Address: call to non-contract'
                                mem[452 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 32, arg2) >> 32
                                mem[516 len 0] = 0
                                call wantAddress with:
                                   funct uint32(stor12)
                                     gas gas_remaining wei
                                    args Mask(224, 32, arg2) << 224, mem[516 len 4]
                            else:
                                if wantLockedTotal > wantLockedTotal:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                wantLockedTotal = 0
                                if eth.balance(this.address) < 0:
                                    revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[558 len 26]
                                if ext_code.size(wantAddress) <= 0:
                                    revert with 0, 'Address: call to non-contract'
                                mem[452 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                mem[516 len 0] = 0
                                call wantAddress with:
                                   funct uint32(stor12)
                                     gas gas_remaining wei
                                    args Mask(480, 0, stor16.field_0), mem[516 len 4]
                        else:
                            if wantLockedTotal >= ext_call.return_data[0]:
                                if ext_call.return_data[0] > wantLockedTotal:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                wantLockedTotal -= ext_call.return_data[0]
                                if eth.balance(this.address) < 0:
                                    revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[558 len 26]
                                if ext_code.size(wantAddress) <= 0:
                                    revert with 0, 'Address: call to non-contract'
                                mem[452 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), ext_call.return_data[0 len 28]
                                call wantAddress with:
                                   funct uint32(stor12)
                                     gas gas_remaining wei
                                    args Mask(480, -256, ext_call.return_data[0 len 28]) << 256, mem[516 len 4]
                            else:
                                if wantLockedTotal > wantLockedTotal:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                wantLockedTotal = 0
                                if eth.balance(this.address) < 0:
                                    revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[558 len 26]
                                if ext_code.size(wantAddress) <= 0:
                                    revert with 0, 'Address: call to non-contract'
                                mem[452 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                mem[516 len 0] = 0
                                call wantAddress with:
                                   funct uint32(stor12)
                                     gas gas_remaining wei
                                    args Mask(480, 0, stor16.field_0), mem[516 len 4]
                    else:
                        require ext_code.size(farmContractAddress)
                        call farmContractAddress.withdraw(uint256 arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args pid, arg2
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require ext_code.size(wantAddress)
                        staticcall wantAddress.0x70a08231 with:
                                gas gas_remaining wei
                               args this.address
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if arg2 <= ext_call.return_data[0]:
                            if wantLockedTotal >= arg2:
                                if arg2 > wantLockedTotal:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                wantLockedTotal -= arg2
                                if eth.balance(this.address) < 0:
                                    revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[558 len 26]
                                if ext_code.size(wantAddress) <= 0:
                                    revert with 0, 'Address: call to non-contract'
                                mem[452 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 32, arg2) >> 32
                                mem[516 len 0] = 0
                                call wantAddress with:
                                   funct uint32(stor12)
                                     gas gas_remaining wei
                                    args Mask(224, 32, arg2) << 224, mem[516 len 4]
                            else:
                                if wantLockedTotal > wantLockedTotal:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                wantLockedTotal = 0
                                if eth.balance(this.address) < 0:
                                    revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[558 len 26]
                                if ext_code.size(wantAddress) <= 0:
                                    revert with 0, 'Address: call to non-contract'
                                mem[452 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                mem[516 len 0] = 0
                                call wantAddress with:
                                   funct uint32(stor12)
                                     gas gas_remaining wei
                                    args Mask(480, 0, stor16.field_0), mem[516 len 4]
                        else:
                            if wantLockedTotal < ext_call.return_data[0]:
                                if wantLockedTotal > wantLockedTotal:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                wantLockedTotal = 0
                                if eth.balance(this.address) < 0:
                                    revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[558 len 26]
                                if ext_code.size(wantAddress) <= 0:
                                    revert with 0, 'Address: call to non-contract'
                                mem[452 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                call wantAddress with:
                                   funct uint32(stor12)
                                     gas gas_remaining wei
                                    args Mask(480, 0, stor16.field_0), mem[516 len 4]
                            else:
                                if ext_call.return_data[0] > wantLockedTotal:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                wantLockedTotal -= ext_call.return_data[0]
                                if eth.balance(this.address) < 0:
                                    revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[558 len 26]
                                if ext_code.size(wantAddress) <= 0:
                                    revert with 0, 'Address: call to non-contract'
                                mem[452 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), ext_call.return_data[0 len 28]
                                mem[516 len 0] = 0
                                call wantAddress with:
                                   funct uint32(stor12)
                                     gas gas_remaining wei
                                    args Mask(480, -256, ext_call.return_data[0 len 28]) << 256, mem[516 len 4]
                    if not return_data.size:
                        require not ext_call.success
                        revert with 'SafeMath: division by zero'
                    mem[484 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not ext_call.success:
                        if return_data.size > 0:
                            revert with ext_call.return_data[0 len return_data.size]
                        revert with 0, 'SafeERC20: low-level call failed'
                    if return_data.size > 0:
                        require return_data.size >= 32
                        if not mem[484]:
                            revert with 0, 
                                        32,
                                        42,
                                        0x775361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                        mem[ceil32(return_data.size) + 563 len 22]
                else:
                    if not arg2:
                        if not isAutoComp:
                            require ext_code.size(wantAddress)
                            staticcall wantAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if 0 > ext_call.return_data[0]:
                                if wantLockedTotal >= ext_call.return_data[0]:
                                    if ext_call.return_data[0] > wantLockedTotal:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    wantLockedTotal -= ext_call.return_data[0]
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                    if ext_code.size(wantAddress) <= 0:
                                        revert with 0, 'Address: call to non-contract'
                                    mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), ext_call.return_data[0 len 28]
                                    call wantAddress with:
                                       funct uint32(stor12)
                                         gas gas_remaining wei
                                        args Mask(480, -256, ext_call.return_data[0 len 28]) << 256, mem[580 len 4]
                                else:
                                    if wantLockedTotal > wantLockedTotal:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    wantLockedTotal = 0
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                    if ext_code.size(wantAddress) <= 0:
                                        revert with 0, 'Address: call to non-contract'
                                    mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                    call wantAddress with:
                                       funct uint32(stor12)
                                         gas gas_remaining wei
                                        args Mask(480, 0, stor16.field_0), mem[580 len 4]
                            else:
                                if wantLockedTotal >= 0:
                                    if 0 > wantLockedTotal:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                    if ext_code.size(wantAddress) <= 0:
                                        revert with 0, 'Address: call to non-contract'
                                    mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), 0
                                    call wantAddress with:
                                       funct uint32(stor12)
                                         gas gas_remaining wei
                                        args 0, mem[580 len 4]
                                else:
                                    if wantLockedTotal > wantLockedTotal:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    wantLockedTotal = 0
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                    if ext_code.size(wantAddress) <= 0:
                                        revert with 0, 'Address: call to non-contract'
                                    mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                    mem[580 len 0] = 0
                                    call wantAddress with:
                                       funct uint32(stor12)
                                         gas gas_remaining wei
                                        args Mask(480, 0, stor16.field_0), mem[580 len 4]
                        else:
                            require ext_code.size(farmContractAddress)
                            call farmContractAddress.withdraw(uint256 arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args pid, 0
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require ext_code.size(wantAddress)
                            staticcall wantAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if 0 > ext_call.return_data[0]:
                                if wantLockedTotal >= ext_call.return_data[0]:
                                    if ext_call.return_data[0] > wantLockedTotal:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    wantLockedTotal -= ext_call.return_data[0]
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                    if ext_code.size(wantAddress) <= 0:
                                        revert with 0, 'Address: call to non-contract'
                                    mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), ext_call.return_data[0 len 28]
                                    call wantAddress with:
                                       funct uint32(stor12)
                                         gas gas_remaining wei
                                        args Mask(480, -256, ext_call.return_data[0 len 28]) << 256, mem[580 len 4]
                                else:
                                    if wantLockedTotal > wantLockedTotal:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    wantLockedTotal = 0
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                    if ext_code.size(wantAddress) <= 0:
                                        revert with 0, 'Address: call to non-contract'
                                    mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                    call wantAddress with:
                                       funct uint32(stor12)
                                         gas gas_remaining wei
                                        args Mask(480, 0, stor16.field_0), mem[580 len 4]
                            else:
                                if wantLockedTotal >= 0:
                                    if 0 > wantLockedTotal:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                    if ext_code.size(wantAddress) <= 0:
                                        revert with 0, 'Address: call to non-contract'
                                    mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), 0
                                    mem[580 len 0] = 0
                                    call wantAddress with:
                                       funct uint32(stor12)
                                         gas gas_remaining wei
                                        args Mask(480, -256, unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), 0) << 256, mem[580 len 4]
                                else:
                                    if wantLockedTotal > wantLockedTotal:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    wantLockedTotal = 0
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                    if ext_code.size(wantAddress) <= 0:
                                        revert with 0, 'Address: call to non-contract'
                                    mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                    mem[580 len 0] = 0
                                    call wantAddress with:
                                       funct uint32(stor12)
                                         gas gas_remaining wei
                                        args Mask(480, 0, stor16.field_0), mem[580 len 4]
                    else:
                        require arg2
                        if arg2 * withdrawFeeFactor / arg2 != withdrawFeeFactor:
                            revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                        if not isAutoComp:
                            require ext_code.size(wantAddress)
                            staticcall wantAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if arg2 * withdrawFeeFactor / 10000 <= ext_call.return_data[0]:
                                if wantLockedTotal >= arg2 * withdrawFeeFactor / 10000:
                                    if arg2 * withdrawFeeFactor / 10000 > wantLockedTotal:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    wantLockedTotal -= arg2 * withdrawFeeFactor / 10000
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                    if ext_code.size(wantAddress) <= 0:
                                        revert with 0, 'Address: call to non-contract'
                                    mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 32, arg2 * withdrawFeeFactor / 10000) >> 32
                                    call wantAddress with:
                                       funct uint32(stor12)
                                         gas gas_remaining wei
                                        args Mask(224, 32, arg2 * withdrawFeeFactor / 10000) << 224, mem[580 len 4]
                                else:
                                    if wantLockedTotal > wantLockedTotal:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    wantLockedTotal = 0
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                    if ext_code.size(wantAddress) <= 0:
                                        revert with 0, 'Address: call to non-contract'
                                    mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                    call wantAddress with:
                                       funct uint32(stor12)
                                         gas gas_remaining wei
                                        args Mask(480, 0, stor16.field_0), mem[580 len 4]
                            else:
                                if wantLockedTotal >= ext_call.return_data[0]:
                                    if ext_call.return_data[0] > wantLockedTotal:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    wantLockedTotal -= ext_call.return_data[0]
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                    if ext_code.size(wantAddress) <= 0:
                                        revert with 0, 'Address: call to non-contract'
                                    mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), ext_call.return_data[0 len 28]
                                    call wantAddress with:
                                       funct uint32(stor12)
                                         gas gas_remaining wei
                                        args Mask(480, -256, ext_call.return_data[0 len 28]) << 256, mem[580 len 4]
                                else:
                                    if wantLockedTotal > wantLockedTotal:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    wantLockedTotal = 0
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                    if ext_code.size(wantAddress) <= 0:
                                        revert with 0, 'Address: call to non-contract'
                                    mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                    mem[580 len 0] = 0
                                    call wantAddress with:
                                       funct uint32(stor12)
                                         gas gas_remaining wei
                                        args Mask(480, 0, stor16.field_0), mem[580 len 4]
                        else:
                            require ext_code.size(farmContractAddress)
                            call farmContractAddress.withdraw(uint256 arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args pid, arg2 * withdrawFeeFactor / 10000
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require ext_code.size(wantAddress)
                            staticcall wantAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if arg2 * withdrawFeeFactor / 10000 <= ext_call.return_data[0]:
                                if wantLockedTotal < arg2 * withdrawFeeFactor / 10000:
                                    if wantLockedTotal > wantLockedTotal:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    wantLockedTotal = 0
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                    if ext_code.size(wantAddress) <= 0:
                                        revert with 0, 'Address: call to non-contract'
                                    mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                    call wantAddress with:
                                       funct uint32(stor12)
                                         gas gas_remaining wei
                                        args Mask(480, 0, stor16.field_0), mem[580 len 4]
                                else:
                                    if arg2 * withdrawFeeFactor / 10000 > wantLockedTotal:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    wantLockedTotal -= arg2 * withdrawFeeFactor / 10000
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                    if ext_code.size(wantAddress) <= 0:
                                        revert with 0, 'Address: call to non-contract'
                                    mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 32, arg2 * withdrawFeeFactor / 10000) >> 32
                                    mem[580 len 0] = 0
                                    call wantAddress with:
                                       funct uint32(stor12)
                                         gas gas_remaining wei
                                        args Mask(224, 32, arg2 * withdrawFeeFactor / 10000) << 224, mem[580 len 4]
                            else:
                                if wantLockedTotal >= ext_call.return_data[0]:
                                    if ext_call.return_data[0] > wantLockedTotal:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    wantLockedTotal -= ext_call.return_data[0]
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                    if ext_code.size(wantAddress) <= 0:
                                        revert with 0, 'Address: call to non-contract'
                                    mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), ext_call.return_data[0 len 28]
                                    mem[580 len 0] = 0
                                    call wantAddress with:
                                       funct uint32(stor12)
                                         gas gas_remaining wei
                                        args Mask(480, -256, ext_call.return_data[0 len 28]) << 256, mem[580 len 4]
                                else:
                                    if wantLockedTotal > wantLockedTotal:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    wantLockedTotal = 0
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                    if ext_code.size(wantAddress) <= 0:
                                        revert with 0, 'Address: call to non-contract'
                                    mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                    mem[580 len 0] = 0
                                    call wantAddress with:
                                       funct uint32(stor12)
                                         gas gas_remaining wei
                                        args Mask(480, 0, stor16.field_0), mem[580 len 4]
                    if not return_data.size:
                        require not ext_call.success
                        revert with 'SafeMath: division by zero'
                    mem[548 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not ext_call.success:
                        if return_data.size > 0:
                            revert with ext_call.return_data[0 len return_data.size]
                        revert with 0, 'SafeERC20: low-level call failed'
                    if return_data.size > 0:
                        require return_data.size >= 32
                        if not mem[548]:
                            revert with 0, 
                                        32,
                                        42,
                                        0x775361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                        mem[ceil32(return_data.size) + 627 len 22]
            else:
                if not arg2:
                    if withdrawFeeFactor >= 10000:
                        if not isAutoComp:
                            require ext_code.size(wantAddress)
                            staticcall wantAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if arg2 <= ext_call.return_data[0]:
                                if wantLockedTotal >= arg2:
                                    if arg2 > wantLockedTotal:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    wantLockedTotal -= arg2
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                    if ext_code.size(wantAddress) <= 0:
                                        revert with 0, 'Address: call to non-contract'
                                    mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 32, arg2) >> 32
                                    call wantAddress with:
                                       funct uint32(stor12)
                                         gas gas_remaining wei
                                        args Mask(224, 32, arg2) << 224, mem[580 len 4]
                                else:
                                    if wantLockedTotal > wantLockedTotal:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    wantLockedTotal = 0
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                    if ext_code.size(wantAddress) <= 0:
                                        revert with 0, 'Address: call to non-contract'
                                    mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                    mem[580 len 0] = 0
                                    call wantAddress with:
                                       funct uint32(stor12)
                                         gas gas_remaining wei
                                        args Mask(480, 0, stor16.field_0), mem[580 len 4]
                            else:
                                if wantLockedTotal >= ext_call.return_data[0]:
                                    if ext_call.return_data[0] > wantLockedTotal:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    wantLockedTotal -= ext_call.return_data[0]
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                    if ext_code.size(wantAddress) <= 0:
                                        revert with 0, 'Address: call to non-contract'
                                    mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), ext_call.return_data[0 len 28]
                                    call wantAddress with:
                                       funct uint32(stor12)
                                         gas gas_remaining wei
                                        args Mask(480, -256, ext_call.return_data[0 len 28]) << 256, mem[580 len 4]
                                else:
                                    if wantLockedTotal > wantLockedTotal:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    wantLockedTotal = 0
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                    if ext_code.size(wantAddress) <= 0:
                                        revert with 0, 'Address: call to non-contract'
                                    mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                    mem[580 len 0] = 0
                                    call wantAddress with:
                                       funct uint32(stor12)
                                         gas gas_remaining wei
                                        args Mask(480, 0, stor16.field_0), mem[580 len 4]
                        else:
                            require ext_code.size(farmContractAddress)
                            call farmContractAddress.withdraw(uint256 arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args pid, arg2
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require ext_code.size(wantAddress)
                            staticcall wantAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if arg2 > ext_call.return_data[0]:
                                if wantLockedTotal >= ext_call.return_data[0]:
                                    if ext_call.return_data[0] > wantLockedTotal:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    wantLockedTotal -= ext_call.return_data[0]
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                    if ext_code.size(wantAddress) <= 0:
                                        revert with 0, 'Address: call to non-contract'
                                    mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), ext_call.return_data[0 len 28]
                                    call wantAddress with:
                                       funct uint32(stor12)
                                         gas gas_remaining wei
                                        args Mask(480, -256, ext_call.return_data[0 len 28]) << 256, mem[580 len 4]
                                else:
                                    if wantLockedTotal > wantLockedTotal:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    wantLockedTotal = 0
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                    if ext_code.size(wantAddress) <= 0:
                                        revert with 0, 'Address: call to non-contract'
                                    mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                    call wantAddress with:
                                       funct uint32(stor12)
                                         gas gas_remaining wei
                                        args Mask(480, 0, stor16.field_0), mem[580 len 4]
                            else:
                                if wantLockedTotal >= arg2:
                                    if arg2 > wantLockedTotal:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    wantLockedTotal -= arg2
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                    if ext_code.size(wantAddress) <= 0:
                                        revert with 0, 'Address: call to non-contract'
                                    mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 32, arg2) >> 32
                                    mem[580 len 0] = 0
                                    call wantAddress with:
                                       funct uint32(stor12)
                                         gas gas_remaining wei
                                        args Mask(224, 32, arg2) << 224, mem[580 len 4]
                                else:
                                    if wantLockedTotal > wantLockedTotal:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    wantLockedTotal = 0
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                    if ext_code.size(wantAddress) <= 0:
                                        revert with 0, 'Address: call to non-contract'
                                    mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                    mem[580 len 0] = 0
                                    call wantAddress with:
                                       funct uint32(stor12)
                                         gas gas_remaining wei
                                        args Mask(480, 0, stor16.field_0), mem[580 len 4]
                        if not return_data.size:
                            require not ext_call.success
                            revert with 'SafeMath: division by zero'
                        mem[548 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size > 0:
                                revert with ext_call.return_data[0 len return_data.size]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if return_data.size > 0:
                            require return_data.size >= 32
                            if not mem[548]:
                                revert with 0, 
                                            32,
                                            42,
                                            0x775361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                            mem[ceil32(return_data.size) + 627 len 22]
                    else:
                        if not arg2:
                            if not isAutoComp:
                                require ext_code.size(wantAddress)
                                staticcall wantAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if 0 <= ext_call.return_data[0]:
                                    if wantLockedTotal >= 0:
                                        if 0 > wantLockedTotal:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                        if ext_code.size(wantAddress) <= 0:
                                            revert with 0, 'Address: call to non-contract'
                                        mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), 0
                                        mem[644 len 0] = 0
                                        call wantAddress with:
                                           funct uint32(stor12)
                                             gas gas_remaining wei
                                            args Mask(480, -256, unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), 0) << 256, mem[644 len 4]
                                    else:
                                        if wantLockedTotal > wantLockedTotal:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        wantLockedTotal = 0
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                        if ext_code.size(wantAddress) <= 0:
                                            revert with 0, 'Address: call to non-contract'
                                        mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                        call wantAddress with:
                                           funct uint32(stor12)
                                             gas gas_remaining wei
                                            args Mask(480, 0, stor16.field_0), mem[644 len 4]
                                else:
                                    if wantLockedTotal >= ext_call.return_data[0]:
                                        if ext_call.return_data[0] > wantLockedTotal:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        wantLockedTotal -= ext_call.return_data[0]
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                        if ext_code.size(wantAddress) <= 0:
                                            revert with 0, 'Address: call to non-contract'
                                        mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), ext_call.return_data[0 len 28]
                                        mem[644 len 0] = 0
                                        call wantAddress with:
                                           funct uint32(stor12)
                                             gas gas_remaining wei
                                            args Mask(480, -256, ext_call.return_data[0 len 28]) << 256, mem[644 len 4]
                                    else:
                                        if wantLockedTotal > wantLockedTotal:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        wantLockedTotal = 0
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                        if ext_code.size(wantAddress) <= 0:
                                            revert with 0, 'Address: call to non-contract'
                                        mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                        mem[644 len 0] = 0
                                        call wantAddress with:
                                           funct uint32(stor12)
                                             gas gas_remaining wei
                                            args Mask(480, 0, stor16.field_0), mem[644 len 4]
                            else:
                                require ext_code.size(farmContractAddress)
                                call farmContractAddress.withdraw(uint256 arg1, uint256 arg2) with:
                                     gas gas_remaining wei
                                    args pid, 0
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(wantAddress)
                                staticcall wantAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if 0 > ext_call.return_data[0]:
                                    if wantLockedTotal >= ext_call.return_data[0]:
                                        if ext_call.return_data[0] > wantLockedTotal:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        wantLockedTotal -= ext_call.return_data[0]
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                        if ext_code.size(wantAddress) <= 0:
                                            revert with 0, 'Address: call to non-contract'
                                        mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), ext_call.return_data[0 len 28]
                                        call wantAddress with:
                                           funct uint32(stor12)
                                             gas gas_remaining wei
                                            args Mask(480, -256, ext_call.return_data[0 len 28]) << 256, mem[644 len 4]
                                    else:
                                        if wantLockedTotal > wantLockedTotal:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        wantLockedTotal = 0
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                        if ext_code.size(wantAddress) <= 0:
                                            revert with 0, 'Address: call to non-contract'
                                        mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                        call wantAddress with:
                                           funct uint32(stor12)
                                             gas gas_remaining wei
                                            args Mask(480, 0, stor16.field_0), mem[644 len 4]
                                else:
                                    if wantLockedTotal >= 0:
                                        if 0 > wantLockedTotal:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                        if ext_code.size(wantAddress) <= 0:
                                            revert with 0, 'Address: call to non-contract'
                                        mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), 0
                                        mem[644 len 0] = 0
                                        call wantAddress with:
                                           funct uint32(stor12)
                                             gas gas_remaining wei
                                            args Mask(480, -256, unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), 0) << 256, mem[644 len 4]
                                    else:
                                        if wantLockedTotal > wantLockedTotal:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        wantLockedTotal = 0
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                        if ext_code.size(wantAddress) <= 0:
                                            revert with 0, 'Address: call to non-contract'
                                        mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                        mem[644 len 0] = 0
                                        call wantAddress with:
                                           funct uint32(stor12)
                                             gas gas_remaining wei
                                            args Mask(480, 0, stor16.field_0), mem[644 len 4]
                        else:
                            require arg2
                            if arg2 * withdrawFeeFactor / arg2 != withdrawFeeFactor:
                                revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                            if not isAutoComp:
                                require ext_code.size(wantAddress)
                                staticcall wantAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if arg2 * withdrawFeeFactor / 10000 <= ext_call.return_data[0]:
                                    if wantLockedTotal >= arg2 * withdrawFeeFactor / 10000:
                                        if arg2 * withdrawFeeFactor / 10000 > wantLockedTotal:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        wantLockedTotal -= arg2 * withdrawFeeFactor / 10000
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                        if ext_code.size(wantAddress) <= 0:
                                            revert with 0, 'Address: call to non-contract'
                                        mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 32, arg2 * withdrawFeeFactor / 10000) >> 32
                                        call wantAddress with:
                                           funct uint32(stor12)
                                             gas gas_remaining wei
                                            args Mask(224, 32, arg2 * withdrawFeeFactor / 10000) << 224, mem[644 len 4]
                                    else:
                                        if wantLockedTotal > wantLockedTotal:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        wantLockedTotal = 0
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                        if ext_code.size(wantAddress) <= 0:
                                            revert with 0, 'Address: call to non-contract'
                                        mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                        call wantAddress with:
                                           funct uint32(stor12)
                                             gas gas_remaining wei
                                            args Mask(480, 0, stor16.field_0), mem[644 len 4]
                                else:
                                    if wantLockedTotal < ext_call.return_data[0]:
                                        if wantLockedTotal > wantLockedTotal:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        wantLockedTotal = 0
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                        if ext_code.size(wantAddress) <= 0:
                                            revert with 0, 'Address: call to non-contract'
                                        mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                        call wantAddress with:
                                           funct uint32(stor12)
                                             gas gas_remaining wei
                                            args Mask(480, 0, stor16.field_0), mem[644 len 4]
                                    else:
                                        if ext_call.return_data[0] > wantLockedTotal:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        wantLockedTotal -= ext_call.return_data[0]
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                        if ext_code.size(wantAddress) <= 0:
                                            revert with 0, 'Address: call to non-contract'
                                        mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), ext_call.return_data[0 len 28]
                                        mem[644 len 0] = 0
                                        call wantAddress with:
                                           funct uint32(stor12)
                                             gas gas_remaining wei
                                            args Mask(480, -256, ext_call.return_data[0 len 28]) << 256, mem[644 len 4]
                            else:
                                require ext_code.size(farmContractAddress)
                                call farmContractAddress.withdraw(uint256 arg1, uint256 arg2) with:
                                     gas gas_remaining wei
                                    args pid, arg2 * withdrawFeeFactor / 10000
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(wantAddress)
                                staticcall wantAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if arg2 * withdrawFeeFactor / 10000 <= ext_call.return_data[0]:
                                    if wantLockedTotal < arg2 * withdrawFeeFactor / 10000:
                                        if wantLockedTotal > wantLockedTotal:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        wantLockedTotal = 0
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                        if ext_code.size(wantAddress) <= 0:
                                            revert with 0, 'Address: call to non-contract'
                                        mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                        call wantAddress with:
                                           funct uint32(stor12)
                                             gas gas_remaining wei
                                            args Mask(480, 0, stor16.field_0), mem[644 len 4]
                                    else:
                                        if arg2 * withdrawFeeFactor / 10000 > wantLockedTotal:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        wantLockedTotal -= arg2 * withdrawFeeFactor / 10000
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                        if ext_code.size(wantAddress) <= 0:
                                            revert with 0, 'Address: call to non-contract'
                                        mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 32, arg2 * withdrawFeeFactor / 10000) >> 32
                                        mem[644 len 0] = 0
                                        call wantAddress with:
                                           funct uint32(stor12)
                                             gas gas_remaining wei
                                            args Mask(224, 32, arg2 * withdrawFeeFactor / 10000) << 224, mem[644 len 4]
                                else:
                                    if wantLockedTotal >= ext_call.return_data[0]:
                                        if ext_call.return_data[0] > wantLockedTotal:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        wantLockedTotal -= ext_call.return_data[0]
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                        if ext_code.size(wantAddress) <= 0:
                                            revert with 0, 'Address: call to non-contract'
                                        mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), ext_call.return_data[0 len 28]
                                        mem[644 len 0] = 0
                                        call wantAddress with:
                                           funct uint32(stor12)
                                             gas gas_remaining wei
                                            args Mask(480, -256, ext_call.return_data[0 len 28]) << 256, mem[644 len 4]
                                    else:
                                        if wantLockedTotal > wantLockedTotal:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        wantLockedTotal = 0
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                        if ext_code.size(wantAddress) <= 0:
                                            revert with 0, 'Address: call to non-contract'
                                        mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                        mem[644 len 0] = 0
                                        call wantAddress with:
                                           funct uint32(stor12)
                                             gas gas_remaining wei
                                            args Mask(480, 0, stor16.field_0), mem[644 len 4]
                        if not return_data.size:
                            require not ext_call.success
                            revert with 'SafeMath: division by zero'
                        mem[612 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size > 0:
                                revert with ext_call.return_data[0 len return_data.size]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if return_data.size > 0:
                            require return_data.size >= 32
                            if not mem[612]:
                                revert with 0, 
                                            32,
                                            42,
                                            0x775361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                            mem[ceil32(return_data.size) + 691 len 22]
                else:
                    require arg2
                    if arg2 * sub_9ccccc15 / arg2 != sub_9ccccc15:
                        revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                    if withdrawFeeFactor >= 10000:
                        if arg2 * sub_9ccccc15 / 10000 <= 0:
                            if not isAutoComp:
                                require ext_code.size(wantAddress)
                                staticcall wantAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if arg2 <= ext_call.return_data[0]:
                                    if wantLockedTotal >= arg2:
                                        if arg2 > wantLockedTotal:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        wantLockedTotal -= arg2
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                        if ext_code.size(wantAddress) <= 0:
                                            revert with 0, 'Address: call to non-contract'
                                        mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 32, arg2) >> 32
                                        call wantAddress with:
                                           funct uint32(stor12)
                                             gas gas_remaining wei
                                            args Mask(224, 32, arg2) << 224, mem[580 len 4]
                                    else:
                                        if wantLockedTotal > wantLockedTotal:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        wantLockedTotal = 0
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                        if ext_code.size(wantAddress) <= 0:
                                            revert with 0, 'Address: call to non-contract'
                                        mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                        call wantAddress with:
                                           funct uint32(stor12)
                                             gas gas_remaining wei
                                            args Mask(480, 0, stor16.field_0), mem[580 len 4]
                                else:
                                    if wantLockedTotal < ext_call.return_data[0]:
                                        if wantLockedTotal > wantLockedTotal:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        wantLockedTotal = 0
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                        if ext_code.size(wantAddress) <= 0:
                                            revert with 0, 'Address: call to non-contract'
                                        mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                        call wantAddress with:
                                           funct uint32(stor12)
                                             gas gas_remaining wei
                                            args Mask(480, 0, stor16.field_0), mem[580 len 4]
                                    else:
                                        if ext_call.return_data[0] > wantLockedTotal:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        wantLockedTotal -= ext_call.return_data[0]
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                        if ext_code.size(wantAddress) <= 0:
                                            revert with 0, 'Address: call to non-contract'
                                        mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), ext_call.return_data[0 len 28]
                                        mem[580 len 0] = 0
                                        call wantAddress with:
                                           funct uint32(stor12)
                                             gas gas_remaining wei
                                            args Mask(480, -256, ext_call.return_data[0 len 28]) << 256, mem[580 len 4]
                            else:
                                require ext_code.size(farmContractAddress)
                                call farmContractAddress.withdraw(uint256 arg1, uint256 arg2) with:
                                     gas gas_remaining wei
                                    args pid, arg2
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(wantAddress)
                                staticcall wantAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if arg2 > ext_call.return_data[0]:
                                    if wantLockedTotal >= ext_call.return_data[0]:
                                        if ext_call.return_data[0] > wantLockedTotal:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        wantLockedTotal -= ext_call.return_data[0]
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                        if ext_code.size(wantAddress) <= 0:
                                            revert with 0, 'Address: call to non-contract'
                                        mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), ext_call.return_data[0 len 28]
                                        call wantAddress with:
                                           funct uint32(stor12)
                                             gas gas_remaining wei
                                            args Mask(480, -256, ext_call.return_data[0 len 28]) << 256, mem[580 len 4]
                                    else:
                                        if wantLockedTotal > wantLockedTotal:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        wantLockedTotal = 0
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                        if ext_code.size(wantAddress) <= 0:
                                            revert with 0, 'Address: call to non-contract'
                                        mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                        call wantAddress with:
                                           funct uint32(stor12)
                                             gas gas_remaining wei
                                            args Mask(480, 0, stor16.field_0), mem[580 len 4]
                                else:
                                    if wantLockedTotal < arg2:
                                        if wantLockedTotal > wantLockedTotal:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        wantLockedTotal = 0
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                        if ext_code.size(wantAddress) <= 0:
                                            revert with 0, 'Address: call to non-contract'
                                        mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                        call wantAddress with:
                                           funct uint32(stor12)
                                             gas gas_remaining wei
                                            args Mask(480, 0, stor16.field_0), mem[580 len 4]
                                    else:
                                        if arg2 > wantLockedTotal:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        wantLockedTotal -= arg2
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                        if ext_code.size(wantAddress) <= 0:
                                            revert with 0, 'Address: call to non-contract'
                                        mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 32, arg2) >> 32
                                        mem[580 len 0] = 0
                                        call wantAddress with:
                                           funct uint32(stor12)
                                             gas gas_remaining wei
                                            args Mask(224, 32, arg2) << 224, mem[580 len 4]
                        else:
                            if not isAutoComp:
                                require ext_code.size(wantAddress)
                                staticcall wantAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if arg2 - (arg2 * sub_9ccccc15 / 10000) <= ext_call.return_data[0]:
                                    if wantLockedTotal >= arg2 - (arg2 * sub_9ccccc15 / 10000):
                                        if arg2 - (arg2 * sub_9ccccc15 / 10000) > wantLockedTotal:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        wantLockedTotal = wantLockedTotal - arg2 + (arg2 * sub_9ccccc15 / 10000)
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                        if ext_code.size(wantAddress) <= 0:
                                            revert with 0, 'Address: call to non-contract'
                                        mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 32, arg2 - (arg2 * sub_9ccccc15 / 10000)) >> 32
                                        mem[580 len 0] = 0
                                        call wantAddress with:
                                           funct uint32(stor12)
                                             gas gas_remaining wei
                                            args Mask(224, 32, arg2 - (arg2 * sub_9ccccc15 / 10000)) << 224, mem[580 len 4]
                                    else:
                                        if wantLockedTotal > wantLockedTotal:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        wantLockedTotal = 0
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                        if ext_code.size(wantAddress) <= 0:
                                            revert with 0, 'Address: call to non-contract'
                                        mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                        mem[580 len 0] = 0
                                        call wantAddress with:
                                           funct uint32(stor12)
                                             gas gas_remaining wei
                                            args Mask(480, 0, stor16.field_0), mem[580 len 4]
                                else:
                                    if wantLockedTotal < ext_call.return_data[0]:
                                        if wantLockedTotal > wantLockedTotal:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        wantLockedTotal = 0
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                        if ext_code.size(wantAddress) <= 0:
                                            revert with 0, 'Address: call to non-contract'
                                        mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                        call wantAddress with:
                                           funct uint32(stor12)
                                             gas gas_remaining wei
                                            args Mask(480, 0, stor16.field_0), mem[580 len 4]
                                    else:
                                        if ext_call.return_data[0] > wantLockedTotal:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        wantLockedTotal -= ext_call.return_data[0]
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                        if ext_code.size(wantAddress) <= 0:
                                            revert with 0, 'Address: call to non-contract'
                                        mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), ext_call.return_data[0 len 28]
                                        mem[580 len 0] = 0
                                        call wantAddress with:
                                           funct uint32(stor12)
                                             gas gas_remaining wei
                                            args Mask(480, -256, ext_call.return_data[0 len 28]) << 256, mem[580 len 4]
                            else:
                                require ext_code.size(farmContractAddress)
                                call farmContractAddress.withdraw(uint256 arg1, uint256 arg2) with:
                                     gas gas_remaining wei
                                    args pid, arg2 - (arg2 * sub_9ccccc15 / 10000)
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(wantAddress)
                                staticcall wantAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if arg2 - (arg2 * sub_9ccccc15 / 10000) <= ext_call.return_data[0]:
                                    if wantLockedTotal < arg2 - (arg2 * sub_9ccccc15 / 10000):
                                        if wantLockedTotal > wantLockedTotal:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        wantLockedTotal = 0
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                        if ext_code.size(wantAddress) <= 0:
                                            revert with 0, 'Address: call to non-contract'
                                        mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                        call wantAddress with:
                                           funct uint32(stor12)
                                             gas gas_remaining wei
                                            args Mask(480, 0, stor16.field_0), mem[580 len 4]
                                    else:
                                        if arg2 - (arg2 * sub_9ccccc15 / 10000) > wantLockedTotal:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        wantLockedTotal = wantLockedTotal - arg2 + (arg2 * sub_9ccccc15 / 10000)
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                        if ext_code.size(wantAddress) <= 0:
                                            revert with 0, 'Address: call to non-contract'
                                        mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 32, arg2 - (arg2 * sub_9ccccc15 / 10000)) >> 32
                                        mem[580 len 0] = 0
                                        call wantAddress with:
                                           funct uint32(stor12)
                                             gas gas_remaining wei
                                            args Mask(224, 32, arg2 - (arg2 * sub_9ccccc15 / 10000)) << 224, mem[580 len 4]
                                else:
                                    if wantLockedTotal >= ext_call.return_data[0]:
                                        if ext_call.return_data[0] > wantLockedTotal:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        wantLockedTotal -= ext_call.return_data[0]
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                        if ext_code.size(wantAddress) <= 0:
                                            revert with 0, 'Address: call to non-contract'
                                        mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), ext_call.return_data[0 len 28]
                                        mem[580 len 0] = 0
                                        call wantAddress with:
                                           funct uint32(stor12)
                                             gas gas_remaining wei
                                            args Mask(480, -256, ext_call.return_data[0 len 28]) << 256, mem[580 len 4]
                                    else:
                                        if wantLockedTotal > wantLockedTotal:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        wantLockedTotal = 0
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                        if ext_code.size(wantAddress) <= 0:
                                            revert with 0, 'Address: call to non-contract'
                                        mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                        mem[580 len 0] = 0
                                        call wantAddress with:
                                           funct uint32(stor12)
                                             gas gas_remaining wei
                                            args Mask(480, 0, stor16.field_0), mem[580 len 4]
                        if not return_data.size:
                            require not ext_call.success
                            revert with 'SafeMath: division by zero'
                        mem[548 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size > 0:
                                revert with ext_call.return_data[0 len return_data.size]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if return_data.size > 0:
                            require return_data.size >= 32
                            if not mem[548]:
                                revert with 0, 
                                            32,
                                            42,
                                            0x775361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                            mem[ceil32(return_data.size) + 627 len 22]
                    else:
                        if not arg2:
                            if arg2 * sub_9ccccc15 / 10000 <= 0:
                                if not isAutoComp:
                                    require ext_code.size(wantAddress)
                                    staticcall wantAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if 0 <= ext_call.return_data[0]:
                                        if wantLockedTotal >= 0:
                                            if 0 > wantLockedTotal:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                            if ext_code.size(wantAddress) <= 0:
                                                revert with 0, 'Address: call to non-contract'
                                            mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), 0
                                            mem[644 len 0] = 0
                                            call wantAddress with:
                                               funct uint32(stor12)
                                                 gas gas_remaining wei
                                                args Mask(480, -256, unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), 0) << 256, mem[644 len 4]
                                        else:
                                            if wantLockedTotal > wantLockedTotal:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            wantLockedTotal = 0
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                            if ext_code.size(wantAddress) <= 0:
                                                revert with 0, 'Address: call to non-contract'
                                            mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                            call wantAddress with:
                                               funct uint32(stor12)
                                                 gas gas_remaining wei
                                                args Mask(480, 0, stor16.field_0), mem[644 len 4]
                                    else:
                                        if wantLockedTotal < ext_call.return_data[0]:
                                            if wantLockedTotal > wantLockedTotal:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            wantLockedTotal = 0
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                            if ext_code.size(wantAddress) <= 0:
                                                revert with 0, 'Address: call to non-contract'
                                            mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                            call wantAddress with:
                                               funct uint32(stor12)
                                                 gas gas_remaining wei
                                                args Mask(480, 0, stor16.field_0), mem[644 len 4]
                                        else:
                                            if ext_call.return_data[0] > wantLockedTotal:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            wantLockedTotal -= ext_call.return_data[0]
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                            if ext_code.size(wantAddress) <= 0:
                                                revert with 0, 'Address: call to non-contract'
                                            mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), ext_call.return_data[0 len 28]
                                            mem[644 len 0] = 0
                                            call wantAddress with:
                                               funct uint32(stor12)
                                                 gas gas_remaining wei
                                                args Mask(480, -256, ext_call.return_data[0 len 28]) << 256, mem[644 len 4]
                                else:
                                    require ext_code.size(farmContractAddress)
                                    call farmContractAddress.withdraw(uint256 arg1, uint256 arg2) with:
                                         gas gas_remaining wei
                                        args pid, 0
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(wantAddress)
                                    staticcall wantAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if 0 > ext_call.return_data[0]:
                                        if wantLockedTotal >= ext_call.return_data[0]:
                                            if ext_call.return_data[0] > wantLockedTotal:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            wantLockedTotal -= ext_call.return_data[0]
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                            if ext_code.size(wantAddress) <= 0:
                                                revert with 0, 'Address: call to non-contract'
                                            mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), ext_call.return_data[0 len 28]
                                            call wantAddress with:
                                               funct uint32(stor12)
                                                 gas gas_remaining wei
                                                args Mask(480, -256, ext_call.return_data[0 len 28]) << 256, mem[644 len 4]
                                        else:
                                            if wantLockedTotal > wantLockedTotal:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            wantLockedTotal = 0
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                            if ext_code.size(wantAddress) <= 0:
                                                revert with 0, 'Address: call to non-contract'
                                            mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                            call wantAddress with:
                                               funct uint32(stor12)
                                                 gas gas_remaining wei
                                                args Mask(480, 0, stor16.field_0), mem[644 len 4]
                                    else:
                                        if wantLockedTotal >= 0:
                                            if 0 > wantLockedTotal:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                            if ext_code.size(wantAddress) <= 0:
                                                revert with 0, 'Address: call to non-contract'
                                            mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), 0
                                            call wantAddress with:
                                               funct uint32(stor12)
                                                 gas gas_remaining wei
                                                args 0, mem[644 len 4]
                                        else:
                                            if wantLockedTotal > wantLockedTotal:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            wantLockedTotal = 0
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                            if ext_code.size(wantAddress) <= 0:
                                                revert with 0, 'Address: call to non-contract'
                                            mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                            mem[644 len 0] = 0
                                            call wantAddress with:
                                               funct uint32(stor12)
                                                 gas gas_remaining wei
                                                args Mask(480, 0, stor16.field_0), mem[644 len 4]
                            else:
                                if not isAutoComp:
                                    require ext_code.size(wantAddress)
                                    staticcall wantAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if -arg2 * sub_9ccccc15 / 10000 <= ext_call.return_data[0]:
                                        if wantLockedTotal >= -arg2 * sub_9ccccc15 / 10000:
                                            if -arg2 * sub_9ccccc15 / 10000 > wantLockedTotal:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            wantLockedTotal += arg2 * sub_9ccccc15 / 10000
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                            if ext_code.size(wantAddress) <= 0:
                                                revert with 0, 'Address: call to non-contract'
                                            mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 32, -arg2 * sub_9ccccc15 / 10000) >> 32
                                            call wantAddress with:
                                               funct uint32(stor12)
                                                 gas gas_remaining wei
                                                args Mask(224, 32, -arg2 * sub_9ccccc15 / 10000) << 224, mem[644 len 4]
                                        else:
                                            if wantLockedTotal > wantLockedTotal:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            wantLockedTotal = 0
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                            if ext_code.size(wantAddress) <= 0:
                                                revert with 0, 'Address: call to non-contract'
                                            mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                            call wantAddress with:
                                               funct uint32(stor12)
                                                 gas gas_remaining wei
                                                args Mask(480, 0, stor16.field_0), mem[644 len 4]
                                    else:
                                        if wantLockedTotal >= ext_call.return_data[0]:
                                            if ext_call.return_data[0] > wantLockedTotal:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            wantLockedTotal -= ext_call.return_data[0]
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                            if ext_code.size(wantAddress) <= 0:
                                                revert with 0, 'Address: call to non-contract'
                                            mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), ext_call.return_data[0 len 28]
                                            call wantAddress with:
                                               funct uint32(stor12)
                                                 gas gas_remaining wei
                                                args Mask(480, -256, ext_call.return_data[0 len 28]) << 256, mem[644 len 4]
                                        else:
                                            if wantLockedTotal > wantLockedTotal:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            wantLockedTotal = 0
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                            if ext_code.size(wantAddress) <= 0:
                                                revert with 0, 'Address: call to non-contract'
                                            mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                            mem[644 len 0] = 0
                                            call wantAddress with:
                                               funct uint32(stor12)
                                                 gas gas_remaining wei
                                                args Mask(480, 0, stor16.field_0), mem[644 len 4]
                                else:
                                    require ext_code.size(farmContractAddress)
                                    call farmContractAddress.withdraw(uint256 arg1, uint256 arg2) with:
                                         gas gas_remaining wei
                                        args pid, -arg2 * sub_9ccccc15 / 10000
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(wantAddress)
                                    staticcall wantAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if -arg2 * sub_9ccccc15 / 10000 <= ext_call.return_data[0]:
                                        if wantLockedTotal < -arg2 * sub_9ccccc15 / 10000:
                                            if wantLockedTotal > wantLockedTotal:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            wantLockedTotal = 0
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                            if ext_code.size(wantAddress) <= 0:
                                                revert with 0, 'Address: call to non-contract'
                                            mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                            call wantAddress with:
                                               funct uint32(stor12)
                                                 gas gas_remaining wei
                                                args Mask(480, 0, stor16.field_0), mem[644 len 4]
                                        else:
                                            if -arg2 * sub_9ccccc15 / 10000 > wantLockedTotal:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            wantLockedTotal += arg2 * sub_9ccccc15 / 10000
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                            if ext_code.size(wantAddress) <= 0:
                                                revert with 0, 'Address: call to non-contract'
                                            mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 32, -arg2 * sub_9ccccc15 / 10000) >> 32
                                            mem[644 len 0] = 0
                                            call wantAddress with:
                                               funct uint32(stor12)
                                                 gas gas_remaining wei
                                                args Mask(224, 32, -arg2 * sub_9ccccc15 / 10000) << 224, mem[644 len 4]
                                    else:
                                        if wantLockedTotal < ext_call.return_data[0]:
                                            if wantLockedTotal > wantLockedTotal:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            wantLockedTotal = 0
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                            if ext_code.size(wantAddress) <= 0:
                                                revert with 0, 'Address: call to non-contract'
                                            mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                            call wantAddress with:
                                               funct uint32(stor12)
                                                 gas gas_remaining wei
                                                args Mask(480, 0, stor16.field_0), mem[644 len 4]
                                        else:
                                            if ext_call.return_data[0] > wantLockedTotal:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            wantLockedTotal -= ext_call.return_data[0]
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                            if ext_code.size(wantAddress) <= 0:
                                                revert with 0, 'Address: call to non-contract'
                                            mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), ext_call.return_data[0 len 28]
                                            mem[644 len 0] = 0
                                            call wantAddress with:
                                               funct uint32(stor12)
                                                 gas gas_remaining wei
                                                args Mask(480, -256, ext_call.return_data[0 len 28]) << 256, mem[644 len 4]
                        else:
                            require arg2
                            if arg2 * withdrawFeeFactor / arg2 != withdrawFeeFactor:
                                revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                            if arg2 * sub_9ccccc15 / 10000 <= 0:
                                if not isAutoComp:
                                    require ext_code.size(wantAddress)
                                    staticcall wantAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if arg2 * withdrawFeeFactor / 10000 <= ext_call.return_data[0]:
                                        if wantLockedTotal >= arg2 * withdrawFeeFactor / 10000:
                                            if arg2 * withdrawFeeFactor / 10000 > wantLockedTotal:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            wantLockedTotal -= arg2 * withdrawFeeFactor / 10000
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                            if ext_code.size(wantAddress) <= 0:
                                                revert with 0, 'Address: call to non-contract'
                                            mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 32, arg2 * withdrawFeeFactor / 10000) >> 32
                                            mem[644 len 0] = 0
                                            call wantAddress with:
                                               funct uint32(stor12)
                                                 gas gas_remaining wei
                                                args Mask(224, 32, arg2 * withdrawFeeFactor / 10000) << 224, mem[644 len 4]
                                        else:
                                            if wantLockedTotal > wantLockedTotal:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            wantLockedTotal = 0
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                            if ext_code.size(wantAddress) <= 0:
                                                revert with 0, 'Address: call to non-contract'
                                            mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                            mem[644 len 0] = 0
                                            call wantAddress with:
                                               funct uint32(stor12)
                                                 gas gas_remaining wei
                                                args Mask(480, 0, stor16.field_0), mem[644 len 4]
                                    else:
                                        if wantLockedTotal >= ext_call.return_data[0]:
                                            if ext_call.return_data[0] > wantLockedTotal:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            wantLockedTotal -= ext_call.return_data[0]
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                            if ext_code.size(wantAddress) <= 0:
                                                revert with 0, 'Address: call to non-contract'
                                            mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), ext_call.return_data[0 len 28]
                                            mem[644 len 0] = 0
                                            call wantAddress with:
                                               funct uint32(stor12)
                                                 gas gas_remaining wei
                                                args Mask(480, -256, ext_call.return_data[0 len 28]) << 256, mem[644 len 4]
                                        else:
                                            if wantLockedTotal > wantLockedTotal:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            wantLockedTotal = 0
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                            if ext_code.size(wantAddress) <= 0:
                                                revert with 0, 'Address: call to non-contract'
                                            mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                            mem[644 len 0] = 0
                                            call wantAddress with:
                                               funct uint32(stor12)
                                                 gas gas_remaining wei
                                                args Mask(480, 0, stor16.field_0), mem[644 len 4]
                                else:
                                    require ext_code.size(farmContractAddress)
                                    call farmContractAddress.withdraw(uint256 arg1, uint256 arg2) with:
                                         gas gas_remaining wei
                                        args pid, arg2 * withdrawFeeFactor / 10000
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(wantAddress)
                                    staticcall wantAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if arg2 * withdrawFeeFactor / 10000 <= ext_call.return_data[0]:
                                        if wantLockedTotal < arg2 * withdrawFeeFactor / 10000:
                                            if wantLockedTotal > wantLockedTotal:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            wantLockedTotal = 0
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                            if ext_code.size(wantAddress) <= 0:
                                                revert with 0, 'Address: call to non-contract'
                                            mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                            call wantAddress with:
                                               funct uint32(stor12)
                                                 gas gas_remaining wei
                                                args Mask(480, 0, stor16.field_0), mem[644 len 4]
                                        else:
                                            if arg2 * withdrawFeeFactor / 10000 > wantLockedTotal:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            wantLockedTotal -= arg2 * withdrawFeeFactor / 10000
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                            if ext_code.size(wantAddress) <= 0:
                                                revert with 0, 'Address: call to non-contract'
                                            mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 32, arg2 * withdrawFeeFactor / 10000) >> 32
                                            mem[644 len 0] = 0
                                            call wantAddress with:
                                               funct uint32(stor12)
                                                 gas gas_remaining wei
                                                args Mask(224, 32, arg2 * withdrawFeeFactor / 10000) << 224, mem[644 len 4]
                                    else:
                                        if wantLockedTotal >= ext_call.return_data[0]:
                                            if ext_call.return_data[0] > wantLockedTotal:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            wantLockedTotal -= ext_call.return_data[0]
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                            if ext_code.size(wantAddress) <= 0:
                                                revert with 0, 'Address: call to non-contract'
                                            mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), ext_call.return_data[0 len 28]
                                            mem[644 len 0] = 0
                                            call wantAddress with:
                                               funct uint32(stor12)
                                                 gas gas_remaining wei
                                                args Mask(480, -256, ext_call.return_data[0 len 28]) << 256, mem[644 len 4]
                                        else:
                                            if wantLockedTotal > wantLockedTotal:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            wantLockedTotal = 0
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                            if ext_code.size(wantAddress) <= 0:
                                                revert with 0, 'Address: call to non-contract'
                                            mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                            mem[644 len 0] = 0
                                            call wantAddress with:
                                               funct uint32(stor12)
                                                 gas gas_remaining wei
                                                args Mask(480, 0, stor16.field_0), mem[644 len 4]
                            else:
                                if not isAutoComp:
                                    require ext_code.size(wantAddress)
                                    staticcall wantAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if (arg2 * withdrawFeeFactor / 10000) - (arg2 * sub_9ccccc15 / 10000) > ext_call.return_data[0]:
                                        if wantLockedTotal >= ext_call.return_data[0]:
                                            if ext_call.return_data[0] > wantLockedTotal:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            wantLockedTotal -= ext_call.return_data[0]
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                            if ext_code.size(wantAddress) <= 0:
                                                revert with 0, 'Address: call to non-contract'
                                            mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), ext_call.return_data[0 len 28]
                                            call wantAddress with:
                                               funct uint32(stor12)
                                                 gas gas_remaining wei
                                                args Mask(480, -256, ext_call.return_data[0 len 28]) << 256, mem[644 len 4]
                                        else:
                                            if wantLockedTotal > wantLockedTotal:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            wantLockedTotal = 0
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                            if ext_code.size(wantAddress) <= 0:
                                                revert with 0, 'Address: call to non-contract'
                                            mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                            call wantAddress with:
                                               funct uint32(stor12)
                                                 gas gas_remaining wei
                                                args Mask(480, 0, stor16.field_0), mem[644 len 4]
                                    else:
                                        if wantLockedTotal >= (arg2 * withdrawFeeFactor / 10000) - (arg2 * sub_9ccccc15 / 10000):
                                            if (arg2 * withdrawFeeFactor / 10000) - (arg2 * sub_9ccccc15 / 10000) > wantLockedTotal:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            wantLockedTotal = wantLockedTotal - (arg2 * withdrawFeeFactor / 10000) + (arg2 * sub_9ccccc15 / 10000)
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                            if ext_code.size(wantAddress) <= 0:
                                                revert with 0, 'Address: call to non-contract'
                                            mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 32, (arg2 * withdrawFeeFactor / 10000) - (arg2 * sub_9ccccc15 / 10000)) >> 32
                                            call wantAddress with:
                                               funct uint32(stor12)
                                                 gas gas_remaining wei
                                                args Mask(224, 32, (arg2 * withdrawFeeFactor / 10000) - (arg2 * sub_9ccccc15 / 10000)) << 224, mem[644 len 4]
                                        else:
                                            if wantLockedTotal > wantLockedTotal:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            wantLockedTotal = 0
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                            if ext_code.size(wantAddress) <= 0:
                                                revert with 0, 'Address: call to non-contract'
                                            mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                            mem[644 len 0] = 0
                                            call wantAddress with:
                                               funct uint32(stor12)
                                                 gas gas_remaining wei
                                                args Mask(480, 0, stor16.field_0), mem[644 len 4]
                                else:
                                    require ext_code.size(farmContractAddress)
                                    call farmContractAddress.withdraw(uint256 arg1, uint256 arg2) with:
                                         gas gas_remaining wei
                                        args pid, (arg2 * withdrawFeeFactor / 10000) - (arg2 * sub_9ccccc15 / 10000)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(wantAddress)
                                    staticcall wantAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if (arg2 * withdrawFeeFactor / 10000) - (arg2 * sub_9ccccc15 / 10000) <= ext_call.return_data[0]:
                                        if wantLockedTotal >= (arg2 * withdrawFeeFactor / 10000) - (arg2 * sub_9ccccc15 / 10000):
                                            if (arg2 * withdrawFeeFactor / 10000) - (arg2 * sub_9ccccc15 / 10000) > wantLockedTotal:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            wantLockedTotal = wantLockedTotal - (arg2 * withdrawFeeFactor / 10000) + (arg2 * sub_9ccccc15 / 10000)
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                            if ext_code.size(wantAddress) <= 0:
                                                revert with 0, 'Address: call to non-contract'
                                            mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 32, (arg2 * withdrawFeeFactor / 10000) - (arg2 * sub_9ccccc15 / 10000)) >> 32
                                            call wantAddress with:
                                               funct uint32(stor12)
                                                 gas gas_remaining wei
                                                args Mask(224, 32, (arg2 * withdrawFeeFactor / 10000) - (arg2 * sub_9ccccc15 / 10000)) << 224, mem[644 len 4]
                                        else:
                                            if wantLockedTotal > wantLockedTotal:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            wantLockedTotal = 0
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                            if ext_code.size(wantAddress) <= 0:
                                                revert with 0, 'Address: call to non-contract'
                                            mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                            call wantAddress with:
                                               funct uint32(stor12)
                                                 gas gas_remaining wei
                                                args Mask(480, 0, stor16.field_0), mem[644 len 4]
                                    else:
                                        if wantLockedTotal >= ext_call.return_data[0]:
                                            if ext_call.return_data[0] > wantLockedTotal:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            wantLockedTotal -= ext_call.return_data[0]
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                            if ext_code.size(wantAddress) <= 0:
                                                revert with 0, 'Address: call to non-contract'
                                            mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), ext_call.return_data[0 len 28]
                                            mem[644 len 0] = 0
                                            call wantAddress with:
                                               funct uint32(stor12)
                                                 gas gas_remaining wei
                                                args Mask(480, -256, ext_call.return_data[0 len 28]) << 256, mem[644 len 4]
                                        else:
                                            if wantLockedTotal > wantLockedTotal:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            wantLockedTotal = 0
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                            if ext_code.size(wantAddress) <= 0:
                                                revert with 0, 'Address: call to non-contract'
                                            mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                            mem[644 len 0] = 0
                                            call wantAddress with:
                                               funct uint32(stor12)
                                                 gas gas_remaining wei
                                                args Mask(480, 0, stor16.field_0), mem[644 len 4]
                        if not return_data.size:
                            require not ext_call.success
                            revert with 'SafeMath: division by zero'
                        mem[612 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size > 0:
                                revert with ext_call.return_data[0 len return_data.size]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if return_data.size > 0:
                            require return_data.size >= 32
                            if not mem[612]:
                                revert with 0, 
                                            32,
                                            42,
                                            0x775361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                            mem[ceil32(return_data.size) + 691 len 22]
    else:
        require arg2
        if arg2 * sharesTotal / arg2 != sharesTotal:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        33,
                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                        mem[197 len 31]
        if wantLockedTotal <= 0:
            revert with 0, 'SafeMath: division by zero'
        require wantLockedTotal
        if arg2 * sharesTotal / wantLockedTotal <= sharesTotal:
            sharesTotal -= arg2 * sharesTotal / wantLockedTotal
            if sub_9ccccc15 <= 0:
                if withdrawFeeFactor >= 10000:
                    if not isAutoComp:
                        require ext_code.size(wantAddress)
                        staticcall wantAddress.0x70a08231 with:
                                gas gas_remaining wei
                               args this.address
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if arg2 <= ext_call.return_data[0]:
                            if wantLockedTotal < arg2:
                                if wantLockedTotal > wantLockedTotal:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                wantLockedTotal = 0
                                if eth.balance(this.address) < 0:
                                    revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[558 len 26]
                                if ext_code.size(wantAddress) <= 0:
                                    revert with 0, 'Address: call to non-contract'
                                mem[452 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                call wantAddress with:
                                   funct uint32(stor12)
                                     gas gas_remaining wei
                                    args Mask(480, 0, stor16.field_0), mem[516 len 4]
                            else:
                                if arg2 > wantLockedTotal:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                wantLockedTotal -= arg2
                                if eth.balance(this.address) < 0:
                                    revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[558 len 26]
                                if ext_code.size(wantAddress) <= 0:
                                    revert with 0, 'Address: call to non-contract'
                                mem[452 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 32, arg2) >> 32
                                mem[516 len 0] = 0
                                call wantAddress with:
                                   funct uint32(stor12)
                                     gas gas_remaining wei
                                    args Mask(224, 32, arg2) << 224, mem[516 len 4]
                        else:
                            if wantLockedTotal >= ext_call.return_data[0]:
                                if ext_call.return_data[0] > wantLockedTotal:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                wantLockedTotal -= ext_call.return_data[0]
                                if eth.balance(this.address) < 0:
                                    revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[558 len 26]
                                if ext_code.size(wantAddress) <= 0:
                                    revert with 0, 'Address: call to non-contract'
                                mem[452 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), ext_call.return_data[0 len 28]
                                mem[516 len 0] = 0
                                call wantAddress with:
                                   funct uint32(stor12)
                                     gas gas_remaining wei
                                    args Mask(480, -256, ext_call.return_data[0 len 28]) << 256, mem[516 len 4]
                            else:
                                if wantLockedTotal > wantLockedTotal:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                wantLockedTotal = 0
                                if eth.balance(this.address) < 0:
                                    revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[558 len 26]
                                if ext_code.size(wantAddress) <= 0:
                                    revert with 0, 'Address: call to non-contract'
                                mem[452 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                mem[516 len 0] = 0
                                call wantAddress with:
                                   funct uint32(stor12)
                                     gas gas_remaining wei
                                    args Mask(480, 0, stor16.field_0), mem[516 len 4]
                    else:
                        require ext_code.size(farmContractAddress)
                        call farmContractAddress.withdraw(uint256 arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args pid, arg2
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require ext_code.size(wantAddress)
                        staticcall wantAddress.0x70a08231 with:
                                gas gas_remaining wei
                               args this.address
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if arg2 <= ext_call.return_data[0]:
                            if wantLockedTotal >= arg2:
                                if arg2 > wantLockedTotal:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                wantLockedTotal -= arg2
                                if eth.balance(this.address) < 0:
                                    revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[558 len 26]
                                if ext_code.size(wantAddress) <= 0:
                                    revert with 0, 'Address: call to non-contract'
                                mem[452 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 32, arg2) >> 32
                                mem[516 len 0] = 0
                                call wantAddress with:
                                   funct uint32(stor12)
                                     gas gas_remaining wei
                                    args Mask(224, 32, arg2) << 224, mem[516 len 4]
                            else:
                                if wantLockedTotal > wantLockedTotal:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                wantLockedTotal = 0
                                if eth.balance(this.address) < 0:
                                    revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[558 len 26]
                                if ext_code.size(wantAddress) <= 0:
                                    revert with 0, 'Address: call to non-contract'
                                mem[452 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                mem[516 len 0] = 0
                                call wantAddress with:
                                   funct uint32(stor12)
                                     gas gas_remaining wei
                                    args Mask(480, 0, stor16.field_0), mem[516 len 4]
                        else:
                            if wantLockedTotal >= ext_call.return_data[0]:
                                if ext_call.return_data[0] > wantLockedTotal:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                wantLockedTotal -= ext_call.return_data[0]
                                if eth.balance(this.address) < 0:
                                    revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[558 len 26]
                                if ext_code.size(wantAddress) <= 0:
                                    revert with 0, 'Address: call to non-contract'
                                mem[452 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), ext_call.return_data[0 len 28]
                                mem[516 len 0] = 0
                                call wantAddress with:
                                   funct uint32(stor12)
                                     gas gas_remaining wei
                                    args Mask(480, -256, ext_call.return_data[0 len 28]) << 256, mem[516 len 4]
                            else:
                                if wantLockedTotal > wantLockedTotal:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                wantLockedTotal = 0
                                if eth.balance(this.address) < 0:
                                    revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[558 len 26]
                                if ext_code.size(wantAddress) <= 0:
                                    revert with 0, 'Address: call to non-contract'
                                mem[452 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                mem[516 len 0] = 0
                                call wantAddress with:
                                   funct uint32(stor12)
                                     gas gas_remaining wei
                                    args Mask(480, 0, stor16.field_0), mem[516 len 4]
                    if not return_data.size:
                        require not ext_call.success
                        revert with 'SafeMath: division by zero'
                    mem[484 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not ext_call.success:
                        if return_data.size > 0:
                            revert with ext_call.return_data[0 len return_data.size]
                        revert with 0, 'SafeERC20: low-level call failed'
                    if return_data.size > 0:
                        require return_data.size >= 32
                        if not mem[484]:
                            revert with 0, 
                                        32,
                                        42,
                                        0x775361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                        mem[ceil32(return_data.size) + 563 len 22]
                else:
                    if not arg2:
                        if not isAutoComp:
                            require ext_code.size(wantAddress)
                            staticcall wantAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if 0 <= ext_call.return_data[0]:
                                if wantLockedTotal >= 0:
                                    if 0 > wantLockedTotal:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                    if ext_code.size(wantAddress) <= 0:
                                        revert with 0, 'Address: call to non-contract'
                                    mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), 0
                                    call wantAddress with:
                                       funct uint32(stor12)
                                         gas gas_remaining wei
                                        args 0, mem[580 len 4]
                                else:
                                    if wantLockedTotal > wantLockedTotal:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    wantLockedTotal = 0
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                    if ext_code.size(wantAddress) <= 0:
                                        revert with 0, 'Address: call to non-contract'
                                    mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                    call wantAddress with:
                                       funct uint32(stor12)
                                         gas gas_remaining wei
                                        args Mask(480, 0, stor16.field_0), mem[580 len 4]
                            else:
                                if wantLockedTotal >= ext_call.return_data[0]:
                                    if ext_call.return_data[0] > wantLockedTotal:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    wantLockedTotal -= ext_call.return_data[0]
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                    if ext_code.size(wantAddress) <= 0:
                                        revert with 0, 'Address: call to non-contract'
                                    mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), ext_call.return_data[0 len 28]
                                    mem[580 len 0] = 0
                                    call wantAddress with:
                                       funct uint32(stor12)
                                         gas gas_remaining wei
                                        args Mask(480, -256, ext_call.return_data[0 len 28]) << 256, mem[580 len 4]
                                else:
                                    if wantLockedTotal > wantLockedTotal:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    wantLockedTotal = 0
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                    if ext_code.size(wantAddress) <= 0:
                                        revert with 0, 'Address: call to non-contract'
                                    mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                    mem[580 len 0] = 0
                                    call wantAddress with:
                                       funct uint32(stor12)
                                         gas gas_remaining wei
                                        args Mask(480, 0, stor16.field_0), mem[580 len 4]
                        else:
                            require ext_code.size(farmContractAddress)
                            call farmContractAddress.withdraw(uint256 arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args pid, 0
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require ext_code.size(wantAddress)
                            staticcall wantAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if 0 <= ext_call.return_data[0]:
                                if wantLockedTotal >= 0:
                                    if 0 > wantLockedTotal:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                    if ext_code.size(wantAddress) <= 0:
                                        revert with 0, 'Address: call to non-contract'
                                    mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), 0
                                    call wantAddress with:
                                       funct uint32(stor12)
                                         gas gas_remaining wei
                                        args 0, mem[580 len 4]
                                else:
                                    if wantLockedTotal > wantLockedTotal:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    wantLockedTotal = 0
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                    if ext_code.size(wantAddress) <= 0:
                                        revert with 0, 'Address: call to non-contract'
                                    mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                    call wantAddress with:
                                       funct uint32(stor12)
                                         gas gas_remaining wei
                                        args Mask(480, 0, stor16.field_0), mem[580 len 4]
                            else:
                                if wantLockedTotal >= ext_call.return_data[0]:
                                    if ext_call.return_data[0] > wantLockedTotal:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    wantLockedTotal -= ext_call.return_data[0]
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                    if ext_code.size(wantAddress) <= 0:
                                        revert with 0, 'Address: call to non-contract'
                                    mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), ext_call.return_data[0 len 28]
                                    call wantAddress with:
                                       funct uint32(stor12)
                                         gas gas_remaining wei
                                        args Mask(480, -256, ext_call.return_data[0 len 28]) << 256, mem[580 len 4]
                                else:
                                    if wantLockedTotal > wantLockedTotal:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    wantLockedTotal = 0
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                    if ext_code.size(wantAddress) <= 0:
                                        revert with 0, 'Address: call to non-contract'
                                    mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                    mem[580 len 0] = 0
                                    call wantAddress with:
                                       funct uint32(stor12)
                                         gas gas_remaining wei
                                        args Mask(480, 0, stor16.field_0), mem[580 len 4]
                    else:
                        require arg2
                        if arg2 * withdrawFeeFactor / arg2 != withdrawFeeFactor:
                            revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                        if not isAutoComp:
                            require ext_code.size(wantAddress)
                            staticcall wantAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if arg2 * withdrawFeeFactor / 10000 <= ext_call.return_data[0]:
                                if wantLockedTotal >= arg2 * withdrawFeeFactor / 10000:
                                    if arg2 * withdrawFeeFactor / 10000 > wantLockedTotal:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    wantLockedTotal -= arg2 * withdrawFeeFactor / 10000
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                    if ext_code.size(wantAddress) <= 0:
                                        revert with 0, 'Address: call to non-contract'
                                    mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 32, arg2 * withdrawFeeFactor / 10000) >> 32
                                    call wantAddress with:
                                       funct uint32(stor12)
                                         gas gas_remaining wei
                                        args Mask(224, 32, arg2 * withdrawFeeFactor / 10000) << 224, mem[580 len 4]
                                else:
                                    if wantLockedTotal > wantLockedTotal:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    wantLockedTotal = 0
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                    if ext_code.size(wantAddress) <= 0:
                                        revert with 0, 'Address: call to non-contract'
                                    mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                    mem[580 len 0] = 0
                                    call wantAddress with:
                                       funct uint32(stor12)
                                         gas gas_remaining wei
                                        args Mask(480, 0, stor16.field_0), mem[580 len 4]
                            else:
                                if wantLockedTotal >= ext_call.return_data[0]:
                                    if ext_call.return_data[0] > wantLockedTotal:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    wantLockedTotal -= ext_call.return_data[0]
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                    if ext_code.size(wantAddress) <= 0:
                                        revert with 0, 'Address: call to non-contract'
                                    mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), ext_call.return_data[0 len 28]
                                    call wantAddress with:
                                       funct uint32(stor12)
                                         gas gas_remaining wei
                                        args Mask(480, -256, ext_call.return_data[0 len 28]) << 256, mem[580 len 4]
                                else:
                                    if wantLockedTotal > wantLockedTotal:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    wantLockedTotal = 0
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                    if ext_code.size(wantAddress) <= 0:
                                        revert with 0, 'Address: call to non-contract'
                                    mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                    mem[580 len 0] = 0
                                    call wantAddress with:
                                       funct uint32(stor12)
                                         gas gas_remaining wei
                                        args Mask(480, 0, stor16.field_0), mem[580 len 4]
                        else:
                            require ext_code.size(farmContractAddress)
                            call farmContractAddress.withdraw(uint256 arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args pid, arg2 * withdrawFeeFactor / 10000
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require ext_code.size(wantAddress)
                            staticcall wantAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if arg2 * withdrawFeeFactor / 10000 <= ext_call.return_data[0]:
                                if wantLockedTotal >= arg2 * withdrawFeeFactor / 10000:
                                    if arg2 * withdrawFeeFactor / 10000 > wantLockedTotal:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    wantLockedTotal -= arg2 * withdrawFeeFactor / 10000
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                    if ext_code.size(wantAddress) <= 0:
                                        revert with 0, 'Address: call to non-contract'
                                    mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 32, arg2 * withdrawFeeFactor / 10000) >> 32
                                    mem[580 len 0] = 0
                                    call wantAddress with:
                                       funct uint32(stor12)
                                         gas gas_remaining wei
                                        args Mask(224, 32, arg2 * withdrawFeeFactor / 10000) << 224, mem[580 len 4]
                                else:
                                    if wantLockedTotal > wantLockedTotal:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    wantLockedTotal = 0
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                    if ext_code.size(wantAddress) <= 0:
                                        revert with 0, 'Address: call to non-contract'
                                    mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                    mem[580 len 0] = 0
                                    call wantAddress with:
                                       funct uint32(stor12)
                                         gas gas_remaining wei
                                        args Mask(480, 0, stor16.field_0), mem[580 len 4]
                            else:
                                if wantLockedTotal >= ext_call.return_data[0]:
                                    if ext_call.return_data[0] > wantLockedTotal:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    wantLockedTotal -= ext_call.return_data[0]
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                    if ext_code.size(wantAddress) <= 0:
                                        revert with 0, 'Address: call to non-contract'
                                    mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), ext_call.return_data[0 len 28]
                                    call wantAddress with:
                                       funct uint32(stor12)
                                         gas gas_remaining wei
                                        args Mask(480, -256, ext_call.return_data[0 len 28]) << 256, mem[580 len 4]
                                else:
                                    if wantLockedTotal > wantLockedTotal:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    wantLockedTotal = 0
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                    if ext_code.size(wantAddress) <= 0:
                                        revert with 0, 'Address: call to non-contract'
                                    mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                    mem[580 len 0] = 0
                                    call wantAddress with:
                                       funct uint32(stor12)
                                         gas gas_remaining wei
                                        args Mask(480, 0, stor16.field_0), mem[580 len 4]
                    if not return_data.size:
                        require not ext_call.success
                        revert with 'SafeMath: division by zero'
                    mem[548 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not ext_call.success:
                        if return_data.size > 0:
                            revert with ext_call.return_data[0 len return_data.size]
                        revert with 0, 'SafeERC20: low-level call failed'
                    if return_data.size > 0:
                        require return_data.size >= 32
                        if not mem[548]:
                            revert with 0, 
                                        32,
                                        42,
                                        0x775361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                        mem[ceil32(return_data.size) + 627 len 22]
            else:
                if stor27[address(arg1)] + sub_c7095c4b < stor27[address(arg1)]:
                    revert with 0, 'SafeMath: addition overflow'
                if stor27[address(arg1)] + sub_c7095c4b <= block.timestamp:
                    if withdrawFeeFactor >= 10000:
                        if not isAutoComp:
                            require ext_code.size(wantAddress)
                            staticcall wantAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if arg2 <= ext_call.return_data[0]:
                                if wantLockedTotal >= arg2:
                                    if arg2 > wantLockedTotal:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    wantLockedTotal -= arg2
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[558 len 26]
                                    if ext_code.size(wantAddress) <= 0:
                                        revert with 0, 'Address: call to non-contract'
                                    mem[452 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 32, arg2) >> 32
                                    call wantAddress with:
                                       funct uint32(stor12)
                                         gas gas_remaining wei
                                        args Mask(224, 32, arg2) << 224, mem[516 len 4]
                                else:
                                    if wantLockedTotal > wantLockedTotal:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    wantLockedTotal = 0
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[558 len 26]
                                    if ext_code.size(wantAddress) <= 0:
                                        revert with 0, 'Address: call to non-contract'
                                    mem[452 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                    call wantAddress with:
                                       funct uint32(stor12)
                                         gas gas_remaining wei
                                        args Mask(480, 0, stor16.field_0), mem[516 len 4]
                            else:
                                if wantLockedTotal >= ext_call.return_data[0]:
                                    if ext_call.return_data[0] > wantLockedTotal:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    wantLockedTotal -= ext_call.return_data[0]
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[558 len 26]
                                    if ext_code.size(wantAddress) <= 0:
                                        revert with 0, 'Address: call to non-contract'
                                    mem[452 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), ext_call.return_data[0 len 28]
                                    call wantAddress with:
                                       funct uint32(stor12)
                                         gas gas_remaining wei
                                        args Mask(480, -256, ext_call.return_data[0 len 28]) << 256, mem[516 len 4]
                                else:
                                    if wantLockedTotal > wantLockedTotal:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    wantLockedTotal = 0
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[558 len 26]
                                    if ext_code.size(wantAddress) <= 0:
                                        revert with 0, 'Address: call to non-contract'
                                    mem[452 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                    mem[516 len 0] = 0
                                    call wantAddress with:
                                       funct uint32(stor12)
                                         gas gas_remaining wei
                                        args Mask(480, 0, stor16.field_0), mem[516 len 4]
                        else:
                            require ext_code.size(farmContractAddress)
                            call farmContractAddress.withdraw(uint256 arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args pid, arg2
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require ext_code.size(wantAddress)
                            staticcall wantAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if arg2 <= ext_call.return_data[0]:
                                if wantLockedTotal >= arg2:
                                    if arg2 > wantLockedTotal:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    wantLockedTotal -= arg2
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[558 len 26]
                                    if ext_code.size(wantAddress) <= 0:
                                        revert with 0, 'Address: call to non-contract'
                                    mem[452 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 32, arg2) >> 32
                                    call wantAddress with:
                                       funct uint32(stor12)
                                         gas gas_remaining wei
                                        args Mask(224, 32, arg2) << 224, mem[516 len 4]
                                else:
                                    if wantLockedTotal > wantLockedTotal:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    wantLockedTotal = 0
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[558 len 26]
                                    if ext_code.size(wantAddress) <= 0:
                                        revert with 0, 'Address: call to non-contract'
                                    mem[452 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                    call wantAddress with:
                                       funct uint32(stor12)
                                         gas gas_remaining wei
                                        args Mask(480, 0, stor16.field_0), mem[516 len 4]
                            else:
                                if wantLockedTotal >= ext_call.return_data[0]:
                                    if ext_call.return_data[0] > wantLockedTotal:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    wantLockedTotal -= ext_call.return_data[0]
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[558 len 26]
                                    if ext_code.size(wantAddress) <= 0:
                                        revert with 0, 'Address: call to non-contract'
                                    mem[452 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), ext_call.return_data[0 len 28]
                                    mem[516 len 0] = 0
                                    call wantAddress with:
                                       funct uint32(stor12)
                                         gas gas_remaining wei
                                        args Mask(480, -256, ext_call.return_data[0 len 28]) << 256, mem[516 len 4]
                                else:
                                    if wantLockedTotal > wantLockedTotal:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    wantLockedTotal = 0
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[558 len 26]
                                    if ext_code.size(wantAddress) <= 0:
                                        revert with 0, 'Address: call to non-contract'
                                    mem[452 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                    mem[516 len 0] = 0
                                    call wantAddress with:
                                       funct uint32(stor12)
                                         gas gas_remaining wei
                                        args Mask(480, 0, stor16.field_0), mem[516 len 4]
                        if not return_data.size:
                            require not ext_call.success
                            revert with 'SafeMath: division by zero'
                        mem[484 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size > 0:
                                revert with ext_call.return_data[0 len return_data.size]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if return_data.size > 0:
                            require return_data.size >= 32
                            if not mem[484]:
                                revert with 0, 
                                            32,
                                            42,
                                            0x775361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                            mem[ceil32(return_data.size) + 563 len 22]
                    else:
                        if not arg2:
                            if not isAutoComp:
                                require ext_code.size(wantAddress)
                                staticcall wantAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if 0 <= ext_call.return_data[0]:
                                    if wantLockedTotal >= 0:
                                        if 0 > wantLockedTotal:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                        if ext_code.size(wantAddress) <= 0:
                                            revert with 0, 'Address: call to non-contract'
                                        mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), 0
                                        mem[580 len 0] = 0
                                        call wantAddress with:
                                           funct uint32(stor12)
                                             gas gas_remaining wei
                                            args Mask(480, -256, unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), 0) << 256, mem[580 len 4]
                                    else:
                                        if wantLockedTotal > wantLockedTotal:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        wantLockedTotal = 0
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                        if ext_code.size(wantAddress) <= 0:
                                            revert with 0, 'Address: call to non-contract'
                                        mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                        call wantAddress with:
                                           funct uint32(stor12)
                                             gas gas_remaining wei
                                            args Mask(480, 0, stor16.field_0), mem[580 len 4]
                                else:
                                    if wantLockedTotal >= ext_call.return_data[0]:
                                        if ext_call.return_data[0] > wantLockedTotal:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        wantLockedTotal -= ext_call.return_data[0]
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                        if ext_code.size(wantAddress) <= 0:
                                            revert with 0, 'Address: call to non-contract'
                                        mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), ext_call.return_data[0 len 28]
                                        call wantAddress with:
                                           funct uint32(stor12)
                                             gas gas_remaining wei
                                            args Mask(480, -256, ext_call.return_data[0 len 28]) << 256, mem[580 len 4]
                                    else:
                                        if wantLockedTotal > wantLockedTotal:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        wantLockedTotal = 0
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                        if ext_code.size(wantAddress) <= 0:
                                            revert with 0, 'Address: call to non-contract'
                                        mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                        mem[580 len 0] = 0
                                        call wantAddress with:
                                           funct uint32(stor12)
                                             gas gas_remaining wei
                                            args Mask(480, 0, stor16.field_0), mem[580 len 4]
                            else:
                                require ext_code.size(farmContractAddress)
                                call farmContractAddress.withdraw(uint256 arg1, uint256 arg2) with:
                                     gas gas_remaining wei
                                    args pid, 0
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(wantAddress)
                                staticcall wantAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if 0 <= ext_call.return_data[0]:
                                    if wantLockedTotal >= 0:
                                        if 0 > wantLockedTotal:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                        if ext_code.size(wantAddress) <= 0:
                                            revert with 0, 'Address: call to non-contract'
                                        mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), 0
                                        call wantAddress with:
                                           funct uint32(stor12)
                                             gas gas_remaining wei
                                            args 0, mem[580 len 4]
                                    else:
                                        if wantLockedTotal > wantLockedTotal:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        wantLockedTotal = 0
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                        if ext_code.size(wantAddress) <= 0:
                                            revert with 0, 'Address: call to non-contract'
                                        mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                        call wantAddress with:
                                           funct uint32(stor12)
                                             gas gas_remaining wei
                                            args Mask(480, 0, stor16.field_0), mem[580 len 4]
                                else:
                                    if wantLockedTotal >= ext_call.return_data[0]:
                                        if ext_call.return_data[0] > wantLockedTotal:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        wantLockedTotal -= ext_call.return_data[0]
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                        if ext_code.size(wantAddress) <= 0:
                                            revert with 0, 'Address: call to non-contract'
                                        mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), ext_call.return_data[0 len 28]
                                        mem[580 len 0] = 0
                                        call wantAddress with:
                                           funct uint32(stor12)
                                             gas gas_remaining wei
                                            args Mask(480, -256, ext_call.return_data[0 len 28]) << 256, mem[580 len 4]
                                    else:
                                        if wantLockedTotal > wantLockedTotal:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        wantLockedTotal = 0
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                        if ext_code.size(wantAddress) <= 0:
                                            revert with 0, 'Address: call to non-contract'
                                        mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                        mem[580 len 0] = 0
                                        call wantAddress with:
                                           funct uint32(stor12)
                                             gas gas_remaining wei
                                            args Mask(480, 0, stor16.field_0), mem[580 len 4]
                        else:
                            require arg2
                            if arg2 * withdrawFeeFactor / arg2 != withdrawFeeFactor:
                                revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                            if not isAutoComp:
                                require ext_code.size(wantAddress)
                                staticcall wantAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if arg2 * withdrawFeeFactor / 10000 <= ext_call.return_data[0]:
                                    if wantLockedTotal >= arg2 * withdrawFeeFactor / 10000:
                                        if arg2 * withdrawFeeFactor / 10000 > wantLockedTotal:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        wantLockedTotal -= arg2 * withdrawFeeFactor / 10000
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                        if ext_code.size(wantAddress) <= 0:
                                            revert with 0, 'Address: call to non-contract'
                                        mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 32, arg2 * withdrawFeeFactor / 10000) >> 32
                                        mem[580 len 0] = 0
                                        call wantAddress with:
                                           funct uint32(stor12)
                                             gas gas_remaining wei
                                            args Mask(224, 32, arg2 * withdrawFeeFactor / 10000) << 224, mem[580 len 4]
                                    else:
                                        if wantLockedTotal > wantLockedTotal:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        wantLockedTotal = 0
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                        if ext_code.size(wantAddress) <= 0:
                                            revert with 0, 'Address: call to non-contract'
                                        mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                        mem[580 len 0] = 0
                                        call wantAddress with:
                                           funct uint32(stor12)
                                             gas gas_remaining wei
                                            args Mask(480, 0, stor16.field_0), mem[580 len 4]
                                else:
                                    if wantLockedTotal < ext_call.return_data[0]:
                                        if wantLockedTotal > wantLockedTotal:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        wantLockedTotal = 0
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                        if ext_code.size(wantAddress) <= 0:
                                            revert with 0, 'Address: call to non-contract'
                                        mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                        call wantAddress with:
                                           funct uint32(stor12)
                                             gas gas_remaining wei
                                            args Mask(480, 0, stor16.field_0), mem[580 len 4]
                                    else:
                                        if ext_call.return_data[0] > wantLockedTotal:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        wantLockedTotal -= ext_call.return_data[0]
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                        if ext_code.size(wantAddress) <= 0:
                                            revert with 0, 'Address: call to non-contract'
                                        mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), ext_call.return_data[0 len 28]
                                        mem[580 len 0] = 0
                                        call wantAddress with:
                                           funct uint32(stor12)
                                             gas gas_remaining wei
                                            args Mask(480, -256, ext_call.return_data[0 len 28]) << 256, mem[580 len 4]
                            else:
                                require ext_code.size(farmContractAddress)
                                call farmContractAddress.withdraw(uint256 arg1, uint256 arg2) with:
                                     gas gas_remaining wei
                                    args pid, arg2 * withdrawFeeFactor / 10000
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(wantAddress)
                                staticcall wantAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if arg2 * withdrawFeeFactor / 10000 <= ext_call.return_data[0]:
                                    if wantLockedTotal < arg2 * withdrawFeeFactor / 10000:
                                        if wantLockedTotal > wantLockedTotal:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        wantLockedTotal = 0
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                        if ext_code.size(wantAddress) <= 0:
                                            revert with 0, 'Address: call to non-contract'
                                        mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                        call wantAddress with:
                                           funct uint32(stor12)
                                             gas gas_remaining wei
                                            args Mask(480, 0, stor16.field_0), mem[580 len 4]
                                    else:
                                        if arg2 * withdrawFeeFactor / 10000 > wantLockedTotal:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        wantLockedTotal -= arg2 * withdrawFeeFactor / 10000
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                        if ext_code.size(wantAddress) <= 0:
                                            revert with 0, 'Address: call to non-contract'
                                        mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 32, arg2 * withdrawFeeFactor / 10000) >> 32
                                        mem[580 len 0] = 0
                                        call wantAddress with:
                                           funct uint32(stor12)
                                             gas gas_remaining wei
                                            args Mask(224, 32, arg2 * withdrawFeeFactor / 10000) << 224, mem[580 len 4]
                                else:
                                    if wantLockedTotal >= ext_call.return_data[0]:
                                        if ext_call.return_data[0] > wantLockedTotal:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        wantLockedTotal -= ext_call.return_data[0]
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                        if ext_code.size(wantAddress) <= 0:
                                            revert with 0, 'Address: call to non-contract'
                                        mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), ext_call.return_data[0 len 28]
                                        call wantAddress with:
                                           funct uint32(stor12)
                                             gas gas_remaining wei
                                            args Mask(480, -256, ext_call.return_data[0 len 28]) << 256, mem[580 len 4]
                                    else:
                                        if wantLockedTotal > wantLockedTotal:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        wantLockedTotal = 0
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                        if ext_code.size(wantAddress) <= 0:
                                            revert with 0, 'Address: call to non-contract'
                                        mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                        mem[580 len 0] = 0
                                        call wantAddress with:
                                           funct uint32(stor12)
                                             gas gas_remaining wei
                                            args Mask(480, 0, stor16.field_0), mem[580 len 4]
                        if not return_data.size:
                            require not ext_call.success
                            revert with 'SafeMath: division by zero'
                        mem[548 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size > 0:
                                revert with ext_call.return_data[0 len return_data.size]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if return_data.size > 0:
                            require return_data.size >= 32
                            if not mem[548]:
                                revert with 0, 
                                            32,
                                            42,
                                            0x775361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                            mem[ceil32(return_data.size) + 627 len 22]
                else:
                    if not arg2:
                        if withdrawFeeFactor >= 10000:
                            if not isAutoComp:
                                require ext_code.size(wantAddress)
                                staticcall wantAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if arg2 <= ext_call.return_data[0]:
                                    if wantLockedTotal >= arg2:
                                        if arg2 > wantLockedTotal:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        wantLockedTotal -= arg2
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                        if ext_code.size(wantAddress) <= 0:
                                            revert with 0, 'Address: call to non-contract'
                                        mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 32, arg2) >> 32
                                        mem[580 len 0] = 0
                                        call wantAddress with:
                                           funct uint32(stor12)
                                             gas gas_remaining wei
                                            args Mask(224, 32, arg2) << 224, mem[580 len 4]
                                    else:
                                        if wantLockedTotal > wantLockedTotal:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        wantLockedTotal = 0
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                        if ext_code.size(wantAddress) <= 0:
                                            revert with 0, 'Address: call to non-contract'
                                        mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                        mem[580 len 0] = 0
                                        call wantAddress with:
                                           funct uint32(stor12)
                                             gas gas_remaining wei
                                            args Mask(480, 0, stor16.field_0), mem[580 len 4]
                                else:
                                    if wantLockedTotal >= ext_call.return_data[0]:
                                        if ext_call.return_data[0] > wantLockedTotal:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        wantLockedTotal -= ext_call.return_data[0]
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                        if ext_code.size(wantAddress) <= 0:
                                            revert with 0, 'Address: call to non-contract'
                                        mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), ext_call.return_data[0 len 28]
                                        call wantAddress with:
                                           funct uint32(stor12)
                                             gas gas_remaining wei
                                            args Mask(480, -256, ext_call.return_data[0 len 28]) << 256, mem[580 len 4]
                                    else:
                                        if wantLockedTotal > wantLockedTotal:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        wantLockedTotal = 0
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                        if ext_code.size(wantAddress) <= 0:
                                            revert with 0, 'Address: call to non-contract'
                                        mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                        mem[580 len 0] = 0
                                        call wantAddress with:
                                           funct uint32(stor12)
                                             gas gas_remaining wei
                                            args Mask(480, 0, stor16.field_0), mem[580 len 4]
                            else:
                                require ext_code.size(farmContractAddress)
                                call farmContractAddress.withdraw(uint256 arg1, uint256 arg2) with:
                                     gas gas_remaining wei
                                    args pid, arg2
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(wantAddress)
                                staticcall wantAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if arg2 <= ext_call.return_data[0]:
                                    if wantLockedTotal >= arg2:
                                        if arg2 > wantLockedTotal:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        wantLockedTotal -= arg2
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                        if ext_code.size(wantAddress) <= 0:
                                            revert with 0, 'Address: call to non-contract'
                                        mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 32, arg2) >> 32
                                        call wantAddress with:
                                           funct uint32(stor12)
                                             gas gas_remaining wei
                                            args Mask(224, 32, arg2) << 224, mem[580 len 4]
                                    else:
                                        if wantLockedTotal > wantLockedTotal:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        wantLockedTotal = 0
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                        if ext_code.size(wantAddress) <= 0:
                                            revert with 0, 'Address: call to non-contract'
                                        mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                        call wantAddress with:
                                           funct uint32(stor12)
                                             gas gas_remaining wei
                                            args Mask(480, 0, stor16.field_0), mem[580 len 4]
                                else:
                                    if wantLockedTotal >= ext_call.return_data[0]:
                                        if ext_call.return_data[0] > wantLockedTotal:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        wantLockedTotal -= ext_call.return_data[0]
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                        if ext_code.size(wantAddress) <= 0:
                                            revert with 0, 'Address: call to non-contract'
                                        mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), ext_call.return_data[0 len 28]
                                        call wantAddress with:
                                           funct uint32(stor12)
                                             gas gas_remaining wei
                                            args Mask(480, -256, ext_call.return_data[0 len 28]) << 256, mem[580 len 4]
                                    else:
                                        if wantLockedTotal > wantLockedTotal:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        wantLockedTotal = 0
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                        if ext_code.size(wantAddress) <= 0:
                                            revert with 0, 'Address: call to non-contract'
                                        mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                        mem[580 len 0] = 0
                                        call wantAddress with:
                                           funct uint32(stor12)
                                             gas gas_remaining wei
                                            args Mask(480, 0, stor16.field_0), mem[580 len 4]
                            if not return_data.size:
                                require not ext_call.success
                                revert with 'SafeMath: division by zero'
                            mem[548 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                if return_data.size > 0:
                                    revert with ext_call.return_data[0 len return_data.size]
                                revert with 0, 'SafeERC20: low-level call failed'
                            if return_data.size > 0:
                                require return_data.size >= 32
                                if not mem[548]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x775361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[ceil32(return_data.size) + 627 len 22]
                        else:
                            if not arg2:
                                if not isAutoComp:
                                    require ext_code.size(wantAddress)
                                    staticcall wantAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if 0 <= ext_call.return_data[0]:
                                        if wantLockedTotal >= 0:
                                            if 0 > wantLockedTotal:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                            if ext_code.size(wantAddress) <= 0:
                                                revert with 0, 'Address: call to non-contract'
                                            mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), 0
                                            call wantAddress with:
                                               funct uint32(stor12)
                                                 gas gas_remaining wei
                                                args 0, mem[644 len 4]
                                        else:
                                            if wantLockedTotal > wantLockedTotal:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            wantLockedTotal = 0
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                            if ext_code.size(wantAddress) <= 0:
                                                revert with 0, 'Address: call to non-contract'
                                            mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                            mem[644 len 0] = 0
                                            call wantAddress with:
                                               funct uint32(stor12)
                                                 gas gas_remaining wei
                                                args Mask(480, 0, stor16.field_0), mem[644 len 4]
                                    else:
                                        if wantLockedTotal >= ext_call.return_data[0]:
                                            if ext_call.return_data[0] > wantLockedTotal:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            wantLockedTotal -= ext_call.return_data[0]
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                            if ext_code.size(wantAddress) <= 0:
                                                revert with 0, 'Address: call to non-contract'
                                            mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), ext_call.return_data[0 len 28]
                                            call wantAddress with:
                                               funct uint32(stor12)
                                                 gas gas_remaining wei
                                                args Mask(480, -256, ext_call.return_data[0 len 28]) << 256, mem[644 len 4]
                                        else:
                                            if wantLockedTotal > wantLockedTotal:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            wantLockedTotal = 0
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                            if ext_code.size(wantAddress) <= 0:
                                                revert with 0, 'Address: call to non-contract'
                                            mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                            mem[644 len 0] = 0
                                            call wantAddress with:
                                               funct uint32(stor12)
                                                 gas gas_remaining wei
                                                args Mask(480, 0, stor16.field_0), mem[644 len 4]
                                else:
                                    require ext_code.size(farmContractAddress)
                                    call farmContractAddress.withdraw(uint256 arg1, uint256 arg2) with:
                                         gas gas_remaining wei
                                        args pid, 0
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(wantAddress)
                                    staticcall wantAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if 0 <= ext_call.return_data[0]:
                                        if wantLockedTotal >= 0:
                                            if 0 > wantLockedTotal:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                            if ext_code.size(wantAddress) <= 0:
                                                revert with 0, 'Address: call to non-contract'
                                            mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), 0
                                            mem[644 len 0] = 0
                                            call wantAddress with:
                                               funct uint32(stor12)
                                                 gas gas_remaining wei
                                                args Mask(480, -256, unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), 0) << 256, mem[644 len 4]
                                        else:
                                            if wantLockedTotal > wantLockedTotal:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            wantLockedTotal = 0
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                            if ext_code.size(wantAddress) <= 0:
                                                revert with 0, 'Address: call to non-contract'
                                            mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                            mem[644 len 0] = 0
                                            call wantAddress with:
                                               funct uint32(stor12)
                                                 gas gas_remaining wei
                                                args Mask(480, 0, stor16.field_0), mem[644 len 4]
                                    else:
                                        if wantLockedTotal >= ext_call.return_data[0]:
                                            if ext_call.return_data[0] > wantLockedTotal:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            wantLockedTotal -= ext_call.return_data[0]
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                            if ext_code.size(wantAddress) <= 0:
                                                revert with 0, 'Address: call to non-contract'
                                            mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), ext_call.return_data[0 len 28]
                                            call wantAddress with:
                                               funct uint32(stor12)
                                                 gas gas_remaining wei
                                                args Mask(480, -256, ext_call.return_data[0 len 28]) << 256, mem[644 len 4]
                                        else:
                                            if wantLockedTotal > wantLockedTotal:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            wantLockedTotal = 0
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                            if ext_code.size(wantAddress) <= 0:
                                                revert with 0, 'Address: call to non-contract'
                                            mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                            mem[644 len 0] = 0
                                            call wantAddress with:
                                               funct uint32(stor12)
                                                 gas gas_remaining wei
                                                args Mask(480, 0, stor16.field_0), mem[644 len 4]
                            else:
                                require arg2
                                if arg2 * withdrawFeeFactor / arg2 != withdrawFeeFactor:
                                    revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                                if isAutoComp:
                                    require ext_code.size(farmContractAddress)
                                    call farmContractAddress.withdraw(uint256 arg1, uint256 arg2) with:
                                         gas gas_remaining wei
                                        args pid, arg2 * withdrawFeeFactor / 10000
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(wantAddress)
                                staticcall wantAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if arg2 * withdrawFeeFactor / 10000 <= ext_call.return_data[0]:
                                    if wantLockedTotal >= arg2 * withdrawFeeFactor / 10000:
                                        if arg2 * withdrawFeeFactor / 10000 > wantLockedTotal:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        wantLockedTotal -= arg2 * withdrawFeeFactor / 10000
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                        if ext_code.size(wantAddress) <= 0:
                                            revert with 0, 'Address: call to non-contract'
                                        mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 32, arg2 * withdrawFeeFactor / 10000) >> 32
                                        call wantAddress with:
                                           funct uint32(stor12)
                                             gas gas_remaining wei
                                            args Mask(224, 32, arg2 * withdrawFeeFactor / 10000) << 224, mem[644 len 4]
                                    else:
                                        if wantLockedTotal > wantLockedTotal:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        wantLockedTotal = 0
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                        if ext_code.size(wantAddress) <= 0:
                                            revert with 0, 'Address: call to non-contract'
                                        mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                        call wantAddress with:
                                           funct uint32(stor12)
                                             gas gas_remaining wei
                                            args Mask(480, 0, stor16.field_0), mem[644 len 4]
                                else:
                                    if wantLockedTotal >= ext_call.return_data[0]:
                                        if ext_call.return_data[0] > wantLockedTotal:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        wantLockedTotal -= ext_call.return_data[0]
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                        if ext_code.size(wantAddress) <= 0:
                                            revert with 0, 'Address: call to non-contract'
                                        mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), ext_call.return_data[0 len 28]
                                        mem[644 len 0] = 0
                                        call wantAddress with:
                                           funct uint32(stor12)
                                             gas gas_remaining wei
                                            args Mask(480, -256, ext_call.return_data[0 len 28]) << 256, mem[644 len 4]
                                    else:
                                        if wantLockedTotal > wantLockedTotal:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        wantLockedTotal = 0
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                        if ext_code.size(wantAddress) <= 0:
                                            revert with 0, 'Address: call to non-contract'
                                        mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                        mem[644 len 0] = 0
                                        call wantAddress with:
                                           funct uint32(stor12)
                                             gas gas_remaining wei
                                            args Mask(480, 0, stor16.field_0), mem[644 len 4]
                            if not return_data.size:
                                require not ext_call.success
                                revert with 'SafeMath: division by zero'
                            mem[612 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                if return_data.size > 0:
                                    revert with ext_call.return_data[0 len return_data.size]
                                revert with 0, 'SafeERC20: low-level call failed'
                            if return_data.size > 0:
                                require return_data.size >= 32
                                if not mem[612]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x775361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[ceil32(return_data.size) + 691 len 22]
                    else:
                        require arg2
                        if arg2 * sub_9ccccc15 / arg2 != sub_9ccccc15:
                            revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                        if withdrawFeeFactor >= 10000:
                            if arg2 * sub_9ccccc15 / 10000 <= 0:
                                if not isAutoComp:
                                    require ext_code.size(wantAddress)
                                    staticcall wantAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if arg2 <= ext_call.return_data[0]:
                                        if wantLockedTotal < arg2:
                                            if wantLockedTotal > wantLockedTotal:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            wantLockedTotal = 0
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                            if ext_code.size(wantAddress) <= 0:
                                                revert with 0, 'Address: call to non-contract'
                                            mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                            call wantAddress with:
                                               funct uint32(stor12)
                                                 gas gas_remaining wei
                                                args Mask(480, 0, stor16.field_0), mem[580 len 4]
                                        else:
                                            if arg2 > wantLockedTotal:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            wantLockedTotal -= arg2
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                            if ext_code.size(wantAddress) <= 0:
                                                revert with 0, 'Address: call to non-contract'
                                            mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 32, arg2) >> 32
                                            mem[580 len 0] = 0
                                            call wantAddress with:
                                               funct uint32(stor12)
                                                 gas gas_remaining wei
                                                args Mask(224, 32, arg2) << 224, mem[580 len 4]
                                    else:
                                        if wantLockedTotal >= ext_call.return_data[0]:
                                            if ext_call.return_data[0] > wantLockedTotal:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            wantLockedTotal -= ext_call.return_data[0]
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                            if ext_code.size(wantAddress) <= 0:
                                                revert with 0, 'Address: call to non-contract'
                                            mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), ext_call.return_data[0 len 28]
                                            mem[580 len 0] = 0
                                            call wantAddress with:
                                               funct uint32(stor12)
                                                 gas gas_remaining wei
                                                args Mask(480, -256, ext_call.return_data[0 len 28]) << 256, mem[580 len 4]
                                        else:
                                            if wantLockedTotal > wantLockedTotal:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            wantLockedTotal = 0
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                            if ext_code.size(wantAddress) <= 0:
                                                revert with 0, 'Address: call to non-contract'
                                            mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                            mem[580 len 0] = 0
                                            call wantAddress with:
                                               funct uint32(stor12)
                                                 gas gas_remaining wei
                                                args Mask(480, 0, stor16.field_0), mem[580 len 4]
                                else:
                                    require ext_code.size(farmContractAddress)
                                    call farmContractAddress.withdraw(uint256 arg1, uint256 arg2) with:
                                         gas gas_remaining wei
                                        args pid, arg2
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(wantAddress)
                                    staticcall wantAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if arg2 <= ext_call.return_data[0]:
                                        if wantLockedTotal >= arg2:
                                            if arg2 > wantLockedTotal:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            wantLockedTotal -= arg2
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                            if ext_code.size(wantAddress) <= 0:
                                                revert with 0, 'Address: call to non-contract'
                                            mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 32, arg2) >> 32
                                            mem[580 len 0] = 0
                                            call wantAddress with:
                                               funct uint32(stor12)
                                                 gas gas_remaining wei
                                                args Mask(224, 32, arg2) << 224, mem[580 len 4]
                                        else:
                                            if wantLockedTotal > wantLockedTotal:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            wantLockedTotal = 0
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                            if ext_code.size(wantAddress) <= 0:
                                                revert with 0, 'Address: call to non-contract'
                                            mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                            mem[580 len 0] = 0
                                            call wantAddress with:
                                               funct uint32(stor12)
                                                 gas gas_remaining wei
                                                args Mask(480, 0, stor16.field_0), mem[580 len 4]
                                    else:
                                        if wantLockedTotal >= ext_call.return_data[0]:
                                            if ext_call.return_data[0] > wantLockedTotal:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            wantLockedTotal -= ext_call.return_data[0]
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                            if ext_code.size(wantAddress) <= 0:
                                                revert with 0, 'Address: call to non-contract'
                                            mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), ext_call.return_data[0 len 28]
                                            call wantAddress with:
                                               funct uint32(stor12)
                                                 gas gas_remaining wei
                                                args Mask(480, -256, ext_call.return_data[0 len 28]) << 256, mem[580 len 4]
                                        else:
                                            if wantLockedTotal > wantLockedTotal:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            wantLockedTotal = 0
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                            if ext_code.size(wantAddress) <= 0:
                                                revert with 0, 'Address: call to non-contract'
                                            mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                            mem[580 len 0] = 0
                                            call wantAddress with:
                                               funct uint32(stor12)
                                                 gas gas_remaining wei
                                                args Mask(480, 0, stor16.field_0), mem[580 len 4]
                            else:
                                if not isAutoComp:
                                    require ext_code.size(wantAddress)
                                    staticcall wantAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if arg2 - (arg2 * sub_9ccccc15 / 10000) <= ext_call.return_data[0]:
                                        if wantLockedTotal >= arg2 - (arg2 * sub_9ccccc15 / 10000):
                                            if arg2 - (arg2 * sub_9ccccc15 / 10000) > wantLockedTotal:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            wantLockedTotal = wantLockedTotal - arg2 + (arg2 * sub_9ccccc15 / 10000)
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                            if ext_code.size(wantAddress) <= 0:
                                                revert with 0, 'Address: call to non-contract'
                                            mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 32, arg2 - (arg2 * sub_9ccccc15 / 10000)) >> 32
                                            mem[580 len 0] = 0
                                            call wantAddress with:
                                               funct uint32(stor12)
                                                 gas gas_remaining wei
                                                args Mask(224, 32, arg2 - (arg2 * sub_9ccccc15 / 10000)) << 224, mem[580 len 4]
                                        else:
                                            if wantLockedTotal > wantLockedTotal:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            wantLockedTotal = 0
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                            if ext_code.size(wantAddress) <= 0:
                                                revert with 0, 'Address: call to non-contract'
                                            mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                            mem[580 len 0] = 0
                                            call wantAddress with:
                                               funct uint32(stor12)
                                                 gas gas_remaining wei
                                                args Mask(480, 0, stor16.field_0), mem[580 len 4]
                                    else:
                                        if wantLockedTotal < ext_call.return_data[0]:
                                            if wantLockedTotal > wantLockedTotal:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            wantLockedTotal = 0
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                            if ext_code.size(wantAddress) <= 0:
                                                revert with 0, 'Address: call to non-contract'
                                            mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                            call wantAddress with:
                                               funct uint32(stor12)
                                                 gas gas_remaining wei
                                                args Mask(480, 0, stor16.field_0), mem[580 len 4]
                                        else:
                                            if ext_call.return_data[0] > wantLockedTotal:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            wantLockedTotal -= ext_call.return_data[0]
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                            if ext_code.size(wantAddress) <= 0:
                                                revert with 0, 'Address: call to non-contract'
                                            mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), ext_call.return_data[0 len 28]
                                            mem[580 len 0] = 0
                                            call wantAddress with:
                                               funct uint32(stor12)
                                                 gas gas_remaining wei
                                                args Mask(480, -256, ext_call.return_data[0 len 28]) << 256, mem[580 len 4]
                                else:
                                    require ext_code.size(farmContractAddress)
                                    call farmContractAddress.withdraw(uint256 arg1, uint256 arg2) with:
                                         gas gas_remaining wei
                                        args pid, arg2 - (arg2 * sub_9ccccc15 / 10000)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(wantAddress)
                                    staticcall wantAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if arg2 - (arg2 * sub_9ccccc15 / 10000) <= ext_call.return_data[0]:
                                        if wantLockedTotal >= arg2 - (arg2 * sub_9ccccc15 / 10000):
                                            if arg2 - (arg2 * sub_9ccccc15 / 10000) > wantLockedTotal:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            wantLockedTotal = wantLockedTotal - arg2 + (arg2 * sub_9ccccc15 / 10000)
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                            if ext_code.size(wantAddress) <= 0:
                                                revert with 0, 'Address: call to non-contract'
                                            mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 32, arg2 - (arg2 * sub_9ccccc15 / 10000)) >> 32
                                            mem[580 len 0] = 0
                                            call wantAddress with:
                                               funct uint32(stor12)
                                                 gas gas_remaining wei
                                                args Mask(224, 32, arg2 - (arg2 * sub_9ccccc15 / 10000)) << 224, mem[580 len 4]
                                        else:
                                            if wantLockedTotal > wantLockedTotal:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            wantLockedTotal = 0
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                            if ext_code.size(wantAddress) <= 0:
                                                revert with 0, 'Address: call to non-contract'
                                            mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                            mem[580 len 0] = 0
                                            call wantAddress with:
                                               funct uint32(stor12)
                                                 gas gas_remaining wei
                                                args Mask(480, 0, stor16.field_0), mem[580 len 4]
                                    else:
                                        if wantLockedTotal >= ext_call.return_data[0]:
                                            if ext_call.return_data[0] > wantLockedTotal:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            wantLockedTotal -= ext_call.return_data[0]
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                            if ext_code.size(wantAddress) <= 0:
                                                revert with 0, 'Address: call to non-contract'
                                            mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), ext_call.return_data[0 len 28]
                                            call wantAddress with:
                                               funct uint32(stor12)
                                                 gas gas_remaining wei
                                                args Mask(480, -256, ext_call.return_data[0 len 28]) << 256, mem[580 len 4]
                                        else:
                                            if wantLockedTotal > wantLockedTotal:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            wantLockedTotal = 0
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                            if ext_code.size(wantAddress) <= 0:
                                                revert with 0, 'Address: call to non-contract'
                                            mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                            mem[580 len 0] = 0
                                            call wantAddress with:
                                               funct uint32(stor12)
                                                 gas gas_remaining wei
                                                args Mask(480, 0, stor16.field_0), mem[580 len 4]
                            if not return_data.size:
                                require not ext_call.success
                                revert with 'SafeMath: division by zero'
                            mem[548 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                if return_data.size > 0:
                                    revert with ext_call.return_data[0 len return_data.size]
                                revert with 0, 'SafeERC20: low-level call failed'
                            if return_data.size > 0:
                                require return_data.size >= 32
                                if not mem[548]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x775361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[ceil32(return_data.size) + 627 len 22]
                        else:
                            if not arg2:
                                if arg2 * sub_9ccccc15 / 10000 <= 0:
                                    if not isAutoComp:
                                        require ext_code.size(wantAddress)
                                        staticcall wantAddress.0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if 0 > ext_call.return_data[0]:
                                            if wantLockedTotal >= ext_call.return_data[0]:
                                                if ext_call.return_data[0] > wantLockedTotal:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                wantLockedTotal -= ext_call.return_data[0]
                                                if eth.balance(this.address) < 0:
                                                    revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                                if ext_code.size(wantAddress) <= 0:
                                                    revert with 0, 'Address: call to non-contract'
                                                mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), ext_call.return_data[0 len 28]
                                                call wantAddress with:
                                                   funct uint32(stor12)
                                                     gas gas_remaining wei
                                                    args Mask(480, -256, ext_call.return_data[0 len 28]) << 256, mem[644 len 4]
                                            else:
                                                if wantLockedTotal > wantLockedTotal:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                wantLockedTotal = 0
                                                if eth.balance(this.address) < 0:
                                                    revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                                if ext_code.size(wantAddress) <= 0:
                                                    revert with 0, 'Address: call to non-contract'
                                                mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                                call wantAddress with:
                                                   funct uint32(stor12)
                                                     gas gas_remaining wei
                                                    args Mask(480, 0, stor16.field_0), mem[644 len 4]
                                        else:
                                            if wantLockedTotal >= 0:
                                                if 0 > wantLockedTotal:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if eth.balance(this.address) < 0:
                                                    revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                                if ext_code.size(wantAddress) <= 0:
                                                    revert with 0, 'Address: call to non-contract'
                                                mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), 0
                                                call wantAddress with:
                                                   funct uint32(stor12)
                                                     gas gas_remaining wei
                                                    args 0, mem[644 len 4]
                                            else:
                                                if wantLockedTotal > wantLockedTotal:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                wantLockedTotal = 0
                                                if eth.balance(this.address) < 0:
                                                    revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                                if ext_code.size(wantAddress) <= 0:
                                                    revert with 0, 'Address: call to non-contract'
                                                mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                                mem[644 len 0] = 0
                                                call wantAddress with:
                                                   funct uint32(stor12)
                                                     gas gas_remaining wei
                                                    args Mask(480, 0, stor16.field_0), mem[644 len 4]
                                    else:
                                        require ext_code.size(farmContractAddress)
                                        call farmContractAddress.withdraw(uint256 arg1, uint256 arg2) with:
                                             gas gas_remaining wei
                                            args pid, 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require ext_code.size(wantAddress)
                                        staticcall wantAddress.0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if 0 <= ext_call.return_data[0]:
                                            if wantLockedTotal >= 0:
                                                if 0 > wantLockedTotal:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if eth.balance(this.address) < 0:
                                                    revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                                if ext_code.size(wantAddress) <= 0:
                                                    revert with 0, 'Address: call to non-contract'
                                                mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), 0
                                                call wantAddress with:
                                                   funct uint32(stor12)
                                                     gas gas_remaining wei
                                                    args 0, mem[644 len 4]
                                            else:
                                                if wantLockedTotal > wantLockedTotal:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                wantLockedTotal = 0
                                                if eth.balance(this.address) < 0:
                                                    revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                                if ext_code.size(wantAddress) <= 0:
                                                    revert with 0, 'Address: call to non-contract'
                                                mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                                mem[644 len 0] = 0
                                                call wantAddress with:
                                                   funct uint32(stor12)
                                                     gas gas_remaining wei
                                                    args Mask(480, 0, stor16.field_0), mem[644 len 4]
                                        else:
                                            if wantLockedTotal >= ext_call.return_data[0]:
                                                if ext_call.return_data[0] > wantLockedTotal:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                wantLockedTotal -= ext_call.return_data[0]
                                                if eth.balance(this.address) < 0:
                                                    revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                                if ext_code.size(wantAddress) <= 0:
                                                    revert with 0, 'Address: call to non-contract'
                                                mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), ext_call.return_data[0 len 28]
                                                mem[644 len 0] = 0
                                                call wantAddress with:
                                                   funct uint32(stor12)
                                                     gas gas_remaining wei
                                                    args Mask(480, -256, ext_call.return_data[0 len 28]) << 256, mem[644 len 4]
                                            else:
                                                if wantLockedTotal > wantLockedTotal:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                wantLockedTotal = 0
                                                if eth.balance(this.address) < 0:
                                                    revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                                if ext_code.size(wantAddress) <= 0:
                                                    revert with 0, 'Address: call to non-contract'
                                                mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                                mem[644 len 0] = 0
                                                call wantAddress with:
                                                   funct uint32(stor12)
                                                     gas gas_remaining wei
                                                    args Mask(480, 0, stor16.field_0), mem[644 len 4]
                                else:
                                    if not isAutoComp:
                                        require ext_code.size(wantAddress)
                                        staticcall wantAddress.0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if -arg2 * sub_9ccccc15 / 10000 <= ext_call.return_data[0]:
                                            if wantLockedTotal >= -arg2 * sub_9ccccc15 / 10000:
                                                if -arg2 * sub_9ccccc15 / 10000 > wantLockedTotal:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                wantLockedTotal += arg2 * sub_9ccccc15 / 10000
                                                if eth.balance(this.address) < 0:
                                                    revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                                if ext_code.size(wantAddress) <= 0:
                                                    revert with 0, 'Address: call to non-contract'
                                                mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 32, -arg2 * sub_9ccccc15 / 10000) >> 32
                                                call wantAddress with:
                                                   funct uint32(stor12)
                                                     gas gas_remaining wei
                                                    args Mask(224, 32, -arg2 * sub_9ccccc15 / 10000) << 224, mem[644 len 4]
                                            else:
                                                if wantLockedTotal > wantLockedTotal:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                wantLockedTotal = 0
                                                if eth.balance(this.address) < 0:
                                                    revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                                if ext_code.size(wantAddress) <= 0:
                                                    revert with 0, 'Address: call to non-contract'
                                                mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                                mem[644 len 0] = 0
                                                call wantAddress with:
                                                   funct uint32(stor12)
                                                     gas gas_remaining wei
                                                    args Mask(480, 0, stor16.field_0), mem[644 len 4]
                                        else:
                                            if wantLockedTotal < ext_call.return_data[0]:
                                                if wantLockedTotal > wantLockedTotal:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                wantLockedTotal = 0
                                                if eth.balance(this.address) < 0:
                                                    revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                                if ext_code.size(wantAddress) <= 0:
                                                    revert with 0, 'Address: call to non-contract'
                                                mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                                call wantAddress with:
                                                   funct uint32(stor12)
                                                     gas gas_remaining wei
                                                    args Mask(480, 0, stor16.field_0), mem[644 len 4]
                                            else:
                                                if ext_call.return_data[0] > wantLockedTotal:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                wantLockedTotal -= ext_call.return_data[0]
                                                if eth.balance(this.address) < 0:
                                                    revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                                if ext_code.size(wantAddress) <= 0:
                                                    revert with 0, 'Address: call to non-contract'
                                                mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), ext_call.return_data[0 len 28]
                                                mem[644 len 0] = 0
                                                call wantAddress with:
                                                   funct uint32(stor12)
                                                     gas gas_remaining wei
                                                    args Mask(480, -256, ext_call.return_data[0 len 28]) << 256, mem[644 len 4]
                                    else:
                                        require ext_code.size(farmContractAddress)
                                        call farmContractAddress.withdraw(uint256 arg1, uint256 arg2) with:
                                             gas gas_remaining wei
                                            args pid, -arg2 * sub_9ccccc15 / 10000
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require ext_code.size(wantAddress)
                                        staticcall wantAddress.0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if -arg2 * sub_9ccccc15 / 10000 <= ext_call.return_data[0]:
                                            if wantLockedTotal >= -arg2 * sub_9ccccc15 / 10000:
                                                if -arg2 * sub_9ccccc15 / 10000 > wantLockedTotal:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                wantLockedTotal += arg2 * sub_9ccccc15 / 10000
                                                if eth.balance(this.address) < 0:
                                                    revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                                if ext_code.size(wantAddress) <= 0:
                                                    revert with 0, 'Address: call to non-contract'
                                                mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 32, -arg2 * sub_9ccccc15 / 10000) >> 32
                                                mem[644 len 0] = 0
                                                call wantAddress with:
                                                   funct uint32(stor12)
                                                     gas gas_remaining wei
                                                    args Mask(224, 32, -arg2 * sub_9ccccc15 / 10000) << 224, mem[644 len 4]
                                            else:
                                                if wantLockedTotal > wantLockedTotal:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                wantLockedTotal = 0
                                                if eth.balance(this.address) < 0:
                                                    revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                                if ext_code.size(wantAddress) <= 0:
                                                    revert with 0, 'Address: call to non-contract'
                                                mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                                mem[644 len 0] = 0
                                                call wantAddress with:
                                                   funct uint32(stor12)
                                                     gas gas_remaining wei
                                                    args Mask(480, 0, stor16.field_0), mem[644 len 4]
                                        else:
                                            if wantLockedTotal >= ext_call.return_data[0]:
                                                if ext_call.return_data[0] > wantLockedTotal:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                wantLockedTotal -= ext_call.return_data[0]
                                                if eth.balance(this.address) < 0:
                                                    revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                                if ext_code.size(wantAddress) <= 0:
                                                    revert with 0, 'Address: call to non-contract'
                                                mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), ext_call.return_data[0 len 28]
                                                call wantAddress with:
                                                   funct uint32(stor12)
                                                     gas gas_remaining wei
                                                    args Mask(480, -256, ext_call.return_data[0 len 28]) << 256, mem[644 len 4]
                                            else:
                                                if wantLockedTotal > wantLockedTotal:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                wantLockedTotal = 0
                                                if eth.balance(this.address) < 0:
                                                    revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                                if ext_code.size(wantAddress) <= 0:
                                                    revert with 0, 'Address: call to non-contract'
                                                mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                                mem[644 len 0] = 0
                                                call wantAddress with:
                                                   funct uint32(stor12)
                                                     gas gas_remaining wei
                                                    args Mask(480, 0, stor16.field_0), mem[644 len 4]
                            else:
                                require arg2
                                if arg2 * withdrawFeeFactor / arg2 != withdrawFeeFactor:
                                    revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                                if arg2 * sub_9ccccc15 / 10000 <= 0:
                                    if not isAutoComp:
                                        require ext_code.size(wantAddress)
                                        staticcall wantAddress.0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if arg2 * withdrawFeeFactor / 10000 <= ext_call.return_data[0]:
                                            if wantLockedTotal >= arg2 * withdrawFeeFactor / 10000:
                                                if arg2 * withdrawFeeFactor / 10000 > wantLockedTotal:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                wantLockedTotal -= arg2 * withdrawFeeFactor / 10000
                                                if eth.balance(this.address) < 0:
                                                    revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                                if ext_code.size(wantAddress) <= 0:
                                                    revert with 0, 'Address: call to non-contract'
                                                mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 32, arg2 * withdrawFeeFactor / 10000) >> 32
                                                mem[644 len 0] = 0
                                                call wantAddress with:
                                                   funct uint32(stor12)
                                                     gas gas_remaining wei
                                                    args Mask(224, 32, arg2 * withdrawFeeFactor / 10000) << 224, mem[644 len 4]
                                            else:
                                                if wantLockedTotal > wantLockedTotal:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                wantLockedTotal = 0
                                                if eth.balance(this.address) < 0:
                                                    revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                                if ext_code.size(wantAddress) <= 0:
                                                    revert with 0, 'Address: call to non-contract'
                                                mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                                mem[644 len 0] = 0
                                                call wantAddress with:
                                                   funct uint32(stor12)
                                                     gas gas_remaining wei
                                                    args Mask(480, 0, stor16.field_0), mem[644 len 4]
                                        else:
                                            if wantLockedTotal < ext_call.return_data[0]:
                                                if wantLockedTotal > wantLockedTotal:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                wantLockedTotal = 0
                                                if eth.balance(this.address) < 0:
                                                    revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                                if ext_code.size(wantAddress) <= 0:
                                                    revert with 0, 'Address: call to non-contract'
                                                mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                                call wantAddress with:
                                                   funct uint32(stor12)
                                                     gas gas_remaining wei
                                                    args Mask(480, 0, stor16.field_0), mem[644 len 4]
                                            else:
                                                if ext_call.return_data[0] > wantLockedTotal:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                wantLockedTotal -= ext_call.return_data[0]
                                                if eth.balance(this.address) < 0:
                                                    revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                                if ext_code.size(wantAddress) <= 0:
                                                    revert with 0, 'Address: call to non-contract'
                                                mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), ext_call.return_data[0 len 28]
                                                mem[644 len 0] = 0
                                                call wantAddress with:
                                                   funct uint32(stor12)
                                                     gas gas_remaining wei
                                                    args Mask(480, -256, ext_call.return_data[0 len 28]) << 256, mem[644 len 4]
                                    else:
                                        require ext_code.size(farmContractAddress)
                                        call farmContractAddress.withdraw(uint256 arg1, uint256 arg2) with:
                                             gas gas_remaining wei
                                            args pid, arg2 * withdrawFeeFactor / 10000
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require ext_code.size(wantAddress)
                                        staticcall wantAddress.0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if arg2 * withdrawFeeFactor / 10000 > ext_call.return_data[0]:
                                            if wantLockedTotal >= ext_call.return_data[0]:
                                                if ext_call.return_data[0] > wantLockedTotal:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                wantLockedTotal -= ext_call.return_data[0]
                                                if eth.balance(this.address) < 0:
                                                    revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                                if ext_code.size(wantAddress) <= 0:
                                                    revert with 0, 'Address: call to non-contract'
                                                mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), ext_call.return_data[0 len 28]
                                                call wantAddress with:
                                                   funct uint32(stor12)
                                                     gas gas_remaining wei
                                                    args Mask(480, -256, ext_call.return_data[0 len 28]) << 256, mem[644 len 4]
                                            else:
                                                if wantLockedTotal > wantLockedTotal:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                wantLockedTotal = 0
                                                if eth.balance(this.address) < 0:
                                                    revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                                if ext_code.size(wantAddress) <= 0:
                                                    revert with 0, 'Address: call to non-contract'
                                                mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                                call wantAddress with:
                                                   funct uint32(stor12)
                                                     gas gas_remaining wei
                                                    args Mask(480, 0, stor16.field_0), mem[644 len 4]
                                        else:
                                            if wantLockedTotal >= arg2 * withdrawFeeFactor / 10000:
                                                if arg2 * withdrawFeeFactor / 10000 > wantLockedTotal:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                wantLockedTotal -= arg2 * withdrawFeeFactor / 10000
                                                if eth.balance(this.address) < 0:
                                                    revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                                if ext_code.size(wantAddress) <= 0:
                                                    revert with 0, 'Address: call to non-contract'
                                                mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 32, arg2 * withdrawFeeFactor / 10000) >> 32
                                                mem[644 len 0] = 0
                                                call wantAddress with:
                                                   funct uint32(stor12)
                                                     gas gas_remaining wei
                                                    args Mask(224, 32, arg2 * withdrawFeeFactor / 10000) << 224, mem[644 len 4]
                                            else:
                                                if wantLockedTotal > wantLockedTotal:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                wantLockedTotal = 0
                                                if eth.balance(this.address) < 0:
                                                    revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                                if ext_code.size(wantAddress) <= 0:
                                                    revert with 0, 'Address: call to non-contract'
                                                mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                                mem[644 len 0] = 0
                                                call wantAddress with:
                                                   funct uint32(stor12)
                                                     gas gas_remaining wei
                                                    args Mask(480, 0, stor16.field_0), mem[644 len 4]
                                else:
                                    if not isAutoComp:
                                        require ext_code.size(wantAddress)
                                        staticcall wantAddress.0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if (arg2 * withdrawFeeFactor / 10000) - (arg2 * sub_9ccccc15 / 10000) > ext_call.return_data[0]:
                                            if wantLockedTotal >= ext_call.return_data[0]:
                                                if ext_call.return_data[0] > wantLockedTotal:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                wantLockedTotal -= ext_call.return_data[0]
                                                if eth.balance(this.address) < 0:
                                                    revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                                if ext_code.size(wantAddress) <= 0:
                                                    revert with 0, 'Address: call to non-contract'
                                                mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), ext_call.return_data[0 len 28]
                                                call wantAddress with:
                                                   funct uint32(stor12)
                                                     gas gas_remaining wei
                                                    args Mask(480, -256, ext_call.return_data[0 len 28]) << 256, mem[644 len 4]
                                            else:
                                                if wantLockedTotal > wantLockedTotal:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                wantLockedTotal = 0
                                                if eth.balance(this.address) < 0:
                                                    revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                                if ext_code.size(wantAddress) <= 0:
                                                    revert with 0, 'Address: call to non-contract'
                                                mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                                call wantAddress with:
                                                   funct uint32(stor12)
                                                     gas gas_remaining wei
                                                    args Mask(480, 0, stor16.field_0), mem[644 len 4]
                                        else:
                                            if wantLockedTotal < (arg2 * withdrawFeeFactor / 10000) - (arg2 * sub_9ccccc15 / 10000):
                                                if wantLockedTotal > wantLockedTotal:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                wantLockedTotal = 0
                                                if eth.balance(this.address) < 0:
                                                    revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                                if ext_code.size(wantAddress) <= 0:
                                                    revert with 0, 'Address: call to non-contract'
                                                mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                                call wantAddress with:
                                                   funct uint32(stor12)
                                                     gas gas_remaining wei
                                                    args Mask(480, 0, stor16.field_0), mem[644 len 4]
                                            else:
                                                if (arg2 * withdrawFeeFactor / 10000) - (arg2 * sub_9ccccc15 / 10000) > wantLockedTotal:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                wantLockedTotal = wantLockedTotal - (arg2 * withdrawFeeFactor / 10000) + (arg2 * sub_9ccccc15 / 10000)
                                                if eth.balance(this.address) < 0:
                                                    revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                                if ext_code.size(wantAddress) <= 0:
                                                    revert with 0, 'Address: call to non-contract'
                                                mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 32, (arg2 * withdrawFeeFactor / 10000) - (arg2 * sub_9ccccc15 / 10000)) >> 32
                                                mem[644 len 0] = 0
                                                call wantAddress with:
                                                   funct uint32(stor12)
                                                     gas gas_remaining wei
                                                    args Mask(224, 32, (arg2 * withdrawFeeFactor / 10000) - (arg2 * sub_9ccccc15 / 10000)) << 224, mem[644 len 4]
                                    else:
                                        require ext_code.size(farmContractAddress)
                                        call farmContractAddress.withdraw(uint256 arg1, uint256 arg2) with:
                                             gas gas_remaining wei
                                            args pid, (arg2 * withdrawFeeFactor / 10000) - (arg2 * sub_9ccccc15 / 10000)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require ext_code.size(wantAddress)
                                        staticcall wantAddress.0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if (arg2 * withdrawFeeFactor / 10000) - (arg2 * sub_9ccccc15 / 10000) <= ext_call.return_data[0]:
                                            if wantLockedTotal >= (arg2 * withdrawFeeFactor / 10000) - (arg2 * sub_9ccccc15 / 10000):
                                                if (arg2 * withdrawFeeFactor / 10000) - (arg2 * sub_9ccccc15 / 10000) > wantLockedTotal:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                wantLockedTotal = wantLockedTotal - (arg2 * withdrawFeeFactor / 10000) + (arg2 * sub_9ccccc15 / 10000)
                                                if eth.balance(this.address) < 0:
                                                    revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                                if ext_code.size(wantAddress) <= 0:
                                                    revert with 0, 'Address: call to non-contract'
                                                mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 32, (arg2 * withdrawFeeFactor / 10000) - (arg2 * sub_9ccccc15 / 10000)) >> 32
                                                mem[644 len 0] = 0
                                                call wantAddress with:
                                                   funct uint32(stor12)
                                                     gas gas_remaining wei
                                                    args Mask(224, 32, (arg2 * withdrawFeeFactor / 10000) - (arg2 * sub_9ccccc15 / 10000)) << 224, mem[644 len 4]
                                            else:
                                                if wantLockedTotal > wantLockedTotal:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                wantLockedTotal = 0
                                                if eth.balance(this.address) < 0:
                                                    revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                                if ext_code.size(wantAddress) <= 0:
                                                    revert with 0, 'Address: call to non-contract'
                                                mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                                mem[644 len 0] = 0
                                                call wantAddress with:
                                                   funct uint32(stor12)
                                                     gas gas_remaining wei
                                                    args Mask(480, 0, stor16.field_0), mem[644 len 4]
                                        else:
                                            if wantLockedTotal < ext_call.return_data[0]:
                                                if wantLockedTotal > wantLockedTotal:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                wantLockedTotal = 0
                                                if eth.balance(this.address) < 0:
                                                    revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                                if ext_code.size(wantAddress) <= 0:
                                                    revert with 0, 'Address: call to non-contract'
                                                mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                                call wantAddress with:
                                                   funct uint32(stor12)
                                                     gas gas_remaining wei
                                                    args Mask(480, 0, stor16.field_0), mem[644 len 4]
                                            else:
                                                if ext_call.return_data[0] > wantLockedTotal:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                wantLockedTotal -= ext_call.return_data[0]
                                                if eth.balance(this.address) < 0:
                                                    revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                                if ext_code.size(wantAddress) <= 0:
                                                    revert with 0, 'Address: call to non-contract'
                                                mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), ext_call.return_data[0 len 28]
                                                mem[644 len 0] = 0
                                                call wantAddress with:
                                                   funct uint32(stor12)
                                                     gas gas_remaining wei
                                                    args Mask(480, -256, ext_call.return_data[0 len 28]) << 256, mem[644 len 4]
                            if not return_data.size:
                                require not ext_call.success
                                revert with 'SafeMath: division by zero'
                            mem[612 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                if return_data.size > 0:
                                    revert with ext_call.return_data[0 len return_data.size]
                                revert with 0, 'SafeERC20: low-level call failed'
                            if return_data.size > 0:
                                require return_data.size >= 32
                                if not mem[612]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x775361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[ceil32(return_data.size) + 691 len 22]
            stor1 = 1
            return (arg2 * sharesTotal / wantLockedTotal)
        if sharesTotal > sharesTotal:
            revert with 0, 'SafeMath: subtraction overflow'
        sharesTotal = 0
        if sub_9ccccc15 <= 0:
            if withdrawFeeFactor >= 10000:
                if not isAutoComp:
                    require ext_code.size(wantAddress)
                    staticcall wantAddress.0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if arg2 <= ext_call.return_data[0]:
                        if wantLockedTotal >= arg2:
                            if arg2 > wantLockedTotal:
                                revert with 0, 'SafeMath: subtraction overflow'
                            wantLockedTotal -= arg2
                            if eth.balance(this.address) < 0:
                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[558 len 26]
                            if ext_code.size(wantAddress) <= 0:
                                revert with 0, 'Address: call to non-contract'
                            mem[452 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 32, arg2) >> 32
                            mem[516 len 0] = 0
                            call wantAddress with:
                               funct uint32(stor12)
                                 gas gas_remaining wei
                                args Mask(224, 32, arg2) << 224, mem[516 len 4]
                        else:
                            if wantLockedTotal > wantLockedTotal:
                                revert with 0, 'SafeMath: subtraction overflow'
                            wantLockedTotal = 0
                            if eth.balance(this.address) < 0:
                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[558 len 26]
                            if ext_code.size(wantAddress) <= 0:
                                revert with 0, 'Address: call to non-contract'
                            mem[452 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                            mem[516 len 0] = 0
                            call wantAddress with:
                               funct uint32(stor12)
                                 gas gas_remaining wei
                                args Mask(480, 0, stor16.field_0), mem[516 len 4]
                    else:
                        if wantLockedTotal < ext_call.return_data[0]:
                            if wantLockedTotal > wantLockedTotal:
                                revert with 0, 'SafeMath: subtraction overflow'
                            wantLockedTotal = 0
                            if eth.balance(this.address) < 0:
                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[558 len 26]
                            if ext_code.size(wantAddress) <= 0:
                                revert with 0, 'Address: call to non-contract'
                            mem[452 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                            call wantAddress with:
                               funct uint32(stor12)
                                 gas gas_remaining wei
                                args Mask(480, 0, stor16.field_0), mem[516 len 4]
                        else:
                            if ext_call.return_data[0] > wantLockedTotal:
                                revert with 0, 'SafeMath: subtraction overflow'
                            wantLockedTotal -= ext_call.return_data[0]
                            if eth.balance(this.address) < 0:
                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[558 len 26]
                            if ext_code.size(wantAddress) <= 0:
                                revert with 0, 'Address: call to non-contract'
                            mem[452 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), ext_call.return_data[0 len 28]
                            mem[516 len 0] = 0
                            call wantAddress with:
                               funct uint32(stor12)
                                 gas gas_remaining wei
                                args Mask(480, -256, ext_call.return_data[0 len 28]) << 256, mem[516 len 4]
                else:
                    require ext_code.size(farmContractAddress)
                    call farmContractAddress.withdraw(uint256 arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args pid, arg2
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require ext_code.size(wantAddress)
                    staticcall wantAddress.0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if arg2 <= ext_call.return_data[0]:
                        if wantLockedTotal >= arg2:
                            if arg2 > wantLockedTotal:
                                revert with 0, 'SafeMath: subtraction overflow'
                            wantLockedTotal -= arg2
                            if eth.balance(this.address) < 0:
                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[558 len 26]
                            if ext_code.size(wantAddress) <= 0:
                                revert with 0, 'Address: call to non-contract'
                            mem[452 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 32, arg2) >> 32
                            call wantAddress with:
                               funct uint32(stor12)
                                 gas gas_remaining wei
                                args Mask(224, 32, arg2) << 224, mem[516 len 4]
                        else:
                            if wantLockedTotal > wantLockedTotal:
                                revert with 0, 'SafeMath: subtraction overflow'
                            wantLockedTotal = 0
                            if eth.balance(this.address) < 0:
                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[558 len 26]
                            if ext_code.size(wantAddress) <= 0:
                                revert with 0, 'Address: call to non-contract'
                            mem[452 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                            mem[516 len 0] = 0
                            call wantAddress with:
                               funct uint32(stor12)
                                 gas gas_remaining wei
                                args Mask(480, 0, stor16.field_0), mem[516 len 4]
                    else:
                        if wantLockedTotal < ext_call.return_data[0]:
                            if wantLockedTotal > wantLockedTotal:
                                revert with 0, 'SafeMath: subtraction overflow'
                            wantLockedTotal = 0
                            if eth.balance(this.address) < 0:
                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[558 len 26]
                            if ext_code.size(wantAddress) <= 0:
                                revert with 0, 'Address: call to non-contract'
                            mem[452 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                            call wantAddress with:
                               funct uint32(stor12)
                                 gas gas_remaining wei
                                args Mask(480, 0, stor16.field_0), mem[516 len 4]
                        else:
                            if ext_call.return_data[0] > wantLockedTotal:
                                revert with 0, 'SafeMath: subtraction overflow'
                            wantLockedTotal -= ext_call.return_data[0]
                            if eth.balance(this.address) < 0:
                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[558 len 26]
                            if ext_code.size(wantAddress) <= 0:
                                revert with 0, 'Address: call to non-contract'
                            mem[452 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), ext_call.return_data[0 len 28]
                            mem[516 len 0] = 0
                            call wantAddress with:
                               funct uint32(stor12)
                                 gas gas_remaining wei
                                args Mask(480, -256, ext_call.return_data[0 len 28]) << 256, mem[516 len 4]
                if not return_data.size:
                    require not ext_call.success
                    revert with 'SafeMath: division by zero'
                mem[484 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not ext_call.success:
                    if return_data.size > 0:
                        revert with ext_call.return_data[0 len return_data.size]
                    revert with 0, 'SafeERC20: low-level call failed'
                if return_data.size > 0:
                    require return_data.size >= 32
                    if not mem[484]:
                        revert with 0, 
                                    32,
                                    42,
                                    0x775361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                    mem[ceil32(return_data.size) + 563 len 22]
            else:
                if not arg2:
                    if not isAutoComp:
                        require ext_code.size(wantAddress)
                        staticcall wantAddress.0x70a08231 with:
                                gas gas_remaining wei
                               args this.address
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if 0 <= ext_call.return_data[0]:
                            if wantLockedTotal >= 0:
                                if 0 > wantLockedTotal:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if eth.balance(this.address) < 0:
                                    revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                if ext_code.size(wantAddress) <= 0:
                                    revert with 0, 'Address: call to non-contract'
                                mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), 0
                                mem[580 len 0] = 0
                                call wantAddress with:
                                   funct uint32(stor12)
                                     gas gas_remaining wei
                                    args Mask(480, -256, unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), 0) << 256, mem[580 len 4]
                            else:
                                if wantLockedTotal > wantLockedTotal:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                wantLockedTotal = 0
                                if eth.balance(this.address) < 0:
                                    revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                if ext_code.size(wantAddress) <= 0:
                                    revert with 0, 'Address: call to non-contract'
                                mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                call wantAddress with:
                                   funct uint32(stor12)
                                     gas gas_remaining wei
                                    args Mask(480, 0, stor16.field_0), mem[580 len 4]
                        else:
                            if wantLockedTotal >= ext_call.return_data[0]:
                                if ext_call.return_data[0] > wantLockedTotal:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                wantLockedTotal -= ext_call.return_data[0]
                                if eth.balance(this.address) < 0:
                                    revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                if ext_code.size(wantAddress) <= 0:
                                    revert with 0, 'Address: call to non-contract'
                                mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), ext_call.return_data[0 len 28]
                                call wantAddress with:
                                   funct uint32(stor12)
                                     gas gas_remaining wei
                                    args Mask(480, -256, ext_call.return_data[0 len 28]) << 256, mem[580 len 4]
                            else:
                                if wantLockedTotal > wantLockedTotal:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                wantLockedTotal = 0
                                if eth.balance(this.address) < 0:
                                    revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                if ext_code.size(wantAddress) <= 0:
                                    revert with 0, 'Address: call to non-contract'
                                mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                call wantAddress with:
                                   funct uint32(stor12)
                                     gas gas_remaining wei
                                    args Mask(480, 0, stor16.field_0), mem[580 len 4]
                    else:
                        require ext_code.size(farmContractAddress)
                        call farmContractAddress.withdraw(uint256 arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args pid, 0
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require ext_code.size(wantAddress)
                        staticcall wantAddress.0x70a08231 with:
                                gas gas_remaining wei
                               args this.address
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if 0 > ext_call.return_data[0]:
                            if wantLockedTotal >= ext_call.return_data[0]:
                                if ext_call.return_data[0] > wantLockedTotal:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                wantLockedTotal -= ext_call.return_data[0]
                                if eth.balance(this.address) < 0:
                                    revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                if ext_code.size(wantAddress) <= 0:
                                    revert with 0, 'Address: call to non-contract'
                                mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), ext_call.return_data[0 len 28]
                                call wantAddress with:
                                   funct uint32(stor12)
                                     gas gas_remaining wei
                                    args Mask(480, -256, ext_call.return_data[0 len 28]) << 256, mem[580 len 4]
                            else:
                                if wantLockedTotal > wantLockedTotal:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                wantLockedTotal = 0
                                if eth.balance(this.address) < 0:
                                    revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                if ext_code.size(wantAddress) <= 0:
                                    revert with 0, 'Address: call to non-contract'
                                mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                call wantAddress with:
                                   funct uint32(stor12)
                                     gas gas_remaining wei
                                    args Mask(480, 0, stor16.field_0), mem[580 len 4]
                        else:
                            if wantLockedTotal >= 0:
                                if 0 > wantLockedTotal:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if eth.balance(this.address) < 0:
                                    revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                if ext_code.size(wantAddress) <= 0:
                                    revert with 0, 'Address: call to non-contract'
                                mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), 0
                                call wantAddress with:
                                   funct uint32(stor12)
                                     gas gas_remaining wei
                                    args 0, mem[580 len 4]
                            else:
                                if wantLockedTotal > wantLockedTotal:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                wantLockedTotal = 0
                                if eth.balance(this.address) < 0:
                                    revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                if ext_code.size(wantAddress) <= 0:
                                    revert with 0, 'Address: call to non-contract'
                                mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                mem[580 len 0] = 0
                                call wantAddress with:
                                   funct uint32(stor12)
                                     gas gas_remaining wei
                                    args Mask(480, 0, stor16.field_0), mem[580 len 4]
                else:
                    require arg2
                    if arg2 * withdrawFeeFactor / arg2 != withdrawFeeFactor:
                        revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                    if not isAutoComp:
                        require ext_code.size(wantAddress)
                        staticcall wantAddress.0x70a08231 with:
                                gas gas_remaining wei
                               args this.address
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if arg2 * withdrawFeeFactor / 10000 <= ext_call.return_data[0]:
                            if wantLockedTotal >= arg2 * withdrawFeeFactor / 10000:
                                if arg2 * withdrawFeeFactor / 10000 > wantLockedTotal:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                wantLockedTotal -= arg2 * withdrawFeeFactor / 10000
                                if eth.balance(this.address) < 0:
                                    revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                if ext_code.size(wantAddress) <= 0:
                                    revert with 0, 'Address: call to non-contract'
                                mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 32, arg2 * withdrawFeeFactor / 10000) >> 32
                                call wantAddress with:
                                   funct uint32(stor12)
                                     gas gas_remaining wei
                                    args Mask(224, 32, arg2 * withdrawFeeFactor / 10000) << 224, mem[580 len 4]
                            else:
                                if wantLockedTotal > wantLockedTotal:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                wantLockedTotal = 0
                                if eth.balance(this.address) < 0:
                                    revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                if ext_code.size(wantAddress) <= 0:
                                    revert with 0, 'Address: call to non-contract'
                                mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                mem[580 len 0] = 0
                                call wantAddress with:
                                   funct uint32(stor12)
                                     gas gas_remaining wei
                                    args Mask(480, 0, stor16.field_0), mem[580 len 4]
                        else:
                            if wantLockedTotal < ext_call.return_data[0]:
                                if wantLockedTotal > wantLockedTotal:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                wantLockedTotal = 0
                                if eth.balance(this.address) < 0:
                                    revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                if ext_code.size(wantAddress) <= 0:
                                    revert with 0, 'Address: call to non-contract'
                                mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                call wantAddress with:
                                   funct uint32(stor12)
                                     gas gas_remaining wei
                                    args Mask(480, 0, stor16.field_0), mem[580 len 4]
                            else:
                                if ext_call.return_data[0] > wantLockedTotal:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                wantLockedTotal -= ext_call.return_data[0]
                                if eth.balance(this.address) < 0:
                                    revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                if ext_code.size(wantAddress) <= 0:
                                    revert with 0, 'Address: call to non-contract'
                                mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), ext_call.return_data[0 len 28]
                                mem[580 len 0] = 0
                                call wantAddress with:
                                   funct uint32(stor12)
                                     gas gas_remaining wei
                                    args Mask(480, -256, ext_call.return_data[0 len 28]) << 256, mem[580 len 4]
                    else:
                        require ext_code.size(farmContractAddress)
                        call farmContractAddress.withdraw(uint256 arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args pid, arg2 * withdrawFeeFactor / 10000
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require ext_code.size(wantAddress)
                        staticcall wantAddress.0x70a08231 with:
                                gas gas_remaining wei
                               args this.address
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if arg2 * withdrawFeeFactor / 10000 <= ext_call.return_data[0]:
                            if wantLockedTotal >= arg2 * withdrawFeeFactor / 10000:
                                if arg2 * withdrawFeeFactor / 10000 > wantLockedTotal:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                wantLockedTotal -= arg2 * withdrawFeeFactor / 10000
                                if eth.balance(this.address) < 0:
                                    revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                if ext_code.size(wantAddress) <= 0:
                                    revert with 0, 'Address: call to non-contract'
                                mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 32, arg2 * withdrawFeeFactor / 10000) >> 32
                                mem[580 len 0] = 0
                                call wantAddress with:
                                   funct uint32(stor12)
                                     gas gas_remaining wei
                                    args Mask(224, 32, arg2 * withdrawFeeFactor / 10000) << 224, mem[580 len 4]
                            else:
                                if wantLockedTotal > wantLockedTotal:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                wantLockedTotal = 0
                                if eth.balance(this.address) < 0:
                                    revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                if ext_code.size(wantAddress) <= 0:
                                    revert with 0, 'Address: call to non-contract'
                                mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                mem[580 len 0] = 0
                                call wantAddress with:
                                   funct uint32(stor12)
                                     gas gas_remaining wei
                                    args Mask(480, 0, stor16.field_0), mem[580 len 4]
                        else:
                            if wantLockedTotal >= ext_call.return_data[0]:
                                if ext_call.return_data[0] > wantLockedTotal:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                wantLockedTotal -= ext_call.return_data[0]
                                if eth.balance(this.address) < 0:
                                    revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                if ext_code.size(wantAddress) <= 0:
                                    revert with 0, 'Address: call to non-contract'
                                mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), ext_call.return_data[0 len 28]
                                call wantAddress with:
                                   funct uint32(stor12)
                                     gas gas_remaining wei
                                    args Mask(480, -256, ext_call.return_data[0 len 28]) << 256, mem[580 len 4]
                            else:
                                if wantLockedTotal > wantLockedTotal:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                wantLockedTotal = 0
                                if eth.balance(this.address) < 0:
                                    revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                if ext_code.size(wantAddress) <= 0:
                                    revert with 0, 'Address: call to non-contract'
                                mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                mem[580 len 0] = 0
                                call wantAddress with:
                                   funct uint32(stor12)
                                     gas gas_remaining wei
                                    args Mask(480, 0, stor16.field_0), mem[580 len 4]
                if not return_data.size:
                    require not ext_call.success
                    revert with 'SafeMath: division by zero'
                mem[548 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not ext_call.success:
                    if return_data.size > 0:
                        revert with ext_call.return_data[0 len return_data.size]
                    revert with 0, 'SafeERC20: low-level call failed'
                if return_data.size > 0:
                    require return_data.size >= 32
                    if not mem[548]:
                        revert with 0, 
                                    32,
                                    42,
                                    0x775361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                    mem[ceil32(return_data.size) + 627 len 22]
        else:
            if stor27[address(arg1)] + sub_c7095c4b < stor27[address(arg1)]:
                revert with 0, 'SafeMath: addition overflow'
            if stor27[address(arg1)] + sub_c7095c4b <= block.timestamp:
                if withdrawFeeFactor >= 10000:
                    if not isAutoComp:
                        require ext_code.size(wantAddress)
                        staticcall wantAddress.0x70a08231 with:
                                gas gas_remaining wei
                               args this.address
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if arg2 > ext_call.return_data[0]:
                            if wantLockedTotal >= ext_call.return_data[0]:
                                if ext_call.return_data[0] > wantLockedTotal:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                wantLockedTotal -= ext_call.return_data[0]
                                if eth.balance(this.address) < 0:
                                    revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[558 len 26]
                                if ext_code.size(wantAddress) <= 0:
                                    revert with 0, 'Address: call to non-contract'
                                mem[452 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), ext_call.return_data[0 len 28]
                                call wantAddress with:
                                   funct uint32(stor12)
                                     gas gas_remaining wei
                                    args Mask(480, -256, ext_call.return_data[0 len 28]) << 256, mem[516 len 4]
                            else:
                                if wantLockedTotal > wantLockedTotal:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                wantLockedTotal = 0
                                if eth.balance(this.address) < 0:
                                    revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[558 len 26]
                                if ext_code.size(wantAddress) <= 0:
                                    revert with 0, 'Address: call to non-contract'
                                mem[452 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                call wantAddress with:
                                   funct uint32(stor12)
                                     gas gas_remaining wei
                                    args Mask(480, 0, stor16.field_0), mem[516 len 4]
                        else:
                            if wantLockedTotal < arg2:
                                if wantLockedTotal > wantLockedTotal:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                wantLockedTotal = 0
                                if eth.balance(this.address) < 0:
                                    revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[558 len 26]
                                if ext_code.size(wantAddress) <= 0:
                                    revert with 0, 'Address: call to non-contract'
                                mem[452 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                call wantAddress with:
                                   funct uint32(stor12)
                                     gas gas_remaining wei
                                    args Mask(480, 0, stor16.field_0), mem[516 len 4]
                            else:
                                if arg2 > wantLockedTotal:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                wantLockedTotal -= arg2
                                if eth.balance(this.address) < 0:
                                    revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[558 len 26]
                                if ext_code.size(wantAddress) <= 0:
                                    revert with 0, 'Address: call to non-contract'
                                mem[452 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 32, arg2) >> 32
                                mem[516 len 0] = 0
                                call wantAddress with:
                                   funct uint32(stor12)
                                     gas gas_remaining wei
                                    args Mask(224, 32, arg2) << 224, mem[516 len 4]
                    else:
                        require ext_code.size(farmContractAddress)
                        call farmContractAddress.withdraw(uint256 arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args pid, arg2
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require ext_code.size(wantAddress)
                        staticcall wantAddress.0x70a08231 with:
                                gas gas_remaining wei
                               args this.address
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if arg2 > ext_call.return_data[0]:
                            if wantLockedTotal >= ext_call.return_data[0]:
                                if ext_call.return_data[0] > wantLockedTotal:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                wantLockedTotal -= ext_call.return_data[0]
                                if eth.balance(this.address) < 0:
                                    revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[558 len 26]
                                if ext_code.size(wantAddress) <= 0:
                                    revert with 0, 'Address: call to non-contract'
                                mem[452 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), ext_call.return_data[0 len 28]
                                call wantAddress with:
                                   funct uint32(stor12)
                                     gas gas_remaining wei
                                    args Mask(480, -256, ext_call.return_data[0 len 28]) << 256, mem[516 len 4]
                            else:
                                if wantLockedTotal > wantLockedTotal:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                wantLockedTotal = 0
                                if eth.balance(this.address) < 0:
                                    revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[558 len 26]
                                if ext_code.size(wantAddress) <= 0:
                                    revert with 0, 'Address: call to non-contract'
                                mem[452 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                call wantAddress with:
                                   funct uint32(stor12)
                                     gas gas_remaining wei
                                    args Mask(480, 0, stor16.field_0), mem[516 len 4]
                        else:
                            if wantLockedTotal >= arg2:
                                if arg2 > wantLockedTotal:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                wantLockedTotal -= arg2
                                if eth.balance(this.address) < 0:
                                    revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[558 len 26]
                                if ext_code.size(wantAddress) <= 0:
                                    revert with 0, 'Address: call to non-contract'
                                mem[452 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 32, arg2) >> 32
                                mem[516 len 0] = 0
                                call wantAddress with:
                                   funct uint32(stor12)
                                     gas gas_remaining wei
                                    args Mask(224, 32, arg2) << 224, mem[516 len 4]
                            else:
                                if wantLockedTotal > wantLockedTotal:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                wantLockedTotal = 0
                                if eth.balance(this.address) < 0:
                                    revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[558 len 26]
                                if ext_code.size(wantAddress) <= 0:
                                    revert with 0, 'Address: call to non-contract'
                                mem[452 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                mem[516 len 0] = 0
                                call wantAddress with:
                                   funct uint32(stor12)
                                     gas gas_remaining wei
                                    args Mask(480, 0, stor16.field_0), mem[516 len 4]
                    if not return_data.size:
                        require not ext_call.success
                        revert with 'SafeMath: division by zero'
                    mem[484 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not ext_call.success:
                        if return_data.size > 0:
                            revert with ext_call.return_data[0 len return_data.size]
                        revert with 0, 'SafeERC20: low-level call failed'
                    if return_data.size > 0:
                        require return_data.size >= 32
                        if not mem[484]:
                            revert with 0, 
                                        32,
                                        42,
                                        0x775361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                        mem[ceil32(return_data.size) + 563 len 22]
                else:
                    if not arg2:
                        if not isAutoComp:
                            require ext_code.size(wantAddress)
                            staticcall wantAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if 0 <= ext_call.return_data[0]:
                                if wantLockedTotal >= 0:
                                    if 0 > wantLockedTotal:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                    if ext_code.size(wantAddress) <= 0:
                                        revert with 0, 'Address: call to non-contract'
                                    mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), 0
                                    call wantAddress with:
                                       funct uint32(stor12)
                                         gas gas_remaining wei
                                        args 0, mem[580 len 4]
                                else:
                                    if wantLockedTotal > wantLockedTotal:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    wantLockedTotal = 0
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                    if ext_code.size(wantAddress) <= 0:
                                        revert with 0, 'Address: call to non-contract'
                                    mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                    call wantAddress with:
                                       funct uint32(stor12)
                                         gas gas_remaining wei
                                        args Mask(480, 0, stor16.field_0), mem[580 len 4]
                            else:
                                if wantLockedTotal >= ext_call.return_data[0]:
                                    if ext_call.return_data[0] > wantLockedTotal:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    wantLockedTotal -= ext_call.return_data[0]
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                    if ext_code.size(wantAddress) <= 0:
                                        revert with 0, 'Address: call to non-contract'
                                    mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), ext_call.return_data[0 len 28]
                                    mem[580 len 0] = 0
                                    call wantAddress with:
                                       funct uint32(stor12)
                                         gas gas_remaining wei
                                        args Mask(480, -256, ext_call.return_data[0 len 28]) << 256, mem[580 len 4]
                                else:
                                    if wantLockedTotal > wantLockedTotal:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    wantLockedTotal = 0
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                    if ext_code.size(wantAddress) <= 0:
                                        revert with 0, 'Address: call to non-contract'
                                    mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                    mem[580 len 0] = 0
                                    call wantAddress with:
                                       funct uint32(stor12)
                                         gas gas_remaining wei
                                        args Mask(480, 0, stor16.field_0), mem[580 len 4]
                        else:
                            require ext_code.size(farmContractAddress)
                            call farmContractAddress.withdraw(uint256 arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args pid, 0
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require ext_code.size(wantAddress)
                            staticcall wantAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if 0 <= ext_call.return_data[0]:
                                if wantLockedTotal >= 0:
                                    if 0 > wantLockedTotal:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                    if ext_code.size(wantAddress) <= 0:
                                        revert with 0, 'Address: call to non-contract'
                                    mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), 0
                                    mem[580 len 0] = 0
                                    call wantAddress with:
                                       funct uint32(stor12)
                                         gas gas_remaining wei
                                        args Mask(480, -256, unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), 0) << 256, mem[580 len 4]
                                else:
                                    if wantLockedTotal > wantLockedTotal:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    wantLockedTotal = 0
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                    if ext_code.size(wantAddress) <= 0:
                                        revert with 0, 'Address: call to non-contract'
                                    mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                    call wantAddress with:
                                       funct uint32(stor12)
                                         gas gas_remaining wei
                                        args Mask(480, 0, stor16.field_0), mem[580 len 4]
                            else:
                                if wantLockedTotal >= ext_call.return_data[0]:
                                    if ext_call.return_data[0] > wantLockedTotal:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    wantLockedTotal -= ext_call.return_data[0]
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                    if ext_code.size(wantAddress) <= 0:
                                        revert with 0, 'Address: call to non-contract'
                                    mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), ext_call.return_data[0 len 28]
                                    mem[580 len 0] = 0
                                    call wantAddress with:
                                       funct uint32(stor12)
                                         gas gas_remaining wei
                                        args Mask(480, -256, ext_call.return_data[0 len 28]) << 256, mem[580 len 4]
                                else:
                                    if wantLockedTotal > wantLockedTotal:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    wantLockedTotal = 0
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                    if ext_code.size(wantAddress) <= 0:
                                        revert with 0, 'Address: call to non-contract'
                                    mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                    mem[580 len 0] = 0
                                    call wantAddress with:
                                       funct uint32(stor12)
                                         gas gas_remaining wei
                                        args Mask(480, 0, stor16.field_0), mem[580 len 4]
                    else:
                        require arg2
                        if arg2 * withdrawFeeFactor / arg2 != withdrawFeeFactor:
                            revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                        if not isAutoComp:
                            require ext_code.size(wantAddress)
                            staticcall wantAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if arg2 * withdrawFeeFactor / 10000 <= ext_call.return_data[0]:
                                if wantLockedTotal >= arg2 * withdrawFeeFactor / 10000:
                                    if arg2 * withdrawFeeFactor / 10000 > wantLockedTotal:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    wantLockedTotal -= arg2 * withdrawFeeFactor / 10000
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                    if ext_code.size(wantAddress) <= 0:
                                        revert with 0, 'Address: call to non-contract'
                                    mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 32, arg2 * withdrawFeeFactor / 10000) >> 32
                                    call wantAddress with:
                                       funct uint32(stor12)
                                         gas gas_remaining wei
                                        args Mask(224, 32, arg2 * withdrawFeeFactor / 10000) << 224, mem[580 len 4]
                                else:
                                    if wantLockedTotal > wantLockedTotal:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    wantLockedTotal = 0
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                    if ext_code.size(wantAddress) <= 0:
                                        revert with 0, 'Address: call to non-contract'
                                    mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                    mem[580 len 0] = 0
                                    call wantAddress with:
                                       funct uint32(stor12)
                                         gas gas_remaining wei
                                        args Mask(480, 0, stor16.field_0), mem[580 len 4]
                            else:
                                if wantLockedTotal < ext_call.return_data[0]:
                                    if wantLockedTotal > wantLockedTotal:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    wantLockedTotal = 0
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                    if ext_code.size(wantAddress) <= 0:
                                        revert with 0, 'Address: call to non-contract'
                                    mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                    call wantAddress with:
                                       funct uint32(stor12)
                                         gas gas_remaining wei
                                        args Mask(480, 0, stor16.field_0), mem[580 len 4]
                                else:
                                    if ext_call.return_data[0] > wantLockedTotal:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    wantLockedTotal -= ext_call.return_data[0]
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                    if ext_code.size(wantAddress) <= 0:
                                        revert with 0, 'Address: call to non-contract'
                                    mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), ext_call.return_data[0 len 28]
                                    mem[580 len 0] = 0
                                    call wantAddress with:
                                       funct uint32(stor12)
                                         gas gas_remaining wei
                                        args Mask(480, -256, ext_call.return_data[0 len 28]) << 256, mem[580 len 4]
                        else:
                            require ext_code.size(farmContractAddress)
                            call farmContractAddress.withdraw(uint256 arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args pid, arg2 * withdrawFeeFactor / 10000
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require ext_code.size(wantAddress)
                            staticcall wantAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if arg2 * withdrawFeeFactor / 10000 > ext_call.return_data[0]:
                                if wantLockedTotal >= ext_call.return_data[0]:
                                    if ext_call.return_data[0] > wantLockedTotal:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    wantLockedTotal -= ext_call.return_data[0]
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                    if ext_code.size(wantAddress) <= 0:
                                        revert with 0, 'Address: call to non-contract'
                                    mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), ext_call.return_data[0 len 28]
                                    call wantAddress with:
                                       funct uint32(stor12)
                                         gas gas_remaining wei
                                        args Mask(480, -256, ext_call.return_data[0 len 28]) << 256, mem[580 len 4]
                                else:
                                    if wantLockedTotal > wantLockedTotal:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    wantLockedTotal = 0
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                    if ext_code.size(wantAddress) <= 0:
                                        revert with 0, 'Address: call to non-contract'
                                    mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                    call wantAddress with:
                                       funct uint32(stor12)
                                         gas gas_remaining wei
                                        args Mask(480, 0, stor16.field_0), mem[580 len 4]
                            else:
                                if wantLockedTotal < arg2 * withdrawFeeFactor / 10000:
                                    if wantLockedTotal > wantLockedTotal:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    wantLockedTotal = 0
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                    if ext_code.size(wantAddress) <= 0:
                                        revert with 0, 'Address: call to non-contract'
                                    mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                    call wantAddress with:
                                       funct uint32(stor12)
                                         gas gas_remaining wei
                                        args Mask(480, 0, stor16.field_0), mem[580 len 4]
                                else:
                                    if arg2 * withdrawFeeFactor / 10000 > wantLockedTotal:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    wantLockedTotal -= arg2 * withdrawFeeFactor / 10000
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                    if ext_code.size(wantAddress) <= 0:
                                        revert with 0, 'Address: call to non-contract'
                                    mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 32, arg2 * withdrawFeeFactor / 10000) >> 32
                                    mem[580 len 0] = 0
                                    call wantAddress with:
                                       funct uint32(stor12)
                                         gas gas_remaining wei
                                        args Mask(224, 32, arg2 * withdrawFeeFactor / 10000) << 224, mem[580 len 4]
                    if not return_data.size:
                        require not ext_call.success
                        revert with 'SafeMath: division by zero'
                    mem[548 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not ext_call.success:
                        if return_data.size > 0:
                            revert with ext_call.return_data[0 len return_data.size]
                        revert with 0, 'SafeERC20: low-level call failed'
                    if return_data.size > 0:
                        require return_data.size >= 32
                        if not mem[548]:
                            revert with 0, 
                                        32,
                                        42,
                                        0x775361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                        mem[ceil32(return_data.size) + 627 len 22]
            else:
                if not arg2:
                    if withdrawFeeFactor >= 10000:
                        if not isAutoComp:
                            require ext_code.size(wantAddress)
                            staticcall wantAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if arg2 > ext_call.return_data[0]:
                                if wantLockedTotal >= ext_call.return_data[0]:
                                    if ext_call.return_data[0] > wantLockedTotal:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    wantLockedTotal -= ext_call.return_data[0]
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                    if ext_code.size(wantAddress) <= 0:
                                        revert with 0, 'Address: call to non-contract'
                                    mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), ext_call.return_data[0 len 28]
                                    call wantAddress with:
                                       funct uint32(stor12)
                                         gas gas_remaining wei
                                        args Mask(480, -256, ext_call.return_data[0 len 28]) << 256, mem[580 len 4]
                                else:
                                    if wantLockedTotal > wantLockedTotal:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    wantLockedTotal = 0
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                    if ext_code.size(wantAddress) <= 0:
                                        revert with 0, 'Address: call to non-contract'
                                    mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                    call wantAddress with:
                                       funct uint32(stor12)
                                         gas gas_remaining wei
                                        args Mask(480, 0, stor16.field_0), mem[580 len 4]
                            else:
                                if wantLockedTotal >= arg2:
                                    if arg2 > wantLockedTotal:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    wantLockedTotal -= arg2
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                    if ext_code.size(wantAddress) <= 0:
                                        revert with 0, 'Address: call to non-contract'
                                    mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 32, arg2) >> 32
                                    mem[580 len 0] = 0
                                    call wantAddress with:
                                       funct uint32(stor12)
                                         gas gas_remaining wei
                                        args Mask(224, 32, arg2) << 224, mem[580 len 4]
                                else:
                                    if wantLockedTotal > wantLockedTotal:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    wantLockedTotal = 0
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                    if ext_code.size(wantAddress) <= 0:
                                        revert with 0, 'Address: call to non-contract'
                                    mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                    mem[580 len 0] = 0
                                    call wantAddress with:
                                       funct uint32(stor12)
                                         gas gas_remaining wei
                                        args Mask(480, 0, stor16.field_0), mem[580 len 4]
                        else:
                            require ext_code.size(farmContractAddress)
                            call farmContractAddress.withdraw(uint256 arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args pid, arg2
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require ext_code.size(wantAddress)
                            staticcall wantAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if arg2 <= ext_call.return_data[0]:
                                if wantLockedTotal >= arg2:
                                    if arg2 > wantLockedTotal:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    wantLockedTotal -= arg2
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                    if ext_code.size(wantAddress) <= 0:
                                        revert with 0, 'Address: call to non-contract'
                                    mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 32, arg2) >> 32
                                    call wantAddress with:
                                       funct uint32(stor12)
                                         gas gas_remaining wei
                                        args Mask(224, 32, arg2) << 224, mem[580 len 4]
                                else:
                                    if wantLockedTotal > wantLockedTotal:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    wantLockedTotal = 0
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                    if ext_code.size(wantAddress) <= 0:
                                        revert with 0, 'Address: call to non-contract'
                                    mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                    call wantAddress with:
                                       funct uint32(stor12)
                                         gas gas_remaining wei
                                        args Mask(480, 0, stor16.field_0), mem[580 len 4]
                            else:
                                if wantLockedTotal >= ext_call.return_data[0]:
                                    if ext_call.return_data[0] > wantLockedTotal:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    wantLockedTotal -= ext_call.return_data[0]
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                    if ext_code.size(wantAddress) <= 0:
                                        revert with 0, 'Address: call to non-contract'
                                    mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), ext_call.return_data[0 len 28]
                                    call wantAddress with:
                                       funct uint32(stor12)
                                         gas gas_remaining wei
                                        args Mask(480, -256, ext_call.return_data[0 len 28]) << 256, mem[580 len 4]
                                else:
                                    if wantLockedTotal > wantLockedTotal:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    wantLockedTotal = 0
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                    if ext_code.size(wantAddress) <= 0:
                                        revert with 0, 'Address: call to non-contract'
                                    mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                    mem[580 len 0] = 0
                                    call wantAddress with:
                                       funct uint32(stor12)
                                         gas gas_remaining wei
                                        args Mask(480, 0, stor16.field_0), mem[580 len 4]
                        if not return_data.size:
                            require not ext_call.success
                            revert with 'SafeMath: division by zero'
                        mem[548 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size > 0:
                                revert with ext_call.return_data[0 len return_data.size]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if return_data.size > 0:
                            require return_data.size >= 32
                            if not mem[548]:
                                revert with 0, 
                                            32,
                                            42,
                                            0x775361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                            mem[ceil32(return_data.size) + 627 len 22]
                    else:
                        if not arg2:
                            if not isAutoComp:
                                require ext_code.size(wantAddress)
                                staticcall wantAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if 0 <= ext_call.return_data[0]:
                                    if wantLockedTotal >= 0:
                                        if 0 > wantLockedTotal:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                        if ext_code.size(wantAddress) <= 0:
                                            revert with 0, 'Address: call to non-contract'
                                        mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), 0
                                        call wantAddress with:
                                           funct uint32(stor12)
                                             gas gas_remaining wei
                                            args 0, mem[644 len 4]
                                    else:
                                        if wantLockedTotal > wantLockedTotal:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        wantLockedTotal = 0
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                        if ext_code.size(wantAddress) <= 0:
                                            revert with 0, 'Address: call to non-contract'
                                        mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                        mem[644 len 0] = 0
                                        call wantAddress with:
                                           funct uint32(stor12)
                                             gas gas_remaining wei
                                            args Mask(480, 0, stor16.field_0), mem[644 len 4]
                                else:
                                    if wantLockedTotal >= ext_call.return_data[0]:
                                        if ext_call.return_data[0] > wantLockedTotal:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        wantLockedTotal -= ext_call.return_data[0]
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                        if ext_code.size(wantAddress) <= 0:
                                            revert with 0, 'Address: call to non-contract'
                                        mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), ext_call.return_data[0 len 28]
                                        call wantAddress with:
                                           funct uint32(stor12)
                                             gas gas_remaining wei
                                            args Mask(480, -256, ext_call.return_data[0 len 28]) << 256, mem[644 len 4]
                                    else:
                                        if wantLockedTotal > wantLockedTotal:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        wantLockedTotal = 0
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                        if ext_code.size(wantAddress) <= 0:
                                            revert with 0, 'Address: call to non-contract'
                                        mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                        mem[644 len 0] = 0
                                        call wantAddress with:
                                           funct uint32(stor12)
                                             gas gas_remaining wei
                                            args Mask(480, 0, stor16.field_0), mem[644 len 4]
                            else:
                                require ext_code.size(farmContractAddress)
                                call farmContractAddress.withdraw(uint256 arg1, uint256 arg2) with:
                                     gas gas_remaining wei
                                    args pid, 0
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(wantAddress)
                                staticcall wantAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if 0 <= ext_call.return_data[0]:
                                    if wantLockedTotal >= 0:
                                        if 0 > wantLockedTotal:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                        if ext_code.size(wantAddress) <= 0:
                                            revert with 0, 'Address: call to non-contract'
                                        mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), 0
                                        call wantAddress with:
                                           funct uint32(stor12)
                                             gas gas_remaining wei
                                            args 0, mem[644 len 4]
                                    else:
                                        if wantLockedTotal > wantLockedTotal:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        wantLockedTotal = 0
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                        if ext_code.size(wantAddress) <= 0:
                                            revert with 0, 'Address: call to non-contract'
                                        mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                        mem[644 len 0] = 0
                                        call wantAddress with:
                                           funct uint32(stor12)
                                             gas gas_remaining wei
                                            args Mask(480, 0, stor16.field_0), mem[644 len 4]
                                else:
                                    if wantLockedTotal < ext_call.return_data[0]:
                                        if wantLockedTotal > wantLockedTotal:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        wantLockedTotal = 0
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                        if ext_code.size(wantAddress) <= 0:
                                            revert with 0, 'Address: call to non-contract'
                                        mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                        call wantAddress with:
                                           funct uint32(stor12)
                                             gas gas_remaining wei
                                            args Mask(480, 0, stor16.field_0), mem[644 len 4]
                                    else:
                                        if ext_call.return_data[0] > wantLockedTotal:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        wantLockedTotal -= ext_call.return_data[0]
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                        if ext_code.size(wantAddress) <= 0:
                                            revert with 0, 'Address: call to non-contract'
                                        mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), ext_call.return_data[0 len 28]
                                        mem[644 len 0] = 0
                                        call wantAddress with:
                                           funct uint32(stor12)
                                             gas gas_remaining wei
                                            args Mask(480, -256, ext_call.return_data[0 len 28]) << 256, mem[644 len 4]
                        else:
                            require arg2
                            if arg2 * withdrawFeeFactor / arg2 != withdrawFeeFactor:
                                revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                            if not isAutoComp:
                                require ext_code.size(wantAddress)
                                staticcall wantAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if arg2 * withdrawFeeFactor / 10000 > ext_call.return_data[0]:
                                    if wantLockedTotal >= ext_call.return_data[0]:
                                        if ext_call.return_data[0] > wantLockedTotal:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        wantLockedTotal -= ext_call.return_data[0]
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                        if ext_code.size(wantAddress) <= 0:
                                            revert with 0, 'Address: call to non-contract'
                                        mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), ext_call.return_data[0 len 28]
                                        call wantAddress with:
                                           funct uint32(stor12)
                                             gas gas_remaining wei
                                            args Mask(480, -256, ext_call.return_data[0 len 28]) << 256, mem[644 len 4]
                                    else:
                                        if wantLockedTotal > wantLockedTotal:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        wantLockedTotal = 0
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                        if ext_code.size(wantAddress) <= 0:
                                            revert with 0, 'Address: call to non-contract'
                                        mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                        call wantAddress with:
                                           funct uint32(stor12)
                                             gas gas_remaining wei
                                            args Mask(480, 0, stor16.field_0), mem[644 len 4]
                                else:
                                    if wantLockedTotal < arg2 * withdrawFeeFactor / 10000:
                                        if wantLockedTotal > wantLockedTotal:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        wantLockedTotal = 0
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                        if ext_code.size(wantAddress) <= 0:
                                            revert with 0, 'Address: call to non-contract'
                                        mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                        call wantAddress with:
                                           funct uint32(stor12)
                                             gas gas_remaining wei
                                            args Mask(480, 0, stor16.field_0), mem[644 len 4]
                                    else:
                                        if arg2 * withdrawFeeFactor / 10000 > wantLockedTotal:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        wantLockedTotal -= arg2 * withdrawFeeFactor / 10000
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                        if ext_code.size(wantAddress) <= 0:
                                            revert with 0, 'Address: call to non-contract'
                                        mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 32, arg2 * withdrawFeeFactor / 10000) >> 32
                                        mem[644 len 0] = 0
                                        call wantAddress with:
                                           funct uint32(stor12)
                                             gas gas_remaining wei
                                            args Mask(224, 32, arg2 * withdrawFeeFactor / 10000) << 224, mem[644 len 4]
                            else:
                                require ext_code.size(farmContractAddress)
                                call farmContractAddress.withdraw(uint256 arg1, uint256 arg2) with:
                                     gas gas_remaining wei
                                    args pid, arg2 * withdrawFeeFactor / 10000
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(wantAddress)
                                staticcall wantAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if arg2 * withdrawFeeFactor / 10000 <= ext_call.return_data[0]:
                                    if wantLockedTotal >= arg2 * withdrawFeeFactor / 10000:
                                        if arg2 * withdrawFeeFactor / 10000 > wantLockedTotal:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        wantLockedTotal -= arg2 * withdrawFeeFactor / 10000
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                        if ext_code.size(wantAddress) <= 0:
                                            revert with 0, 'Address: call to non-contract'
                                        mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 32, arg2 * withdrawFeeFactor / 10000) >> 32
                                        call wantAddress with:
                                           funct uint32(stor12)
                                             gas gas_remaining wei
                                            args Mask(224, 32, arg2 * withdrawFeeFactor / 10000) << 224, mem[644 len 4]
                                    else:
                                        if wantLockedTotal > wantLockedTotal:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        wantLockedTotal = 0
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                        if ext_code.size(wantAddress) <= 0:
                                            revert with 0, 'Address: call to non-contract'
                                        mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                        mem[644 len 0] = 0
                                        call wantAddress with:
                                           funct uint32(stor12)
                                             gas gas_remaining wei
                                            args Mask(480, 0, stor16.field_0), mem[644 len 4]
                                else:
                                    if wantLockedTotal < ext_call.return_data[0]:
                                        if wantLockedTotal > wantLockedTotal:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        wantLockedTotal = 0
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                        if ext_code.size(wantAddress) <= 0:
                                            revert with 0, 'Address: call to non-contract'
                                        mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                        call wantAddress with:
                                           funct uint32(stor12)
                                             gas gas_remaining wei
                                            args Mask(480, 0, stor16.field_0), mem[644 len 4]
                                    else:
                                        if ext_call.return_data[0] > wantLockedTotal:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        wantLockedTotal -= ext_call.return_data[0]
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                        if ext_code.size(wantAddress) <= 0:
                                            revert with 0, 'Address: call to non-contract'
                                        mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), ext_call.return_data[0 len 28]
                                        mem[644 len 0] = 0
                                        call wantAddress with:
                                           funct uint32(stor12)
                                             gas gas_remaining wei
                                            args Mask(480, -256, ext_call.return_data[0 len 28]) << 256, mem[644 len 4]
                        if not return_data.size:
                            require not ext_call.success
                            revert with 'SafeMath: division by zero'
                        mem[612 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size > 0:
                                revert with ext_call.return_data[0 len return_data.size]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if return_data.size > 0:
                            require return_data.size >= 32
                            if not mem[612]:
                                revert with 0, 
                                            32,
                                            42,
                                            0x775361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                            mem[ceil32(return_data.size) + 691 len 22]
                else:
                    require arg2
                    if arg2 * sub_9ccccc15 / arg2 != sub_9ccccc15:
                        revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                    if withdrawFeeFactor >= 10000:
                        if arg2 * sub_9ccccc15 / 10000 <= 0:
                            if not isAutoComp:
                                require ext_code.size(wantAddress)
                                staticcall wantAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if arg2 <= ext_call.return_data[0]:
                                    if wantLockedTotal >= arg2:
                                        if arg2 > wantLockedTotal:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        wantLockedTotal -= arg2
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                        if ext_code.size(wantAddress) <= 0:
                                            revert with 0, 'Address: call to non-contract'
                                        mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 32, arg2) >> 32
                                        mem[580 len 0] = 0
                                        call wantAddress with:
                                           funct uint32(stor12)
                                             gas gas_remaining wei
                                            args Mask(224, 32, arg2) << 224, mem[580 len 4]
                                    else:
                                        if wantLockedTotal > wantLockedTotal:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        wantLockedTotal = 0
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                        if ext_code.size(wantAddress) <= 0:
                                            revert with 0, 'Address: call to non-contract'
                                        mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                        mem[580 len 0] = 0
                                        call wantAddress with:
                                           funct uint32(stor12)
                                             gas gas_remaining wei
                                            args Mask(480, 0, stor16.field_0), mem[580 len 4]
                                else:
                                    if wantLockedTotal < ext_call.return_data[0]:
                                        if wantLockedTotal > wantLockedTotal:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        wantLockedTotal = 0
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                        if ext_code.size(wantAddress) <= 0:
                                            revert with 0, 'Address: call to non-contract'
                                        mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                        call wantAddress with:
                                           funct uint32(stor12)
                                             gas gas_remaining wei
                                            args Mask(480, 0, stor16.field_0), mem[580 len 4]
                                    else:
                                        if ext_call.return_data[0] > wantLockedTotal:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        wantLockedTotal -= ext_call.return_data[0]
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                        if ext_code.size(wantAddress) <= 0:
                                            revert with 0, 'Address: call to non-contract'
                                        mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), ext_call.return_data[0 len 28]
                                        mem[580 len 0] = 0
                                        call wantAddress with:
                                           funct uint32(stor12)
                                             gas gas_remaining wei
                                            args Mask(480, -256, ext_call.return_data[0 len 28]) << 256, mem[580 len 4]
                            else:
                                require ext_code.size(farmContractAddress)
                                call farmContractAddress.withdraw(uint256 arg1, uint256 arg2) with:
                                     gas gas_remaining wei
                                    args pid, arg2
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(wantAddress)
                                staticcall wantAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if arg2 > ext_call.return_data[0]:
                                    if wantLockedTotal >= ext_call.return_data[0]:
                                        if ext_call.return_data[0] > wantLockedTotal:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        wantLockedTotal -= ext_call.return_data[0]
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                        if ext_code.size(wantAddress) <= 0:
                                            revert with 0, 'Address: call to non-contract'
                                        mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), ext_call.return_data[0 len 28]
                                        call wantAddress with:
                                           funct uint32(stor12)
                                             gas gas_remaining wei
                                            args Mask(480, -256, ext_call.return_data[0 len 28]) << 256, mem[580 len 4]
                                    else:
                                        if wantLockedTotal > wantLockedTotal:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        wantLockedTotal = 0
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                        if ext_code.size(wantAddress) <= 0:
                                            revert with 0, 'Address: call to non-contract'
                                        mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                        call wantAddress with:
                                           funct uint32(stor12)
                                             gas gas_remaining wei
                                            args Mask(480, 0, stor16.field_0), mem[580 len 4]
                                else:
                                    if wantLockedTotal < arg2:
                                        if wantLockedTotal > wantLockedTotal:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        wantLockedTotal = 0
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                        if ext_code.size(wantAddress) <= 0:
                                            revert with 0, 'Address: call to non-contract'
                                        mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                        call wantAddress with:
                                           funct uint32(stor12)
                                             gas gas_remaining wei
                                            args Mask(480, 0, stor16.field_0), mem[580 len 4]
                                    else:
                                        if arg2 > wantLockedTotal:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        wantLockedTotal -= arg2
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                        if ext_code.size(wantAddress) <= 0:
                                            revert with 0, 'Address: call to non-contract'
                                        mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 32, arg2) >> 32
                                        mem[580 len 0] = 0
                                        call wantAddress with:
                                           funct uint32(stor12)
                                             gas gas_remaining wei
                                            args Mask(224, 32, arg2) << 224, mem[580 len 4]
                        else:
                            if not isAutoComp:
                                require ext_code.size(wantAddress)
                                staticcall wantAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if arg2 - (arg2 * sub_9ccccc15 / 10000) <= ext_call.return_data[0]:
                                    if wantLockedTotal >= arg2 - (arg2 * sub_9ccccc15 / 10000):
                                        if arg2 - (arg2 * sub_9ccccc15 / 10000) > wantLockedTotal:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        wantLockedTotal = wantLockedTotal - arg2 + (arg2 * sub_9ccccc15 / 10000)
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                        if ext_code.size(wantAddress) <= 0:
                                            revert with 0, 'Address: call to non-contract'
                                        mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 32, arg2 - (arg2 * sub_9ccccc15 / 10000)) >> 32
                                        call wantAddress with:
                                           funct uint32(stor12)
                                             gas gas_remaining wei
                                            args Mask(224, 32, arg2 - (arg2 * sub_9ccccc15 / 10000)) << 224, mem[580 len 4]
                                    else:
                                        if wantLockedTotal > wantLockedTotal:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        wantLockedTotal = 0
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                        if ext_code.size(wantAddress) <= 0:
                                            revert with 0, 'Address: call to non-contract'
                                        mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                        mem[580 len 0] = 0
                                        call wantAddress with:
                                           funct uint32(stor12)
                                             gas gas_remaining wei
                                            args Mask(480, 0, stor16.field_0), mem[580 len 4]
                                else:
                                    if wantLockedTotal >= ext_call.return_data[0]:
                                        if ext_call.return_data[0] > wantLockedTotal:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        wantLockedTotal -= ext_call.return_data[0]
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                        if ext_code.size(wantAddress) <= 0:
                                            revert with 0, 'Address: call to non-contract'
                                        mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), ext_call.return_data[0 len 28]
                                        mem[580 len 0] = 0
                                        call wantAddress with:
                                           funct uint32(stor12)
                                             gas gas_remaining wei
                                            args Mask(480, -256, ext_call.return_data[0 len 28]) << 256, mem[580 len 4]
                                    else:
                                        if wantLockedTotal > wantLockedTotal:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        wantLockedTotal = 0
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                        if ext_code.size(wantAddress) <= 0:
                                            revert with 0, 'Address: call to non-contract'
                                        mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                        mem[580 len 0] = 0
                                        call wantAddress with:
                                           funct uint32(stor12)
                                             gas gas_remaining wei
                                            args Mask(480, 0, stor16.field_0), mem[580 len 4]
                            else:
                                require ext_code.size(farmContractAddress)
                                call farmContractAddress.withdraw(uint256 arg1, uint256 arg2) with:
                                     gas gas_remaining wei
                                    args pid, arg2 - (arg2 * sub_9ccccc15 / 10000)
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(wantAddress)
                                staticcall wantAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if arg2 - (arg2 * sub_9ccccc15 / 10000) <= ext_call.return_data[0]:
                                    if wantLockedTotal >= arg2 - (arg2 * sub_9ccccc15 / 10000):
                                        if arg2 - (arg2 * sub_9ccccc15 / 10000) > wantLockedTotal:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        wantLockedTotal = wantLockedTotal - arg2 + (arg2 * sub_9ccccc15 / 10000)
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                        if ext_code.size(wantAddress) <= 0:
                                            revert with 0, 'Address: call to non-contract'
                                        mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 32, arg2 - (arg2 * sub_9ccccc15 / 10000)) >> 32
                                        call wantAddress with:
                                           funct uint32(stor12)
                                             gas gas_remaining wei
                                            args Mask(224, 32, arg2 - (arg2 * sub_9ccccc15 / 10000)) << 224, mem[580 len 4]
                                    else:
                                        if wantLockedTotal > wantLockedTotal:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        wantLockedTotal = 0
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                        if ext_code.size(wantAddress) <= 0:
                                            revert with 0, 'Address: call to non-contract'
                                        mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                        call wantAddress with:
                                           funct uint32(stor12)
                                             gas gas_remaining wei
                                            args Mask(480, 0, stor16.field_0), mem[580 len 4]
                                else:
                                    if wantLockedTotal >= ext_call.return_data[0]:
                                        if ext_call.return_data[0] > wantLockedTotal:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        wantLockedTotal -= ext_call.return_data[0]
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                        if ext_code.size(wantAddress) <= 0:
                                            revert with 0, 'Address: call to non-contract'
                                        mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), ext_call.return_data[0 len 28]
                                        call wantAddress with:
                                           funct uint32(stor12)
                                             gas gas_remaining wei
                                            args Mask(480, -256, ext_call.return_data[0 len 28]) << 256, mem[580 len 4]
                                    else:
                                        if wantLockedTotal > wantLockedTotal:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        wantLockedTotal = 0
                                        if eth.balance(this.address) < 0:
                                            revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                                        if ext_code.size(wantAddress) <= 0:
                                            revert with 0, 'Address: call to non-contract'
                                        mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                        mem[580 len 0] = 0
                                        call wantAddress with:
                                           funct uint32(stor12)
                                             gas gas_remaining wei
                                            args Mask(480, 0, stor16.field_0), mem[580 len 4]
                        if not return_data.size:
                            require not ext_call.success
                            revert with 'SafeMath: division by zero'
                        mem[548 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size > 0:
                                revert with ext_call.return_data[0 len return_data.size]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if return_data.size > 0:
                            require return_data.size >= 32
                            if not mem[548]:
                                revert with 0, 
                                            32,
                                            42,
                                            0x775361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                            mem[ceil32(return_data.size) + 627 len 22]
                    else:
                        if not arg2:
                            if arg2 * sub_9ccccc15 / 10000 <= 0:
                                if not isAutoComp:
                                    require ext_code.size(wantAddress)
                                    staticcall wantAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if 0 <= ext_call.return_data[0]:
                                        if wantLockedTotal >= 0:
                                            if 0 > wantLockedTotal:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                            if ext_code.size(wantAddress) <= 0:
                                                revert with 0, 'Address: call to non-contract'
                                            mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), 0
                                            call wantAddress with:
                                               funct uint32(stor12)
                                                 gas gas_remaining wei
                                                args 0, mem[644 len 4]
                                        else:
                                            if wantLockedTotal > wantLockedTotal:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            wantLockedTotal = 0
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                            if ext_code.size(wantAddress) <= 0:
                                                revert with 0, 'Address: call to non-contract'
                                            mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                            mem[644 len 0] = 0
                                            call wantAddress with:
                                               funct uint32(stor12)
                                                 gas gas_remaining wei
                                                args Mask(480, 0, stor16.field_0), mem[644 len 4]
                                    else:
                                        if wantLockedTotal >= ext_call.return_data[0]:
                                            if ext_call.return_data[0] > wantLockedTotal:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            wantLockedTotal -= ext_call.return_data[0]
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                            if ext_code.size(wantAddress) <= 0:
                                                revert with 0, 'Address: call to non-contract'
                                            mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), ext_call.return_data[0 len 28]
                                            mem[644 len 0] = 0
                                            call wantAddress with:
                                               funct uint32(stor12)
                                                 gas gas_remaining wei
                                                args Mask(480, -256, ext_call.return_data[0 len 28]) << 256, mem[644 len 4]
                                        else:
                                            if wantLockedTotal > wantLockedTotal:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            wantLockedTotal = 0
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                            if ext_code.size(wantAddress) <= 0:
                                                revert with 0, 'Address: call to non-contract'
                                            mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                            mem[644 len 0] = 0
                                            call wantAddress with:
                                               funct uint32(stor12)
                                                 gas gas_remaining wei
                                                args Mask(480, 0, stor16.field_0), mem[644 len 4]
                                else:
                                    require ext_code.size(farmContractAddress)
                                    call farmContractAddress.withdraw(uint256 arg1, uint256 arg2) with:
                                         gas gas_remaining wei
                                        args pid, 0
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(wantAddress)
                                    staticcall wantAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if 0 <= ext_call.return_data[0]:
                                        if wantLockedTotal >= 0:
                                            if 0 > wantLockedTotal:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                            if ext_code.size(wantAddress) <= 0:
                                                revert with 0, 'Address: call to non-contract'
                                            mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), 0
                                            mem[644 len 0] = 0
                                            call wantAddress with:
                                               funct uint32(stor12)
                                                 gas gas_remaining wei
                                                args Mask(480, -256, unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), 0) << 256, mem[644 len 4]
                                        else:
                                            if wantLockedTotal > wantLockedTotal:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            wantLockedTotal = 0
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                            if ext_code.size(wantAddress) <= 0:
                                                revert with 0, 'Address: call to non-contract'
                                            mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                            mem[644 len 0] = 0
                                            call wantAddress with:
                                               funct uint32(stor12)
                                                 gas gas_remaining wei
                                                args Mask(480, 0, stor16.field_0), mem[644 len 4]
                                    else:
                                        if wantLockedTotal < ext_call.return_data[0]:
                                            if wantLockedTotal > wantLockedTotal:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            wantLockedTotal = 0
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                            if ext_code.size(wantAddress) <= 0:
                                                revert with 0, 'Address: call to non-contract'
                                            mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                            call wantAddress with:
                                               funct uint32(stor12)
                                                 gas gas_remaining wei
                                                args Mask(480, 0, stor16.field_0), mem[644 len 4]
                                        else:
                                            if ext_call.return_data[0] > wantLockedTotal:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            wantLockedTotal -= ext_call.return_data[0]
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                            if ext_code.size(wantAddress) <= 0:
                                                revert with 0, 'Address: call to non-contract'
                                            mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), ext_call.return_data[0 len 28]
                                            mem[644 len 0] = 0
                                            call wantAddress with:
                                               funct uint32(stor12)
                                                 gas gas_remaining wei
                                                args Mask(480, -256, ext_call.return_data[0 len 28]) << 256, mem[644 len 4]
                            else:
                                if not isAutoComp:
                                    require ext_code.size(wantAddress)
                                    staticcall wantAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if -arg2 * sub_9ccccc15 / 10000 <= ext_call.return_data[0]:
                                        if wantLockedTotal < -arg2 * sub_9ccccc15 / 10000:
                                            if wantLockedTotal > wantLockedTotal:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            wantLockedTotal = 0
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                            if ext_code.size(wantAddress) <= 0:
                                                revert with 0, 'Address: call to non-contract'
                                            mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                            call wantAddress with:
                                               funct uint32(stor12)
                                                 gas gas_remaining wei
                                                args Mask(480, 0, stor16.field_0), mem[644 len 4]
                                        else:
                                            if -arg2 * sub_9ccccc15 / 10000 > wantLockedTotal:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            wantLockedTotal += arg2 * sub_9ccccc15 / 10000
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                            if ext_code.size(wantAddress) <= 0:
                                                revert with 0, 'Address: call to non-contract'
                                            mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 32, -arg2 * sub_9ccccc15 / 10000) >> 32
                                            mem[644 len 0] = 0
                                            call wantAddress with:
                                               funct uint32(stor12)
                                                 gas gas_remaining wei
                                                args Mask(224, 32, -arg2 * sub_9ccccc15 / 10000) << 224, mem[644 len 4]
                                    else:
                                        if wantLockedTotal < ext_call.return_data[0]:
                                            if wantLockedTotal > wantLockedTotal:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            wantLockedTotal = 0
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                            if ext_code.size(wantAddress) <= 0:
                                                revert with 0, 'Address: call to non-contract'
                                            mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                            call wantAddress with:
                                               funct uint32(stor12)
                                                 gas gas_remaining wei
                                                args Mask(480, 0, stor16.field_0), mem[644 len 4]
                                        else:
                                            if ext_call.return_data[0] > wantLockedTotal:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            wantLockedTotal -= ext_call.return_data[0]
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                            if ext_code.size(wantAddress) <= 0:
                                                revert with 0, 'Address: call to non-contract'
                                            mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), ext_call.return_data[0 len 28]
                                            mem[644 len 0] = 0
                                            call wantAddress with:
                                               funct uint32(stor12)
                                                 gas gas_remaining wei
                                                args Mask(480, -256, ext_call.return_data[0 len 28]) << 256, mem[644 len 4]
                                else:
                                    require ext_code.size(farmContractAddress)
                                    call farmContractAddress.withdraw(uint256 arg1, uint256 arg2) with:
                                         gas gas_remaining wei
                                        args pid, -arg2 * sub_9ccccc15 / 10000
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(wantAddress)
                                    staticcall wantAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if -arg2 * sub_9ccccc15 / 10000 <= ext_call.return_data[0]:
                                        if wantLockedTotal >= -arg2 * sub_9ccccc15 / 10000:
                                            if -arg2 * sub_9ccccc15 / 10000 > wantLockedTotal:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            wantLockedTotal += arg2 * sub_9ccccc15 / 10000
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                            if ext_code.size(wantAddress) <= 0:
                                                revert with 0, 'Address: call to non-contract'
                                            mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 32, -arg2 * sub_9ccccc15 / 10000) >> 32
                                            call wantAddress with:
                                               funct uint32(stor12)
                                                 gas gas_remaining wei
                                                args Mask(224, 32, -arg2 * sub_9ccccc15 / 10000) << 224, mem[644 len 4]
                                        else:
                                            if wantLockedTotal > wantLockedTotal:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            wantLockedTotal = 0
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                            if ext_code.size(wantAddress) <= 0:
                                                revert with 0, 'Address: call to non-contract'
                                            mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                            mem[644 len 0] = 0
                                            call wantAddress with:
                                               funct uint32(stor12)
                                                 gas gas_remaining wei
                                                args Mask(480, 0, stor16.field_0), mem[644 len 4]
                                    else:
                                        if wantLockedTotal < ext_call.return_data[0]:
                                            if wantLockedTotal > wantLockedTotal:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            wantLockedTotal = 0
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                            if ext_code.size(wantAddress) <= 0:
                                                revert with 0, 'Address: call to non-contract'
                                            mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                            call wantAddress with:
                                               funct uint32(stor12)
                                                 gas gas_remaining wei
                                                args Mask(480, 0, stor16.field_0), mem[644 len 4]
                                        else:
                                            if ext_call.return_data[0] > wantLockedTotal:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            wantLockedTotal -= ext_call.return_data[0]
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                            if ext_code.size(wantAddress) <= 0:
                                                revert with 0, 'Address: call to non-contract'
                                            mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), ext_call.return_data[0 len 28]
                                            mem[644 len 0] = 0
                                            call wantAddress with:
                                               funct uint32(stor12)
                                                 gas gas_remaining wei
                                                args Mask(480, -256, ext_call.return_data[0 len 28]) << 256, mem[644 len 4]
                        else:
                            require arg2
                            if arg2 * withdrawFeeFactor / arg2 != withdrawFeeFactor:
                                revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                            if arg2 * sub_9ccccc15 / 10000 <= 0:
                                if not isAutoComp:
                                    require ext_code.size(wantAddress)
                                    staticcall wantAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if arg2 * withdrawFeeFactor / 10000 <= ext_call.return_data[0]:
                                        if wantLockedTotal < arg2 * withdrawFeeFactor / 10000:
                                            if wantLockedTotal > wantLockedTotal:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            wantLockedTotal = 0
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                            if ext_code.size(wantAddress) <= 0:
                                                revert with 0, 'Address: call to non-contract'
                                            mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                            call wantAddress with:
                                               funct uint32(stor12)
                                                 gas gas_remaining wei
                                                args Mask(480, 0, stor16.field_0), mem[644 len 4]
                                        else:
                                            if arg2 * withdrawFeeFactor / 10000 > wantLockedTotal:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            wantLockedTotal -= arg2 * withdrawFeeFactor / 10000
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                            if ext_code.size(wantAddress) <= 0:
                                                revert with 0, 'Address: call to non-contract'
                                            mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 32, arg2 * withdrawFeeFactor / 10000) >> 32
                                            mem[644 len 0] = 0
                                            call wantAddress with:
                                               funct uint32(stor12)
                                                 gas gas_remaining wei
                                                args Mask(224, 32, arg2 * withdrawFeeFactor / 10000) << 224, mem[644 len 4]
                                    else:
                                        if wantLockedTotal >= ext_call.return_data[0]:
                                            if ext_call.return_data[0] > wantLockedTotal:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            wantLockedTotal -= ext_call.return_data[0]
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                            if ext_code.size(wantAddress) <= 0:
                                                revert with 0, 'Address: call to non-contract'
                                            mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), ext_call.return_data[0 len 28]
                                            mem[644 len 0] = 0
                                            call wantAddress with:
                                               funct uint32(stor12)
                                                 gas gas_remaining wei
                                                args Mask(480, -256, ext_call.return_data[0 len 28]) << 256, mem[644 len 4]
                                        else:
                                            if wantLockedTotal > wantLockedTotal:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            wantLockedTotal = 0
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                            if ext_code.size(wantAddress) <= 0:
                                                revert with 0, 'Address: call to non-contract'
                                            mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                            mem[644 len 0] = 0
                                            call wantAddress with:
                                               funct uint32(stor12)
                                                 gas gas_remaining wei
                                                args Mask(480, 0, stor16.field_0), mem[644 len 4]
                                else:
                                    require ext_code.size(farmContractAddress)
                                    call farmContractAddress.withdraw(uint256 arg1, uint256 arg2) with:
                                         gas gas_remaining wei
                                        args pid, arg2 * withdrawFeeFactor / 10000
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(wantAddress)
                                    staticcall wantAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if arg2 * withdrawFeeFactor / 10000 > ext_call.return_data[0]:
                                        if wantLockedTotal >= ext_call.return_data[0]:
                                            if ext_call.return_data[0] > wantLockedTotal:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            wantLockedTotal -= ext_call.return_data[0]
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                            if ext_code.size(wantAddress) <= 0:
                                                revert with 0, 'Address: call to non-contract'
                                            mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), ext_call.return_data[0 len 28]
                                            call wantAddress with:
                                               funct uint32(stor12)
                                                 gas gas_remaining wei
                                                args Mask(480, -256, ext_call.return_data[0 len 28]) << 256, mem[644 len 4]
                                        else:
                                            if wantLockedTotal > wantLockedTotal:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            wantLockedTotal = 0
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                            if ext_code.size(wantAddress) <= 0:
                                                revert with 0, 'Address: call to non-contract'
                                            mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                            call wantAddress with:
                                               funct uint32(stor12)
                                                 gas gas_remaining wei
                                                args Mask(480, 0, stor16.field_0), mem[644 len 4]
                                    else:
                                        if wantLockedTotal < arg2 * withdrawFeeFactor / 10000:
                                            if wantLockedTotal > wantLockedTotal:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            wantLockedTotal = 0
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                            if ext_code.size(wantAddress) <= 0:
                                                revert with 0, 'Address: call to non-contract'
                                            mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                            call wantAddress with:
                                               funct uint32(stor12)
                                                 gas gas_remaining wei
                                                args Mask(480, 0, stor16.field_0), mem[644 len 4]
                                        else:
                                            if arg2 * withdrawFeeFactor / 10000 > wantLockedTotal:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            wantLockedTotal -= arg2 * withdrawFeeFactor / 10000
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                            if ext_code.size(wantAddress) <= 0:
                                                revert with 0, 'Address: call to non-contract'
                                            mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 32, arg2 * withdrawFeeFactor / 10000) >> 32
                                            mem[644 len 0] = 0
                                            call wantAddress with:
                                               funct uint32(stor12)
                                                 gas gas_remaining wei
                                                args Mask(224, 32, arg2 * withdrawFeeFactor / 10000) << 224, mem[644 len 4]
                            else:
                                if not isAutoComp:
                                    require ext_code.size(wantAddress)
                                    staticcall wantAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if (arg2 * withdrawFeeFactor / 10000) - (arg2 * sub_9ccccc15 / 10000) <= ext_call.return_data[0]:
                                        if wantLockedTotal >= (arg2 * withdrawFeeFactor / 10000) - (arg2 * sub_9ccccc15 / 10000):
                                            if (arg2 * withdrawFeeFactor / 10000) - (arg2 * sub_9ccccc15 / 10000) > wantLockedTotal:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            wantLockedTotal = wantLockedTotal - (arg2 * withdrawFeeFactor / 10000) + (arg2 * sub_9ccccc15 / 10000)
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                            if ext_code.size(wantAddress) <= 0:
                                                revert with 0, 'Address: call to non-contract'
                                            mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 32, (arg2 * withdrawFeeFactor / 10000) - (arg2 * sub_9ccccc15 / 10000)) >> 32
                                            call wantAddress with:
                                               funct uint32(stor12)
                                                 gas gas_remaining wei
                                                args Mask(224, 32, (arg2 * withdrawFeeFactor / 10000) - (arg2 * sub_9ccccc15 / 10000)) << 224, mem[644 len 4]
                                        else:
                                            if wantLockedTotal > wantLockedTotal:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            wantLockedTotal = 0
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                            if ext_code.size(wantAddress) <= 0:
                                                revert with 0, 'Address: call to non-contract'
                                            mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                            call wantAddress with:
                                               funct uint32(stor12)
                                                 gas gas_remaining wei
                                                args Mask(480, 0, stor16.field_0), mem[644 len 4]
                                    else:
                                        if wantLockedTotal >= ext_call.return_data[0]:
                                            if ext_call.return_data[0] > wantLockedTotal:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            wantLockedTotal -= ext_call.return_data[0]
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                            if ext_code.size(wantAddress) <= 0:
                                                revert with 0, 'Address: call to non-contract'
                                            mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), ext_call.return_data[0 len 28]
                                            call wantAddress with:
                                               funct uint32(stor12)
                                                 gas gas_remaining wei
                                                args Mask(480, -256, ext_call.return_data[0 len 28]) << 256, mem[644 len 4]
                                        else:
                                            if wantLockedTotal > wantLockedTotal:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            wantLockedTotal = 0
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                            if ext_code.size(wantAddress) <= 0:
                                                revert with 0, 'Address: call to non-contract'
                                            mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                            call wantAddress with:
                                               funct uint32(stor12)
                                                 gas gas_remaining wei
                                                args Mask(480, 0, stor16.field_0), mem[644 len 4]
                                else:
                                    require ext_code.size(farmContractAddress)
                                    call farmContractAddress.withdraw(uint256 arg1, uint256 arg2) with:
                                         gas gas_remaining wei
                                        args pid, (arg2 * withdrawFeeFactor / 10000) - (arg2 * sub_9ccccc15 / 10000)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(wantAddress)
                                    staticcall wantAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if (arg2 * withdrawFeeFactor / 10000) - (arg2 * sub_9ccccc15 / 10000) <= ext_call.return_data[0]:
                                        if wantLockedTotal < (arg2 * withdrawFeeFactor / 10000) - (arg2 * sub_9ccccc15 / 10000):
                                            if wantLockedTotal > wantLockedTotal:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            wantLockedTotal = 0
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                            if ext_code.size(wantAddress) <= 0:
                                                revert with 0, 'Address: call to non-contract'
                                            mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                            call wantAddress with:
                                               funct uint32(stor12)
                                                 gas gas_remaining wei
                                                args Mask(480, 0, stor16.field_0), mem[644 len 4]
                                        else:
                                            if (arg2 * withdrawFeeFactor / 10000) - (arg2 * sub_9ccccc15 / 10000) > wantLockedTotal:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            wantLockedTotal = wantLockedTotal - (arg2 * withdrawFeeFactor / 10000) + (arg2 * sub_9ccccc15 / 10000)
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                            if ext_code.size(wantAddress) <= 0:
                                                revert with 0, 'Address: call to non-contract'
                                            mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 32, (arg2 * withdrawFeeFactor / 10000) - (arg2 * sub_9ccccc15 / 10000)) >> 32
                                            mem[644 len 0] = 0
                                            call wantAddress with:
                                               funct uint32(stor12)
                                                 gas gas_remaining wei
                                                args Mask(224, 32, (arg2 * withdrawFeeFactor / 10000) - (arg2 * sub_9ccccc15 / 10000)) << 224, mem[644 len 4]
                                    else:
                                        if wantLockedTotal >= ext_call.return_data[0]:
                                            if ext_call.return_data[0] > wantLockedTotal:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            wantLockedTotal -= ext_call.return_data[0]
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                            if ext_code.size(wantAddress) <= 0:
                                                revert with 0, 'Address: call to non-contract'
                                            mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), ext_call.return_data[0 len 28]
                                            mem[644 len 0] = 0
                                            call wantAddress with:
                                               funct uint32(stor12)
                                                 gas gas_remaining wei
                                                args Mask(480, -256, ext_call.return_data[0 len 28]) << 256, mem[644 len 4]
                                        else:
                                            if wantLockedTotal > wantLockedTotal:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            wantLockedTotal = 0
                                            if eth.balance(this.address) < 0:
                                                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[686 len 26]
                                            if ext_code.size(wantAddress) <= 0:
                                                revert with 0, 'Address: call to non-contract'
                                            mem[580 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor12), uint32(stor12), Mask(224, 0, stor16.field_32)
                                            mem[644 len 0] = 0
                                            call wantAddress with:
                                               funct uint32(stor12)
                                                 gas gas_remaining wei
                                                args Mask(480, 0, stor16.field_0), mem[644 len 4]
                        if not return_data.size:
                            require not ext_call.success
                            revert with 'SafeMath: division by zero'
                        mem[612 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size > 0:
                                revert with ext_call.return_data[0 len return_data.size]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if return_data.size > 0:
                            require return_data.size >= 32
                            if not mem[612]:
                                revert with 0, 
                                            32,
                                            42,
                                            0x775361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                            mem[ceil32(return_data.size) + 691 len 22]
    stor1 = 1
    return sharesTotal
}

function convertDustToEarned() payable {
    if paused:
        revert with 0, 'Pausable: paused'
    if not isAutoComp:
        revert with 0, '!isAutoComp'
    if sub_0ddea8c3:
        revert with 0, 'isSingleVault'
    require ext_code.size(token0Address)
    staticcall token0Address.0x70a08231 with:
            gas gas_remaining wei
           args this.address
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if token0Address == earnedAddress:
        require ext_code.size(token1Address)
        staticcall token1Address.0x70a08231 with:
                gas gas_remaining wei
               args this.address
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if token1Address != earnedAddress:
            if ext_call.return_data[0] > 0:
                require ext_code.size(token1Address)
                staticcall token1Address.0xdd62ed3e with:
                        gas gas_remaining wei
                       args address(this.address), address(uniRouterAddress)
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if 2 * ext_call.return_data[0] < ext_call.return_data[0]:
                    revert with 0, 'SafeMath: addition overflow'
                mem[132] = address(uniRouterAddress)
                mem[164] = 2 * ext_call.return_data[0]
                mem[96] = 68
                mem[132 len 28] = Mask(224, 0, stor8)
                mem[128 len 4] = approve(address arg1, uint256 arg2)
                mem[196] = 32
                mem[228] = 'SafeERC20: low-level call failed'
                if eth.balance(this.address) < 0:
                    revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[366 len 26]
                if ext_code.size(token1Address) <= 0:
                    revert with 0, 'Address: call to non-contract'
                mem[260 len 64] = approve(address arg1, uint256 arg2), Mask(224, 0, stor8), uint32(stor8), Mask(224, 31, ext_call.return_data[0]) >> 31
                mem[352 len 4] = 0
                call token1Address with:
                   funct uint32(stor8)
                     gas gas_remaining wei
                    args Mask(224, 31, ext_call.return_data[0]) << 225, mem[324 len 4]
                if not return_data.size:
                    if not ext_call.success:
                        revert with approve(address arg1, uint256 arg2), Mask(224, 0, stor8), uint32(stor8), 2 * ext_call.return_data[0]
                    if not approve(address arg1, uint256 arg2), Mask(224, 0, stor8):
                        revert with 0, 32, 42, 0x775361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565, mem[370 len 22]
                    mem[260] = token1ToEarnedPath.length
                    if not token1ToEarnedPath.length:
                        mem[(32 * token1ToEarnedPath.length) + 292] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                        mem[(32 * token1ToEarnedPath.length) + 296] = ext_call.return_data[0]
                        mem[(32 * token1ToEarnedPath.length) + 328] = 64
                        mem[(32 * token1ToEarnedPath.length) + 360] = token1ToEarnedPath.length
                        mem[(32 * token1ToEarnedPath.length) + 392 len floor32(token1ToEarnedPath.length)] = mem[292 len floor32(token1ToEarnedPath.length)]
                        require ext_code.size(address(uniRouterAddress))
                        staticcall address(uniRouterAddress).getAmountsOut(uint256 arg1, address[] arg2) with:
                                gas gas_remaining wei
                               args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[292 len floor32(token1ToEarnedPath.length)], mem[(32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 392 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * token1ToEarnedPath.length) + 292 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292
                        require return_data.size >= 32
                        _4519 = mem[(32 * token1ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28]
                        require mem[(32 * token1ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] <= 4294967296
                        require mem[(32 * token1ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                        require mem[mem[(32 * token1ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] + (32 * token1ToEarnedPath.length) + 292] <= 4294967296 and mem[(32 * token1ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] + (32 * mem[mem[(32 * token1ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] + (32 * token1ToEarnedPath.length) + 292]) + 32 <= return_data.size
                        mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292] = mem[mem[(32 * token1ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] + (32 * token1ToEarnedPath.length) + 292]
                        _4554 = mem[_4519 + (32 * token1ToEarnedPath.length) + 292]
                        mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 324 len floor32(mem[_4519 + (32 * token1ToEarnedPath.length) + 292])] = mem[_4519 + (32 * token1ToEarnedPath.length) + 324 len floor32(mem[_4519 + (32 * token1ToEarnedPath.length) + 292])]
                        mem[64] = (32 * _4554) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 388
                        mem[(32 * _4554) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 324] = 30
                        mem[(32 * _4554) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 356] = 'SafeMath: subtraction overflow'
                        if 1 > mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292] - 1 < mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292]
                        _6712 = mem[(32 * mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292] - 1) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 324]
                        if not mem[(32 * mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292] - 1) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 324]:
                            mem[(32 * _4554) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)] = mem[292 len floor32(token1ToEarnedPath.length)]
                            require ext_code.size(address(uniRouterAddress))
                            call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + sub_1b61e055, token1ToEarnedPath.length, mem[292 len floor32(token1ToEarnedPath.length)], mem[(32 * _4554) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + floor32(token1ToEarnedPath.length) + 648 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                        else:
                            require mem[(32 * mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292] - 1) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 324]
                            if mem[(32 * mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292] - 1) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 324] * slippageFactor / mem[(32 * mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292] - 1) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 324] != slippageFactor:
                                revert with 0, 
                                            32,
                                            33,
                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[(32 * _4554) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 489 len 31]
                            mem[(32 * _4554) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)] = mem[292 len floor32(token1ToEarnedPath.length)]
                            require ext_code.size(address(uniRouterAddress))
                            call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0], _6712 * slippageFactor / 1000, Array(len=token1ToEarnedPath.length, data=mem[292 len floor32(token1ToEarnedPath.length)], mem[(32 * _4554) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + floor32(token1ToEarnedPath.length) + 648 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + sub_1b61e055
                    else:
                        mem[0] = 33
                        mem[292] = address(token1ToEarnedPath.field_0)
                        idx = 292
                        s = 0
                        while (32 * token1ToEarnedPath.length) + 260 > idx:
                            mem[idx + 32] = token1ToEarnedPath[s].field_256
                            idx = idx + 32
                            s = s + 1
                            continue 
                        mem[(32 * token1ToEarnedPath.length) + 292] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                        mem[(32 * token1ToEarnedPath.length) + 296] = ext_call.return_data[0]
                        mem[(32 * token1ToEarnedPath.length) + 328] = 64
                        mem[(32 * token1ToEarnedPath.length) + 360] = token1ToEarnedPath.length
                        mem[(32 * token1ToEarnedPath.length) + 392 len floor32(token1ToEarnedPath.length)] = mem[292 len floor32(token1ToEarnedPath.length)]
                        require ext_code.size(address(uniRouterAddress))
                        staticcall address(uniRouterAddress).getAmountsOut(uint256 arg1, address[] arg2) with:
                                gas gas_remaining wei
                               args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[292 len floor32(token1ToEarnedPath.length)], mem[(32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 392 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * token1ToEarnedPath.length) + 292 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292
                        require return_data.size >= 32
                        _10675 = mem[(32 * token1ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28]
                        require mem[(32 * token1ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] <= 4294967296
                        require mem[(32 * token1ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                        require mem[mem[(32 * token1ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] + (32 * token1ToEarnedPath.length) + 292] <= 4294967296 and mem[(32 * token1ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] + (32 * mem[mem[(32 * token1ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] + (32 * token1ToEarnedPath.length) + 292]) + 32 <= return_data.size
                        mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292] = mem[mem[(32 * token1ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] + (32 * token1ToEarnedPath.length) + 292]
                        _10726 = mem[_10675 + (32 * token1ToEarnedPath.length) + 292]
                        mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 324 len floor32(mem[_10675 + (32 * token1ToEarnedPath.length) + 292])] = mem[_10675 + (32 * token1ToEarnedPath.length) + 324 len floor32(mem[_10675 + (32 * token1ToEarnedPath.length) + 292])]
                        mem[64] = (32 * _10726) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 388
                        mem[(32 * _10726) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 324] = 30
                        mem[(32 * _10726) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 356] = 'SafeMath: subtraction overflow'
                        if 1 > mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292] - 1 < mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292]
                        _14532 = mem[(32 * mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292] - 1) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 324]
                        if not mem[(32 * mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292] - 1) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 324]:
                            mem[(32 * _10726) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)] = mem[292 len floor32(token1ToEarnedPath.length)]
                            require ext_code.size(address(uniRouterAddress))
                            call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + sub_1b61e055, token1ToEarnedPath.length, mem[292 len floor32(token1ToEarnedPath.length)], mem[(32 * _10726) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + floor32(token1ToEarnedPath.length) + 648 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                        else:
                            require mem[(32 * mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292] - 1) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 324]
                            if mem[(32 * mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292] - 1) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 324] * slippageFactor / mem[(32 * mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292] - 1) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 324] != slippageFactor:
                                revert with 0, 
                                            32,
                                            33,
                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[(32 * _10726) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 489 len 31]
                            mem[(32 * _10726) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)] = mem[292 len floor32(token1ToEarnedPath.length)]
                            require ext_code.size(address(uniRouterAddress))
                            call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0], _14532 * slippageFactor / 1000, Array(len=token1ToEarnedPath.length, data=mem[292 len floor32(token1ToEarnedPath.length)], mem[(32 * _10726) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + floor32(token1ToEarnedPath.length) + 648 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + sub_1b61e055
                else:
                    mem[260] = return_data.size
                    mem[292 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not ext_call.success:
                        if return_data.size > 0:
                            revert with ext_call.return_data[0 len return_data.size]
                        revert with 0, 'SafeERC20: low-level call failed'
                    if return_data.size <= 0:
                        mem[ceil32(return_data.size) + 261] = token1ToEarnedPath.length
                        if not token1ToEarnedPath.length:
                            mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                            mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 297] = ext_call.return_data[0]
                            mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 329] = 64
                            mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 361] = token1ToEarnedPath.length
                            mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 393 len floor32(token1ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)]
                            require ext_code.size(address(uniRouterAddress))
                            staticcall address(uniRouterAddress).getAmountsOut(uint256 arg1, address[] arg2) with:
                                    gas gas_remaining wei
                                   args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)], mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 393 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293
                            require return_data.size >= 32
                            _4521 = mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28]
                            require mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] <= 4294967296
                            require mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                            require mem[mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293] <= 4294967296 and mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + (32 * mem[mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293]) + 32 <= return_data.size
                            mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] = mem[mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293]
                            _4555 = mem[_4521 + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293]
                            mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325 len floor32(mem[_4521 + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293])] = mem[_4521 + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 325 len floor32(mem[_4521 + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293])]
                            mem[(32 * _4555) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325] = 30
                            mem[(32 * _4555) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 357] = 'SafeMath: subtraction overflow'
                            if 1 > mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293]:
                                revert with 0, 'SafeMath: subtraction overflow'
                            require mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1 < mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293]
                            _6715 = mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325]
                            if not mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325]:
                                mem[(32 * _4555) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)]
                                require ext_code.size(address(uniRouterAddress))
                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + sub_1b61e055, token1ToEarnedPath.length, mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)], mem[(32 * _4555) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + floor32(token1ToEarnedPath.length) + 649 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                            else:
                                require mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325]
                                if mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325] * slippageFactor / mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325] != slippageFactor:
                                    revert with 0, 
                                                32,
                                                33,
                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[(32 * _4555) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 490 len 31]
                                mem[(32 * _4555) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)]
                                require ext_code.size(address(uniRouterAddress))
                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0], _6715 * slippageFactor / 1000, Array(len=token1ToEarnedPath.length, data=mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)], mem[(32 * _4555) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + floor32(token1ToEarnedPath.length) + 649 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + sub_1b61e055
                        else:
                            mem[ceil32(return_data.size) + 293] = address(token1ToEarnedPath.field_0)
                            idx = ceil32(return_data.size) + 293
                            s = 0
                            while ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 261 > idx:
                                mem[idx + 32] = token1ToEarnedPath[s].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                            mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                            mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 297] = ext_call.return_data[0]
                            mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 329] = 64
                            mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 361] = token1ToEarnedPath.length
                            mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 393 len floor32(token1ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)]
                            require ext_code.size(address(uniRouterAddress))
                            staticcall address(uniRouterAddress).getAmountsOut(uint256 arg1, address[] arg2) with:
                                    gas gas_remaining wei
                                   args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)], mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 393 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293
                            require return_data.size >= 32
                            _10677 = mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28]
                            require mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] <= 4294967296
                            require mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                            require mem[mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293] <= 4294967296 and mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + (32 * mem[mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293]) + 32 <= return_data.size
                            mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] = mem[mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293]
                            _10727 = mem[_10677 + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293]
                            mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325 len floor32(mem[_10677 + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293])] = mem[_10677 + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 325 len floor32(mem[_10677 + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293])]
                            mem[(32 * _10727) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325] = 30
                            mem[(32 * _10727) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 357] = 'SafeMath: subtraction overflow'
                            if 1 > mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293]:
                                revert with 0, 'SafeMath: subtraction overflow'
                            require mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1 < mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293]
                            _14535 = mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325]
                            if not mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325]:
                                mem[(32 * _10727) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)]
                                require ext_code.size(address(uniRouterAddress))
                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + sub_1b61e055, token1ToEarnedPath.length, mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)], mem[(32 * _10727) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + floor32(token1ToEarnedPath.length) + 649 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                            else:
                                require mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325]
                                if mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325] * slippageFactor / mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325] != slippageFactor:
                                    revert with 0, 
                                                32,
                                                33,
                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[(32 * _10727) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 490 len 31]
                                mem[(32 * _10727) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)]
                                require ext_code.size(address(uniRouterAddress))
                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0], _14535 * slippageFactor / 1000, Array(len=token1ToEarnedPath.length, data=mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)], mem[(32 * _10727) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + floor32(token1ToEarnedPath.length) + 649 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + sub_1b61e055
                    else:
                        require return_data.size >= 32
                        if not mem[292]:
                            revert with 0, 
                                        32,
                                        42,
                                        0x775361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                        mem[ceil32(return_data.size) + 371 len 22]
                        mem[ceil32(return_data.size) + 261] = token1ToEarnedPath.length
                        if not token1ToEarnedPath.length:
                            mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                            mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 297] = ext_call.return_data[0]
                            mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 329] = 64
                            mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 361] = token1ToEarnedPath.length
                            mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 393 len floor32(token1ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)]
                            require ext_code.size(address(uniRouterAddress))
                            staticcall address(uniRouterAddress).getAmountsOut(uint256 arg1, address[] arg2) with:
                                    gas gas_remaining wei
                                   args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)], mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 393 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293
                            require return_data.size >= 32
                            _4523 = mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28]
                            require mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] <= 4294967296
                            require mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                            require mem[mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293] <= 4294967296 and mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + (32 * mem[mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293]) + 32 <= return_data.size
                            mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] = mem[mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293]
                            _4556 = mem[_4523 + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293]
                            mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325 len floor32(mem[_4523 + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293])] = mem[_4523 + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 325 len floor32(mem[_4523 + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293])]
                            mem[(32 * _4556) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325] = 30
                            mem[(32 * _4556) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 357] = 'SafeMath: subtraction overflow'
                            if 1 > mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293]:
                                revert with 0, 'SafeMath: subtraction overflow'
                            require mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1 < mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293]
                            _6718 = mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325]
                            if not mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325]:
                                mem[(32 * _4556) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)]
                                require ext_code.size(address(uniRouterAddress))
                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + sub_1b61e055, token1ToEarnedPath.length, mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)], mem[(32 * _4556) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + floor32(token1ToEarnedPath.length) + 649 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                            else:
                                require mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325]
                                if mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325] * slippageFactor / mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325] != slippageFactor:
                                    revert with 0, 
                                                32,
                                                33,
                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[(32 * _4556) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 490 len 31]
                                mem[(32 * _4556) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)]
                                require ext_code.size(address(uniRouterAddress))
                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0], _6718 * slippageFactor / 1000, Array(len=token1ToEarnedPath.length, data=mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)], mem[(32 * _4556) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + floor32(token1ToEarnedPath.length) + 649 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + sub_1b61e055
                        else:
                            mem[ceil32(return_data.size) + 293] = address(token1ToEarnedPath.field_0)
                            idx = ceil32(return_data.size) + 293
                            s = 0
                            while ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 261 > idx:
                                mem[idx + 32] = token1ToEarnedPath[s].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                            mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                            mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 297] = ext_call.return_data[0]
                            mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 329] = 64
                            mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 361] = token1ToEarnedPath.length
                            mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 393 len floor32(token1ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)]
                            require ext_code.size(address(uniRouterAddress))
                            staticcall address(uniRouterAddress).getAmountsOut(uint256 arg1, address[] arg2) with:
                                    gas gas_remaining wei
                                   args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)], mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 393 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293
                            require return_data.size >= 32
                            _10679 = mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28]
                            require mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] <= 4294967296
                            require mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                            require mem[mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293] <= 4294967296 and mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + (32 * mem[mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293]) + 32 <= return_data.size
                            mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] = mem[mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293]
                            _10728 = mem[_10679 + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293]
                            mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325 len floor32(mem[_10679 + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293])] = mem[_10679 + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 325 len floor32(mem[_10679 + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293])]
                            mem[(32 * _10728) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325] = 30
                            mem[(32 * _10728) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 357] = 'SafeMath: subtraction overflow'
                            if 1 > mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293]:
                                revert with 0, 'SafeMath: subtraction overflow'
                            require mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1 < mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293]
                            _14538 = mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325]
                            if not mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325]:
                                mem[(32 * _10728) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)]
                                require ext_code.size(address(uniRouterAddress))
                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + sub_1b61e055, token1ToEarnedPath.length, mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)], mem[(32 * _10728) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + floor32(token1ToEarnedPath.length) + 649 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                            else:
                                require mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325]
                                if mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325] * slippageFactor / mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325] != slippageFactor:
                                    revert with 0, 
                                                32,
                                                33,
                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[(32 * _10728) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 490 len 31]
                                mem[(32 * _10728) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)]
                                require ext_code.size(address(uniRouterAddress))
                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0], _14538 * slippageFactor / 1000, Array(len=token1ToEarnedPath.length, data=mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)], mem[(32 * _10728) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + floor32(token1ToEarnedPath.length) + 649 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + sub_1b61e055
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
    else:
        if ext_call.return_data[0] <= 0:
            require ext_code.size(token1Address)
            staticcall token1Address.0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if token1Address != earnedAddress:
                if ext_call.return_data[0] > 0:
                    require ext_code.size(token1Address)
                    staticcall token1Address.0xdd62ed3e with:
                            gas gas_remaining wei
                           args address(this.address), address(uniRouterAddress)
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if 2 * ext_call.return_data[0] < ext_call.return_data[0]:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[132] = address(uniRouterAddress)
                    mem[164] = 2 * ext_call.return_data[0]
                    mem[96] = 68
                    mem[132 len 28] = Mask(224, 0, stor8)
                    mem[128 len 4] = approve(address arg1, uint256 arg2)
                    mem[196] = 32
                    mem[228] = 'SafeERC20: low-level call failed'
                    if eth.balance(this.address) < 0:
                        revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[366 len 26]
                    if ext_code.size(token1Address) <= 0:
                        revert with 0, 'Address: call to non-contract'
                    mem[260 len 64] = approve(address arg1, uint256 arg2), Mask(224, 0, stor8), uint32(stor8), Mask(224, 31, ext_call.return_data[0]) >> 31
                    mem[352 len 4] = 0
                    mem[324 len 0] = 0
                    call token1Address with:
                       funct uint32(stor8)
                         gas gas_remaining wei
                        args Mask(224, 31, ext_call.return_data[0]) << 225, mem[324 len 4]
                    if not return_data.size:
                        if not ext_call.success:
                            revert with approve(address arg1, uint256 arg2), Mask(224, 0, stor8), uint32(stor8), 2 * ext_call.return_data[0]
                        if not approve(address arg1, uint256 arg2), Mask(224, 0, stor8):
                            revert with 0, 32, 42, 0x775361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565, mem[370 len 22]
                        mem[260] = token1ToEarnedPath.length
                        if not token1ToEarnedPath.length:
                            mem[(32 * token1ToEarnedPath.length) + 292] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                            mem[(32 * token1ToEarnedPath.length) + 296] = ext_call.return_data[0]
                            mem[(32 * token1ToEarnedPath.length) + 328] = 64
                            mem[(32 * token1ToEarnedPath.length) + 360] = token1ToEarnedPath.length
                            mem[(32 * token1ToEarnedPath.length) + 392 len floor32(token1ToEarnedPath.length)] = mem[292 len floor32(token1ToEarnedPath.length)]
                            require ext_code.size(address(uniRouterAddress))
                            staticcall address(uniRouterAddress).getAmountsOut(uint256 arg1, address[] arg2) with:
                                    gas gas_remaining wei
                                   args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[292 len floor32(token1ToEarnedPath.length)], mem[(32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 392 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[(32 * token1ToEarnedPath.length) + 292 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292
                            require return_data.size >= 32
                            _4527 = mem[(32 * token1ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28]
                            require mem[(32 * token1ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] <= 4294967296
                            require mem[(32 * token1ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                            require mem[mem[(32 * token1ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] + (32 * token1ToEarnedPath.length) + 292] <= 4294967296 and mem[(32 * token1ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] + (32 * mem[mem[(32 * token1ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] + (32 * token1ToEarnedPath.length) + 292]) + 32 <= return_data.size
                            mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292] = mem[mem[(32 * token1ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] + (32 * token1ToEarnedPath.length) + 292]
                            _4558 = mem[_4527 + (32 * token1ToEarnedPath.length) + 292]
                            mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 324 len floor32(mem[_4527 + (32 * token1ToEarnedPath.length) + 292])] = mem[_4527 + (32 * token1ToEarnedPath.length) + 324 len floor32(mem[_4527 + (32 * token1ToEarnedPath.length) + 292])]
                            mem[64] = (32 * _4558) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 388
                            mem[(32 * _4558) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 324] = 30
                            mem[(32 * _4558) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 356] = 'SafeMath: subtraction overflow'
                            if 1 > mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292]:
                                revert with 0, 'SafeMath: subtraction overflow'
                            require mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292] - 1 < mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292]
                            _6724 = mem[(32 * mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292] - 1) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 324]
                            if not mem[(32 * mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292] - 1) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 324]:
                                mem[(32 * _4558) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)] = mem[292 len floor32(token1ToEarnedPath.length)]
                                require ext_code.size(address(uniRouterAddress))
                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + sub_1b61e055, token1ToEarnedPath.length, mem[292 len floor32(token1ToEarnedPath.length)], mem[(32 * _4558) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + floor32(token1ToEarnedPath.length) + 648 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                            else:
                                require mem[(32 * mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292] - 1) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 324]
                                if mem[(32 * mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292] - 1) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 324] * slippageFactor / mem[(32 * mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292] - 1) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 324] != slippageFactor:
                                    revert with 0, 
                                                32,
                                                33,
                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[(32 * _4558) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 489 len 31]
                                mem[(32 * _4558) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)] = mem[292 len floor32(token1ToEarnedPath.length)]
                                require ext_code.size(address(uniRouterAddress))
                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0], _6724 * slippageFactor / 1000, Array(len=token1ToEarnedPath.length, data=mem[292 len floor32(token1ToEarnedPath.length)], mem[(32 * _4558) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + floor32(token1ToEarnedPath.length) + 648 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + sub_1b61e055
                        else:
                            mem[0] = 33
                            mem[292] = address(token1ToEarnedPath.field_0)
                            idx = 292
                            s = 0
                            while (32 * token1ToEarnedPath.length) + 260 > idx:
                                mem[idx + 32] = token1ToEarnedPath[s].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                            mem[(32 * token1ToEarnedPath.length) + 292] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                            mem[(32 * token1ToEarnedPath.length) + 296] = ext_call.return_data[0]
                            mem[(32 * token1ToEarnedPath.length) + 328] = 64
                            mem[(32 * token1ToEarnedPath.length) + 360] = token1ToEarnedPath.length
                            mem[(32 * token1ToEarnedPath.length) + 392 len floor32(token1ToEarnedPath.length)] = mem[292 len floor32(token1ToEarnedPath.length)]
                            require ext_code.size(address(uniRouterAddress))
                            staticcall address(uniRouterAddress).getAmountsOut(uint256 arg1, address[] arg2) with:
                                    gas gas_remaining wei
                                   args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[292 len floor32(token1ToEarnedPath.length)], mem[(32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 392 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[(32 * token1ToEarnedPath.length) + 292 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292
                            require return_data.size >= 32
                            _10683 = mem[(32 * token1ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28]
                            require mem[(32 * token1ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] <= 4294967296
                            require mem[(32 * token1ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                            require mem[mem[(32 * token1ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] + (32 * token1ToEarnedPath.length) + 292] <= 4294967296 and mem[(32 * token1ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] + (32 * mem[mem[(32 * token1ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] + (32 * token1ToEarnedPath.length) + 292]) + 32 <= return_data.size
                            mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292] = mem[mem[(32 * token1ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] + (32 * token1ToEarnedPath.length) + 292]
                            _10730 = mem[_10683 + (32 * token1ToEarnedPath.length) + 292]
                            mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 324 len floor32(mem[_10683 + (32 * token1ToEarnedPath.length) + 292])] = mem[_10683 + (32 * token1ToEarnedPath.length) + 324 len floor32(mem[_10683 + (32 * token1ToEarnedPath.length) + 292])]
                            mem[64] = (32 * _10730) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 388
                            mem[(32 * _10730) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 324] = 30
                            mem[(32 * _10730) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 356] = 'SafeMath: subtraction overflow'
                            if 1 > mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292]:
                                revert with 0, 'SafeMath: subtraction overflow'
                            require mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292] - 1 < mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292]
                            _14544 = mem[(32 * mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292] - 1) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 324]
                            if not mem[(32 * mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292] - 1) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 324]:
                                mem[(32 * _10730) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)] = mem[292 len floor32(token1ToEarnedPath.length)]
                                require ext_code.size(address(uniRouterAddress))
                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + sub_1b61e055, token1ToEarnedPath.length, mem[292 len floor32(token1ToEarnedPath.length)], mem[(32 * _10730) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + floor32(token1ToEarnedPath.length) + 648 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                            else:
                                require mem[(32 * mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292] - 1) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 324]
                                if mem[(32 * mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292] - 1) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 324] * slippageFactor / mem[(32 * mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292] - 1) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 324] != slippageFactor:
                                    revert with 0, 
                                                32,
                                                33,
                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[(32 * _10730) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 489 len 31]
                                mem[(32 * _10730) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)] = mem[292 len floor32(token1ToEarnedPath.length)]
                                require ext_code.size(address(uniRouterAddress))
                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0], _14544 * slippageFactor / 1000, Array(len=token1ToEarnedPath.length, data=mem[292 len floor32(token1ToEarnedPath.length)], mem[(32 * _10730) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + floor32(token1ToEarnedPath.length) + 648 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + sub_1b61e055
                    else:
                        mem[260] = return_data.size
                        mem[292 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size > 0:
                                revert with ext_call.return_data[0 len return_data.size]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if return_data.size <= 0:
                            mem[ceil32(return_data.size) + 261] = token1ToEarnedPath.length
                            if not token1ToEarnedPath.length:
                                mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 297] = ext_call.return_data[0]
                                mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 329] = 64
                                mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 361] = token1ToEarnedPath.length
                                mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 393 len floor32(token1ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)]
                                require ext_code.size(address(uniRouterAddress))
                                staticcall address(uniRouterAddress).getAmountsOut(uint256 arg1, address[] arg2) with:
                                        gas gas_remaining wei
                                       args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)], mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 393 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293
                                require return_data.size >= 32
                                _4529 = mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28]
                                require mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                require mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                require mem[mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293] <= 4294967296 and mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + (32 * mem[mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293]) + 32 <= return_data.size
                                mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] = mem[mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293]
                                _4559 = mem[_4529 + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293]
                                mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325 len floor32(mem[_4529 + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293])] = mem[_4529 + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 325 len floor32(mem[_4529 + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293])]
                                mem[(32 * _4559) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325] = 30
                                mem[(32 * _4559) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 357] = 'SafeMath: subtraction overflow'
                                if 1 > mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                require mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1 < mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293]
                                _6727 = mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325]
                                if not mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325]:
                                    mem[(32 * _4559) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)]
                                    require ext_code.size(address(uniRouterAddress))
                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + sub_1b61e055, token1ToEarnedPath.length, mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)], mem[(32 * _4559) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + floor32(token1ToEarnedPath.length) + 649 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                else:
                                    require mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325]
                                    if mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325] * slippageFactor / mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325] != slippageFactor:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[(32 * _4559) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 490 len 31]
                                    mem[(32 * _4559) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)]
                                    require ext_code.size(address(uniRouterAddress))
                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], _6727 * slippageFactor / 1000, Array(len=token1ToEarnedPath.length, data=mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)], mem[(32 * _4559) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + floor32(token1ToEarnedPath.length) + 649 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + sub_1b61e055
                            else:
                                mem[ceil32(return_data.size) + 293] = address(token1ToEarnedPath.field_0)
                                idx = ceil32(return_data.size) + 293
                                s = 0
                                while ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 261 > idx:
                                    mem[idx + 32] = token1ToEarnedPath[s].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 297] = ext_call.return_data[0]
                                mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 329] = 64
                                mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 361] = token1ToEarnedPath.length
                                mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 393 len floor32(token1ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)]
                                require ext_code.size(address(uniRouterAddress))
                                staticcall address(uniRouterAddress).getAmountsOut(uint256 arg1, address[] arg2) with:
                                        gas gas_remaining wei
                                       args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)], mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 393 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293
                                require return_data.size >= 32
                                _10685 = mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28]
                                require mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                require mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                require mem[mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293] <= 4294967296 and mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + (32 * mem[mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293]) + 32 <= return_data.size
                                mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] = mem[mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293]
                                _10731 = mem[_10685 + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293]
                                mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325 len floor32(mem[_10685 + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293])] = mem[_10685 + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 325 len floor32(mem[_10685 + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293])]
                                mem[(32 * _10731) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325] = 30
                                mem[(32 * _10731) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 357] = 'SafeMath: subtraction overflow'
                                if 1 > mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                require mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1 < mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293]
                                _14547 = mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325]
                                if not mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325]:
                                    mem[(32 * _10731) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)]
                                    require ext_code.size(address(uniRouterAddress))
                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + sub_1b61e055, token1ToEarnedPath.length, mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)], mem[(32 * _10731) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + floor32(token1ToEarnedPath.length) + 649 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                else:
                                    require mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325]
                                    if mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325] * slippageFactor / mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325] != slippageFactor:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[(32 * _10731) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 490 len 31]
                                    mem[(32 * _10731) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)]
                                    require ext_code.size(address(uniRouterAddress))
                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], _14547 * slippageFactor / 1000, Array(len=token1ToEarnedPath.length, data=mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)], mem[(32 * _10731) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + floor32(token1ToEarnedPath.length) + 649 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + sub_1b61e055
                        else:
                            require return_data.size >= 32
                            if not mem[292]:
                                revert with 0, 
                                            32,
                                            42,
                                            0x775361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                            mem[ceil32(return_data.size) + 371 len 22]
                            mem[ceil32(return_data.size) + 261] = token1ToEarnedPath.length
                            if not token1ToEarnedPath.length:
                                mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 297] = ext_call.return_data[0]
                                mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 329] = 64
                                mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 361] = token1ToEarnedPath.length
                                mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 393 len floor32(token1ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)]
                                require ext_code.size(address(uniRouterAddress))
                                staticcall address(uniRouterAddress).getAmountsOut(uint256 arg1, address[] arg2) with:
                                        gas gas_remaining wei
                                       args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)], mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 393 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293
                                require return_data.size >= 32
                                _4531 = mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28]
                                require mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                require mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                require mem[mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293] <= 4294967296 and mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + (32 * mem[mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293]) + 32 <= return_data.size
                                mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] = mem[mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293]
                                _4560 = mem[_4531 + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293]
                                mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325 len floor32(mem[_4531 + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293])] = mem[_4531 + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 325 len floor32(mem[_4531 + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293])]
                                mem[(32 * _4560) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325] = 30
                                mem[(32 * _4560) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 357] = 'SafeMath: subtraction overflow'
                                if 1 > mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                require mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1 < mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293]
                                _6730 = mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325]
                                if not mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325]:
                                    mem[(32 * _4560) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)]
                                    require ext_code.size(address(uniRouterAddress))
                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + sub_1b61e055, token1ToEarnedPath.length, mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)], mem[(32 * _4560) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + floor32(token1ToEarnedPath.length) + 649 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                else:
                                    require mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325]
                                    if mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325] * slippageFactor / mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325] != slippageFactor:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[(32 * _4560) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 490 len 31]
                                    mem[(32 * _4560) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)]
                                    require ext_code.size(address(uniRouterAddress))
                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], _6730 * slippageFactor / 1000, Array(len=token1ToEarnedPath.length, data=mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)], mem[(32 * _4560) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + floor32(token1ToEarnedPath.length) + 649 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + sub_1b61e055
                            else:
                                mem[ceil32(return_data.size) + 293] = address(token1ToEarnedPath.field_0)
                                idx = ceil32(return_data.size) + 293
                                s = 0
                                while ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 261 > idx:
                                    mem[idx + 32] = token1ToEarnedPath[s].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 297] = ext_call.return_data[0]
                                mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 329] = 64
                                mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 361] = token1ToEarnedPath.length
                                mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 393 len floor32(token1ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)]
                                require ext_code.size(address(uniRouterAddress))
                                staticcall address(uniRouterAddress).getAmountsOut(uint256 arg1, address[] arg2) with:
                                        gas gas_remaining wei
                                       args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)], mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 393 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293
                                require return_data.size >= 32
                                _10687 = mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28]
                                require mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                require mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                require mem[mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293] <= 4294967296 and mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + (32 * mem[mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293]) + 32 <= return_data.size
                                mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] = mem[mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293]
                                _10732 = mem[_10687 + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293]
                                mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325 len floor32(mem[_10687 + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293])] = mem[_10687 + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 325 len floor32(mem[_10687 + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293])]
                                mem[(32 * _10732) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325] = 30
                                mem[(32 * _10732) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 357] = 'SafeMath: subtraction overflow'
                                if 1 > mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                require mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1 < mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293]
                                _14550 = mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325]
                                if not mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325]:
                                    mem[(32 * _10732) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)]
                                    require ext_code.size(address(uniRouterAddress))
                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + sub_1b61e055, token1ToEarnedPath.length, mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)], mem[(32 * _10732) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + floor32(token1ToEarnedPath.length) + 649 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                else:
                                    require mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325]
                                    if mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325] * slippageFactor / mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325] != slippageFactor:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[(32 * _10732) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 490 len 31]
                                    mem[(32 * _10732) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)]
                                    require ext_code.size(address(uniRouterAddress))
                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], _14550 * slippageFactor / 1000, Array(len=token1ToEarnedPath.length, data=mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)], mem[(32 * _10732) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + floor32(token1ToEarnedPath.length) + 649 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + sub_1b61e055
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
        else:
            require ext_code.size(token0Address)
            staticcall token0Address.0xdd62ed3e with:
                    gas gas_remaining wei
                   args address(this.address), address(uniRouterAddress)
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if 2 * ext_call.return_data[0] < ext_call.return_data[0]:
                revert with 0, 'SafeMath: addition overflow'
            mem[132] = address(uniRouterAddress)
            mem[164] = 2 * ext_call.return_data[0]
            mem[96] = 68
            mem[132 len 28] = Mask(224, 0, stor8)
            mem[128 len 4] = approve(address arg1, uint256 arg2)
            mem[196] = 32
            mem[228] = 'SafeERC20: low-level call failed'
            if eth.balance(this.address) < 0:
                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[366 len 26]
            if ext_code.size(token0Address) <= 0:
                revert with 0, 'Address: call to non-contract'
            mem[260 len 64] = approve(address arg1, uint256 arg2), Mask(224, 0, stor8), uint32(stor8), Mask(224, 31, ext_call.return_data[0]) >> 31
            mem[352 len 4] = 0
            mem[324 len 0] = 0
            call token0Address with:
               funct uint32(stor8)
                 gas gas_remaining wei
                args Mask(224, 31, ext_call.return_data[0]) << 225, mem[324 len 4]
            if not return_data.size:
                if not ext_call.success:
                    revert with approve(address arg1, uint256 arg2), Mask(224, 0, stor8), uint32(stor8), 2 * ext_call.return_data[0]
                if not approve(address arg1, uint256 arg2), Mask(224, 0, stor8):
                    revert with 0, 32, 42, 0x775361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565, mem[370 len 22]
                mem[260] = token0ToEarnedPath.length
                if not token0ToEarnedPath.length:
                    mem[(32 * token0ToEarnedPath.length) + 292] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                    mem[(32 * token0ToEarnedPath.length) + 296] = ext_call.return_data[0]
                    mem[(32 * token0ToEarnedPath.length) + 328] = 64
                    mem[(32 * token0ToEarnedPath.length) + 360] = token0ToEarnedPath.length
                    mem[(32 * token0ToEarnedPath.length) + 392 len floor32(token0ToEarnedPath.length)] = mem[292 len floor32(token0ToEarnedPath.length)]
                    require ext_code.size(address(uniRouterAddress))
                    staticcall address(uniRouterAddress).getAmountsOut(uint256 arg1, address[] arg2) with:
                            gas gas_remaining wei
                           args ext_call.return_data[0], Array(len=token0ToEarnedPath.length, data=mem[292 len floor32(token0ToEarnedPath.length)], mem[(32 * token0ToEarnedPath.length) + floor32(token0ToEarnedPath.length) + 392 len (32 * token0ToEarnedPath.length) - floor32(token0ToEarnedPath.length)])
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[(32 * token0ToEarnedPath.length) + 292 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 292
                    require return_data.size >= 32
                    _4535 = mem[(32 * token0ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28]
                    require mem[(32 * token0ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] <= 4294967296
                    require mem[(32 * token0ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                    require mem[mem[(32 * token0ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] + (32 * token0ToEarnedPath.length) + 292] <= 4294967296 and mem[(32 * token0ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] + (32 * mem[mem[(32 * token0ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] + (32 * token0ToEarnedPath.length) + 292]) + 32 <= return_data.size
                    mem[(32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 292] = mem[mem[(32 * token0ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] + (32 * token0ToEarnedPath.length) + 292]
                    _4562 = mem[_4535 + (32 * token0ToEarnedPath.length) + 292]
                    mem[(32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 324 len floor32(mem[_4535 + (32 * token0ToEarnedPath.length) + 292])] = mem[_4535 + (32 * token0ToEarnedPath.length) + 324 len floor32(mem[_4535 + (32 * token0ToEarnedPath.length) + 292])]
                    mem[64] = (32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 388
                    mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 324] = 30
                    mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 356] = 'SafeMath: subtraction overflow'
                    if 1 > mem[(32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 292]:
                        revert with 0, 'SafeMath: subtraction overflow'
                    require mem[(32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 292] - 1 < mem[(32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 292]
                    _6736 = mem[(32 * mem[(32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 292] - 1) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 324]
                    if not mem[(32 * mem[(32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 292] - 1) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 324]:
                        mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 388] = 26
                        mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 420] = 'SafeMath: division by zero'
                        mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token0ToEarnedPath.length)] = mem[292 len floor32(token0ToEarnedPath.length)]
                        require ext_code.size(address(uniRouterAddress))
                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + sub_1b61e055, token0ToEarnedPath.length, mem[292 len floor32(token0ToEarnedPath.length)], mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + floor32(token0ToEarnedPath.length) + 648 len (32 * token0ToEarnedPath.length) - floor32(token0ToEarnedPath.length)]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require ext_code.size(token1Address)
                        staticcall token1Address.0x70a08231 with:
                                gas gas_remaining wei
                               args this.address
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if token1Address != earnedAddress:
                            if ext_call.return_data[0] > 0:
                                require ext_code.size(token1Address)
                                staticcall token1Address.0xdd62ed3e with:
                                        gas gas_remaining wei
                                       args address(this.address), address(uniRouterAddress)
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if 2 * ext_call.return_data[0] < ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 488] = address(uniRouterAddress)
                                mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 520] = 2 * ext_call.return_data[0]
                                mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 452] = 68
                                mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 488 len 28] = Mask(224, 0, stor8)
                                mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 484 len 4] = approve(address arg1, uint256 arg2)
                                mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 552] = 32
                                mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 584] = 'SafeERC20: low-level call failed'
                                if eth.balance(this.address) < 0:
                                    revert with 0, 
                                                32,
                                                38,
                                                0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c,
                                                mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 722 len 26]
                                if ext_code.size(token1Address) <= 0:
                                    revert with 0, 'Address: call to non-contract'
                                mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 616 len 64] = approve(address arg1, uint256 arg2), Mask(224, 0, stor8), uint32(stor8), Mask(224, 31, ext_call.return_data[0]) >> 31
                                mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 708 len 4] = 0
                                mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 680 len 0] = 0
                                call token1Address with:
                                   funct uint32(stor8)
                                     gas gas_remaining wei
                                    args Mask(224, 31, ext_call.return_data[0]) << 225, mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 680 len 4]
                                if not return_data.size:
                                    if not ext_call.success:
                                        revert with approve(address arg1, uint256 arg2), Mask(224, 0, stor8), uint32(stor8), 2 * ext_call.return_data[0]
                                    if not approve(address arg1, uint256 arg2), Mask(224, 0, stor8):
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x775361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 726 len 22]
                                    mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 616] = token1ToEarnedPath.length
                                    if not token1ToEarnedPath.length:
                                        mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                        mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 652] = ext_call.return_data[0]
                                        mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 684] = 64
                                        mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 716] = token1ToEarnedPath.length
                                        mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 748 len floor32(token1ToEarnedPath.length)] = mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)]
                                        require ext_code.size(address(uniRouterAddress))
                                        staticcall address(uniRouterAddress).getAmountsOut(uint256 arg1, address[] arg2) with:
                                                gas gas_remaining wei
                                               args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)], mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 748 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648
                                        require return_data.size >= 32
                                        _18027 = mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28]
                                        require mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                        require mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                        require mem[mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + (32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648] <= 4294967296 and mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + (32 * mem[mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + (32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648]) + 32 <= return_data.size
                                        mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] = mem[mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + (32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648]
                                        _18128 = mem[_18027 + (32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648]
                                        mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680 len floor32(mem[_18027 + (32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648])] = mem[_18027 + (32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 680 len floor32(mem[_18027 + (32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648])]
                                        mem[(32 * _18128) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680] = 30
                                        mem[(32 * _18128) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 712] = 'SafeMath: subtraction overflow'
                                        if 1 > mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1 < mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648]
                                        _21272 = mem[(32 * mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680]
                                        if not mem[(32 * mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680]:
                                            mem[(32 * _18128) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 744] = 26
                                            mem[(32 * _18128) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 776] = 'SafeMath: division by zero'
                                            mem[(32 * _18128) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 808] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                            mem[(32 * _18128) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 812] = ext_call.return_data[0]
                                            mem[(32 * _18128) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 844] = 0
                                            mem[(32 * _18128) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 908] = this.address
                                            mem[(32 * _18128) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 940] = block.timestamp + sub_1b61e055
                                            mem[(32 * _18128) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 876] = 160
                                            mem[(32 * _18128) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 972] = token1ToEarnedPath.length
                                            mem[(32 * _18128) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1004 len floor32(token1ToEarnedPath.length)] = mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)]
                                            require ext_code.size(address(uniRouterAddress))
                                            call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                 gas gas_remaining wei
                                                args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + sub_1b61e055, token1ToEarnedPath.length, mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)], mem[(32 * _18128) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1004 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                        else:
                                            require mem[(32 * mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680]
                                            if mem[(32 * mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680] * slippageFactor / mem[(32 * mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680] != slippageFactor:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * _18128) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845 len 31]
                                            mem[(32 * _18128) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 744] = 26
                                            mem[(32 * _18128) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 776] = 'SafeMath: division by zero'
                                            mem[(32 * _18128) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 808] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                            mem[(32 * _18128) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 812] = ext_call.return_data[0]
                                            mem[(32 * _18128) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 844] = _21272 * slippageFactor / 1000
                                            mem[(32 * _18128) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 908] = this.address
                                            mem[(32 * _18128) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 940] = block.timestamp + sub_1b61e055
                                            mem[(32 * _18128) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 876] = 160
                                            mem[(32 * _18128) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 972] = token1ToEarnedPath.length
                                            mem[(32 * _18128) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1004 len floor32(token1ToEarnedPath.length)] = mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)]
                                            require ext_code.size(address(uniRouterAddress))
                                            call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                 gas gas_remaining wei
                                                args ext_call.return_data[0], _21272 * slippageFactor / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)], mem[(32 * _18128) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1004 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + sub_1b61e055
                                    else:
                                        mem[0] = 33
                                        mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648] = address(token1ToEarnedPath.field_0)
                                        idx = (32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648
                                        s = 0
                                        while (32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 616 > idx:
                                            mem[idx + 32] = token1ToEarnedPath[s].field_256
                                            idx = idx + 32
                                            s = s + 1
                                            continue 
                                        mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                        mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 652] = ext_call.return_data[0]
                                        mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 684] = 64
                                        mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 716] = token1ToEarnedPath.length
                                        mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 748 len floor32(token1ToEarnedPath.length)] = mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)]
                                        require ext_code.size(address(uniRouterAddress))
                                        staticcall address(uniRouterAddress).getAmountsOut(uint256 arg1, address[] arg2) with:
                                                gas gas_remaining wei
                                               args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)], mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 748 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648
                                        require return_data.size >= 32
                                        _24619 = mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28]
                                        require mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                        require mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                        require mem[mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + (32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648] <= 4294967296 and mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + (32 * mem[mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + (32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648]) + 32 <= return_data.size
                                        mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] = mem[mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + (32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648]
                                        _24790 = mem[_24619 + (32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648]
                                        mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680 len floor32(mem[_24619 + (32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648])] = mem[_24619 + (32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 680 len floor32(mem[_24619 + (32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648])]
                                        mem[(32 * _24790) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680] = 30
                                        mem[(32 * _24790) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 712] = 'SafeMath: subtraction overflow'
                                        if 1 > mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1 < mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648]
                                        _27328 = mem[(32 * mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680]
                                        if not mem[(32 * mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680]:
                                            mem[(32 * _24790) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 744] = 26
                                            mem[(32 * _24790) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 776] = 'SafeMath: division by zero'
                                            mem[(32 * _24790) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 808] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                            mem[(32 * _24790) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 812] = ext_call.return_data[0]
                                            mem[(32 * _24790) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 844] = 0
                                            mem[(32 * _24790) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 908] = this.address
                                            mem[(32 * _24790) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 940] = block.timestamp + sub_1b61e055
                                            mem[(32 * _24790) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 876] = 160
                                            mem[(32 * _24790) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 972] = token1ToEarnedPath.length
                                            mem[(32 * _24790) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1004 len floor32(token1ToEarnedPath.length)] = mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)]
                                            require ext_code.size(address(uniRouterAddress))
                                            call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                 gas gas_remaining wei
                                                args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + sub_1b61e055, token1ToEarnedPath.length, mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)], mem[(32 * _24790) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1004 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                        else:
                                            require mem[(32 * mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680]
                                            if mem[(32 * mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680] * slippageFactor / mem[(32 * mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680] != slippageFactor:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * _24790) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845 len 31]
                                            mem[(32 * _24790) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 744] = 26
                                            mem[(32 * _24790) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 776] = 'SafeMath: division by zero'
                                            mem[(32 * _24790) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 808] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                            mem[(32 * _24790) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 812] = ext_call.return_data[0]
                                            mem[(32 * _24790) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 844] = _27328 * slippageFactor / 1000
                                            mem[(32 * _24790) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 908] = this.address
                                            mem[(32 * _24790) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 940] = block.timestamp + sub_1b61e055
                                            mem[(32 * _24790) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 876] = 160
                                            mem[(32 * _24790) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 972] = token1ToEarnedPath.length
                                            mem[(32 * _24790) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1004 len floor32(token1ToEarnedPath.length)] = mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)]
                                            require ext_code.size(address(uniRouterAddress))
                                            call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                 gas gas_remaining wei
                                                args ext_call.return_data[0], _27328 * slippageFactor / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)], mem[(32 * _24790) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1004 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + sub_1b61e055
                                else:
                                    mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 616] = return_data.size
                                    mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    if not ext_call.success:
                                        if return_data.size > 0:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        revert with 0, 'SafeERC20: low-level call failed'
                                    if return_data.size <= 0:
                                        mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 617] = token1ToEarnedPath.length
                                        if not token1ToEarnedPath.length:
                                            mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 653] = ext_call.return_data[0]
                                            mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 685] = 64
                                            mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 717] = token1ToEarnedPath.length
                                            mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 749 len floor32(token1ToEarnedPath.length)] = mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                            require ext_code.size(address(uniRouterAddress))
                                            staticcall address(uniRouterAddress).getAmountsOut(uint256 arg1, address[] arg2) with:
                                                    gas gas_remaining wei
                                                   args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 749 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649
                                            require return_data.size >= 32
                                            _18029 = mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28]
                                            require mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                            require mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                            require mem[mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] <= 4294967296 and mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * mem[mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]) + 32 <= return_data.size
                                            mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = mem[mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]
                                            _18129 = mem[_18029 + (32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]
                                            mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[_18029 + (32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649])] = mem[_18029 + (32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[_18029 + (32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649])]
                                            mem[64] = (32 * _18129) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745
                                            mem[(32 * _18129) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] = 30
                                            mem[(32 * _18129) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 713] = 'SafeMath: subtraction overflow'
                                            if 1 > mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1 < mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]
                                            _21275 = mem[(32 * mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]
                                            if not mem[(32 * mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]:
                                                mem[(32 * _18129) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                mem[(32 * _18129) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                mem[(32 * _18129) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _18129) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                mem[(32 * _18129) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 845] = 0
                                                mem[(32 * _18129) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                mem[(32 * _18129) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + sub_1b61e055
                                                mem[(32 * _18129) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                mem[(32 * _18129) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                mem[(32 * _18129) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + sub_1b61e055, token1ToEarnedPath.length, mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _18129) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                            else:
                                                require mem[(32 * mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]
                                                if mem[(32 * mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] * slippageFactor / mem[(32 * mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] != slippageFactor:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * _18129) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 846 len 31]
                                                mem[(32 * _18129) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                mem[(32 * _18129) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                mem[(32 * _18129) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _18129) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                mem[(32 * _18129) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 845] = _21275 * slippageFactor / 1000
                                                mem[(32 * _18129) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                mem[(32 * _18129) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + sub_1b61e055
                                                mem[(32 * _18129) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                mem[(32 * _18129) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                mem[(32 * _18129) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], _21275 * slippageFactor / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _18129) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + sub_1b61e055
                                        else:
                                            mem[0] = 33
                                            mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649] = address(token1ToEarnedPath.field_0)
                                            idx = (32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649
                                            s = 0
                                            while (32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 617 > idx:
                                                mem[idx + 32] = token1ToEarnedPath[s].field_256
                                                idx = idx + 32
                                                s = s + 1
                                                continue 
                                            mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 653] = ext_call.return_data[0]
                                            mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 685] = 64
                                            mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 717] = token1ToEarnedPath.length
                                            mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 749 len floor32(token1ToEarnedPath.length)] = mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                            require ext_code.size(address(uniRouterAddress))
                                            staticcall address(uniRouterAddress).getAmountsOut(uint256 arg1, address[] arg2) with:
                                                    gas gas_remaining wei
                                                   args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 749 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649
                                            require return_data.size >= 32
                                            _24621 = mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28]
                                            require mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                            require mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                            require mem[mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] <= 4294967296 and mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * mem[mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]) + 32 <= return_data.size
                                            mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = mem[mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]
                                            _24791 = mem[_24621 + (32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]
                                            mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[_24621 + (32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649])] = mem[_24621 + (32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[_24621 + (32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649])]
                                            mem[64] = (32 * _24791) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745
                                            mem[(32 * _24791) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] = 30
                                            mem[(32 * _24791) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 713] = 'SafeMath: subtraction overflow'
                                            if 1 > mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1 < mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]
                                            _27331 = mem[(32 * mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]
                                            if not mem[(32 * mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]:
                                                mem[(32 * _24791) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                mem[(32 * _24791) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                mem[(32 * _24791) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _24791) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                mem[(32 * _24791) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 845] = 0
                                                mem[(32 * _24791) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                mem[(32 * _24791) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + sub_1b61e055
                                                mem[(32 * _24791) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                mem[(32 * _24791) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                mem[(32 * _24791) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + sub_1b61e055, token1ToEarnedPath.length, mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _24791) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                            else:
                                                require mem[(32 * mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]
                                                if mem[(32 * mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] * slippageFactor / mem[(32 * mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] != slippageFactor:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * _24791) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 846 len 31]
                                                mem[(32 * _24791) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                mem[(32 * _24791) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                mem[(32 * _24791) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _24791) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                mem[(32 * _24791) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 845] = _27331 * slippageFactor / 1000
                                                mem[(32 * _24791) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                mem[(32 * _24791) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + sub_1b61e055
                                                mem[(32 * _24791) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                mem[(32 * _24791) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                mem[(32 * _24791) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], _27331 * slippageFactor / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _24791) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + sub_1b61e055
                                    else:
                                        require return_data.size >= 32
                                        if not mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x775361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 727 len 22]
                                        mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 617] = token1ToEarnedPath.length
                                        if not token1ToEarnedPath.length:
                                            mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 653] = ext_call.return_data[0]
                                            mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 685] = 64
                                            mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 717] = token1ToEarnedPath.length
                                            mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 749 len floor32(token1ToEarnedPath.length)] = mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                            require ext_code.size(address(uniRouterAddress))
                                            staticcall address(uniRouterAddress).getAmountsOut(uint256 arg1, address[] arg2) with:
                                                    gas gas_remaining wei
                                                   args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 749 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649
                                            require return_data.size >= 32
                                            _18031 = mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28]
                                            require mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                            require mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                            require mem[mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] <= 4294967296 and mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * mem[mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]) + 32 <= return_data.size
                                            mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = mem[mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]
                                            _18130 = mem[_18031 + (32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]
                                            mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[_18031 + (32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649])] = mem[_18031 + (32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[_18031 + (32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649])]
                                            mem[64] = (32 * _18130) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745
                                            mem[(32 * _18130) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] = 30
                                            mem[(32 * _18130) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 713] = 'SafeMath: subtraction overflow'
                                            if 1 > mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1 < mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]
                                            _21278 = mem[(32 * mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]
                                            if not mem[(32 * mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]:
                                                mem[(32 * _18130) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                mem[(32 * _18130) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                mem[(32 * _18130) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _18130) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                mem[(32 * _18130) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 845] = 0
                                                mem[(32 * _18130) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                mem[(32 * _18130) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + sub_1b61e055
                                                mem[(32 * _18130) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                mem[(32 * _18130) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                mem[(32 * _18130) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + sub_1b61e055, token1ToEarnedPath.length, mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _18130) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                            else:
                                                require mem[(32 * mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]
                                                if mem[(32 * mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] * slippageFactor / mem[(32 * mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] != slippageFactor:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * _18130) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 846 len 31]
                                                mem[(32 * _18130) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                mem[(32 * _18130) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                mem[(32 * _18130) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _18130) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                mem[(32 * _18130) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 845] = _21278 * slippageFactor / 1000
                                                mem[(32 * _18130) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                mem[(32 * _18130) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + sub_1b61e055
                                                mem[(32 * _18130) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                mem[(32 * _18130) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                mem[(32 * _18130) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], _21278 * slippageFactor / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _18130) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + sub_1b61e055
                                        else:
                                            mem[0] = 33
                                            mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649] = address(token1ToEarnedPath.field_0)
                                            idx = (32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649
                                            s = 0
                                            while (32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 617 > idx:
                                                mem[idx + 32] = token1ToEarnedPath[s].field_256
                                                idx = idx + 32
                                                s = s + 1
                                                continue 
                                            mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 653] = ext_call.return_data[0]
                                            mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 685] = 64
                                            mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 717] = token1ToEarnedPath.length
                                            mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 749 len floor32(token1ToEarnedPath.length)] = mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                            require ext_code.size(address(uniRouterAddress))
                                            staticcall address(uniRouterAddress).getAmountsOut(uint256 arg1, address[] arg2) with:
                                                    gas gas_remaining wei
                                                   args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 749 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649
                                            require return_data.size >= 32
                                            _24623 = mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28]
                                            require mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                            require mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                            require mem[mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] <= 4294967296 and mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * mem[mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]) + 32 <= return_data.size
                                            mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = mem[mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]
                                            _24792 = mem[_24623 + (32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]
                                            mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[_24623 + (32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649])] = mem[_24623 + (32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[_24623 + (32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649])]
                                            mem[64] = (32 * _24792) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745
                                            mem[(32 * _24792) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] = 30
                                            mem[(32 * _24792) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 713] = 'SafeMath: subtraction overflow'
                                            if 1 > mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1 < mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]
                                            _27334 = mem[(32 * mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]
                                            if not mem[(32 * mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]:
                                                mem[(32 * _24792) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                mem[(32 * _24792) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                mem[(32 * _24792) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _24792) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                mem[(32 * _24792) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 845] = 0
                                                mem[(32 * _24792) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                mem[(32 * _24792) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + sub_1b61e055
                                                mem[(32 * _24792) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                mem[(32 * _24792) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                mem[(32 * _24792) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + sub_1b61e055, token1ToEarnedPath.length, mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _24792) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                            else:
                                                require mem[(32 * mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]
                                                if mem[(32 * mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] * slippageFactor / mem[(32 * mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] != slippageFactor:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * _24792) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 846 len 31]
                                                mem[(32 * _24792) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                mem[(32 * _24792) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                mem[(32 * _24792) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _24792) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                mem[(32 * _24792) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 845] = _27334 * slippageFactor / 1000
                                                mem[(32 * _24792) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                mem[(32 * _24792) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + sub_1b61e055
                                                mem[(32 * _24792) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                mem[(32 * _24792) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                mem[(32 * _24792) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], _27334 * slippageFactor / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _24792) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + sub_1b61e055
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                    else:
                        require mem[(32 * mem[(32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 292] - 1) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 324]
                        if mem[(32 * mem[(32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 292] - 1) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 324] * slippageFactor / mem[(32 * mem[(32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 292] - 1) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 324] != slippageFactor:
                            revert with 0, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 489 len 31]
                        mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 388] = 26
                        mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 420] = 'SafeMath: division by zero'
                        mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token0ToEarnedPath.length)] = mem[292 len floor32(token0ToEarnedPath.length)]
                        require ext_code.size(address(uniRouterAddress))
                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args ext_call.return_data[0], _6736 * slippageFactor / 1000, Array(len=token0ToEarnedPath.length, data=mem[292 len floor32(token0ToEarnedPath.length)], mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + floor32(token0ToEarnedPath.length) + 648 len (32 * token0ToEarnedPath.length) - floor32(token0ToEarnedPath.length)]), address(this.address), block.timestamp + sub_1b61e055
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require ext_code.size(token1Address)
                        staticcall token1Address.0x70a08231 with:
                                gas gas_remaining wei
                               args this.address
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if token1Address != earnedAddress:
                            if ext_call.return_data[0] > 0:
                                require ext_code.size(token1Address)
                                staticcall token1Address.0xdd62ed3e with:
                                        gas gas_remaining wei
                                       args address(this.address), address(uniRouterAddress)
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if 2 * ext_call.return_data[0] < ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 488] = address(uniRouterAddress)
                                mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 520] = 2 * ext_call.return_data[0]
                                mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 452] = 68
                                mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 488 len 28] = Mask(224, 0, stor8)
                                mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 484 len 4] = approve(address arg1, uint256 arg2)
                                mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 552] = 32
                                mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 584] = 'SafeERC20: low-level call failed'
                                if eth.balance(this.address) < 0:
                                    revert with 0, 
                                                32,
                                                38,
                                                0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c,
                                                mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 722 len 26]
                                if ext_code.size(token1Address) <= 0:
                                    revert with 0, 'Address: call to non-contract'
                                mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 616 len 64] = approve(address arg1, uint256 arg2), Mask(224, 0, stor8), uint32(stor8), Mask(224, 31, ext_call.return_data[0]) >> 31
                                mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 708 len 4] = 0
                                mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 680 len 0] = 0
                                call token1Address with:
                                   funct uint32(stor8)
                                     gas gas_remaining wei
                                    args Mask(224, 31, ext_call.return_data[0]) << 225, mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 680 len 4]
                                if not return_data.size:
                                    if not ext_call.success:
                                        revert with approve(address arg1, uint256 arg2), Mask(224, 0, stor8), uint32(stor8), 2 * ext_call.return_data[0]
                                    if not approve(address arg1, uint256 arg2), Mask(224, 0, stor8):
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x775361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 726 len 22]
                                    mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 616] = token1ToEarnedPath.length
                                    if not token1ToEarnedPath.length:
                                        mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                        mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 652] = ext_call.return_data[0]
                                        mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 684] = 64
                                        mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 716] = token1ToEarnedPath.length
                                        mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 748 len floor32(token1ToEarnedPath.length)] = mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)]
                                        require ext_code.size(address(uniRouterAddress))
                                        staticcall address(uniRouterAddress).getAmountsOut(uint256 arg1, address[] arg2) with:
                                                gas gas_remaining wei
                                               args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)], mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 748 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648
                                        require return_data.size >= 32
                                        _18019 = mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28]
                                        require mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                        require mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                        require mem[mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + (32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648] <= 4294967296 and mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + (32 * mem[mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + (32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648]) + 32 <= return_data.size
                                        mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] = mem[mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + (32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648]
                                        _18124 = mem[_18019 + (32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648]
                                        mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680 len floor32(mem[_18019 + (32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648])] = mem[_18019 + (32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 680 len floor32(mem[_18019 + (32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648])]
                                        mem[(32 * _18124) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680] = 30
                                        mem[(32 * _18124) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 712] = 'SafeMath: subtraction overflow'
                                        if 1 > mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1 < mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648]
                                        _21260 = mem[(32 * mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680]
                                        if not mem[(32 * mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680]:
                                            mem[(32 * _18124) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 744] = 26
                                            mem[(32 * _18124) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 776] = 'SafeMath: division by zero'
                                            mem[(32 * _18124) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 808] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                            mem[(32 * _18124) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 812] = ext_call.return_data[0]
                                            mem[(32 * _18124) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 844] = 0
                                            mem[(32 * _18124) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 908] = this.address
                                            mem[(32 * _18124) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 940] = block.timestamp + sub_1b61e055
                                            mem[(32 * _18124) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 876] = 160
                                            mem[(32 * _18124) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 972] = token1ToEarnedPath.length
                                            mem[(32 * _18124) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1004 len floor32(token1ToEarnedPath.length)] = mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)]
                                            require ext_code.size(address(uniRouterAddress))
                                            call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                 gas gas_remaining wei
                                                args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + sub_1b61e055, token1ToEarnedPath.length, mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)], mem[(32 * _18124) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1004 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                        else:
                                            require mem[(32 * mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680]
                                            if mem[(32 * mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680] * slippageFactor / mem[(32 * mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680] != slippageFactor:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * _18124) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845 len 31]
                                            mem[(32 * _18124) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 744] = 26
                                            mem[(32 * _18124) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 776] = 'SafeMath: division by zero'
                                            mem[(32 * _18124) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 808] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                            mem[(32 * _18124) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 812] = ext_call.return_data[0]
                                            mem[(32 * _18124) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 844] = _21260 * slippageFactor / 1000
                                            mem[(32 * _18124) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 908] = this.address
                                            mem[(32 * _18124) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 940] = block.timestamp + sub_1b61e055
                                            mem[(32 * _18124) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 876] = 160
                                            mem[(32 * _18124) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 972] = token1ToEarnedPath.length
                                            mem[(32 * _18124) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1004 len floor32(token1ToEarnedPath.length)] = mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)]
                                            require ext_code.size(address(uniRouterAddress))
                                            call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                 gas gas_remaining wei
                                                args ext_call.return_data[0], _21260 * slippageFactor / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)], mem[(32 * _18124) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1004 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + sub_1b61e055
                                    else:
                                        mem[0] = 33
                                        mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648] = address(token1ToEarnedPath.field_0)
                                        idx = (32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648
                                        s = 0
                                        while (32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 616 > idx:
                                            mem[idx + 32] = token1ToEarnedPath[s].field_256
                                            idx = idx + 32
                                            s = s + 1
                                            continue 
                                        mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                        mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 652] = ext_call.return_data[0]
                                        mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 684] = 64
                                        mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 716] = token1ToEarnedPath.length
                                        mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 748 len floor32(token1ToEarnedPath.length)] = mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)]
                                        require ext_code.size(address(uniRouterAddress))
                                        staticcall address(uniRouterAddress).getAmountsOut(uint256 arg1, address[] arg2) with:
                                                gas gas_remaining wei
                                               args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)], mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 748 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648
                                        require return_data.size >= 32
                                        _24611 = mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28]
                                        require mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                        require mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                        require mem[mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + (32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648] <= 4294967296 and mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + (32 * mem[mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + (32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648]) + 32 <= return_data.size
                                        mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] = mem[mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + (32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648]
                                        _24786 = mem[_24611 + (32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648]
                                        mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680 len floor32(mem[_24611 + (32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648])] = mem[_24611 + (32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 680 len floor32(mem[_24611 + (32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648])]
                                        mem[(32 * _24786) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680] = 30
                                        mem[(32 * _24786) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 712] = 'SafeMath: subtraction overflow'
                                        if 1 > mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1 < mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648]
                                        _27316 = mem[(32 * mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680]
                                        if not mem[(32 * mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680]:
                                            mem[(32 * _24786) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 744] = 26
                                            mem[(32 * _24786) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 776] = 'SafeMath: division by zero'
                                            mem[(32 * _24786) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 808] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                            mem[(32 * _24786) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 812] = ext_call.return_data[0]
                                            mem[(32 * _24786) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 844] = 0
                                            mem[(32 * _24786) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 908] = this.address
                                            mem[(32 * _24786) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 940] = block.timestamp + sub_1b61e055
                                            mem[(32 * _24786) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 876] = 160
                                            mem[(32 * _24786) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 972] = token1ToEarnedPath.length
                                            mem[(32 * _24786) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1004 len floor32(token1ToEarnedPath.length)] = mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)]
                                            require ext_code.size(address(uniRouterAddress))
                                            call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                 gas gas_remaining wei
                                                args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + sub_1b61e055, token1ToEarnedPath.length, mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)], mem[(32 * _24786) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1004 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                        else:
                                            require mem[(32 * mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680]
                                            if mem[(32 * mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680] * slippageFactor / mem[(32 * mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680] != slippageFactor:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * _24786) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845 len 31]
                                            mem[(32 * _24786) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 744] = 26
                                            mem[(32 * _24786) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 776] = 'SafeMath: division by zero'
                                            mem[(32 * _24786) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 808] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                            mem[(32 * _24786) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 812] = ext_call.return_data[0]
                                            mem[(32 * _24786) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 844] = _27316 * slippageFactor / 1000
                                            mem[(32 * _24786) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 908] = this.address
                                            mem[(32 * _24786) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 940] = block.timestamp + sub_1b61e055
                                            mem[(32 * _24786) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 876] = 160
                                            mem[(32 * _24786) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 972] = token1ToEarnedPath.length
                                            mem[(32 * _24786) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1004 len floor32(token1ToEarnedPath.length)] = mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)]
                                            require ext_code.size(address(uniRouterAddress))
                                            call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                 gas gas_remaining wei
                                                args ext_call.return_data[0], _27316 * slippageFactor / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)], mem[(32 * _24786) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1004 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + sub_1b61e055
                                else:
                                    mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 616] = return_data.size
                                    mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    if not ext_call.success:
                                        if return_data.size > 0:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        revert with 0, 'SafeERC20: low-level call failed'
                                    if return_data.size <= 0:
                                        mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 617] = token1ToEarnedPath.length
                                        if not token1ToEarnedPath.length:
                                            mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 653] = ext_call.return_data[0]
                                            mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 685] = 64
                                            mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 717] = token1ToEarnedPath.length
                                            mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 749 len floor32(token1ToEarnedPath.length)] = mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                            require ext_code.size(address(uniRouterAddress))
                                            staticcall address(uniRouterAddress).getAmountsOut(uint256 arg1, address[] arg2) with:
                                                    gas gas_remaining wei
                                                   args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 749 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649
                                            require return_data.size >= 32
                                            _18021 = mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28]
                                            require mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                            require mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                            require mem[mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] <= 4294967296 and mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * mem[mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]) + 32 <= return_data.size
                                            mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = mem[mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]
                                            _18125 = mem[_18021 + (32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]
                                            mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[_18021 + (32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649])] = mem[_18021 + (32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[_18021 + (32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649])]
                                            mem[64] = (32 * _18125) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745
                                            mem[(32 * _18125) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] = 30
                                            mem[(32 * _18125) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 713] = 'SafeMath: subtraction overflow'
                                            if 1 > mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1 < mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]
                                            _21263 = mem[(32 * mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]
                                            if not mem[(32 * mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]:
                                                mem[(32 * _18125) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                mem[(32 * _18125) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                mem[(32 * _18125) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _18125) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                mem[(32 * _18125) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 845] = 0
                                                mem[(32 * _18125) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                mem[(32 * _18125) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + sub_1b61e055
                                                mem[(32 * _18125) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                mem[(32 * _18125) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                mem[(32 * _18125) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + sub_1b61e055, token1ToEarnedPath.length, mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _18125) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                            else:
                                                require mem[(32 * mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]
                                                if mem[(32 * mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] * slippageFactor / mem[(32 * mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] != slippageFactor:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * _18125) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 846 len 31]
                                                mem[(32 * _18125) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                mem[(32 * _18125) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                mem[(32 * _18125) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _18125) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                mem[(32 * _18125) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 845] = _21263 * slippageFactor / 1000
                                                mem[(32 * _18125) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                mem[(32 * _18125) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + sub_1b61e055
                                                mem[(32 * _18125) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                mem[(32 * _18125) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                mem[(32 * _18125) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], _21263 * slippageFactor / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _18125) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + sub_1b61e055
                                        else:
                                            mem[0] = 33
                                            mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649] = address(token1ToEarnedPath.field_0)
                                            idx = (32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649
                                            s = 0
                                            while (32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 617 > idx:
                                                mem[idx + 32] = token1ToEarnedPath[s].field_256
                                                idx = idx + 32
                                                s = s + 1
                                                continue 
                                            mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 653] = ext_call.return_data[0]
                                            mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 685] = 64
                                            mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 717] = token1ToEarnedPath.length
                                            mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 749 len floor32(token1ToEarnedPath.length)] = mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                            require ext_code.size(address(uniRouterAddress))
                                            staticcall address(uniRouterAddress).getAmountsOut(uint256 arg1, address[] arg2) with:
                                                    gas gas_remaining wei
                                                   args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 749 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649
                                            require return_data.size >= 32
                                            _24613 = mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28]
                                            require mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                            require mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                            require mem[mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] <= 4294967296 and mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * mem[mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]) + 32 <= return_data.size
                                            mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = mem[mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]
                                            _24787 = mem[_24613 + (32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]
                                            mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[_24613 + (32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649])] = mem[_24613 + (32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[_24613 + (32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649])]
                                            mem[64] = (32 * _24787) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745
                                            mem[(32 * _24787) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] = 30
                                            mem[(32 * _24787) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 713] = 'SafeMath: subtraction overflow'
                                            if 1 > mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1 < mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]
                                            _27319 = mem[(32 * mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]
                                            if not mem[(32 * mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]:
                                                mem[(32 * _24787) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                mem[(32 * _24787) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                mem[(32 * _24787) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _24787) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                mem[(32 * _24787) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 845] = 0
                                                mem[(32 * _24787) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                mem[(32 * _24787) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + sub_1b61e055
                                                mem[(32 * _24787) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                mem[(32 * _24787) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                mem[(32 * _24787) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + sub_1b61e055, token1ToEarnedPath.length, mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _24787) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                            else:
                                                require mem[(32 * mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]
                                                if mem[(32 * mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] * slippageFactor / mem[(32 * mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] != slippageFactor:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * _24787) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 846 len 31]
                                                mem[(32 * _24787) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                mem[(32 * _24787) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                mem[(32 * _24787) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _24787) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                mem[(32 * _24787) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 845] = _27319 * slippageFactor / 1000
                                                mem[(32 * _24787) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                mem[(32 * _24787) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + sub_1b61e055
                                                mem[(32 * _24787) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                mem[(32 * _24787) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                mem[(32 * _24787) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], _27319 * slippageFactor / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _24787) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + sub_1b61e055
                                    else:
                                        require return_data.size >= 32
                                        if not mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x775361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 727 len 22]
                                        mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 617] = token1ToEarnedPath.length
                                        if not token1ToEarnedPath.length:
                                            mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 653] = ext_call.return_data[0]
                                            mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 685] = 64
                                            mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 717] = token1ToEarnedPath.length
                                            mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 749 len floor32(token1ToEarnedPath.length)] = mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                            require ext_code.size(address(uniRouterAddress))
                                            staticcall address(uniRouterAddress).getAmountsOut(uint256 arg1, address[] arg2) with:
                                                    gas gas_remaining wei
                                                   args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 749 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649
                                            require return_data.size >= 32
                                            _18023 = mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28]
                                            require mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                            require mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                            require mem[mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] <= 4294967296 and mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * mem[mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]) + 32 <= return_data.size
                                            mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = mem[mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]
                                            _18126 = mem[_18023 + (32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]
                                            mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[_18023 + (32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649])] = mem[_18023 + (32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[_18023 + (32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649])]
                                            mem[64] = (32 * _18126) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745
                                            mem[(32 * _18126) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] = 30
                                            mem[(32 * _18126) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 713] = 'SafeMath: subtraction overflow'
                                            if 1 > mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1 < mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]
                                            _21266 = mem[(32 * mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]
                                            if not mem[(32 * mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]:
                                                mem[(32 * _18126) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                mem[(32 * _18126) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                mem[(32 * _18126) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _18126) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                mem[(32 * _18126) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 845] = 0
                                                mem[(32 * _18126) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                mem[(32 * _18126) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + sub_1b61e055
                                                mem[(32 * _18126) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                mem[(32 * _18126) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                mem[(32 * _18126) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + sub_1b61e055, token1ToEarnedPath.length, mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _18126) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                            else:
                                                require mem[(32 * mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]
                                                if mem[(32 * mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] * slippageFactor / mem[(32 * mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] != slippageFactor:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * _18126) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 846 len 31]
                                                mem[(32 * _18126) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                mem[(32 * _18126) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                mem[(32 * _18126) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _18126) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                mem[(32 * _18126) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 845] = _21266 * slippageFactor / 1000
                                                mem[(32 * _18126) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                mem[(32 * _18126) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + sub_1b61e055
                                                mem[(32 * _18126) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                mem[(32 * _18126) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                mem[(32 * _18126) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], _21266 * slippageFactor / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _18126) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + sub_1b61e055
                                        else:
                                            mem[0] = 33
                                            mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649] = address(token1ToEarnedPath.field_0)
                                            idx = (32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649
                                            s = 0
                                            while (32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 617 > idx:
                                                mem[idx + 32] = token1ToEarnedPath[s].field_256
                                                idx = idx + 32
                                                s = s + 1
                                                continue 
                                            mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 653] = ext_call.return_data[0]
                                            mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 685] = 64
                                            mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 717] = token1ToEarnedPath.length
                                            mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 749 len floor32(token1ToEarnedPath.length)] = mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                            require ext_code.size(address(uniRouterAddress))
                                            staticcall address(uniRouterAddress).getAmountsOut(uint256 arg1, address[] arg2) with:
                                                    gas gas_remaining wei
                                                   args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 749 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649
                                            require return_data.size >= 32
                                            _24615 = mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28]
                                            require mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                            require mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                            require mem[mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] <= 4294967296 and mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * mem[mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]) + 32 <= return_data.size
                                            mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = mem[mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]
                                            _24788 = mem[_24615 + (32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]
                                            mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[_24615 + (32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649])] = mem[_24615 + (32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[_24615 + (32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649])]
                                            mem[64] = (32 * _24788) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745
                                            mem[(32 * _24788) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] = 30
                                            mem[(32 * _24788) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 713] = 'SafeMath: subtraction overflow'
                                            if 1 > mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1 < mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]
                                            _27322 = mem[(32 * mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]
                                            if not mem[(32 * mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]:
                                                mem[(32 * _24788) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                mem[(32 * _24788) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                mem[(32 * _24788) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _24788) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                mem[(32 * _24788) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 845] = 0
                                                mem[(32 * _24788) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                mem[(32 * _24788) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + sub_1b61e055
                                                mem[(32 * _24788) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                mem[(32 * _24788) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                mem[(32 * _24788) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + sub_1b61e055, token1ToEarnedPath.length, mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _24788) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                            else:
                                                require mem[(32 * mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]
                                                if mem[(32 * mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] * slippageFactor / mem[(32 * mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] != slippageFactor:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * _24788) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 846 len 31]
                                                mem[(32 * _24788) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                mem[(32 * _24788) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                mem[(32 * _24788) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _24788) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                mem[(32 * _24788) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 845] = _27322 * slippageFactor / 1000
                                                mem[(32 * _24788) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                mem[(32 * _24788) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + sub_1b61e055
                                                mem[(32 * _24788) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                mem[(32 * _24788) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                mem[(32 * _24788) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], _27322 * slippageFactor / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _4562) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _24788) + (32 * _4562) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + sub_1b61e055
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                else:
                    mem[0] = 32
                    mem[292] = address(token0ToEarnedPath.field_0)
                    idx = 292
                    s = 0
                    while (32 * token0ToEarnedPath.length) + 260 > idx:
                        mem[idx + 32] = token0ToEarnedPath[s].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    mem[(32 * token0ToEarnedPath.length) + 292] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                    mem[(32 * token0ToEarnedPath.length) + 296] = ext_call.return_data[0]
                    mem[(32 * token0ToEarnedPath.length) + 328] = 64
                    mem[(32 * token0ToEarnedPath.length) + 360] = token0ToEarnedPath.length
                    mem[(32 * token0ToEarnedPath.length) + 392 len floor32(token0ToEarnedPath.length)] = mem[292 len floor32(token0ToEarnedPath.length)]
                    require ext_code.size(address(uniRouterAddress))
                    staticcall address(uniRouterAddress).getAmountsOut(uint256 arg1, address[] arg2) with:
                            gas gas_remaining wei
                           args ext_call.return_data[0], Array(len=token0ToEarnedPath.length, data=mem[292 len floor32(token0ToEarnedPath.length)], mem[(32 * token0ToEarnedPath.length) + floor32(token0ToEarnedPath.length) + 392 len (32 * token0ToEarnedPath.length) - floor32(token0ToEarnedPath.length)])
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[(32 * token0ToEarnedPath.length) + 292 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 292
                    require return_data.size >= 32
                    _10691 = mem[(32 * token0ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28]
                    require mem[(32 * token0ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] <= 4294967296
                    require mem[(32 * token0ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                    require mem[mem[(32 * token0ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] + (32 * token0ToEarnedPath.length) + 292] <= 4294967296 and mem[(32 * token0ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] + (32 * mem[mem[(32 * token0ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] + (32 * token0ToEarnedPath.length) + 292]) + 32 <= return_data.size
                    mem[(32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 292] = mem[mem[(32 * token0ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] + (32 * token0ToEarnedPath.length) + 292]
                    _10738 = mem[_10691 + (32 * token0ToEarnedPath.length) + 292]
                    mem[(32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 324 len floor32(mem[_10691 + (32 * token0ToEarnedPath.length) + 292])] = mem[_10691 + (32 * token0ToEarnedPath.length) + 324 len floor32(mem[_10691 + (32 * token0ToEarnedPath.length) + 292])]
                    mem[64] = (32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 388
                    mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 324] = 30
                    mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 356] = 'SafeMath: subtraction overflow'
                    if 1 > mem[(32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 292]:
                        revert with 0, 'SafeMath: subtraction overflow'
                    require mem[(32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 292] - 1 < mem[(32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 292]
                    _14556 = mem[(32 * mem[(32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 292] - 1) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 324]
                    if not mem[(32 * mem[(32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 292] - 1) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 324]:
                        mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 388] = 26
                        mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 420] = 'SafeMath: division by zero'
                        mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token0ToEarnedPath.length)] = mem[292 len floor32(token0ToEarnedPath.length)]
                        require ext_code.size(address(uniRouterAddress))
                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + sub_1b61e055, token0ToEarnedPath.length, mem[292 len floor32(token0ToEarnedPath.length)], mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + floor32(token0ToEarnedPath.length) + 648 len (32 * token0ToEarnedPath.length) - floor32(token0ToEarnedPath.length)]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require ext_code.size(token1Address)
                        staticcall token1Address.0x70a08231 with:
                                gas gas_remaining wei
                               args this.address
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if token1Address != earnedAddress:
                            if ext_call.return_data[0] > 0:
                                require ext_code.size(token1Address)
                                staticcall token1Address.0xdd62ed3e with:
                                        gas gas_remaining wei
                                       args address(this.address), address(uniRouterAddress)
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if 2 * ext_call.return_data[0] < ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 488] = address(uniRouterAddress)
                                mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 520] = 2 * ext_call.return_data[0]
                                mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 452] = 68
                                mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 488 len 28] = Mask(224, 0, stor8)
                                mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 484 len 4] = approve(address arg1, uint256 arg2)
                                mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 552] = 32
                                mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 584] = 'SafeERC20: low-level call failed'
                                if eth.balance(this.address) < 0:
                                    revert with 0, 
                                                32,
                                                38,
                                                0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c,
                                                mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 722 len 26]
                                if ext_code.size(token1Address) <= 0:
                                    revert with 0, 'Address: call to non-contract'
                                mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 616 len 64] = approve(address arg1, uint256 arg2), Mask(224, 0, stor8), uint32(stor8), Mask(224, 31, ext_call.return_data[0]) >> 31
                                mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 708 len 4] = 0
                                call token1Address with:
                                   funct token0ToEarnedPath.length.field_224
                                     gas gas_remaining wei
                                    args Mask(224, 31, ext_call.return_data[0]) << 225, mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 680 len 4]
                                if not return_data.size:
                                    if not ext_call.success:
                                        revert with approve(address arg1, uint256 arg2), Mask(224, 0, stor8), uint32(stor8), 2 * ext_call.return_data[0]
                                    if not approve(address arg1, uint256 arg2), Mask(224, 0, stor8):
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x775361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 726 len 22]
                                    mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 616] = token1ToEarnedPath.length
                                    if not token1ToEarnedPath.length:
                                        mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                        mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 652] = ext_call.return_data[0]
                                        mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 684] = 64
                                        mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 716] = token1ToEarnedPath.length
                                        mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 748 len floor32(token1ToEarnedPath.length)] = mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)]
                                        var125001 = floor32(token1ToEarnedPath.length)
                                        require ext_code.size(address(uniRouterAddress))
                                        staticcall address(uniRouterAddress).getAmountsOut(uint256 arg1, address[] arg2) with:
                                                gas gas_remaining wei
                                               args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)], mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 748 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648
                                        require return_data.size >= 32
                                        _24635 = mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28]
                                        require mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                        require mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                        require mem[mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + (32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648] <= 4294967296 and mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + (32 * mem[mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + (32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648]) + 32 <= return_data.size
                                        mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] = mem[mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + (32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648]
                                        _24798 = mem[_24635 + (32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648]
                                        mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680 len floor32(mem[_24635 + (32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648])] = mem[_24635 + (32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 680 len floor32(mem[_24635 + (32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648])]
                                        mem[64] = (32 * _24798) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 744
                                        mem[(32 * _24798) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680] = 30
                                        mem[(32 * _24798) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 712] = 'SafeMath: subtraction overflow'
                                        if 1 > mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1 < mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648]
                                        _27352 = mem[(32 * mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680]
                                        if not mem[(32 * mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680]:
                                            mem[(32 * _24798) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 744] = 26
                                            mem[(32 * _24798) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 776] = 'SafeMath: division by zero'
                                            mem[(32 * _24798) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 808] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                            mem[(32 * _24798) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 812] = ext_call.return_data[0]
                                            mem[(32 * _24798) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 844] = 0
                                            mem[(32 * _24798) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 908] = this.address
                                            mem[(32 * _24798) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 940] = block.timestamp + sub_1b61e055
                                            mem[(32 * _24798) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 876] = 160
                                            mem[(32 * _24798) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 972] = token1ToEarnedPath.length
                                            mem[(32 * _24798) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1004 len floor32(token1ToEarnedPath.length)] = mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)]
                                            require ext_code.size(address(uniRouterAddress))
                                            call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                 gas gas_remaining wei
                                                args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + sub_1b61e055, token1ToEarnedPath.length, mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)], mem[(32 * _24798) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1004 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                        else:
                                            require mem[(32 * mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680]
                                            if mem[(32 * mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680] * slippageFactor / mem[(32 * mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680] != slippageFactor:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * _24798) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845 len 31]
                                            mem[(32 * _24798) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 744] = 26
                                            mem[(32 * _24798) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 776] = 'SafeMath: division by zero'
                                            mem[(32 * _24798) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 808] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                            mem[(32 * _24798) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 812] = ext_call.return_data[0]
                                            mem[(32 * _24798) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 844] = _27352 * slippageFactor / 1000
                                            mem[(32 * _24798) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 908] = this.address
                                            mem[(32 * _24798) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 940] = block.timestamp + sub_1b61e055
                                            mem[(32 * _24798) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 876] = 160
                                            mem[(32 * _24798) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 972] = token1ToEarnedPath.length
                                            mem[(32 * _24798) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1004 len floor32(token1ToEarnedPath.length)] = mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)]
                                            require ext_code.size(address(uniRouterAddress))
                                            call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                 gas gas_remaining wei
                                                args ext_call.return_data[0], _27352 * slippageFactor / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)], mem[(32 * _24798) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1004 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + sub_1b61e055
                                    else:
                                        mem[0] = 33
                                        mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648] = address(token1ToEarnedPath.field_0)
                                        idx = (32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648
                                        s = 0
                                        while (32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 616 > idx:
                                            mem[idx + 32] = token1ToEarnedPath[s].field_256
                                            idx = idx + 32
                                            s = s + 1
                                            continue 
                                        mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                        mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 652] = ext_call.return_data[0]
                                        mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 684] = 64
                                        mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 716] = token1ToEarnedPath.length
                                        mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 748 len floor32(token1ToEarnedPath.length)] = mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)]
                                        require ext_code.size(address(uniRouterAddress))
                                        staticcall address(uniRouterAddress).getAmountsOut(uint256 arg1, address[] arg2) with:
                                                gas gas_remaining wei
                                               args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)], mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 748 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648
                                        require return_data.size >= 32
                                        _29947 = mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28]
                                        require mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                        require mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                        require mem[mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + (32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648] <= 4294967296 and mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + (32 * mem[mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + (32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648]) + 32 <= return_data.size
                                        mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] = mem[mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + (32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648]
                                        _30030 = mem[_29947 + (32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648]
                                        mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680 len floor32(mem[_29947 + (32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648])] = mem[_29947 + (32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 680 len floor32(mem[_29947 + (32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648])]
                                        mem[64] = (32 * _30030) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 744
                                        mem[(32 * _30030) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680] = 30
                                        mem[(32 * _30030) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 712] = 'SafeMath: subtraction overflow'
                                        if 1 > mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1 < mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648]
                                        _31176 = mem[(32 * mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680]
                                        if not mem[(32 * mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680]:
                                            mem[(32 * _30030) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 744] = 26
                                            mem[(32 * _30030) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 776] = 'SafeMath: division by zero'
                                            mem[(32 * _30030) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 808] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                            mem[(32 * _30030) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 812] = ext_call.return_data[0]
                                            mem[(32 * _30030) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 844] = 0
                                            mem[(32 * _30030) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 908] = this.address
                                            mem[(32 * _30030) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 940] = block.timestamp + sub_1b61e055
                                            mem[(32 * _30030) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 876] = 160
                                            mem[(32 * _30030) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 972] = token1ToEarnedPath.length
                                            mem[(32 * _30030) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1004 len floor32(token1ToEarnedPath.length)] = mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)]
                                            require ext_code.size(address(uniRouterAddress))
                                            call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                 gas gas_remaining wei
                                                args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + sub_1b61e055, token1ToEarnedPath.length, mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)], mem[(32 * _30030) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1004 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                        else:
                                            require mem[(32 * mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680]
                                            if mem[(32 * mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680] * slippageFactor / mem[(32 * mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680] != slippageFactor:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * _30030) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845 len 31]
                                            mem[(32 * _30030) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 744] = 26
                                            mem[(32 * _30030) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 776] = 'SafeMath: division by zero'
                                            mem[(32 * _30030) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 808] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                            mem[(32 * _30030) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 812] = ext_call.return_data[0]
                                            mem[(32 * _30030) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 844] = _31176 * slippageFactor / 1000
                                            mem[(32 * _30030) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 908] = this.address
                                            mem[(32 * _30030) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 940] = block.timestamp + sub_1b61e055
                                            mem[(32 * _30030) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 876] = 160
                                            mem[(32 * _30030) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 972] = token1ToEarnedPath.length
                                            mem[(32 * _30030) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1004 len floor32(token1ToEarnedPath.length)] = mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)]
                                            require ext_code.size(address(uniRouterAddress))
                                            call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                 gas gas_remaining wei
                                                args ext_call.return_data[0], _31176 * slippageFactor / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)], mem[(32 * _30030) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1004 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + sub_1b61e055
                                else:
                                    mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 616] = return_data.size
                                    mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    if not ext_call.success:
                                        if return_data.size > 0:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        revert with 0, 'SafeERC20: low-level call failed'
                                    if return_data.size <= 0:
                                        mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 617] = token1ToEarnedPath.length
                                        if not token1ToEarnedPath.length:
                                            mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 653] = ext_call.return_data[0]
                                            mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 685] = 64
                                            mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 717] = token1ToEarnedPath.length
                                            mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 749 len floor32(token1ToEarnedPath.length)] = mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                            var122001 = floor32(token1ToEarnedPath.length)
                                            require ext_code.size(address(uniRouterAddress))
                                            staticcall address(uniRouterAddress).getAmountsOut(uint256 arg1, address[] arg2) with:
                                                    gas gas_remaining wei
                                                   args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 749 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649
                                            require return_data.size >= 32
                                            _24637 = mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28]
                                            require mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                            require mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                            require mem[mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] <= 4294967296 and mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * mem[mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]) + 32 <= return_data.size
                                            mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = mem[mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]
                                            _24799 = mem[_24637 + (32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]
                                            mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[_24637 + (32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649])] = mem[_24637 + (32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[_24637 + (32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649])]
                                            mem[64] = (32 * _24799) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745
                                            mem[(32 * _24799) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] = 30
                                            mem[(32 * _24799) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 713] = 'SafeMath: subtraction overflow'
                                            if 1 > mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1 < mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]
                                            _27355 = mem[(32 * mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]
                                            if not mem[(32 * mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]:
                                                mem[(32 * _24799) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                mem[(32 * _24799) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                mem[(32 * _24799) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _24799) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                mem[(32 * _24799) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 845] = 0
                                                mem[(32 * _24799) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                mem[(32 * _24799) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + sub_1b61e055
                                                mem[(32 * _24799) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                mem[(32 * _24799) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                mem[(32 * _24799) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + sub_1b61e055, token1ToEarnedPath.length, mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _24799) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                            else:
                                                require mem[(32 * mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]
                                                if mem[(32 * mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] * slippageFactor / mem[(32 * mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] != slippageFactor:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * _24799) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 846 len 31]
                                                mem[(32 * _24799) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                mem[(32 * _24799) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                mem[(32 * _24799) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _24799) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                mem[(32 * _24799) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 845] = _27355 * slippageFactor / 1000
                                                mem[(32 * _24799) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                mem[(32 * _24799) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + sub_1b61e055
                                                mem[(32 * _24799) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                mem[(32 * _24799) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                mem[(32 * _24799) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], _27355 * slippageFactor / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _24799) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + sub_1b61e055
                                        else:
                                            mem[0] = 33
                                            mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649] = address(token1ToEarnedPath.field_0)
                                            idx = (32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649
                                            s = 0
                                            while (32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 617 > idx:
                                                mem[idx + 32] = token1ToEarnedPath[s].field_256
                                                idx = idx + 32
                                                s = s + 1
                                                continue 
                                            mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 653] = ext_call.return_data[0]
                                            mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 685] = 64
                                            mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 717] = token1ToEarnedPath.length
                                            mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 749 len floor32(token1ToEarnedPath.length)] = mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                            require ext_code.size(address(uniRouterAddress))
                                            staticcall address(uniRouterAddress).getAmountsOut(uint256 arg1, address[] arg2) with:
                                                    gas gas_remaining wei
                                                   args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 749 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649
                                            require return_data.size >= 32
                                            _29949 = mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28]
                                            require mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                            require mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                            require mem[mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] <= 4294967296 and mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * mem[mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]) + 32 <= return_data.size
                                            mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = mem[mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]
                                            _30031 = mem[_29949 + (32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]
                                            mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[_29949 + (32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649])] = mem[_29949 + (32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[_29949 + (32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649])]
                                            mem[64] = (32 * _30031) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745
                                            mem[(32 * _30031) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] = 30
                                            mem[(32 * _30031) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 713] = 'SafeMath: subtraction overflow'
                                            if 1 > mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1 < mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]
                                            _31179 = mem[(32 * mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]
                                            if not mem[(32 * mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]:
                                                mem[(32 * _30031) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                mem[(32 * _30031) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                mem[(32 * _30031) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _30031) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                mem[(32 * _30031) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 845] = 0
                                                mem[(32 * _30031) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                mem[(32 * _30031) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + sub_1b61e055
                                                mem[(32 * _30031) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                mem[(32 * _30031) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                mem[(32 * _30031) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + sub_1b61e055, token1ToEarnedPath.length, mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _30031) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                            else:
                                                require mem[(32 * mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]
                                                if mem[(32 * mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] * slippageFactor / mem[(32 * mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] != slippageFactor:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * _30031) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 846 len 31]
                                                mem[(32 * _30031) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                mem[(32 * _30031) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                mem[(32 * _30031) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _30031) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                mem[(32 * _30031) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 845] = _31179 * slippageFactor / 1000
                                                mem[(32 * _30031) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                mem[(32 * _30031) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + sub_1b61e055
                                                mem[(32 * _30031) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                mem[(32 * _30031) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                mem[(32 * _30031) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], _31179 * slippageFactor / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _30031) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + sub_1b61e055
                                    else:
                                        require return_data.size >= 32
                                        if not mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x775361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 727 len 22]
                                        mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 617] = token1ToEarnedPath.length
                                        if not token1ToEarnedPath.length:
                                            mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 653] = ext_call.return_data[0]
                                            mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 685] = 64
                                            mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 717] = token1ToEarnedPath.length
                                            mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 749 len floor32(token1ToEarnedPath.length)] = mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                            var125001 = floor32(token1ToEarnedPath.length)
                                            require ext_code.size(address(uniRouterAddress))
                                            staticcall address(uniRouterAddress).getAmountsOut(uint256 arg1, address[] arg2) with:
                                                    gas gas_remaining wei
                                                   args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 749 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649
                                            require return_data.size >= 32
                                            _24639 = mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28]
                                            require mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                            require mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                            require mem[mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] <= 4294967296 and mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * mem[mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]) + 32 <= return_data.size
                                            mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = mem[mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]
                                            _24800 = mem[_24639 + (32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]
                                            mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[_24639 + (32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649])] = mem[_24639 + (32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[_24639 + (32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649])]
                                            mem[64] = (32 * _24800) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745
                                            mem[(32 * _24800) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] = 30
                                            mem[(32 * _24800) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 713] = 'SafeMath: subtraction overflow'
                                            if 1 > mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1 < mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]
                                            _27358 = mem[(32 * mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]
                                            if not mem[(32 * mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]:
                                                mem[(32 * _24800) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                mem[(32 * _24800) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                mem[(32 * _24800) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _24800) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                mem[(32 * _24800) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 845] = 0
                                                mem[(32 * _24800) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                mem[(32 * _24800) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + sub_1b61e055
                                                mem[(32 * _24800) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                mem[(32 * _24800) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                mem[(32 * _24800) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + sub_1b61e055, token1ToEarnedPath.length, mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _24800) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                            else:
                                                require mem[(32 * mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]
                                                if mem[(32 * mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] * slippageFactor / mem[(32 * mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] != slippageFactor:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * _24800) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 846 len 31]
                                                mem[(32 * _24800) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                mem[(32 * _24800) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                mem[(32 * _24800) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _24800) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                mem[(32 * _24800) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 845] = _27358 * slippageFactor / 1000
                                                mem[(32 * _24800) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                mem[(32 * _24800) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + sub_1b61e055
                                                mem[(32 * _24800) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                mem[(32 * _24800) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                mem[(32 * _24800) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], _27358 * slippageFactor / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _24800) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + sub_1b61e055
                                        else:
                                            mem[0] = 33
                                            mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649] = address(token1ToEarnedPath.field_0)
                                            idx = (32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649
                                            s = 0
                                            while (32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 617 > idx:
                                                mem[idx + 32] = token1ToEarnedPath[s].field_256
                                                idx = idx + 32
                                                s = s + 1
                                                continue 
                                            mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 653] = ext_call.return_data[0]
                                            mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 685] = 64
                                            mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 717] = token1ToEarnedPath.length
                                            mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 749 len floor32(token1ToEarnedPath.length)] = mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                            require ext_code.size(address(uniRouterAddress))
                                            staticcall address(uniRouterAddress).getAmountsOut(uint256 arg1, address[] arg2) with:
                                                    gas gas_remaining wei
                                                   args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 749 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649
                                            require return_data.size >= 32
                                            _29951 = mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28]
                                            require mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                            require mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                            require mem[mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] <= 4294967296 and mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * mem[mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]) + 32 <= return_data.size
                                            mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = mem[mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]
                                            _30032 = mem[_29951 + (32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]
                                            mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[_29951 + (32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649])] = mem[_29951 + (32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[_29951 + (32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649])]
                                            mem[64] = (32 * _30032) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745
                                            mem[(32 * _30032) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] = 30
                                            mem[(32 * _30032) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 713] = 'SafeMath: subtraction overflow'
                                            if 1 > mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1 < mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]
                                            _31182 = mem[(32 * mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]
                                            if not mem[(32 * mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]:
                                                mem[(32 * _30032) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                mem[(32 * _30032) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                mem[(32 * _30032) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _30032) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                mem[(32 * _30032) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 845] = 0
                                                mem[(32 * _30032) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                mem[(32 * _30032) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + sub_1b61e055
                                                mem[(32 * _30032) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                mem[(32 * _30032) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                mem[(32 * _30032) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + sub_1b61e055, token1ToEarnedPath.length, mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _30032) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                            else:
                                                require mem[(32 * mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]
                                                if mem[(32 * mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] * slippageFactor / mem[(32 * mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] != slippageFactor:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * _30032) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 846 len 31]
                                                mem[(32 * _30032) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                mem[(32 * _30032) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                mem[(32 * _30032) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _30032) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                mem[(32 * _30032) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 845] = _31182 * slippageFactor / 1000
                                                mem[(32 * _30032) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                mem[(32 * _30032) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + sub_1b61e055
                                                mem[(32 * _30032) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                mem[(32 * _30032) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                mem[(32 * _30032) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], _31182 * slippageFactor / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _30032) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + sub_1b61e055
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                    else:
                        require mem[(32 * mem[(32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 292] - 1) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 324]
                        if mem[(32 * mem[(32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 292] - 1) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 324] * slippageFactor / mem[(32 * mem[(32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 292] - 1) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 324] != slippageFactor:
                            revert with 0, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 489 len 31]
                        mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 388] = 26
                        mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 420] = 'SafeMath: division by zero'
                        mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token0ToEarnedPath.length)] = mem[292 len floor32(token0ToEarnedPath.length)]
                        require ext_code.size(address(uniRouterAddress))
                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args ext_call.return_data[0], _14556 * slippageFactor / 1000, Array(len=token0ToEarnedPath.length, data=mem[292 len floor32(token0ToEarnedPath.length)], mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + floor32(token0ToEarnedPath.length) + 648 len (32 * token0ToEarnedPath.length) - floor32(token0ToEarnedPath.length)]), address(this.address), block.timestamp + sub_1b61e055
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require ext_code.size(token1Address)
                        staticcall token1Address.0x70a08231 with:
                                gas gas_remaining wei
                               args this.address
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if token1Address != earnedAddress:
                            if ext_call.return_data[0] > 0:
                                require ext_code.size(token1Address)
                                staticcall token1Address.0xdd62ed3e with:
                                        gas gas_remaining wei
                                       args address(this.address), address(uniRouterAddress)
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if 2 * ext_call.return_data[0] < ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 488] = address(uniRouterAddress)
                                mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 520] = 2 * ext_call.return_data[0]
                                mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 452] = 68
                                mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 488 len 28] = Mask(224, 0, stor8)
                                mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 484 len 4] = approve(address arg1, uint256 arg2)
                                mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 552] = 32
                                mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 584] = 'SafeERC20: low-level call failed'
                                if eth.balance(this.address) < 0:
                                    revert with 0, 
                                                32,
                                                38,
                                                0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c,
                                                mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 722 len 26]
                                if ext_code.size(token1Address) <= 0:
                                    revert with 0, 'Address: call to non-contract'
                                mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 616 len 64] = approve(address arg1, uint256 arg2), Mask(224, 0, stor8), uint32(stor8), Mask(224, 31, ext_call.return_data[0]) >> 31
                                mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 708 len 4] = 0
                                mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 680 len 0] = 0
                                call token1Address with:
                                   funct uint32(stor8)
                                     gas gas_remaining wei
                                    args Mask(224, 31, ext_call.return_data[0]) << 225, mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 680 len 4]
                                if not return_data.size:
                                    if not ext_call.success:
                                        revert with approve(address arg1, uint256 arg2), Mask(224, 0, stor8), uint32(stor8), 2 * ext_call.return_data[0]
                                    if not approve(address arg1, uint256 arg2), Mask(224, 0, stor8):
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x775361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 726 len 22]
                                    mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 616] = token1ToEarnedPath.length
                                    if not token1ToEarnedPath.length:
                                        mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                        mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 652] = ext_call.return_data[0]
                                        mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 684] = 64
                                        mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 716] = token1ToEarnedPath.length
                                        mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 748 len floor32(token1ToEarnedPath.length)] = mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)]
                                        require ext_code.size(address(uniRouterAddress))
                                        staticcall address(uniRouterAddress).getAmountsOut(uint256 arg1, address[] arg2) with:
                                                gas gas_remaining wei
                                               args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)], mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 748 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648
                                        require return_data.size >= 32
                                        _24627 = mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28]
                                        require mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                        require mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                        require mem[mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + (32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648] <= 4294967296 and mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + (32 * mem[mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + (32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648]) + 32 <= return_data.size
                                        mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] = mem[mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + (32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648]
                                        _24794 = mem[_24627 + (32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648]
                                        mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680 len floor32(mem[_24627 + (32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648])] = mem[_24627 + (32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 680 len floor32(mem[_24627 + (32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648])]
                                        mem[64] = (32 * _24794) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 744
                                        mem[(32 * _24794) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680] = 30
                                        mem[(32 * _24794) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 712] = 'SafeMath: subtraction overflow'
                                        if 1 > mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1 < mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648]
                                        _27340 = mem[(32 * mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680]
                                        if not mem[(32 * mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680]:
                                            mem[(32 * _24794) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 744] = 26
                                            mem[(32 * _24794) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 776] = 'SafeMath: division by zero'
                                            mem[(32 * _24794) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 808] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                            mem[(32 * _24794) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 812] = ext_call.return_data[0]
                                            mem[(32 * _24794) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 844] = 0
                                            mem[(32 * _24794) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 908] = this.address
                                            mem[(32 * _24794) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 940] = block.timestamp + sub_1b61e055
                                            mem[(32 * _24794) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 876] = 160
                                            mem[(32 * _24794) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 972] = token1ToEarnedPath.length
                                            mem[(32 * _24794) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1004 len floor32(token1ToEarnedPath.length)] = mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)]
                                            require ext_code.size(address(uniRouterAddress))
                                            call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                 gas gas_remaining wei
                                                args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + sub_1b61e055, token1ToEarnedPath.length, mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)], mem[(32 * _24794) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1004 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                        else:
                                            require mem[(32 * mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680]
                                            if mem[(32 * mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680] * slippageFactor / mem[(32 * mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680] != slippageFactor:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * _24794) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845 len 31]
                                            mem[(32 * _24794) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 744] = 26
                                            mem[(32 * _24794) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 776] = 'SafeMath: division by zero'
                                            mem[(32 * _24794) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 808] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                            mem[(32 * _24794) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 812] = ext_call.return_data[0]
                                            mem[(32 * _24794) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 844] = _27340 * slippageFactor / 1000
                                            mem[(32 * _24794) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 908] = this.address
                                            mem[(32 * _24794) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 940] = block.timestamp + sub_1b61e055
                                            mem[(32 * _24794) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 876] = 160
                                            mem[(32 * _24794) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 972] = token1ToEarnedPath.length
                                            mem[(32 * _24794) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1004 len floor32(token1ToEarnedPath.length)] = mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)]
                                            require ext_code.size(address(uniRouterAddress))
                                            call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                 gas gas_remaining wei
                                                args ext_call.return_data[0], _27340 * slippageFactor / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)], mem[(32 * _24794) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1004 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + sub_1b61e055
                                    else:
                                        mem[0] = 33
                                        mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648] = address(token1ToEarnedPath.field_0)
                                        idx = (32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648
                                        s = 0
                                        while (32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 616 > idx:
                                            mem[idx + 32] = token1ToEarnedPath[s].field_256
                                            idx = idx + 32
                                            s = s + 1
                                            continue 
                                        mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                        mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 652] = ext_call.return_data[0]
                                        mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 684] = 64
                                        mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 716] = token1ToEarnedPath.length
                                        mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 748 len floor32(token1ToEarnedPath.length)] = mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)]
                                        require ext_code.size(address(uniRouterAddress))
                                        staticcall address(uniRouterAddress).getAmountsOut(uint256 arg1, address[] arg2) with:
                                                gas gas_remaining wei
                                               args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)], mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 748 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648
                                        require return_data.size >= 32
                                        _29939 = mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28]
                                        require mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                        require mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                        require mem[mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + (32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648] <= 4294967296 and mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + (32 * mem[mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + (32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648]) + 32 <= return_data.size
                                        mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] = mem[mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + (32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648]
                                        _30026 = mem[_29939 + (32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648]
                                        mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680 len floor32(mem[_29939 + (32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648])] = mem[_29939 + (32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 680 len floor32(mem[_29939 + (32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648])]
                                        mem[64] = (32 * _30026) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 744
                                        mem[(32 * _30026) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680] = 30
                                        mem[(32 * _30026) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 712] = 'SafeMath: subtraction overflow'
                                        if 1 > mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1 < mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648]
                                        _31164 = mem[(32 * mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680]
                                        if not mem[(32 * mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680]:
                                            mem[(32 * _30026) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 744] = 26
                                            mem[(32 * _30026) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 776] = 'SafeMath: division by zero'
                                            mem[(32 * _30026) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 808] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                            mem[(32 * _30026) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 812] = ext_call.return_data[0]
                                            mem[(32 * _30026) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 844] = 0
                                            mem[(32 * _30026) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 908] = this.address
                                            mem[(32 * _30026) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 940] = block.timestamp + sub_1b61e055
                                            mem[(32 * _30026) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 876] = 160
                                            mem[(32 * _30026) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 972] = token1ToEarnedPath.length
                                            mem[(32 * _30026) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1004 len floor32(token1ToEarnedPath.length)] = mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)]
                                            require ext_code.size(address(uniRouterAddress))
                                            call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                 gas gas_remaining wei
                                                args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + sub_1b61e055, token1ToEarnedPath.length, mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)], mem[(32 * _30026) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1004 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                        else:
                                            require mem[(32 * mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680]
                                            if mem[(32 * mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680] * slippageFactor / mem[(32 * mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680] != slippageFactor:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * _30026) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845 len 31]
                                            mem[(32 * _30026) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 744] = 26
                                            mem[(32 * _30026) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 776] = 'SafeMath: division by zero'
                                            mem[(32 * _30026) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 808] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                            mem[(32 * _30026) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 812] = ext_call.return_data[0]
                                            mem[(32 * _30026) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 844] = _31164 * slippageFactor / 1000
                                            mem[(32 * _30026) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 908] = this.address
                                            mem[(32 * _30026) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 940] = block.timestamp + sub_1b61e055
                                            mem[(32 * _30026) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 876] = 160
                                            mem[(32 * _30026) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 972] = token1ToEarnedPath.length
                                            mem[(32 * _30026) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1004 len floor32(token1ToEarnedPath.length)] = mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)]
                                            require ext_code.size(address(uniRouterAddress))
                                            call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                 gas gas_remaining wei
                                                args ext_call.return_data[0], _31164 * slippageFactor / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)], mem[(32 * _30026) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1004 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + sub_1b61e055
                                else:
                                    mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 616] = return_data.size
                                    mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    if not ext_call.success:
                                        if return_data.size > 0:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        revert with 0, 'SafeERC20: low-level call failed'
                                    if return_data.size <= 0:
                                        mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 617] = token1ToEarnedPath.length
                                        if not token1ToEarnedPath.length:
                                            mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 653] = ext_call.return_data[0]
                                            mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 685] = 64
                                            mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 717] = token1ToEarnedPath.length
                                            mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 749 len floor32(token1ToEarnedPath.length)] = mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                            require ext_code.size(address(uniRouterAddress))
                                            staticcall address(uniRouterAddress).getAmountsOut(uint256 arg1, address[] arg2) with:
                                                    gas gas_remaining wei
                                                   args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 749 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649
                                            require return_data.size >= 32
                                            _24629 = mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28]
                                            require mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                            require mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                            require mem[mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] <= 4294967296 and mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * mem[mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]) + 32 <= return_data.size
                                            mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = mem[mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]
                                            _24795 = mem[_24629 + (32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]
                                            mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[_24629 + (32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649])] = mem[_24629 + (32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[_24629 + (32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649])]
                                            mem[64] = (32 * _24795) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745
                                            mem[(32 * _24795) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] = 30
                                            mem[(32 * _24795) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 713] = 'SafeMath: subtraction overflow'
                                            if 1 > mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1 < mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]
                                            _27343 = mem[(32 * mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]
                                            if not mem[(32 * mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]:
                                                mem[(32 * _24795) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                mem[(32 * _24795) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                mem[(32 * _24795) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _24795) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                mem[(32 * _24795) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 845] = 0
                                                mem[(32 * _24795) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                mem[(32 * _24795) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + sub_1b61e055
                                                mem[(32 * _24795) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                mem[(32 * _24795) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                mem[(32 * _24795) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + sub_1b61e055, token1ToEarnedPath.length, mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _24795) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                            else:
                                                require mem[(32 * mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]
                                                if mem[(32 * mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] * slippageFactor / mem[(32 * mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] != slippageFactor:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * _24795) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 846 len 31]
                                                mem[(32 * _24795) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                mem[(32 * _24795) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                mem[(32 * _24795) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _24795) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                mem[(32 * _24795) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 845] = _27343 * slippageFactor / 1000
                                                mem[(32 * _24795) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                mem[(32 * _24795) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + sub_1b61e055
                                                mem[(32 * _24795) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                mem[(32 * _24795) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                mem[(32 * _24795) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], _27343 * slippageFactor / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _24795) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + sub_1b61e055
                                        else:
                                            mem[0] = 33
                                            mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649] = address(token1ToEarnedPath.field_0)
                                            idx = (32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649
                                            s = 0
                                            while (32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 617 > idx:
                                                mem[idx + 32] = token1ToEarnedPath[s].field_256
                                                idx = idx + 32
                                                s = s + 1
                                                continue 
                                            mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 653] = ext_call.return_data[0]
                                            mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 685] = 64
                                            mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 717] = token1ToEarnedPath.length
                                            mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 749 len floor32(token1ToEarnedPath.length)] = mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                            require ext_code.size(address(uniRouterAddress))
                                            staticcall address(uniRouterAddress).getAmountsOut(uint256 arg1, address[] arg2) with:
                                                    gas gas_remaining wei
                                                   args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 749 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649
                                            require return_data.size >= 32
                                            _29941 = mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28]
                                            require mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                            require mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                            require mem[mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] <= 4294967296 and mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * mem[mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]) + 32 <= return_data.size
                                            mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = mem[mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]
                                            _30027 = mem[_29941 + (32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]
                                            mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[_29941 + (32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649])] = mem[_29941 + (32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[_29941 + (32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649])]
                                            mem[64] = (32 * _30027) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745
                                            mem[(32 * _30027) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] = 30
                                            mem[(32 * _30027) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 713] = 'SafeMath: subtraction overflow'
                                            if 1 > mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1 < mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]
                                            _31167 = mem[(32 * mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]
                                            if not mem[(32 * mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]:
                                                mem[(32 * _30027) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                mem[(32 * _30027) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                mem[(32 * _30027) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _30027) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                mem[(32 * _30027) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 845] = 0
                                                mem[(32 * _30027) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                mem[(32 * _30027) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + sub_1b61e055
                                                mem[(32 * _30027) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                mem[(32 * _30027) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                mem[(32 * _30027) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + sub_1b61e055, token1ToEarnedPath.length, mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _30027) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                            else:
                                                require mem[(32 * mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]
                                                if mem[(32 * mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] * slippageFactor / mem[(32 * mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] != slippageFactor:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * _30027) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 846 len 31]
                                                mem[(32 * _30027) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                mem[(32 * _30027) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                mem[(32 * _30027) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _30027) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                mem[(32 * _30027) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 845] = _31167 * slippageFactor / 1000
                                                mem[(32 * _30027) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                mem[(32 * _30027) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + sub_1b61e055
                                                mem[(32 * _30027) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                mem[(32 * _30027) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                mem[(32 * _30027) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], _31167 * slippageFactor / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _30027) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + sub_1b61e055
                                    else:
                                        require return_data.size >= 32
                                        if not mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x775361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 727 len 22]
                                        mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 617] = token1ToEarnedPath.length
                                        if not token1ToEarnedPath.length:
                                            mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 653] = ext_call.return_data[0]
                                            mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 685] = 64
                                            mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 717] = token1ToEarnedPath.length
                                            mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 749 len floor32(token1ToEarnedPath.length)] = mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                            require ext_code.size(address(uniRouterAddress))
                                            staticcall address(uniRouterAddress).getAmountsOut(uint256 arg1, address[] arg2) with:
                                                    gas gas_remaining wei
                                                   args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 749 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649
                                            require return_data.size >= 32
                                            _24631 = mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28]
                                            require mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                            require mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                            require mem[mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] <= 4294967296 and mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * mem[mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]) + 32 <= return_data.size
                                            mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = mem[mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]
                                            _24796 = mem[_24631 + (32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]
                                            mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[_24631 + (32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649])] = mem[_24631 + (32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[_24631 + (32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649])]
                                            mem[64] = (32 * _24796) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745
                                            mem[(32 * _24796) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] = 30
                                            mem[(32 * _24796) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 713] = 'SafeMath: subtraction overflow'
                                            if 1 > mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1 < mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]
                                            _27346 = mem[(32 * mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]
                                            if not mem[(32 * mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]:
                                                mem[(32 * _24796) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                mem[(32 * _24796) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                mem[(32 * _24796) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _24796) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                mem[(32 * _24796) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 845] = 0
                                                mem[(32 * _24796) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                mem[(32 * _24796) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + sub_1b61e055
                                                mem[(32 * _24796) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                mem[(32 * _24796) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                mem[(32 * _24796) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + sub_1b61e055, token1ToEarnedPath.length, mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _24796) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                            else:
                                                require mem[(32 * mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]
                                                if mem[(32 * mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] * slippageFactor / mem[(32 * mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] != slippageFactor:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * _24796) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 846 len 31]
                                                mem[(32 * _24796) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                mem[(32 * _24796) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                mem[(32 * _24796) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _24796) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                mem[(32 * _24796) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 845] = _27346 * slippageFactor / 1000
                                                mem[(32 * _24796) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                mem[(32 * _24796) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + sub_1b61e055
                                                mem[(32 * _24796) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                mem[(32 * _24796) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                mem[(32 * _24796) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], _27346 * slippageFactor / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _24796) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + sub_1b61e055
                                        else:
                                            mem[0] = 33
                                            mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649] = address(token1ToEarnedPath.field_0)
                                            idx = (32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649
                                            s = 0
                                            while (32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 617 > idx:
                                                mem[idx + 32] = token1ToEarnedPath[s].field_256
                                                idx = idx + 32
                                                s = s + 1
                                                continue 
                                            mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 653] = ext_call.return_data[0]
                                            mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 685] = 64
                                            mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 717] = token1ToEarnedPath.length
                                            mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 749 len floor32(token1ToEarnedPath.length)] = mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                            require ext_code.size(address(uniRouterAddress))
                                            staticcall address(uniRouterAddress).getAmountsOut(uint256 arg1, address[] arg2) with:
                                                    gas gas_remaining wei
                                                   args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 749 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649
                                            require return_data.size >= 32
                                            _29943 = mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28]
                                            require mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                            require mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                            require mem[mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] <= 4294967296 and mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * mem[mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]) + 32 <= return_data.size
                                            mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = mem[mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]
                                            _30028 = mem[_29943 + (32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]
                                            mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[_29943 + (32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649])] = mem[_29943 + (32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[_29943 + (32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649])]
                                            mem[64] = (32 * _30028) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745
                                            mem[(32 * _30028) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] = 30
                                            mem[(32 * _30028) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 713] = 'SafeMath: subtraction overflow'
                                            if 1 > mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1 < mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]
                                            _31170 = mem[(32 * mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]
                                            if not mem[(32 * mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]:
                                                mem[(32 * _30028) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                mem[(32 * _30028) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                mem[(32 * _30028) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _30028) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                mem[(32 * _30028) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 845] = 0
                                                mem[(32 * _30028) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                mem[(32 * _30028) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + sub_1b61e055
                                                mem[(32 * _30028) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                mem[(32 * _30028) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                mem[(32 * _30028) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + sub_1b61e055, token1ToEarnedPath.length, mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _30028) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                            else:
                                                require mem[(32 * mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]
                                                if mem[(32 * mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] * slippageFactor / mem[(32 * mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] != slippageFactor:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * _30028) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 846 len 31]
                                                mem[(32 * _30028) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                mem[(32 * _30028) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                mem[(32 * _30028) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _30028) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                mem[(32 * _30028) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 845] = _31170 * slippageFactor / 1000
                                                mem[(32 * _30028) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                mem[(32 * _30028) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + sub_1b61e055
                                                mem[(32 * _30028) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                mem[(32 * _30028) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                mem[(32 * _30028) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], _31170 * slippageFactor / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _10738) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _30028) + (32 * _10738) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + sub_1b61e055
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
            else:
                mem[260] = return_data.size
                mem[292 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not ext_call.success:
                    if return_data.size > 0:
                        revert with ext_call.return_data[0 len return_data.size]
                    revert with 0, 'SafeERC20: low-level call failed'
                if return_data.size <= 0:
                    mem[ceil32(return_data.size) + 261] = token0ToEarnedPath.length
                    if not token0ToEarnedPath.length:
                        mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                        mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 297] = ext_call.return_data[0]
                        mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 329] = 64
                        mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 361] = token0ToEarnedPath.length
                        mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 393 len floor32(token0ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token0ToEarnedPath.length)]
                        require ext_code.size(address(uniRouterAddress))
                        staticcall address(uniRouterAddress).getAmountsOut(uint256 arg1, address[] arg2) with:
                                gas gas_remaining wei
                               args ext_call.return_data[0], Array(len=token0ToEarnedPath.length, data=mem[ceil32(return_data.size) + 293 len floor32(token0ToEarnedPath.length)], mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + floor32(token0ToEarnedPath.length) + 393 len (32 * token0ToEarnedPath.length) - floor32(token0ToEarnedPath.length)])
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 293
                        require return_data.size >= 32
                        _4537 = mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28]
                        require mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] <= 4294967296
                        require mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                        require mem[mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293] <= 4294967296 and mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + (32 * mem[mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 293] = mem[mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293]
                        _4563 = mem[_4537 + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293]
                        mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 325 len floor32(mem[_4537 + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293])] = mem[_4537 + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 325 len floor32(mem[_4537 + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293])]
                        mem[64] = (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 389
                        mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 325] = 30
                        mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 357] = 'SafeMath: subtraction overflow'
                        if 1 > mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 293]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1 < mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 293]
                        _6739 = mem[(32 * mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 325]
                        if not mem[(32 * mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 325]:
                            mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 389] = 26
                            mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 421] = 'SafeMath: division by zero'
                            mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token0ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token0ToEarnedPath.length)]
                            require ext_code.size(address(uniRouterAddress))
                            call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + sub_1b61e055, token0ToEarnedPath.length, mem[ceil32(return_data.size) + 293 len floor32(token0ToEarnedPath.length)], mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + floor32(token0ToEarnedPath.length) + 649 len (32 * token0ToEarnedPath.length) - floor32(token0ToEarnedPath.length)]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require ext_code.size(token1Address)
                            staticcall token1Address.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if token1Address != earnedAddress:
                                if ext_call.return_data[0] > 0:
                                    require ext_code.size(token1Address)
                                    staticcall token1Address.0xdd62ed3e with:
                                            gas gas_remaining wei
                                           args address(this.address), address(uniRouterAddress)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if 2 * ext_call.return_data[0] < ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 489] = address(uniRouterAddress)
                                    mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 521] = 2 * ext_call.return_data[0]
                                    mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 453] = 68
                                    mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 489 len 28] = Mask(224, 0, stor8)
                                    mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 485 len 4] = approve(address arg1, uint256 arg2)
                                    mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 553] = 32
                                    mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 585] = 'SafeERC20: low-level call failed'
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 
                                                    32,
                                                    38,
                                                    0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c,
                                                    mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 723 len 26]
                                    if ext_code.size(token1Address) <= 0:
                                        revert with 0, 'Address: call to non-contract'
                                    mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 617 len 64] = approve(address arg1, uint256 arg2), Mask(224, 0, stor8), uint32(stor8), Mask(224, 31, ext_call.return_data[0]) >> 31
                                    mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 709 len 4] = 0
                                    call token1Address with:
                                       funct token0ToEarnedPath.length.field_224
                                         gas gas_remaining wei
                                        args Mask(224, 31, ext_call.return_data[0]) << 225, mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 681 len 4]
                                    if return_data.size:
                                        mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 617] = return_data.size
                                        mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            if return_data.size > 0:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            revert with 0, 'SafeERC20: low-level call failed'
                                        if return_data.size <= 0:
                                            mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 618] = token1ToEarnedPath.length
                                            if not token1ToEarnedPath.length:
                                                mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = ext_call.return_data[0]
                                                mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 64
                                                mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = token1ToEarnedPath.length
                                                mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 750 len floor32(token1ToEarnedPath.length)] = mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                staticcall address(uniRouterAddress).getAmountsOut(uint256 arg1, address[] arg2) with:
                                                        gas gas_remaining wei
                                                       args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 750 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                require return_data.size >= 32
                                                _18045 = mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28]
                                                require mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                require mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                require mem[mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] <= 4294967296 and mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * mem[mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]) + 32 <= return_data.size
                                                mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = mem[mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                _18139 = mem[_18045 + (32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[_18045 + (32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650])] = mem[_18045 + (32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[_18045 + (32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650])]
                                                mem[(32 * _18139) + (32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] = 30
                                                mem[(32 * _18139) + (32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 714] = 'SafeMath: subtraction overflow'
                                                if 1 > mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1 < mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                _21299 = mem[(32 * mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                if not mem[(32 * mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]:
                                                    mem[(32 * _18139) + (32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + sub_1b61e055, token1ToEarnedPath.length, mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _18139) + (32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                else:
                                                    require mem[(32 * mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                    if mem[(32 * mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] * slippageFactor / mem[(32 * mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] != slippageFactor:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * _18139) + (32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 847 len 31]
                                                    mem[(32 * _18139) + (32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], _21299 * slippageFactor / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _18139) + (32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + sub_1b61e055
                                            else:
                                                mem[0] = 33
                                                mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650] = address(token1ToEarnedPath.field_0)
                                                idx = (32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650
                                                s = 0
                                                while (32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 618 > idx:
                                                    mem[idx + 32] = token1ToEarnedPath[s].field_256
                                                    idx = idx + 32
                                                    s = s + 1
                                                    continue 
                                                mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = ext_call.return_data[0]
                                                mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 64
                                                mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = token1ToEarnedPath.length
                                                mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 750 len floor32(token1ToEarnedPath.length)] = mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                staticcall address(uniRouterAddress).getAmountsOut(uint256 arg1, address[] arg2) with:
                                                        gas gas_remaining wei
                                                       args mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654 len (4 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + (-2 * ceil32(return_data.size)) + 96]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                require return_data.size >= 32
                                                _24653 = mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28]
                                                require mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                require mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                require mem[mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] <= 4294967296 and mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * mem[mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]) + 32 <= return_data.size
                                                mem[(32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = mem[mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                _24807 = mem[_24653 + (32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                mem[(32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[_24653 + (32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650])] = mem[_24653 + (32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[_24653 + (32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650])]
                                                mem[64] = (32 * _24807) + (32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 746
                                                mem[(32 * _24807) + (32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] = 30
                                                mem[(32 * _24807) + (32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 714] = 'SafeMath: subtraction overflow'
                                                if 1 > mem[(32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require mem[(32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1 < mem[(32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                _27379 = mem[(32 * mem[(32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                if not mem[(32 * mem[(32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]:
                                                    mem[(32 * _24807) + (32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + sub_1b61e055, token1ToEarnedPath.length, mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _24807) + (32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                else:
                                                    require mem[(32 * mem[(32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                    if mem[(32 * mem[(32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] * slippageFactor / mem[(32 * mem[(32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] != slippageFactor:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * _24807) + (32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 847 len 31]
                                                    mem[(32 * _24807) + (32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], _27379 * slippageFactor / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _24807) + (32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + sub_1b61e055
                                        else:
                                            require return_data.size >= 32
                                            if not mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649]:
                                                revert with 0, 
                                                            32,
                                                            42,
                                                            0x775361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                            mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 728 len 22]
                                            mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 618] = token1ToEarnedPath.length
                                            if not token1ToEarnedPath.length:
                                                mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = ext_call.return_data[0]
                                                mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 64
                                                mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = token1ToEarnedPath.length
                                                mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 750 len floor32(token1ToEarnedPath.length)] = mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                staticcall address(uniRouterAddress).getAmountsOut(uint256 arg1, address[] arg2) with:
                                                        gas gas_remaining wei
                                                       args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 750 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                require return_data.size >= 32
                                                _18047 = mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28]
                                                require mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                require mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                require mem[mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] <= 4294967296 and mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * mem[mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]) + 32 <= return_data.size
                                                mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = mem[mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                _18140 = mem[_18047 + (32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[_18047 + (32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650])] = mem[_18047 + (32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[_18047 + (32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650])]
                                                mem[(32 * _18140) + (32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] = 30
                                                mem[(32 * _18140) + (32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 714] = 'SafeMath: subtraction overflow'
                                                if 1 > mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1 < mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                _21302 = mem[(32 * mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                if not mem[(32 * mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]:
                                                    mem[(32 * _18140) + (32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + sub_1b61e055, token1ToEarnedPath.length, mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _18140) + (32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                else:
                                                    require mem[(32 * mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                    if mem[(32 * mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] * slippageFactor / mem[(32 * mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] != slippageFactor:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * _18140) + (32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 847 len 31]
                                                    mem[(32 * _18140) + (32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], _21302 * slippageFactor / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _18140) + (32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + sub_1b61e055
                                            else:
                                                mem[0] = 33
                                                mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650] = address(token1ToEarnedPath.field_0)
                                                idx = (32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650
                                                s = 0
                                                while (32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 618 > idx:
                                                    mem[idx + 32] = token1ToEarnedPath[s].field_256
                                                    idx = idx + 32
                                                    s = s + 1
                                                    continue 
                                                mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = ext_call.return_data[0]
                                                mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 64
                                                mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = token1ToEarnedPath.length
                                                mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 750 len floor32(token1ToEarnedPath.length)] = mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                staticcall address(uniRouterAddress).getAmountsOut(uint256 arg1, address[] arg2) with:
                                                        gas gas_remaining wei
                                                       args mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654 len (4 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + (-2 * ceil32(return_data.size)) + 96]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                require return_data.size >= 32
                                                _24655 = mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28]
                                                require mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                require mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                require mem[mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] <= 4294967296 and mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * mem[mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]) + 32 <= return_data.size
                                                mem[(32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = mem[mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                _24808 = mem[_24655 + (32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                mem[(32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[_24655 + (32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650])] = mem[_24655 + (32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[_24655 + (32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650])]
                                                mem[64] = (32 * _24808) + (32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 746
                                                mem[(32 * _24808) + (32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] = 30
                                                mem[(32 * _24808) + (32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 714] = 'SafeMath: subtraction overflow'
                                                if 1 > mem[(32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require mem[(32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1 < mem[(32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                _27382 = mem[(32 * mem[(32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                if not mem[(32 * mem[(32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]:
                                                    mem[(32 * _24808) + (32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + sub_1b61e055, token1ToEarnedPath.length, mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _24808) + (32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                else:
                                                    require mem[(32 * mem[(32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                    if mem[(32 * mem[(32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] * slippageFactor / mem[(32 * mem[(32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] != slippageFactor:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * _24808) + (32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 847 len 31]
                                                    mem[(32 * _24808) + (32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], _27382 * slippageFactor / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _24808) + (32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + sub_1b61e055
                                    else:
                                        if not ext_call.success:
                                            revert with approve(address arg1, uint256 arg2), Mask(224, 0, stor8), uint32(stor8), 2 * ext_call.return_data[0]
                                        if not approve(address arg1, uint256 arg2), Mask(224, 0, stor8):
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x775361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 727 len 22]
                                        mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 617] = token1ToEarnedPath.length
                                        if not token1ToEarnedPath.length:
                                            mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 653] = ext_call.return_data[0]
                                            mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 685] = 64
                                            mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 717] = token1ToEarnedPath.length
                                            mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 749 len floor32(token1ToEarnedPath.length)] = mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                            require ext_code.size(address(uniRouterAddress))
                                            staticcall address(uniRouterAddress).getAmountsOut(uint256 arg1, address[] arg2) with:
                                                    gas gas_remaining wei
                                                   args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 749 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649
                                            require return_data.size >= 32
                                            _18043 = mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28]
                                            require mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                            require mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                            require mem[mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] <= 4294967296 and mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * mem[mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]) + 32 <= return_data.size
                                            mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] = mem[mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]
                                            _18138 = mem[_18043 + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]
                                            mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[_18043 + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649])] = mem[_18043 + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[_18043 + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649])]
                                            mem[64] = (32 * _18138) + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745
                                            mem[(32 * _18138) + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] = 30
                                            mem[(32 * _18138) + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 713] = 'SafeMath: subtraction overflow'
                                            if 1 > mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1 < mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649]
                                            _21296 = mem[(32 * mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]
                                            if not mem[(32 * mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]:
                                                mem[(32 * _18138) + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                mem[(32 * _18138) + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                mem[(32 * _18138) + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _18138) + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                mem[(32 * _18138) + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845] = 0
                                                mem[(32 * _18138) + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                mem[(32 * _18138) + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + sub_1b61e055
                                                mem[(32 * _18138) + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                mem[(32 * _18138) + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                mem[(32 * _18138) + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + sub_1b61e055, token1ToEarnedPath.length, mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _18138) + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                            else:
                                                require mem[(32 * mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]
                                                if mem[(32 * mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] * slippageFactor / mem[(32 * mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] != slippageFactor:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * _18138) + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 846 len 31]
                                                mem[(32 * _18138) + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                mem[(32 * _18138) + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                mem[(32 * _18138) + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _18138) + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                mem[(32 * _18138) + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845] = _21296 * slippageFactor / 1000
                                                mem[(32 * _18138) + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                mem[(32 * _18138) + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + sub_1b61e055
                                                mem[(32 * _18138) + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                mem[(32 * _18138) + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                mem[(32 * _18138) + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], _21296 * slippageFactor / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _18138) + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + sub_1b61e055
                                        else:
                                            mem[0] = 33
                                            mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649] = address(token1ToEarnedPath.field_0)
                                            idx = (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649
                                            s = 0
                                            while (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 617 > idx:
                                                mem[idx + 32] = token1ToEarnedPath[s].field_256
                                                idx = idx + 32
                                                s = s + 1
                                                continue 
                                            mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 653] = ext_call.return_data[0]
                                            mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 685] = 64
                                            mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 717] = token1ToEarnedPath.length
                                            mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 749 len floor32(token1ToEarnedPath.length)] = mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                            require ext_code.size(address(uniRouterAddress))
                                            staticcall address(uniRouterAddress).getAmountsOut(uint256 arg1, address[] arg2) with:
                                                    gas gas_remaining wei
                                                   args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 749 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649
                                            require return_data.size >= 32
                                            _24651 = mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28]
                                            require mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                            require mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                            require mem[mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] <= 4294967296 and mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * mem[mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]) + 32 <= return_data.size
                                            mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] = mem[mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]
                                            _24806 = mem[_24651 + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]
                                            mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[_24651 + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649])] = mem[_24651 + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[_24651 + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649])]
                                            mem[64] = (32 * _24806) + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745
                                            mem[(32 * _24806) + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] = 30
                                            mem[(32 * _24806) + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 713] = 'SafeMath: subtraction overflow'
                                            if 1 > mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1 < mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649]
                                            _27376 = mem[(32 * mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]
                                            if not mem[(32 * mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]:
                                                mem[(32 * _24806) + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                mem[(32 * _24806) + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                mem[(32 * _24806) + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _24806) + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                mem[(32 * _24806) + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845] = 0
                                                mem[(32 * _24806) + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                mem[(32 * _24806) + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + sub_1b61e055
                                                mem[(32 * _24806) + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                mem[(32 * _24806) + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                mem[(32 * _24806) + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + sub_1b61e055, token1ToEarnedPath.length, mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _24806) + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                            else:
                                                require mem[(32 * mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]
                                                if mem[(32 * mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] * slippageFactor / mem[(32 * mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] != slippageFactor:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * _24806) + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 846 len 31]
                                                mem[(32 * _24806) + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                mem[(32 * _24806) + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                mem[(32 * _24806) + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _24806) + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                mem[(32 * _24806) + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845] = _27376 * slippageFactor / 1000
                                                mem[(32 * _24806) + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                mem[(32 * _24806) + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + sub_1b61e055
                                                mem[(32 * _24806) + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                mem[(32 * _24806) + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                mem[(32 * _24806) + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], _27376 * slippageFactor / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _24806) + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + sub_1b61e055
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                        else:
                            require mem[(32 * mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 325]
                            if mem[(32 * mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 325] * slippageFactor / mem[(32 * mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 325] != slippageFactor:
                                revert with 0, 
                                            32,
                                            33,
                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 490 len 31]
                            mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 389] = 26
                            mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 421] = 'SafeMath: division by zero'
                            mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token0ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token0ToEarnedPath.length)]
                            require ext_code.size(address(uniRouterAddress))
                            call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0], _6739 * slippageFactor / 1000, Array(len=token0ToEarnedPath.length, data=mem[ceil32(return_data.size) + 293 len floor32(token0ToEarnedPath.length)], mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + floor32(token0ToEarnedPath.length) + 649 len (32 * token0ToEarnedPath.length) - floor32(token0ToEarnedPath.length)]), address(this.address), block.timestamp + sub_1b61e055
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require ext_code.size(token1Address)
                            staticcall token1Address.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if token1Address != earnedAddress:
                                if ext_call.return_data[0] > 0:
                                    require ext_code.size(token1Address)
                                    staticcall token1Address.0xdd62ed3e with:
                                            gas gas_remaining wei
                                           args address(this.address), address(uniRouterAddress)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if 2 * ext_call.return_data[0] < ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 489] = address(uniRouterAddress)
                                    mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 521] = 2 * ext_call.return_data[0]
                                    mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 453] = 68
                                    mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 489 len 28] = Mask(224, 0, stor8)
                                    mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 485 len 4] = approve(address arg1, uint256 arg2)
                                    mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 553] = 32
                                    mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 585] = 'SafeERC20: low-level call failed'
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 
                                                    32,
                                                    38,
                                                    0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c,
                                                    mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 723 len 26]
                                    if ext_code.size(token1Address) <= 0:
                                        revert with 0, 'Address: call to non-contract'
                                    mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 617 len 64] = approve(address arg1, uint256 arg2), Mask(224, 0, stor8), uint32(stor8), Mask(224, 31, ext_call.return_data[0]) >> 31
                                    mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 709 len 4] = 0
                                    mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 681 len 0] = 0
                                    call token1Address with:
                                       funct uint32(stor8)
                                         gas gas_remaining wei
                                        args Mask(224, 31, ext_call.return_data[0]) << 225, mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 681 len 4]
                                    if return_data.size:
                                        mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 617] = return_data.size
                                        mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            if return_data.size > 0:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 618] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 622] = 32
                                            mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 654] = 32
                                            mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 686] = 'SafeERC20: low-level call failed'
                                            revert with memory
                                              from (32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 618
                                               len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                        if return_data.size <= 0:
                                            mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 618] = token1ToEarnedPath.length
                                            if not token1ToEarnedPath.length:
                                                mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = ext_call.return_data[0]
                                                mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 64
                                                mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = token1ToEarnedPath.length
                                                mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 750 len floor32(token1ToEarnedPath.length)] = mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                staticcall address(uniRouterAddress).getAmountsOut(uint256 arg1, address[] arg2) with:
                                                        gas gas_remaining wei
                                                       args mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654 len (4 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + (-2 * ceil32(return_data.size)) + 96]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                require return_data.size >= 32
                                                _18037 = mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28]
                                                require mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                require mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                require mem[mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] <= 4294967296 and mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * mem[mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]) + 32 <= return_data.size
                                                mem[(32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = mem[mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                _18135 = mem[_18037 + (32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                mem[(32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[_18037 + (32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650])] = mem[_18037 + (32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[_18037 + (32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650])]
                                                mem[64] = (32 * _18135) + (32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 746
                                                mem[(32 * _18135) + (32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] = 30
                                                mem[(32 * _18135) + (32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 714] = 'SafeMath: subtraction overflow'
                                                if 1 > mem[(32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require mem[(32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1 < mem[(32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                _21287 = mem[(32 * mem[(32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                if not mem[(32 * mem[(32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]:
                                                    mem[(32 * _18135) + (32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + sub_1b61e055, token1ToEarnedPath.length, mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _18135) + (32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                else:
                                                    require mem[(32 * mem[(32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                    if mem[(32 * mem[(32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] * slippageFactor / mem[(32 * mem[(32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] != slippageFactor:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * _18135) + (32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 847 len 31]
                                                    mem[(32 * _18135) + (32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], _21287 * slippageFactor / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _18135) + (32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + sub_1b61e055
                                            else:
                                                mem[0] = 33
                                                mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650] = address(token1ToEarnedPath.field_0)
                                                idx = (32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650
                                                s = 0
                                                while (32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 618 > idx:
                                                    mem[idx + 32] = token1ToEarnedPath[s].field_256
                                                    idx = idx + 32
                                                    s = s + 1
                                                    continue 
                                                mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = ext_call.return_data[0]
                                                mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 64
                                                mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = token1ToEarnedPath.length
                                                mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 750 len floor32(token1ToEarnedPath.length)] = mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                staticcall address(uniRouterAddress).getAmountsOut(uint256 arg1, address[] arg2) with:
                                                        gas gas_remaining wei
                                                       args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 750 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                require return_data.size >= 32
                                                _24645 = mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28]
                                                require mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                require mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                require mem[mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] <= 4294967296 and mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * mem[mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]) + 32 <= return_data.size
                                                mem[(32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = mem[mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                _24803 = mem[_24645 + (32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                mem[(32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[_24645 + (32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650])] = mem[_24645 + (32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[_24645 + (32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650])]
                                                mem[64] = (32 * _24803) + (32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 746
                                                mem[(32 * _24803) + (32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] = 30
                                                mem[(32 * _24803) + (32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 714] = 'SafeMath: subtraction overflow'
                                                if 1 > mem[(32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require mem[(32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1 < mem[(32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                _27367 = mem[(32 * mem[(32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                if not mem[(32 * mem[(32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]:
                                                    mem[(32 * _24803) + (32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + sub_1b61e055, token1ToEarnedPath.length, mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _24803) + (32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                else:
                                                    require mem[(32 * mem[(32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                    if mem[(32 * mem[(32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] * slippageFactor / mem[(32 * mem[(32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] != slippageFactor:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * _24803) + (32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 847 len 31]
                                                    mem[(32 * _24803) + (32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], _27367 * slippageFactor / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _24803) + (32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + sub_1b61e055
                                        else:
                                            require return_data.size >= 32
                                            if not mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649]:
                                                mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 618] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 622] = 32
                                                mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 654] = 42
                                                mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 686 len 42] = 0x775361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565
                                                revert with memory
                                                  from (32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 618
                                                   len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 132
                                            mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 618] = token1ToEarnedPath.length
                                            if not token1ToEarnedPath.length:
                                                mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = ext_call.return_data[0]
                                                mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 64
                                                mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = token1ToEarnedPath.length
                                                mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 750 len floor32(token1ToEarnedPath.length)] = mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                staticcall address(uniRouterAddress).getAmountsOut(uint256 arg1, address[] arg2) with:
                                                        gas gas_remaining wei
                                                       args mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654 len (4 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + (-2 * ceil32(return_data.size)) + 96]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                require return_data.size >= 32
                                                _18039 = mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28]
                                                require mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                require mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                require mem[mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] <= 4294967296 and mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * mem[mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]) + 32 <= return_data.size
                                                mem[(32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = mem[mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                _18136 = mem[_18039 + (32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                mem[(32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[_18039 + (32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650])] = mem[_18039 + (32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[_18039 + (32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650])]
                                                mem[64] = (32 * _18136) + (32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 746
                                                mem[(32 * _18136) + (32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] = 30
                                                mem[(32 * _18136) + (32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 714] = 'SafeMath: subtraction overflow'
                                                if 1 > mem[(32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require mem[(32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1 < mem[(32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                _21290 = mem[(32 * mem[(32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                if not mem[(32 * mem[(32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]:
                                                    mem[(32 * _18136) + (32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + sub_1b61e055, token1ToEarnedPath.length, mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _18136) + (32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                else:
                                                    require mem[(32 * mem[(32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                    if mem[(32 * mem[(32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] * slippageFactor / mem[(32 * mem[(32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] != slippageFactor:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * _18136) + (32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 847 len 31]
                                                    mem[(32 * _18136) + (32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], _21290 * slippageFactor / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _18136) + (32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + sub_1b61e055
                                            else:
                                                mem[0] = 33
                                                mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650] = address(token1ToEarnedPath.field_0)
                                                idx = (32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650
                                                s = 0
                                                while (32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 618 > idx:
                                                    mem[idx + 32] = token1ToEarnedPath[s].field_256
                                                    idx = idx + 32
                                                    s = s + 1
                                                    continue 
                                                mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = ext_call.return_data[0]
                                                mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 64
                                                mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = token1ToEarnedPath.length
                                                mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 750 len floor32(token1ToEarnedPath.length)] = mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                staticcall address(uniRouterAddress).getAmountsOut(uint256 arg1, address[] arg2) with:
                                                        gas gas_remaining wei
                                                       args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 750 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                require return_data.size >= 32
                                                _24647 = mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28]
                                                require mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                require mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                require mem[mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] <= 4294967296 and mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * mem[mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]) + 32 <= return_data.size
                                                mem[(32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = mem[mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                _24804 = mem[_24647 + (32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                mem[(32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[_24647 + (32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650])] = mem[_24647 + (32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[_24647 + (32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650])]
                                                mem[64] = (32 * _24804) + (32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 746
                                                mem[(32 * _24804) + (32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] = 30
                                                mem[(32 * _24804) + (32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 714] = 'SafeMath: subtraction overflow'
                                                if 1 > mem[(32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require mem[(32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1 < mem[(32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                _27370 = mem[(32 * mem[(32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                if not mem[(32 * mem[(32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]:
                                                    mem[(32 * _24804) + (32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + sub_1b61e055, token1ToEarnedPath.length, mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _24804) + (32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                else:
                                                    require mem[(32 * mem[(32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                    if mem[(32 * mem[(32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] * slippageFactor / mem[(32 * mem[(32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] != slippageFactor:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * _24804) + (32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 847 len 31]
                                                    mem[(32 * _24804) + (32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], _27370 * slippageFactor / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _4563) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _24804) + (32 * _4563) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + sub_1b61e055
                                    else:
                                        if not ext_call.success:
                                            revert with approve(address arg1, uint256 arg2), Mask(224, 0, stor8), uint32(stor8), 2 * ext_call.return_data[0]
                                        if not approve(address arg1, uint256 arg2), Mask(224, 0, stor8):
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x775361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 727 len 22]
                                        mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 617] = token1ToEarnedPath.length
                                        if not token1ToEarnedPath.length:
                                            mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 653] = ext_call.return_data[0]
                                            mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 685] = 64
                                            mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 717] = token1ToEarnedPath.length
                                            mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 749 len floor32(token1ToEarnedPath.length)] = mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                            require ext_code.size(address(uniRouterAddress))
                                            staticcall address(uniRouterAddress).getAmountsOut(uint256 arg1, address[] arg2) with:
                                                    gas gas_remaining wei
                                                   args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 749 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649
                                            require return_data.size >= 32
                                            _18035 = mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28]
                                            require mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                            require mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                            require mem[mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] <= 4294967296 and mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * mem[mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]) + 32 <= return_data.size
                                            mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] = mem[mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]
                                            _18134 = mem[_18035 + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]
                                            mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[_18035 + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649])] = mem[_18035 + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[_18035 + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649])]
                                            mem[64] = (32 * _18134) + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745
                                            mem[(32 * _18134) + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] = 30
                                            mem[(32 * _18134) + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 713] = 'SafeMath: subtraction overflow'
                                            if 1 > mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1 < mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649]
                                            _21284 = mem[(32 * mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]
                                            if not mem[(32 * mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]:
                                                mem[(32 * _18134) + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                mem[(32 * _18134) + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                mem[(32 * _18134) + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _18134) + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                mem[(32 * _18134) + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845] = 0
                                                mem[(32 * _18134) + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                mem[(32 * _18134) + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + sub_1b61e055
                                                mem[(32 * _18134) + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                mem[(32 * _18134) + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                mem[(32 * _18134) + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + sub_1b61e055, token1ToEarnedPath.length, mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _18134) + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                            else:
                                                require mem[(32 * mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]
                                                if mem[(32 * mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] * slippageFactor / mem[(32 * mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] != slippageFactor:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * _18134) + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 846 len 31]
                                                mem[(32 * _18134) + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                mem[(32 * _18134) + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                mem[(32 * _18134) + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _18134) + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                mem[(32 * _18134) + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845] = _21284 * slippageFactor / 1000
                                                mem[(32 * _18134) + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                mem[(32 * _18134) + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + sub_1b61e055
                                                mem[(32 * _18134) + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                mem[(32 * _18134) + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                mem[(32 * _18134) + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], _21284 * slippageFactor / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _18134) + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + sub_1b61e055
                                        else:
                                            mem[0] = 33
                                            mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649] = address(token1ToEarnedPath.field_0)
                                            idx = (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649
                                            s = 0
                                            while (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 617 > idx:
                                                mem[idx + 32] = token1ToEarnedPath[s].field_256
                                                idx = idx + 32
                                                s = s + 1
                                                continue 
                                            mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 653] = ext_call.return_data[0]
                                            mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 685] = 64
                                            mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 717] = token1ToEarnedPath.length
                                            mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 749 len floor32(token1ToEarnedPath.length)] = mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                            require ext_code.size(address(uniRouterAddress))
                                            staticcall address(uniRouterAddress).getAmountsOut(uint256 arg1, address[] arg2) with:
                                                    gas gas_remaining wei
                                                   args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 749 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649
                                            require return_data.size >= 32
                                            _24643 = mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28]
                                            require mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                            require mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                            require mem[mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] <= 4294967296 and mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * mem[mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]) + 32 <= return_data.size
                                            mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] = mem[mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]
                                            _24802 = mem[_24643 + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]
                                            mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[_24643 + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649])] = mem[_24643 + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[_24643 + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649])]
                                            mem[64] = (32 * _24802) + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745
                                            mem[(32 * _24802) + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] = 30
                                            mem[(32 * _24802) + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 713] = 'SafeMath: subtraction overflow'
                                            if 1 > mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1 < mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649]
                                            _27364 = mem[(32 * mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]
                                            if not mem[(32 * mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]:
                                                mem[(32 * _24802) + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                mem[(32 * _24802) + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                mem[(32 * _24802) + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _24802) + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                mem[(32 * _24802) + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845] = 0
                                                mem[(32 * _24802) + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                mem[(32 * _24802) + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + sub_1b61e055
                                                mem[(32 * _24802) + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                mem[(32 * _24802) + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                mem[(32 * _24802) + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + sub_1b61e055, token1ToEarnedPath.length, mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _24802) + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                            else:
                                                require mem[(32 * mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]
                                                if mem[(32 * mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] * slippageFactor / mem[(32 * mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] != slippageFactor:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * _24802) + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 846 len 31]
                                                mem[(32 * _24802) + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                mem[(32 * _24802) + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                mem[(32 * _24802) + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _24802) + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                mem[(32 * _24802) + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845] = _27364 * slippageFactor / 1000
                                                mem[(32 * _24802) + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                mem[(32 * _24802) + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + sub_1b61e055
                                                mem[(32 * _24802) + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                mem[(32 * _24802) + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                mem[(32 * _24802) + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], _27364 * slippageFactor / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _24802) + (32 * _4563) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + sub_1b61e055
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                    else:
                        mem[0] = 32
                        mem[ceil32(return_data.size) + 293] = address(token0ToEarnedPath.field_0)
                        idx = ceil32(return_data.size) + 293
                        s = 0
                        while ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 261 > idx:
                            mem[idx + 32] = token0ToEarnedPath[s].field_256
                            idx = idx + 32
                            s = s + 1
                            continue 
                        mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                        mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 297] = ext_call.return_data[0]
                        mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 329] = 64
                        mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 361] = token0ToEarnedPath.length
                        mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 393 len floor32(token0ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token0ToEarnedPath.length)]
                        require ext_code.size(address(uniRouterAddress))
                        staticcall address(uniRouterAddress).getAmountsOut(uint256 arg1, address[] arg2) with:
                                gas gas_remaining wei
                               args ext_call.return_data[0], Array(len=token0ToEarnedPath.length, data=mem[ceil32(return_data.size) + 293 len floor32(token0ToEarnedPath.length)], mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + floor32(token0ToEarnedPath.length) + 393 len (32 * token0ToEarnedPath.length) - floor32(token0ToEarnedPath.length)])
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 293
                        require return_data.size >= 32
                        _10693 = mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28]
                        require mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] <= 4294967296
                        require mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                        require mem[mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293] <= 4294967296 and mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + (32 * mem[mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 293] = mem[mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293]
                        _10741 = mem[_10693 + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293]
                        mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 325 len floor32(mem[_10693 + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293])] = mem[_10693 + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 325 len floor32(mem[_10693 + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293])]
                        mem[64] = (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 389
                        mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 325] = 30
                        mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 357] = 'SafeMath: subtraction overflow'
                        if 1 > mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 293]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1 < mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 293]
                        _14559 = mem[(32 * mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 325]
                        if not mem[(32 * mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 325]:
                            mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 389] = 26
                            mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 421] = 'SafeMath: division by zero'
                            mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token0ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token0ToEarnedPath.length)]
                            require ext_code.size(address(uniRouterAddress))
                            call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + sub_1b61e055, token0ToEarnedPath.length, mem[ceil32(return_data.size) + 293 len floor32(token0ToEarnedPath.length)], mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + floor32(token0ToEarnedPath.length) + 649 len (32 * token0ToEarnedPath.length) - floor32(token0ToEarnedPath.length)]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require ext_code.size(token1Address)
                            staticcall token1Address.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if token1Address != earnedAddress:
                                if ext_call.return_data[0] > 0:
                                    require ext_code.size(token1Address)
                                    staticcall token1Address.0xdd62ed3e with:
                                            gas gas_remaining wei
                                           args address(this.address), address(uniRouterAddress)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if 2 * ext_call.return_data[0] < ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 489] = address(uniRouterAddress)
                                    mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 521] = 2 * ext_call.return_data[0]
                                    mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 453] = 68
                                    mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 489 len 28] = Mask(224, 0, stor8)
                                    mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 485 len 4] = approve(address arg1, uint256 arg2)
                                    mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 553] = 32
                                    mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 585] = 'SafeERC20: low-level call failed'
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 
                                                    32,
                                                    38,
                                                    0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c,
                                                    mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 723 len 26]
                                    if ext_code.size(token1Address) <= 0:
                                        revert with 0, 'Address: call to non-contract'
                                    mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 617 len 64] = approve(address arg1, uint256 arg2), Mask(224, 0, stor8), uint32(stor8), Mask(224, 31, ext_call.return_data[0]) >> 31
                                    mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 709 len 4] = 0
                                    call token1Address with:
                                       funct token0ToEarnedPath.length.field_224
                                         gas gas_remaining wei
                                        args Mask(224, 31, ext_call.return_data[0]) << 225, mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 681 len 4]
                                    if return_data.size:
                                        mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 617] = return_data.size
                                        mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            if return_data.size > 0:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            revert with 0, 'SafeERC20: low-level call failed'
                                        if return_data.size <= 0:
                                            mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 618] = token1ToEarnedPath.length
                                            if not token1ToEarnedPath.length:
                                                mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = ext_call.return_data[0]
                                                mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 64
                                                mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = token1ToEarnedPath.length
                                                mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 750 len floor32(token1ToEarnedPath.length)] = mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                var119001 = floor32(token1ToEarnedPath.length)
                                                require ext_code.size(address(uniRouterAddress))
                                                staticcall address(uniRouterAddress).getAmountsOut(uint256 arg1, address[] arg2) with:
                                                        gas gas_remaining wei
                                                       args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 750 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                require return_data.size >= 32
                                                _24669 = mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28]
                                                require mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                require mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                require mem[mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] <= 4294967296 and mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * mem[mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]) + 32 <= return_data.size
                                                mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = mem[mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                _24815 = mem[_24669 + (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[_24669 + (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650])] = mem[_24669 + (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[_24669 + (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650])]
                                                mem[(32 * _24815) + (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] = 30
                                                mem[(32 * _24815) + (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 714] = 'SafeMath: subtraction overflow'
                                                if 1 > mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1 < mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                _27403 = mem[(32 * mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                if not mem[(32 * mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]:
                                                    mem[(32 * _24815) + (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + sub_1b61e055, token1ToEarnedPath.length, mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _24815) + (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                else:
                                                    require mem[(32 * mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                    if mem[(32 * mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] * slippageFactor / mem[(32 * mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] != slippageFactor:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * _24815) + (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 847 len 31]
                                                    mem[(32 * _24815) + (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], _27403 * slippageFactor / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _24815) + (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + sub_1b61e055
                                            else:
                                                mem[0] = 33
                                                mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650] = address(token1ToEarnedPath.field_0)
                                                idx = (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650
                                                s = 0
                                                while (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 618 > idx:
                                                    mem[idx + 32] = token1ToEarnedPath[s].field_256
                                                    idx = idx + 32
                                                    s = s + 1
                                                    continue 
                                                mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = ext_call.return_data[0]
                                                mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 64
                                                mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = token1ToEarnedPath.length
                                                mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 750 len floor32(token1ToEarnedPath.length)] = mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                staticcall address(uniRouterAddress).getAmountsOut(uint256 arg1, address[] arg2) with:
                                                        gas gas_remaining wei
                                                       args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 750 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                require return_data.size >= 32
                                                _29965 = mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28]
                                                require mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                require mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                require mem[mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] <= 4294967296 and mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * mem[mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]) + 32 <= return_data.size
                                                mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = mem[mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                _30039 = mem[_29965 + (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[_29965 + (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650])] = mem[_29965 + (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[_29965 + (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650])]
                                                mem[(32 * _30039) + (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] = 30
                                                mem[(32 * _30039) + (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 714] = 'SafeMath: subtraction overflow'
                                                if 1 > mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1 < mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                _31203 = mem[(32 * mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                if not mem[(32 * mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]:
                                                    mem[(32 * _30039) + (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + sub_1b61e055, token1ToEarnedPath.length, mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _30039) + (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                else:
                                                    require mem[(32 * mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                    if mem[(32 * mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] * slippageFactor / mem[(32 * mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] != slippageFactor:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * _30039) + (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 847 len 31]
                                                    mem[(32 * _30039) + (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], _31203 * slippageFactor / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _30039) + (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + sub_1b61e055
                                        else:
                                            require return_data.size >= 32
                                            if not mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649]:
                                                revert with 0, 
                                                            32,
                                                            42,
                                                            0x775361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                            mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 728 len 22]
                                            mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 618] = token1ToEarnedPath.length
                                            if not token1ToEarnedPath.length:
                                                mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = ext_call.return_data[0]
                                                mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 64
                                                mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = token1ToEarnedPath.length
                                                mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 750 len floor32(token1ToEarnedPath.length)] = mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                var122001 = floor32(token1ToEarnedPath.length)
                                                require ext_code.size(address(uniRouterAddress))
                                                staticcall address(uniRouterAddress).getAmountsOut(uint256 arg1, address[] arg2) with:
                                                        gas gas_remaining wei
                                                       args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 750 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                require return_data.size >= 32
                                                _24671 = mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28]
                                                require mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                require mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                require mem[mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] <= 4294967296 and mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * mem[mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]) + 32 <= return_data.size
                                                mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = mem[mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                _24816 = mem[_24671 + (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[_24671 + (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650])] = mem[_24671 + (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[_24671 + (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650])]
                                                mem[(32 * _24816) + (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] = 30
                                                mem[(32 * _24816) + (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 714] = 'SafeMath: subtraction overflow'
                                                if 1 > mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1 < mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                _27406 = mem[(32 * mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                if not mem[(32 * mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]:
                                                    mem[(32 * _24816) + (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + sub_1b61e055, token1ToEarnedPath.length, mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _24816) + (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                else:
                                                    require mem[(32 * mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                    if mem[(32 * mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] * slippageFactor / mem[(32 * mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] != slippageFactor:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * _24816) + (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 847 len 31]
                                                    mem[(32 * _24816) + (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], _27406 * slippageFactor / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _24816) + (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + sub_1b61e055
                                            else:
                                                mem[0] = 33
                                                mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650] = address(token1ToEarnedPath.field_0)
                                                idx = (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650
                                                s = 0
                                                while (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 618 > idx:
                                                    mem[idx + 32] = token1ToEarnedPath[s].field_256
                                                    idx = idx + 32
                                                    s = s + 1
                                                    continue 
                                                mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = ext_call.return_data[0]
                                                mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 64
                                                mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = token1ToEarnedPath.length
                                                mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 750 len floor32(token1ToEarnedPath.length)] = mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                staticcall address(uniRouterAddress).getAmountsOut(uint256 arg1, address[] arg2) with:
                                                        gas gas_remaining wei
                                                       args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 750 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                require return_data.size >= 32
                                                _29967 = mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28]
                                                require mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                require mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                require mem[mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] <= 4294967296 and mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * mem[mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]) + 32 <= return_data.size
                                                mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = mem[mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                _30040 = mem[_29967 + (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[_29967 + (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650])] = mem[_29967 + (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[_29967 + (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650])]
                                                mem[(32 * _30040) + (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] = 30
                                                mem[(32 * _30040) + (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 714] = 'SafeMath: subtraction overflow'
                                                if 1 > mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1 < mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                _31206 = mem[(32 * mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                if not mem[(32 * mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]:
                                                    mem[(32 * _30040) + (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + sub_1b61e055, token1ToEarnedPath.length, mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _30040) + (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                else:
                                                    require mem[(32 * mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                    if mem[(32 * mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] * slippageFactor / mem[(32 * mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] != slippageFactor:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * _30040) + (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 847 len 31]
                                                    mem[(32 * _30040) + (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], _31206 * slippageFactor / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _30040) + (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + sub_1b61e055
                                    else:
                                        if not ext_call.success:
                                            revert with approve(address arg1, uint256 arg2), Mask(224, 0, stor8), uint32(stor8), 2 * ext_call.return_data[0]
                                        if not approve(address arg1, uint256 arg2), Mask(224, 0, stor8):
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x775361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 727 len 22]
                                        mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 617] = token1ToEarnedPath.length
                                        if not token1ToEarnedPath.length:
                                            mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 653] = ext_call.return_data[0]
                                            mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 685] = 64
                                            mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 717] = token1ToEarnedPath.length
                                            mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 749 len floor32(token1ToEarnedPath.length)] = mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                            var122001 = floor32(token1ToEarnedPath.length)
                                            require ext_code.size(address(uniRouterAddress))
                                            staticcall address(uniRouterAddress).getAmountsOut(uint256 arg1, address[] arg2) with:
                                                    gas gas_remaining wei
                                                   args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 749 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649
                                            require return_data.size >= 32
                                            _24667 = mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28]
                                            require mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                            require mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                            require mem[mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] <= 4294967296 and mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * mem[mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]) + 32 <= return_data.size
                                            mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] = mem[mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]
                                            _24814 = mem[_24667 + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]
                                            mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[_24667 + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649])] = mem[_24667 + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[_24667 + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649])]
                                            mem[(32 * _24814) + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] = 30
                                            mem[(32 * _24814) + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 713] = 'SafeMath: subtraction overflow'
                                            if 1 > mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1 < mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649]
                                            _27400 = mem[(32 * mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]
                                            if not mem[(32 * mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]:
                                                mem[(32 * _24814) + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                mem[(32 * _24814) + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                mem[(32 * _24814) + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _24814) + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                mem[(32 * _24814) + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845] = 0
                                                mem[(32 * _24814) + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                mem[(32 * _24814) + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + sub_1b61e055
                                                mem[(32 * _24814) + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                mem[(32 * _24814) + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                mem[(32 * _24814) + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + sub_1b61e055, token1ToEarnedPath.length, mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _24814) + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                            else:
                                                require mem[(32 * mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]
                                                if mem[(32 * mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] * slippageFactor / mem[(32 * mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] != slippageFactor:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * _24814) + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 846 len 31]
                                                mem[(32 * _24814) + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                mem[(32 * _24814) + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                mem[(32 * _24814) + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _24814) + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                mem[(32 * _24814) + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845] = _27400 * slippageFactor / 1000
                                                mem[(32 * _24814) + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                mem[(32 * _24814) + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + sub_1b61e055
                                                mem[(32 * _24814) + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                mem[(32 * _24814) + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                mem[(32 * _24814) + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], _27400 * slippageFactor / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _24814) + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + sub_1b61e055
                                        else:
                                            mem[0] = 33
                                            mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649] = address(token1ToEarnedPath.field_0)
                                            idx = (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649
                                            s = 0
                                            while (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 617 > idx:
                                                mem[idx + 32] = token1ToEarnedPath[s].field_256
                                                idx = idx + 32
                                                s = s + 1
                                                continue 
                                            mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 653] = ext_call.return_data[0]
                                            mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 685] = 64
                                            mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 717] = token1ToEarnedPath.length
                                            mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 749 len floor32(token1ToEarnedPath.length)] = mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                            require ext_code.size(address(uniRouterAddress))
                                            staticcall address(uniRouterAddress).getAmountsOut(uint256 arg1, address[] arg2) with:
                                                    gas gas_remaining wei
                                                   args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 749 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649
                                            require return_data.size >= 32
                                            _29963 = mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28]
                                            require mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                            require mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                            require mem[mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] <= 4294967296 and mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * mem[mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]) + 32 <= return_data.size
                                            mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] = mem[mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]
                                            _30038 = mem[_29963 + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]
                                            mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[_29963 + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649])] = mem[_29963 + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[_29963 + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649])]
                                            mem[(32 * _30038) + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] = 30
                                            mem[(32 * _30038) + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 713] = 'SafeMath: subtraction overflow'
                                            if 1 > mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1 < mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649]
                                            _31200 = mem[(32 * mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]
                                            if not mem[(32 * mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]:
                                                mem[(32 * _30038) + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                mem[(32 * _30038) + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                mem[(32 * _30038) + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _30038) + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                mem[(32 * _30038) + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845] = 0
                                                mem[(32 * _30038) + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                mem[(32 * _30038) + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + sub_1b61e055
                                                mem[(32 * _30038) + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                mem[(32 * _30038) + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                mem[(32 * _30038) + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + sub_1b61e055, token1ToEarnedPath.length, mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _30038) + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                            else:
                                                require mem[(32 * mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]
                                                if mem[(32 * mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] * slippageFactor / mem[(32 * mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] != slippageFactor:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * _30038) + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 846 len 31]
                                                mem[(32 * _30038) + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                mem[(32 * _30038) + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                mem[(32 * _30038) + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _30038) + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                mem[(32 * _30038) + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845] = _31200 * slippageFactor / 1000
                                                mem[(32 * _30038) + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                mem[(32 * _30038) + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + sub_1b61e055
                                                mem[(32 * _30038) + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                mem[(32 * _30038) + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                mem[(32 * _30038) + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], _31200 * slippageFactor / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _30038) + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + sub_1b61e055
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                        else:
                            require mem[(32 * mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 325]
                            if mem[(32 * mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 325] * slippageFactor / mem[(32 * mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 325] != slippageFactor:
                                revert with 0, 
                                            32,
                                            33,
                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 490 len 31]
                            mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 389] = 26
                            mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 421] = 'SafeMath: division by zero'
                            mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token0ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token0ToEarnedPath.length)]
                            require ext_code.size(address(uniRouterAddress))
                            call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0], _14559 * slippageFactor / 1000, Array(len=token0ToEarnedPath.length, data=mem[ceil32(return_data.size) + 293 len floor32(token0ToEarnedPath.length)], mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + floor32(token0ToEarnedPath.length) + 649 len (32 * token0ToEarnedPath.length) - floor32(token0ToEarnedPath.length)]), address(this.address), block.timestamp + sub_1b61e055
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require ext_code.size(token1Address)
                            staticcall token1Address.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if token1Address != earnedAddress:
                                if ext_call.return_data[0] > 0:
                                    require ext_code.size(token1Address)
                                    staticcall token1Address.0xdd62ed3e with:
                                            gas gas_remaining wei
                                           args address(this.address), address(uniRouterAddress)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if 2 * ext_call.return_data[0] < ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 489] = address(uniRouterAddress)
                                    mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 521] = 2 * ext_call.return_data[0]
                                    mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 453] = 68
                                    mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 489 len 28] = Mask(224, 0, stor8)
                                    mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 485 len 4] = approve(address arg1, uint256 arg2)
                                    mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 553] = 32
                                    mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 585] = 'SafeERC20: low-level call failed'
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 
                                                    32,
                                                    38,
                                                    0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c,
                                                    mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 723 len 26]
                                    if ext_code.size(token1Address) <= 0:
                                        revert with 0, 'Address: call to non-contract'
                                    mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 617 len 64] = approve(address arg1, uint256 arg2), Mask(224, 0, stor8), uint32(stor8), Mask(224, 31, ext_call.return_data[0]) >> 31
                                    mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 709 len 4] = 0
                                    mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 681 len 0] = 0
                                    call token1Address with:
                                       funct uint32(stor8)
                                         gas gas_remaining wei
                                        args Mask(224, 31, ext_call.return_data[0]) << 225, mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 681 len 4]
                                    if return_data.size:
                                        mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 617] = return_data.size
                                        mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            if return_data.size > 0:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            revert with 0, 'SafeERC20: low-level call failed'
                                        if return_data.size <= 0:
                                            mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 618] = token1ToEarnedPath.length
                                            if not token1ToEarnedPath.length:
                                                mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = ext_call.return_data[0]
                                                mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 64
                                                mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = token1ToEarnedPath.length
                                                mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 750 len floor32(token1ToEarnedPath.length)] = mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                staticcall address(uniRouterAddress).getAmountsOut(uint256 arg1, address[] arg2) with:
                                                        gas gas_remaining wei
                                                       args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 750 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                require return_data.size >= 32
                                                _24661 = mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28]
                                                require mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                require mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                require mem[mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] <= 4294967296 and mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * mem[mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]) + 32 <= return_data.size
                                                mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = mem[mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                _24811 = mem[_24661 + (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[_24661 + (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650])] = mem[_24661 + (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[_24661 + (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650])]
                                                mem[(32 * _24811) + (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] = 30
                                                mem[(32 * _24811) + (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 714] = 'SafeMath: subtraction overflow'
                                                if 1 > mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1 < mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                _27391 = mem[(32 * mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                if not mem[(32 * mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]:
                                                    mem[(32 * _24811) + (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + sub_1b61e055, token1ToEarnedPath.length, mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _24811) + (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                else:
                                                    require mem[(32 * mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                    if mem[(32 * mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] * slippageFactor / mem[(32 * mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] != slippageFactor:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * _24811) + (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 847 len 31]
                                                    mem[(32 * _24811) + (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], _27391 * slippageFactor / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _24811) + (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + sub_1b61e055
                                            else:
                                                mem[0] = 33
                                                mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650] = address(token1ToEarnedPath.field_0)
                                                idx = (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650
                                                s = 0
                                                while (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 618 > idx:
                                                    mem[idx + 32] = token1ToEarnedPath[s].field_256
                                                    idx = idx + 32
                                                    s = s + 1
                                                    continue 
                                                mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = ext_call.return_data[0]
                                                mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 64
                                                mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = token1ToEarnedPath.length
                                                mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 750 len floor32(token1ToEarnedPath.length)] = mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                staticcall address(uniRouterAddress).getAmountsOut(uint256 arg1, address[] arg2) with:
                                                        gas gas_remaining wei
                                                       args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 750 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                require return_data.size >= 32
                                                _29957 = mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28]
                                                require mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                require mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                require mem[mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] <= 4294967296 and mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * mem[mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]) + 32 <= return_data.size
                                                mem[(32 * _10741) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = mem[mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                _30035 = mem[_29957 + (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                mem[(32 * _10741) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[_29957 + (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650])] = mem[_29957 + (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[_29957 + (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650])]
                                                mem[64] = (32 * _30035) + (32 * _10741) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 746
                                                mem[(32 * _30035) + (32 * _10741) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] = 30
                                                mem[(32 * _30035) + (32 * _10741) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 714] = 'SafeMath: subtraction overflow'
                                                if 1 > mem[(32 * _10741) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require mem[(32 * _10741) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1 < mem[(32 * _10741) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                _31191 = mem[(32 * mem[(32 * _10741) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _10741) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                if not mem[(32 * mem[(32 * _10741) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _10741) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]:
                                                    mem[(32 * _30035) + (32 * _10741) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + sub_1b61e055, token1ToEarnedPath.length, mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _30035) + (32 * _10741) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                else:
                                                    require mem[(32 * mem[(32 * _10741) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _10741) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                    if mem[(32 * mem[(32 * _10741) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _10741) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] * slippageFactor / mem[(32 * mem[(32 * _10741) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _10741) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] != slippageFactor:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * _30035) + (32 * _10741) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 847 len 31]
                                                    mem[(32 * _30035) + (32 * _10741) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], _31191 * slippageFactor / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _30035) + (32 * _10741) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + sub_1b61e055
                                        else:
                                            require return_data.size >= 32
                                            if not mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649]:
                                                revert with 0, 
                                                            32,
                                                            42,
                                                            0x775361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                            mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 728 len 22]
                                            mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 618] = token1ToEarnedPath.length
                                            if not token1ToEarnedPath.length:
                                                mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = ext_call.return_data[0]
                                                mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 64
                                                mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = token1ToEarnedPath.length
                                                mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 750 len floor32(token1ToEarnedPath.length)] = mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                staticcall address(uniRouterAddress).getAmountsOut(uint256 arg1, address[] arg2) with:
                                                        gas gas_remaining wei
                                                       args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 750 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                require return_data.size >= 32
                                                _24663 = mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28]
                                                require mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                require mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                require mem[mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] <= 4294967296 and mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * mem[mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]) + 32 <= return_data.size
                                                mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = mem[mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                _24812 = mem[_24663 + (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[_24663 + (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650])] = mem[_24663 + (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[_24663 + (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650])]
                                                mem[(32 * _24812) + (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] = 30
                                                mem[(32 * _24812) + (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 714] = 'SafeMath: subtraction overflow'
                                                if 1 > mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1 < mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                _27394 = mem[(32 * mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                if not mem[(32 * mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]:
                                                    mem[(32 * _24812) + (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + sub_1b61e055, token1ToEarnedPath.length, mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _24812) + (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                else:
                                                    require mem[(32 * mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                    if mem[(32 * mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] * slippageFactor / mem[(32 * mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] != slippageFactor:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * _24812) + (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 847 len 31]
                                                    mem[(32 * _24812) + (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], _27394 * slippageFactor / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _24812) + (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + sub_1b61e055
                                            else:
                                                mem[0] = 33
                                                mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650] = address(token1ToEarnedPath.field_0)
                                                idx = (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650
                                                s = 0
                                                while (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 618 > idx:
                                                    mem[idx + 32] = token1ToEarnedPath[s].field_256
                                                    idx = idx + 32
                                                    s = s + 1
                                                    continue 
                                                mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = ext_call.return_data[0]
                                                mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 64
                                                mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = token1ToEarnedPath.length
                                                mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 750 len floor32(token1ToEarnedPath.length)] = mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                staticcall address(uniRouterAddress).getAmountsOut(uint256 arg1, address[] arg2) with:
                                                        gas gas_remaining wei
                                                       args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 750 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                require return_data.size >= 32
                                                _29959 = mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28]
                                                require mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                require mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                require mem[mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] <= 4294967296 and mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * mem[mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]) + 32 <= return_data.size
                                                mem[(32 * _10741) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = mem[mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                _30036 = mem[_29959 + (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                mem[(32 * _10741) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[_29959 + (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650])] = mem[_29959 + (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[_29959 + (32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650])]
                                                mem[64] = (32 * _30036) + (32 * _10741) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 746
                                                mem[(32 * _30036) + (32 * _10741) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] = 30
                                                mem[(32 * _30036) + (32 * _10741) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 714] = 'SafeMath: subtraction overflow'
                                                if 1 > mem[(32 * _10741) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require mem[(32 * _10741) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1 < mem[(32 * _10741) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                _31194 = mem[(32 * mem[(32 * _10741) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _10741) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                if not mem[(32 * mem[(32 * _10741) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _10741) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]:
                                                    mem[(32 * _30036) + (32 * _10741) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + sub_1b61e055, token1ToEarnedPath.length, mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _30036) + (32 * _10741) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                else:
                                                    require mem[(32 * mem[(32 * _10741) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _10741) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                    if mem[(32 * mem[(32 * _10741) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _10741) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] * slippageFactor / mem[(32 * mem[(32 * _10741) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _10741) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] != slippageFactor:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * _30036) + (32 * _10741) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 847 len 31]
                                                    mem[(32 * _30036) + (32 * _10741) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], _31194 * slippageFactor / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _10741) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _30036) + (32 * _10741) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + sub_1b61e055
                                    else:
                                        if not ext_call.success:
                                            revert with approve(address arg1, uint256 arg2), Mask(224, 0, stor8), uint32(stor8), 2 * ext_call.return_data[0]
                                        if not approve(address arg1, uint256 arg2), Mask(224, 0, stor8):
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x775361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 727 len 22]
                                        mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 617] = token1ToEarnedPath.length
                                        if not token1ToEarnedPath.length:
                                            mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 653] = ext_call.return_data[0]
                                            mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 685] = 64
                                            mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 717] = token1ToEarnedPath.length
                                            mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 749 len floor32(token1ToEarnedPath.length)] = mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                            require ext_code.size(address(uniRouterAddress))
                                            staticcall address(uniRouterAddress).getAmountsOut(uint256 arg1, address[] arg2) with:
                                                    gas gas_remaining wei
                                                   args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 749 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649
                                            require return_data.size >= 32
                                            _24659 = mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28]
                                            require mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                            require mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                            require mem[mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] <= 4294967296 and mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * mem[mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]) + 32 <= return_data.size
                                            mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] = mem[mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]
                                            _24810 = mem[_24659 + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]
                                            mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[_24659 + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649])] = mem[_24659 + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[_24659 + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649])]
                                            mem[(32 * _24810) + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] = 30
                                            mem[(32 * _24810) + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 713] = 'SafeMath: subtraction overflow'
                                            if 1 > mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1 < mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649]
                                            _27388 = mem[(32 * mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]
                                            if not mem[(32 * mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]:
                                                mem[(32 * _24810) + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                mem[(32 * _24810) + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                mem[(32 * _24810) + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _24810) + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                mem[(32 * _24810) + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845] = 0
                                                mem[(32 * _24810) + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                mem[(32 * _24810) + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + sub_1b61e055
                                                mem[(32 * _24810) + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                mem[(32 * _24810) + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                mem[(32 * _24810) + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + sub_1b61e055, token1ToEarnedPath.length, mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _24810) + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                            else:
                                                require mem[(32 * mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]
                                                if mem[(32 * mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] * slippageFactor / mem[(32 * mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] != slippageFactor:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * _24810) + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 846 len 31]
                                                mem[(32 * _24810) + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                mem[(32 * _24810) + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                mem[(32 * _24810) + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _24810) + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                mem[(32 * _24810) + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845] = _27388 * slippageFactor / 1000
                                                mem[(32 * _24810) + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                mem[(32 * _24810) + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + sub_1b61e055
                                                mem[(32 * _24810) + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                mem[(32 * _24810) + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                mem[(32 * _24810) + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], _27388 * slippageFactor / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _24810) + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + sub_1b61e055
                                        else:
                                            mem[0] = 33
                                            mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649] = address(token1ToEarnedPath.field_0)
                                            idx = (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649
                                            s = 0
                                            while (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 617 > idx:
                                                mem[idx + 32] = token1ToEarnedPath[s].field_256
                                                idx = idx + 32
                                                s = s + 1
                                                continue 
                                            mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 653] = ext_call.return_data[0]
                                            mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 685] = 64
                                            mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 717] = token1ToEarnedPath.length
                                            mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 749 len floor32(token1ToEarnedPath.length)] = mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                            require ext_code.size(address(uniRouterAddress))
                                            staticcall address(uniRouterAddress).getAmountsOut(uint256 arg1, address[] arg2) with:
                                                    gas gas_remaining wei
                                                   args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 749 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649
                                            require return_data.size >= 32
                                            _29955 = mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28]
                                            require mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                            require mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                            require mem[mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] <= 4294967296 and mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * mem[mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]) + 32 <= return_data.size
                                            mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] = mem[mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]
                                            _30034 = mem[_29955 + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]
                                            mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[_29955 + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649])] = mem[_29955 + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[_29955 + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649])]
                                            mem[64] = (32 * _30034) + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745
                                            mem[(32 * _30034) + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] = 30
                                            mem[(32 * _30034) + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 713] = 'SafeMath: subtraction overflow'
                                            if 1 > mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1 < mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649]
                                            _31188 = mem[(32 * mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]
                                            if not mem[(32 * mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]:
                                                mem[(32 * _30034) + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                mem[(32 * _30034) + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                mem[(32 * _30034) + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _30034) + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                mem[(32 * _30034) + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845] = 0
                                                mem[(32 * _30034) + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                mem[(32 * _30034) + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + sub_1b61e055
                                                mem[(32 * _30034) + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                mem[(32 * _30034) + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                mem[(32 * _30034) + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + sub_1b61e055, token1ToEarnedPath.length, mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _30034) + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                            else:
                                                require mem[(32 * mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]
                                                if mem[(32 * mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] * slippageFactor / mem[(32 * mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] != slippageFactor:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * _30034) + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 846 len 31]
                                                mem[(32 * _30034) + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                mem[(32 * _30034) + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                mem[(32 * _30034) + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _30034) + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                mem[(32 * _30034) + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845] = _31188 * slippageFactor / 1000
                                                mem[(32 * _30034) + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                mem[(32 * _30034) + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + sub_1b61e055
                                                mem[(32 * _30034) + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                mem[(32 * _30034) + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                mem[(32 * _30034) + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], _31188 * slippageFactor / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _30034) + (32 * _10741) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + sub_1b61e055
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                else:
                    require return_data.size >= 32
                    if not mem[292]:
                        revert with 0, 
                                    32,
                                    42,
                                    0x775361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                    mem[ceil32(return_data.size) + 371 len 22]
                    mem[ceil32(return_data.size) + 261] = token0ToEarnedPath.length
                    if not token0ToEarnedPath.length:
                        mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                        mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 297] = ext_call.return_data[0]
                        mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 329] = 64
                        mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 361] = token0ToEarnedPath.length
                        mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 393 len floor32(token0ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token0ToEarnedPath.length)]
                        require ext_code.size(address(uniRouterAddress))
                        staticcall address(uniRouterAddress).getAmountsOut(uint256 arg1, address[] arg2) with:
                                gas gas_remaining wei
                               args ext_call.return_data[0], Array(len=token0ToEarnedPath.length, data=mem[ceil32(return_data.size) + 293 len floor32(token0ToEarnedPath.length)], mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + floor32(token0ToEarnedPath.length) + 393 len (32 * token0ToEarnedPath.length) - floor32(token0ToEarnedPath.length)])
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 293
                        require return_data.size >= 32
                        _4539 = mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28]
                        require mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] <= 4294967296
                        require mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                        require mem[mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293] <= 4294967296 and mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + (32 * mem[mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 293] = mem[mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293]
                        _4564 = mem[_4539 + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293]
                        mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 325 len floor32(mem[_4539 + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293])] = mem[_4539 + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 325 len floor32(mem[_4539 + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293])]
                        mem[64] = (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 389
                        mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 325] = 30
                        mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 357] = 'SafeMath: subtraction overflow'
                        if 1 > mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 293]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1 < mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 293]
                        _6742 = mem[(32 * mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 325]
                        if not mem[(32 * mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 325]:
                            mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 389] = 26
                            mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 421] = 'SafeMath: division by zero'
                            mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token0ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token0ToEarnedPath.length)]
                            require ext_code.size(address(uniRouterAddress))
                            call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + sub_1b61e055, token0ToEarnedPath.length, mem[ceil32(return_data.size) + 293 len floor32(token0ToEarnedPath.length)], mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + floor32(token0ToEarnedPath.length) + 649 len (32 * token0ToEarnedPath.length) - floor32(token0ToEarnedPath.length)]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require ext_code.size(token1Address)
                            staticcall token1Address.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if token1Address != earnedAddress:
                                if ext_call.return_data[0] > 0:
                                    require ext_code.size(token1Address)
                                    staticcall token1Address.0xdd62ed3e with:
                                            gas gas_remaining wei
                                           args address(this.address), address(uniRouterAddress)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if 2 * ext_call.return_data[0] < ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 489] = address(uniRouterAddress)
                                    mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 521] = 2 * ext_call.return_data[0]
                                    mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 453] = 68
                                    mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 489 len 28] = Mask(224, 0, stor8)
                                    mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 485 len 4] = approve(address arg1, uint256 arg2)
                                    mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 553] = 32
                                    mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 585] = 'SafeERC20: low-level call failed'
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 
                                                    32,
                                                    38,
                                                    0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c,
                                                    mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 723 len 26]
                                    if ext_code.size(token1Address) <= 0:
                                        revert with 0, 'Address: call to non-contract'
                                    mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 617 len 64] = approve(address arg1, uint256 arg2), Mask(224, 0, stor8), uint32(stor8), Mask(224, 31, ext_call.return_data[0]) >> 31
                                    mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 709 len 4] = 0
                                    mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 681 len 0] = 0
                                    call token1Address with:
                                       funct uint32(stor8)
                                         gas gas_remaining wei
                                        args Mask(224, 31, ext_call.return_data[0]) << 225, mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 681 len 4]
                                    if return_data.size:
                                        mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 617] = return_data.size
                                        mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            if return_data.size > 0:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 618] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 622] = 32
                                            mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 654] = 32
                                            mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 686] = 'SafeERC20: low-level call failed'
                                            revert with memory
                                              from (32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 618
                                               len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                        if return_data.size <= 0:
                                            mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 618] = token1ToEarnedPath.length
                                            if not token1ToEarnedPath.length:
                                                mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = ext_call.return_data[0]
                                                mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 64
                                                mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = token1ToEarnedPath.length
                                                mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 750 len floor32(token1ToEarnedPath.length)] = mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                staticcall address(uniRouterAddress).getAmountsOut(uint256 arg1, address[] arg2) with:
                                                        gas gas_remaining wei
                                                       args mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654 len (4 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + (-2 * ceil32(return_data.size)) + 96]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                require return_data.size >= 32
                                                _18061 = mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28]
                                                require mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                require mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                require mem[mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] <= 4294967296 and mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * mem[mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]) + 32 <= return_data.size
                                                mem[(32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = mem[mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                _18149 = mem[_18061 + (32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                mem[(32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[_18061 + (32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650])] = mem[_18061 + (32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[_18061 + (32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650])]
                                                mem[64] = (32 * _18149) + (32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 746
                                                mem[(32 * _18149) + (32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] = 30
                                                mem[(32 * _18149) + (32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 714] = 'SafeMath: subtraction overflow'
                                                if 1 > mem[(32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require mem[(32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1 < mem[(32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                _21323 = mem[(32 * mem[(32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                if not mem[(32 * mem[(32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]:
                                                    mem[(32 * _18149) + (32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + sub_1b61e055, token1ToEarnedPath.length, mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _18149) + (32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                else:
                                                    require mem[(32 * mem[(32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                    if mem[(32 * mem[(32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] * slippageFactor / mem[(32 * mem[(32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] != slippageFactor:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * _18149) + (32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 847 len 31]
                                                    mem[(32 * _18149) + (32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], _21323 * slippageFactor / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _18149) + (32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + sub_1b61e055
                                            else:
                                                mem[0] = 33
                                                mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650] = address(token1ToEarnedPath.field_0)
                                                idx = (32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650
                                                s = 0
                                                while (32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 618 > idx:
                                                    mem[idx + 32] = token1ToEarnedPath[s].field_256
                                                    idx = idx + 32
                                                    s = s + 1
                                                    continue 
                                                mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = ext_call.return_data[0]
                                                mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 64
                                                mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = token1ToEarnedPath.length
                                                mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 750 len floor32(token1ToEarnedPath.length)] = mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                staticcall address(uniRouterAddress).getAmountsOut(uint256 arg1, address[] arg2) with:
                                                        gas gas_remaining wei
                                                       args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 750 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                require return_data.size >= 32
                                                _24685 = mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28]
                                                require mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                require mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                require mem[mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] <= 4294967296 and mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * mem[mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]) + 32 <= return_data.size
                                                mem[(32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = mem[mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                _24823 = mem[_24685 + (32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                mem[(32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[_24685 + (32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650])] = mem[_24685 + (32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[_24685 + (32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650])]
                                                mem[64] = (32 * _24823) + (32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 746
                                                mem[(32 * _24823) + (32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] = 30
                                                mem[(32 * _24823) + (32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 714] = 'SafeMath: subtraction overflow'
                                                if 1 > mem[(32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require mem[(32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1 < mem[(32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                _27427 = mem[(32 * mem[(32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                if not mem[(32 * mem[(32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]:
                                                    mem[(32 * _24823) + (32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + sub_1b61e055, token1ToEarnedPath.length, mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _24823) + (32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                else:
                                                    require mem[(32 * mem[(32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                    if mem[(32 * mem[(32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] * slippageFactor / mem[(32 * mem[(32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] != slippageFactor:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * _24823) + (32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 847 len 31]
                                                    mem[(32 * _24823) + (32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], _27427 * slippageFactor / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _24823) + (32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + sub_1b61e055
                                        else:
                                            require return_data.size >= 32
                                            if not mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649]:
                                                mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 618] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 622] = 32
                                                mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 654] = 42
                                                mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 686 len 42] = 0x775361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565
                                                revert with memory
                                                  from (32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 618
                                                   len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 132
                                            mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 618] = token1ToEarnedPath.length
                                            if not token1ToEarnedPath.length:
                                                mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = ext_call.return_data[0]
                                                mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 64
                                                mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = token1ToEarnedPath.length
                                                mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 750 len floor32(token1ToEarnedPath.length)] = mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                staticcall address(uniRouterAddress).getAmountsOut(uint256 arg1, address[] arg2) with:
                                                        gas gas_remaining wei
                                                       args mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654 len (4 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + (-2 * ceil32(return_data.size)) + 96]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                require return_data.size >= 32
                                                _18063 = mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28]
                                                require mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                require mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                require mem[mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] <= 4294967296 and mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * mem[mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]) + 32 <= return_data.size
                                                mem[(32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = mem[mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                _18150 = mem[_18063 + (32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                mem[(32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[_18063 + (32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650])] = mem[_18063 + (32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[_18063 + (32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650])]
                                                mem[64] = (32 * _18150) + (32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 746
                                                mem[(32 * _18150) + (32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] = 30
                                                mem[(32 * _18150) + (32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 714] = 'SafeMath: subtraction overflow'
                                                if 1 > mem[(32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require mem[(32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1 < mem[(32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                _21326 = mem[(32 * mem[(32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                if not mem[(32 * mem[(32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]:
                                                    mem[(32 * _18150) + (32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + sub_1b61e055, token1ToEarnedPath.length, mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _18150) + (32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                else:
                                                    require mem[(32 * mem[(32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                    if mem[(32 * mem[(32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] * slippageFactor / mem[(32 * mem[(32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] != slippageFactor:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * _18150) + (32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 847 len 31]
                                                    mem[(32 * _18150) + (32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], _21326 * slippageFactor / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _18150) + (32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + sub_1b61e055
                                            else:
                                                mem[0] = 33
                                                mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650] = address(token1ToEarnedPath.field_0)
                                                idx = (32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650
                                                s = 0
                                                while (32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 618 > idx:
                                                    mem[idx + 32] = token1ToEarnedPath[s].field_256
                                                    idx = idx + 32
                                                    s = s + 1
                                                    continue 
                                                mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = ext_call.return_data[0]
                                                mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 64
                                                mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = token1ToEarnedPath.length
                                                mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 750 len floor32(token1ToEarnedPath.length)] = mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                staticcall address(uniRouterAddress).getAmountsOut(uint256 arg1, address[] arg2) with:
                                                        gas gas_remaining wei
                                                       args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 750 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                require return_data.size >= 32
                                                _24687 = mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28]
                                                require mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                require mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                require mem[mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] <= 4294967296 and mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * mem[mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]) + 32 <= return_data.size
                                                mem[(32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = mem[mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                _24824 = mem[_24687 + (32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                mem[(32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[_24687 + (32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650])] = mem[_24687 + (32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[_24687 + (32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650])]
                                                mem[64] = (32 * _24824) + (32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 746
                                                mem[(32 * _24824) + (32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] = 30
                                                mem[(32 * _24824) + (32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 714] = 'SafeMath: subtraction overflow'
                                                if 1 > mem[(32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require mem[(32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1 < mem[(32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                _27430 = mem[(32 * mem[(32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                if not mem[(32 * mem[(32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]:
                                                    mem[(32 * _24824) + (32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + sub_1b61e055, token1ToEarnedPath.length, mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _24824) + (32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                else:
                                                    require mem[(32 * mem[(32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                    if mem[(32 * mem[(32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] * slippageFactor / mem[(32 * mem[(32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] != slippageFactor:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * _24824) + (32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 847 len 31]
                                                    mem[(32 * _24824) + (32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], _27430 * slippageFactor / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _24824) + (32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + sub_1b61e055
                                    else:
                                        if not ext_call.success:
                                            revert with approve(address arg1, uint256 arg2), Mask(224, 0, stor8), uint32(stor8), 2 * ext_call.return_data[0]
                                        if not approve(address arg1, uint256 arg2), Mask(224, 0, stor8):
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x775361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 727 len 22]
                                        mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 617] = token1ToEarnedPath.length
                                        if not token1ToEarnedPath.length:
                                            mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 653] = ext_call.return_data[0]
                                            mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 685] = 64
                                            mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 717] = token1ToEarnedPath.length
                                            mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 749 len floor32(token1ToEarnedPath.length)] = mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                            require ext_code.size(address(uniRouterAddress))
                                            staticcall address(uniRouterAddress).getAmountsOut(uint256 arg1, address[] arg2) with:
                                                    gas gas_remaining wei
                                                   args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 749 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649
                                            require return_data.size >= 32
                                            _18059 = mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28]
                                            require mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                            require mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                            require mem[mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] <= 4294967296 and mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * mem[mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]) + 32 <= return_data.size
                                            mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] = mem[mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]
                                            _18148 = mem[_18059 + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]
                                            mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[_18059 + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649])] = mem[_18059 + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[_18059 + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649])]
                                            mem[64] = (32 * _18148) + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745
                                            mem[(32 * _18148) + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] = 30
                                            mem[(32 * _18148) + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 713] = 'SafeMath: subtraction overflow'
                                            if 1 > mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1 < mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649]
                                            _21320 = mem[(32 * mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]
                                            if not mem[(32 * mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]:
                                                mem[(32 * _18148) + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                mem[(32 * _18148) + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                mem[(32 * _18148) + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _18148) + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                mem[(32 * _18148) + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845] = 0
                                                mem[(32 * _18148) + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                mem[(32 * _18148) + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + sub_1b61e055
                                                mem[(32 * _18148) + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                mem[(32 * _18148) + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                mem[(32 * _18148) + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + sub_1b61e055, token1ToEarnedPath.length, mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _18148) + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                            else:
                                                require mem[(32 * mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]
                                                if mem[(32 * mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] * slippageFactor / mem[(32 * mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] != slippageFactor:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * _18148) + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 846 len 31]
                                                mem[(32 * _18148) + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                mem[(32 * _18148) + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                mem[(32 * _18148) + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _18148) + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                mem[(32 * _18148) + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845] = _21320 * slippageFactor / 1000
                                                mem[(32 * _18148) + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                mem[(32 * _18148) + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + sub_1b61e055
                                                mem[(32 * _18148) + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                mem[(32 * _18148) + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                mem[(32 * _18148) + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], _21320 * slippageFactor / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _18148) + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + sub_1b61e055
                                        else:
                                            mem[0] = 33
                                            mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649] = address(token1ToEarnedPath.field_0)
                                            idx = (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649
                                            s = 0
                                            while (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 617 > idx:
                                                mem[idx + 32] = token1ToEarnedPath[s].field_256
                                                idx = idx + 32
                                                s = s + 1
                                                continue 
                                            mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 653] = ext_call.return_data[0]
                                            mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 685] = 64
                                            mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 717] = token1ToEarnedPath.length
                                            mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 749 len floor32(token1ToEarnedPath.length)] = mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                            require ext_code.size(address(uniRouterAddress))
                                            staticcall address(uniRouterAddress).getAmountsOut(uint256 arg1, address[] arg2) with:
                                                    gas gas_remaining wei
                                                   args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 749 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649
                                            require return_data.size >= 32
                                            _24683 = mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28]
                                            require mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                            require mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                            require mem[mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] <= 4294967296 and mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * mem[mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]) + 32 <= return_data.size
                                            mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] = mem[mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]
                                            _24822 = mem[_24683 + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]
                                            mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[_24683 + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649])] = mem[_24683 + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[_24683 + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649])]
                                            mem[64] = (32 * _24822) + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745
                                            mem[(32 * _24822) + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] = 30
                                            mem[(32 * _24822) + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 713] = 'SafeMath: subtraction overflow'
                                            if 1 > mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1 < mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649]
                                            _27424 = mem[(32 * mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]
                                            if not mem[(32 * mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]:
                                                mem[(32 * _24822) + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                mem[(32 * _24822) + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                mem[(32 * _24822) + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _24822) + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                mem[(32 * _24822) + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845] = 0
                                                mem[(32 * _24822) + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                mem[(32 * _24822) + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + sub_1b61e055
                                                mem[(32 * _24822) + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                mem[(32 * _24822) + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                mem[(32 * _24822) + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + sub_1b61e055, token1ToEarnedPath.length, mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _24822) + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                            else:
                                                require mem[(32 * mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]
                                                if mem[(32 * mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] * slippageFactor / mem[(32 * mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] != slippageFactor:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * _24822) + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 846 len 31]
                                                mem[(32 * _24822) + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                mem[(32 * _24822) + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                mem[(32 * _24822) + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _24822) + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                mem[(32 * _24822) + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845] = _27424 * slippageFactor / 1000
                                                mem[(32 * _24822) + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                mem[(32 * _24822) + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + sub_1b61e055
                                                mem[(32 * _24822) + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                mem[(32 * _24822) + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                mem[(32 * _24822) + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], _27424 * slippageFactor / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _24822) + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + sub_1b61e055
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                        else:
                            require mem[(32 * mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 325]
                            if mem[(32 * mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 325] * slippageFactor / mem[(32 * mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 325] != slippageFactor:
                                revert with 0, 
                                            32,
                                            33,
                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 490 len 31]
                            mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 389] = 26
                            mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 421] = 'SafeMath: division by zero'
                            mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token0ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token0ToEarnedPath.length)]
                            require ext_code.size(address(uniRouterAddress))
                            call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0], _6742 * slippageFactor / 1000, Array(len=token0ToEarnedPath.length, data=mem[ceil32(return_data.size) + 293 len floor32(token0ToEarnedPath.length)], mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + floor32(token0ToEarnedPath.length) + 649 len (32 * token0ToEarnedPath.length) - floor32(token0ToEarnedPath.length)]), address(this.address), block.timestamp + sub_1b61e055
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require ext_code.size(token1Address)
                            staticcall token1Address.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if token1Address != earnedAddress:
                                if ext_call.return_data[0] > 0:
                                    require ext_code.size(token1Address)
                                    staticcall token1Address.0xdd62ed3e with:
                                            gas gas_remaining wei
                                           args address(this.address), address(uniRouterAddress)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if 2 * ext_call.return_data[0] < ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 489] = address(uniRouterAddress)
                                    mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 521] = 2 * ext_call.return_data[0]
                                    mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 453] = 68
                                    mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 489 len 28] = Mask(224, 0, stor8)
                                    mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 485 len 4] = approve(address arg1, uint256 arg2)
                                    mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 553] = 32
                                    mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 585] = 'SafeERC20: low-level call failed'
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 
                                                    32,
                                                    38,
                                                    0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c,
                                                    mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 723 len 26]
                                    if ext_code.size(token1Address) <= 0:
                                        revert with 0, 'Address: call to non-contract'
                                    mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 617 len 64] = approve(address arg1, uint256 arg2), Mask(224, 0, stor8), uint32(stor8), Mask(224, 31, ext_call.return_data[0]) >> 31
                                    mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 709 len 4] = 0
                                    call token1Address with:
                                       funct token0ToEarnedPath.length.field_224
                                         gas gas_remaining wei
                                        args Mask(224, 31, ext_call.return_data[0]) << 225, mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 681 len 4]
                                    if return_data.size:
                                        mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 617] = return_data.size
                                        mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            if return_data.size > 0:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            revert with 0, 'SafeERC20: low-level call failed'
                                        if return_data.size <= 0:
                                            mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 618] = token1ToEarnedPath.length
                                            if not token1ToEarnedPath.length:
                                                mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = ext_call.return_data[0]
                                                mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 64
                                                mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = token1ToEarnedPath.length
                                                mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 750 len floor32(token1ToEarnedPath.length)] = mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                staticcall address(uniRouterAddress).getAmountsOut(uint256 arg1, address[] arg2) with:
                                                        gas gas_remaining wei
                                                       args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 750 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                require return_data.size >= 32
                                                _18053 = mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28]
                                                require mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                require mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                require mem[mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] <= 4294967296 and mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * mem[mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]) + 32 <= return_data.size
                                                mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = mem[mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                _18145 = mem[_18053 + (32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[_18053 + (32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650])] = mem[_18053 + (32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[_18053 + (32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650])]
                                                mem[64] = (32 * _18145) + (32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 746
                                                mem[(32 * _18145) + (32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] = 30
                                                mem[(32 * _18145) + (32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 714] = 'SafeMath: subtraction overflow'
                                                if 1 > mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1 < mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                _21311 = mem[(32 * mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                if not mem[(32 * mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]:
                                                    mem[(32 * _18145) + (32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + sub_1b61e055, token1ToEarnedPath.length, mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _18145) + (32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                else:
                                                    require mem[(32 * mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                    if mem[(32 * mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] * slippageFactor / mem[(32 * mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] != slippageFactor:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * _18145) + (32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 847 len 31]
                                                    mem[(32 * _18145) + (32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], _21311 * slippageFactor / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _18145) + (32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + sub_1b61e055
                                            else:
                                                mem[0] = 33
                                                mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650] = address(token1ToEarnedPath.field_0)
                                                idx = (32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650
                                                s = 0
                                                while (32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 618 > idx:
                                                    mem[idx + 32] = token1ToEarnedPath[s].field_256
                                                    idx = idx + 32
                                                    s = s + 1
                                                    continue 
                                                mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = ext_call.return_data[0]
                                                mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 64
                                                mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = token1ToEarnedPath.length
                                                mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 750 len floor32(token1ToEarnedPath.length)] = mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                staticcall address(uniRouterAddress).getAmountsOut(uint256 arg1, address[] arg2) with:
                                                        gas gas_remaining wei
                                                       args mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654 len (4 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + (-2 * ceil32(return_data.size)) + 96]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                require return_data.size >= 32
                                                _24677 = mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28]
                                                require mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                require mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                require mem[mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] <= 4294967296 and mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * mem[mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]) + 32 <= return_data.size
                                                mem[(32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = mem[mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                _24819 = mem[_24677 + (32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                mem[(32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[_24677 + (32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650])] = mem[_24677 + (32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[_24677 + (32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650])]
                                                mem[64] = (32 * _24819) + (32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 746
                                                mem[(32 * _24819) + (32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] = 30
                                                mem[(32 * _24819) + (32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 714] = 'SafeMath: subtraction overflow'
                                                if 1 > mem[(32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require mem[(32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1 < mem[(32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                _27415 = mem[(32 * mem[(32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                if not mem[(32 * mem[(32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]:
                                                    mem[(32 * _24819) + (32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + sub_1b61e055, token1ToEarnedPath.length, mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _24819) + (32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                else:
                                                    require mem[(32 * mem[(32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                    if mem[(32 * mem[(32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] * slippageFactor / mem[(32 * mem[(32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] != slippageFactor:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * _24819) + (32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 847 len 31]
                                                    mem[(32 * _24819) + (32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], _27415 * slippageFactor / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _24819) + (32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + sub_1b61e055
                                        else:
                                            require return_data.size >= 32
                                            if not mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649]:
                                                revert with 0, 
                                                            32,
                                                            42,
                                                            0x775361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                            mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 728 len 22]
                                            mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 618] = token1ToEarnedPath.length
                                            if not token1ToEarnedPath.length:
                                                mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = ext_call.return_data[0]
                                                mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 64
                                                mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = token1ToEarnedPath.length
                                                mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 750 len floor32(token1ToEarnedPath.length)] = mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                staticcall address(uniRouterAddress).getAmountsOut(uint256 arg1, address[] arg2) with:
                                                        gas gas_remaining wei
                                                       args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 750 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                require return_data.size >= 32
                                                _18055 = mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28]
                                                require mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                require mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                require mem[mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] <= 4294967296 and mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * mem[mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]) + 32 <= return_data.size
                                                mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = mem[mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                _18146 = mem[_18055 + (32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[_18055 + (32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650])] = mem[_18055 + (32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[_18055 + (32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650])]
                                                mem[64] = (32 * _18146) + (32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 746
                                                mem[(32 * _18146) + (32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] = 30
                                                mem[(32 * _18146) + (32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 714] = 'SafeMath: subtraction overflow'
                                                if 1 > mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1 < mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                _21314 = mem[(32 * mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                if not mem[(32 * mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]:
                                                    mem[(32 * _18146) + (32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + sub_1b61e055, token1ToEarnedPath.length, mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _18146) + (32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                else:
                                                    require mem[(32 * mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                    if mem[(32 * mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] * slippageFactor / mem[(32 * mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] != slippageFactor:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * _18146) + (32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 847 len 31]
                                                    mem[(32 * _18146) + (32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], _21314 * slippageFactor / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _18146) + (32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + sub_1b61e055
                                            else:
                                                mem[0] = 33
                                                mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650] = address(token1ToEarnedPath.field_0)
                                                idx = (32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650
                                                s = 0
                                                while (32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 618 > idx:
                                                    mem[idx + 32] = token1ToEarnedPath[s].field_256
                                                    idx = idx + 32
                                                    s = s + 1
                                                    continue 
                                                mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = ext_call.return_data[0]
                                                mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 64
                                                mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = token1ToEarnedPath.length
                                                mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 750 len floor32(token1ToEarnedPath.length)] = mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                staticcall address(uniRouterAddress).getAmountsOut(uint256 arg1, address[] arg2) with:
                                                        gas gas_remaining wei
                                                       args mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654 len (4 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + (-2 * ceil32(return_data.size)) + 96]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                require return_data.size >= 32
                                                _24679 = mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28]
                                                require mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                require mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                require mem[mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] <= 4294967296 and mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * mem[mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]) + 32 <= return_data.size
                                                mem[(32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = mem[mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                _24820 = mem[_24679 + (32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                mem[(32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[_24679 + (32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650])] = mem[_24679 + (32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[_24679 + (32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650])]
                                                mem[64] = (32 * _24820) + (32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 746
                                                mem[(32 * _24820) + (32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] = 30
                                                mem[(32 * _24820) + (32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 714] = 'SafeMath: subtraction overflow'
                                                if 1 > mem[(32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require mem[(32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1 < mem[(32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                _27418 = mem[(32 * mem[(32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                if not mem[(32 * mem[(32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]:
                                                    mem[(32 * _24820) + (32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + sub_1b61e055, token1ToEarnedPath.length, mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _24820) + (32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                else:
                                                    require mem[(32 * mem[(32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                    if mem[(32 * mem[(32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] * slippageFactor / mem[(32 * mem[(32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] != slippageFactor:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * _24820) + (32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 847 len 31]
                                                    mem[(32 * _24820) + (32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], _27418 * slippageFactor / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _4564) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _24820) + (32 * _4564) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + sub_1b61e055
                                    else:
                                        if not ext_call.success:
                                            revert with approve(address arg1, uint256 arg2), Mask(224, 0, stor8), uint32(stor8), 2 * ext_call.return_data[0]
                                        if not approve(address arg1, uint256 arg2), Mask(224, 0, stor8):
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x775361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 727 len 22]
                                        mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 617] = token1ToEarnedPath.length
                                        if not token1ToEarnedPath.length:
                                            mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 653] = ext_call.return_data[0]
                                            mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 685] = 64
                                            mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 717] = token1ToEarnedPath.length
                                            mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 749 len floor32(token1ToEarnedPath.length)] = mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                            require ext_code.size(address(uniRouterAddress))
                                            staticcall address(uniRouterAddress).getAmountsOut(uint256 arg1, address[] arg2) with:
                                                    gas gas_remaining wei
                                                   args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 749 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649
                                            require return_data.size >= 32
                                            _18051 = mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28]
                                            require mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                            require mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                            require mem[mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] <= 4294967296 and mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * mem[mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]) + 32 <= return_data.size
                                            mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] = mem[mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]
                                            _18144 = mem[_18051 + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]
                                            mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[_18051 + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649])] = mem[_18051 + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[_18051 + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649])]
                                            mem[64] = (32 * _18144) + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745
                                            mem[(32 * _18144) + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] = 30
                                            mem[(32 * _18144) + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 713] = 'SafeMath: subtraction overflow'
                                            if 1 > mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1 < mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649]
                                            _21308 = mem[(32 * mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]
                                            if not mem[(32 * mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]:
                                                mem[(32 * _18144) + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                mem[(32 * _18144) + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                mem[(32 * _18144) + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _18144) + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                mem[(32 * _18144) + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845] = 0
                                                mem[(32 * _18144) + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                mem[(32 * _18144) + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + sub_1b61e055
                                                mem[(32 * _18144) + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                mem[(32 * _18144) + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                mem[(32 * _18144) + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + sub_1b61e055, token1ToEarnedPath.length, mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _18144) + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                            else:
                                                require mem[(32 * mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]
                                                if mem[(32 * mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] * slippageFactor / mem[(32 * mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] != slippageFactor:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * _18144) + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 846 len 31]
                                                mem[(32 * _18144) + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                mem[(32 * _18144) + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                mem[(32 * _18144) + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _18144) + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                mem[(32 * _18144) + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845] = _21308 * slippageFactor / 1000
                                                mem[(32 * _18144) + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                mem[(32 * _18144) + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + sub_1b61e055
                                                mem[(32 * _18144) + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                mem[(32 * _18144) + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                mem[(32 * _18144) + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], _21308 * slippageFactor / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _18144) + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + sub_1b61e055
                                        else:
                                            mem[0] = 33
                                            mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649] = address(token1ToEarnedPath.field_0)
                                            idx = (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649
                                            s = 0
                                            while (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 617 > idx:
                                                mem[idx + 32] = token1ToEarnedPath[s].field_256
                                                idx = idx + 32
                                                s = s + 1
                                                continue 
                                            mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 653] = ext_call.return_data[0]
                                            mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 685] = 64
                                            mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 717] = token1ToEarnedPath.length
                                            mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 749 len floor32(token1ToEarnedPath.length)] = mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                            require ext_code.size(address(uniRouterAddress))
                                            staticcall address(uniRouterAddress).getAmountsOut(uint256 arg1, address[] arg2) with:
                                                    gas gas_remaining wei
                                                   args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 749 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649
                                            require return_data.size >= 32
                                            _24675 = mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28]
                                            require mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                            require mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                            require mem[mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] <= 4294967296 and mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * mem[mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]) + 32 <= return_data.size
                                            mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] = mem[mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]
                                            _24818 = mem[_24675 + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]
                                            mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[_24675 + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649])] = mem[_24675 + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[_24675 + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649])]
                                            mem[64] = (32 * _24818) + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745
                                            mem[(32 * _24818) + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] = 30
                                            mem[(32 * _24818) + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 713] = 'SafeMath: subtraction overflow'
                                            if 1 > mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1 < mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649]
                                            _27412 = mem[(32 * mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]
                                            if not mem[(32 * mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]:
                                                mem[(32 * _24818) + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                mem[(32 * _24818) + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                mem[(32 * _24818) + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _24818) + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                mem[(32 * _24818) + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845] = 0
                                                mem[(32 * _24818) + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                mem[(32 * _24818) + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + sub_1b61e055
                                                mem[(32 * _24818) + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                mem[(32 * _24818) + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                mem[(32 * _24818) + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + sub_1b61e055, token1ToEarnedPath.length, mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _24818) + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                            else:
                                                require mem[(32 * mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]
                                                if mem[(32 * mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] * slippageFactor / mem[(32 * mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] != slippageFactor:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * _24818) + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 846 len 31]
                                                mem[(32 * _24818) + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                mem[(32 * _24818) + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                mem[(32 * _24818) + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _24818) + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                mem[(32 * _24818) + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845] = _27412 * slippageFactor / 1000
                                                mem[(32 * _24818) + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                mem[(32 * _24818) + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + sub_1b61e055
                                                mem[(32 * _24818) + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                mem[(32 * _24818) + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                mem[(32 * _24818) + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], _27412 * slippageFactor / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _24818) + (32 * _4564) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + sub_1b61e055
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                    else:
                        mem[0] = 32
                        mem[ceil32(return_data.size) + 293] = address(token0ToEarnedPath.field_0)
                        idx = ceil32(return_data.size) + 293
                        s = 0
                        while ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 261 > idx:
                            mem[idx + 32] = token0ToEarnedPath[s].field_256
                            idx = idx + 32
                            s = s + 1
                            continue 
                        mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                        mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 297] = ext_call.return_data[0]
                        mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 329] = 64
                        mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 361] = token0ToEarnedPath.length
                        mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 393 len floor32(token0ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token0ToEarnedPath.length)]
                        require ext_code.size(address(uniRouterAddress))
                        staticcall address(uniRouterAddress).getAmountsOut(uint256 arg1, address[] arg2) with:
                                gas gas_remaining wei
                               args ext_call.return_data[0], Array(len=token0ToEarnedPath.length, data=mem[ceil32(return_data.size) + 293 len floor32(token0ToEarnedPath.length)], mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + floor32(token0ToEarnedPath.length) + 393 len (32 * token0ToEarnedPath.length) - floor32(token0ToEarnedPath.length)])
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 293
                        require return_data.size >= 32
                        _10695 = mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28]
                        require mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] <= 4294967296
                        require mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                        require mem[mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293] <= 4294967296 and mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + (32 * mem[mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 293] = mem[mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293]
                        _10744 = mem[_10695 + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293]
                        mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 325 len floor32(mem[_10695 + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293])] = mem[_10695 + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 325 len floor32(mem[_10695 + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293])]
                        mem[64] = (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 389
                        mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 325] = 30
                        mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 357] = 'SafeMath: subtraction overflow'
                        if 1 > mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 293]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1 < mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 293]
                        _14562 = mem[(32 * mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 325]
                        if not mem[(32 * mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 325]:
                            mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 389] = 26
                            mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 421] = 'SafeMath: division by zero'
                            mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token0ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token0ToEarnedPath.length)]
                            require ext_code.size(address(uniRouterAddress))
                            call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + sub_1b61e055, token0ToEarnedPath.length, mem[ceil32(return_data.size) + 293 len floor32(token0ToEarnedPath.length)], mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + floor32(token0ToEarnedPath.length) + 649 len (32 * token0ToEarnedPath.length) - floor32(token0ToEarnedPath.length)]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require ext_code.size(token1Address)
                            staticcall token1Address.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if token1Address != earnedAddress:
                                if ext_call.return_data[0] > 0:
                                    require ext_code.size(token1Address)
                                    staticcall token1Address.0xdd62ed3e with:
                                            gas gas_remaining wei
                                           args address(this.address), address(uniRouterAddress)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if 2 * ext_call.return_data[0] < ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 489] = address(uniRouterAddress)
                                    mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 521] = 2 * ext_call.return_data[0]
                                    mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 453] = 68
                                    mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 489 len 28] = Mask(224, 0, stor8)
                                    mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 485 len 4] = approve(address arg1, uint256 arg2)
                                    mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 553] = 32
                                    mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 585] = 'SafeERC20: low-level call failed'
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 
                                                    32,
                                                    38,
                                                    0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c,
                                                    mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 723 len 26]
                                    if ext_code.size(token1Address) <= 0:
                                        revert with 0, 'Address: call to non-contract'
                                    mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 617 len 64] = approve(address arg1, uint256 arg2), Mask(224, 0, stor8), uint32(stor8), Mask(224, 31, ext_call.return_data[0]) >> 31
                                    mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 709 len 4] = 0
                                    mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 681 len 0] = 0
                                    call token1Address with:
                                       funct uint32(stor8)
                                         gas gas_remaining wei
                                        args Mask(224, 31, ext_call.return_data[0]) << 225, mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 681 len 4]
                                    if return_data.size:
                                        mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 617] = return_data.size
                                        mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            if return_data.size > 0:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            revert with 0, 'SafeERC20: low-level call failed'
                                        if return_data.size <= 0:
                                            mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 618] = token1ToEarnedPath.length
                                            if not token1ToEarnedPath.length:
                                                mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = ext_call.return_data[0]
                                                mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 64
                                                mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = token1ToEarnedPath.length
                                                mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 750 len floor32(token1ToEarnedPath.length)] = mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                var122001 = floor32(token1ToEarnedPath.length)
                                                require ext_code.size(address(uniRouterAddress))
                                                staticcall address(uniRouterAddress).getAmountsOut(uint256 arg1, address[] arg2) with:
                                                        gas gas_remaining wei
                                                       args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 750 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                require return_data.size >= 32
                                                _24701 = mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28]
                                                require mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                require mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                require mem[mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] <= 4294967296 and mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * mem[mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]) + 32 <= return_data.size
                                                mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = mem[mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                _24831 = mem[_24701 + (32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[_24701 + (32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650])] = mem[_24701 + (32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[_24701 + (32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650])]
                                                mem[64] = (32 * _24831) + (32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 746
                                                mem[(32 * _24831) + (32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] = 30
                                                mem[(32 * _24831) + (32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 714] = 'SafeMath: subtraction overflow'
                                                if 1 > mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1 < mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                _27451 = mem[(32 * mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                if not mem[(32 * mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]:
                                                    mem[(32 * _24831) + (32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + sub_1b61e055, token1ToEarnedPath.length, mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _24831) + (32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                else:
                                                    require mem[(32 * mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                    if mem[(32 * mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] * slippageFactor / mem[(32 * mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] != slippageFactor:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * _24831) + (32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 847 len 31]
                                                    mem[(32 * _24831) + (32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], _27451 * slippageFactor / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _24831) + (32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + sub_1b61e055
                                            else:
                                                mem[0] = 33
                                                mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650] = address(token1ToEarnedPath.field_0)
                                                idx = (32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650
                                                s = 0
                                                while (32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 618 > idx:
                                                    mem[idx + 32] = token1ToEarnedPath[s].field_256
                                                    idx = idx + 32
                                                    s = s + 1
                                                    continue 
                                                mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = ext_call.return_data[0]
                                                mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 64
                                                mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = token1ToEarnedPath.length
                                                mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 750 len floor32(token1ToEarnedPath.length)] = mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                staticcall address(uniRouterAddress).getAmountsOut(uint256 arg1, address[] arg2) with:
                                                        gas gas_remaining wei
                                                       args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 750 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                require return_data.size >= 32
                                                _29981 = mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28]
                                                require mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                require mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                require mem[mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] <= 4294967296 and mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * mem[mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]) + 32 <= return_data.size
                                                mem[(32 * _10744) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = mem[mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                _30047 = mem[_29981 + (32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                mem[(32 * _10744) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[_29981 + (32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650])] = mem[_29981 + (32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[_29981 + (32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650])]
                                                mem[64] = (32 * _30047) + (32 * _10744) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 746
                                                mem[(32 * _30047) + (32 * _10744) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] = 30
                                                mem[(32 * _30047) + (32 * _10744) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 714] = 'SafeMath: subtraction overflow'
                                                if 1 > mem[(32 * _10744) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require mem[(32 * _10744) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1 < mem[(32 * _10744) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                _31227 = mem[(32 * mem[(32 * _10744) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _10744) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                if not mem[(32 * mem[(32 * _10744) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _10744) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]:
                                                    mem[(32 * _30047) + (32 * _10744) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + sub_1b61e055, token1ToEarnedPath.length, mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _30047) + (32 * _10744) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                else:
                                                    require mem[(32 * mem[(32 * _10744) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _10744) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                    if mem[(32 * mem[(32 * _10744) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _10744) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] * slippageFactor / mem[(32 * mem[(32 * _10744) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _10744) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] != slippageFactor:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * _30047) + (32 * _10744) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 847 len 31]
                                                    mem[(32 * _30047) + (32 * _10744) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], _31227 * slippageFactor / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _30047) + (32 * _10744) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + sub_1b61e055
                                        else:
                                            require return_data.size >= 32
                                            if not mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649]:
                                                revert with 0, 
                                                            32,
                                                            42,
                                                            0x775361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                            mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 728 len 22]
                                            mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 618] = token1ToEarnedPath.length
                                            if not token1ToEarnedPath.length:
                                                mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = ext_call.return_data[0]
                                                mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 64
                                                mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = token1ToEarnedPath.length
                                                mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 750 len floor32(token1ToEarnedPath.length)] = mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                var125001 = floor32(token1ToEarnedPath.length)
                                                require ext_code.size(address(uniRouterAddress))
                                                staticcall address(uniRouterAddress).getAmountsOut(uint256 arg1, address[] arg2) with:
                                                        gas gas_remaining wei
                                                       args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 750 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                require return_data.size >= 32
                                                _24703 = mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28]
                                                require mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                require mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                require mem[mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] <= 4294967296 and mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * mem[mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]) + 32 <= return_data.size
                                                mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = mem[mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                _24832 = mem[_24703 + (32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[_24703 + (32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650])] = mem[_24703 + (32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[_24703 + (32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650])]
                                                mem[64] = (32 * _24832) + (32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 746
                                                mem[(32 * _24832) + (32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] = 30
                                                mem[(32 * _24832) + (32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 714] = 'SafeMath: subtraction overflow'
                                                if 1 > mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1 < mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                _27454 = mem[(32 * mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                if not mem[(32 * mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]:
                                                    mem[(32 * _24832) + (32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + sub_1b61e055, token1ToEarnedPath.length, mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _24832) + (32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                else:
                                                    require mem[(32 * mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                    if mem[(32 * mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] * slippageFactor / mem[(32 * mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] != slippageFactor:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * _24832) + (32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 847 len 31]
                                                    mem[(32 * _24832) + (32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], _27454 * slippageFactor / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _24832) + (32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + sub_1b61e055
                                            else:
                                                mem[0] = 33
                                                mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650] = address(token1ToEarnedPath.field_0)
                                                idx = (32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650
                                                s = 0
                                                while (32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 618 > idx:
                                                    mem[idx + 32] = token1ToEarnedPath[s].field_256
                                                    idx = idx + 32
                                                    s = s + 1
                                                    continue 
                                                mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = ext_call.return_data[0]
                                                mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 64
                                                mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = token1ToEarnedPath.length
                                                mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 750 len floor32(token1ToEarnedPath.length)] = mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                staticcall address(uniRouterAddress).getAmountsOut(uint256 arg1, address[] arg2) with:
                                                        gas gas_remaining wei
                                                       args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 750 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                require return_data.size >= 32
                                                _29983 = mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28]
                                                require mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                require mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                require mem[mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] <= 4294967296 and mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * mem[mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]) + 32 <= return_data.size
                                                mem[(32 * _10744) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = mem[mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                _30048 = mem[_29983 + (32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                mem[(32 * _10744) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[_29983 + (32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650])] = mem[_29983 + (32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[_29983 + (32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650])]
                                                mem[64] = (32 * _30048) + (32 * _10744) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 746
                                                mem[(32 * _30048) + (32 * _10744) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] = 30
                                                mem[(32 * _30048) + (32 * _10744) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 714] = 'SafeMath: subtraction overflow'
                                                if 1 > mem[(32 * _10744) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require mem[(32 * _10744) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1 < mem[(32 * _10744) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                _31230 = mem[(32 * mem[(32 * _10744) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _10744) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                if not mem[(32 * mem[(32 * _10744) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _10744) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]:
                                                    mem[(32 * _30048) + (32 * _10744) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + sub_1b61e055, token1ToEarnedPath.length, mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _30048) + (32 * _10744) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                else:
                                                    require mem[(32 * mem[(32 * _10744) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _10744) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                    if mem[(32 * mem[(32 * _10744) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _10744) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] * slippageFactor / mem[(32 * mem[(32 * _10744) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _10744) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] != slippageFactor:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * _30048) + (32 * _10744) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 847 len 31]
                                                    mem[(32 * _30048) + (32 * _10744) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], _31230 * slippageFactor / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _30048) + (32 * _10744) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + sub_1b61e055
                                    else:
                                        if not ext_call.success:
                                            revert with approve(address arg1, uint256 arg2), Mask(224, 0, stor8), uint32(stor8), 2 * ext_call.return_data[0]
                                        if not approve(address arg1, uint256 arg2), Mask(224, 0, stor8):
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x775361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 727 len 22]
                                        mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 617] = token1ToEarnedPath.length
                                        if not token1ToEarnedPath.length:
                                            mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 653] = ext_call.return_data[0]
                                            mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 685] = 64
                                            mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 717] = token1ToEarnedPath.length
                                            mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 749 len floor32(token1ToEarnedPath.length)] = mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                            var125001 = floor32(token1ToEarnedPath.length)
                                            require ext_code.size(address(uniRouterAddress))
                                            staticcall address(uniRouterAddress).getAmountsOut(uint256 arg1, address[] arg2) with:
                                                    gas gas_remaining wei
                                                   args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 749 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649
                                            require return_data.size >= 32
                                            _24699 = mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28]
                                            require mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                            require mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                            require mem[mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] <= 4294967296 and mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * mem[mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]) + 32 <= return_data.size
                                            mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] = mem[mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]
                                            _24830 = mem[_24699 + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]
                                            mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[_24699 + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649])] = mem[_24699 + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[_24699 + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649])]
                                            mem[64] = (32 * _24830) + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745
                                            mem[(32 * _24830) + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] = 30
                                            mem[(32 * _24830) + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 713] = 'SafeMath: subtraction overflow'
                                            if 1 > mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1 < mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649]
                                            _27448 = mem[(32 * mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]
                                            if not mem[(32 * mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]:
                                                mem[(32 * _24830) + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                mem[(32 * _24830) + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                mem[(32 * _24830) + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _24830) + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                mem[(32 * _24830) + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845] = 0
                                                mem[(32 * _24830) + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                mem[(32 * _24830) + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + sub_1b61e055
                                                mem[(32 * _24830) + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                mem[(32 * _24830) + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                mem[(32 * _24830) + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + sub_1b61e055, token1ToEarnedPath.length, mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _24830) + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                            else:
                                                require mem[(32 * mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]
                                                if mem[(32 * mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] * slippageFactor / mem[(32 * mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] != slippageFactor:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * _24830) + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 846 len 31]
                                                mem[(32 * _24830) + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                mem[(32 * _24830) + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                mem[(32 * _24830) + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _24830) + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                mem[(32 * _24830) + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845] = _27448 * slippageFactor / 1000
                                                mem[(32 * _24830) + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                mem[(32 * _24830) + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + sub_1b61e055
                                                mem[(32 * _24830) + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                mem[(32 * _24830) + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                mem[(32 * _24830) + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], _27448 * slippageFactor / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _24830) + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + sub_1b61e055
                                        else:
                                            mem[0] = 33
                                            mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649] = address(token1ToEarnedPath.field_0)
                                            idx = (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649
                                            s = 0
                                            while (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 617 > idx:
                                                mem[idx + 32] = token1ToEarnedPath[s].field_256
                                                idx = idx + 32
                                                s = s + 1
                                                continue 
                                            mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 653] = ext_call.return_data[0]
                                            mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 685] = 64
                                            mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 717] = token1ToEarnedPath.length
                                            mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 749 len floor32(token1ToEarnedPath.length)] = mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                            require ext_code.size(address(uniRouterAddress))
                                            staticcall address(uniRouterAddress).getAmountsOut(uint256 arg1, address[] arg2) with:
                                                    gas gas_remaining wei
                                                   args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 749 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649
                                            require return_data.size >= 32
                                            _29979 = mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28]
                                            require mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                            require mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                            require mem[mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] <= 4294967296 and mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * mem[mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]) + 32 <= return_data.size
                                            mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] = mem[mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]
                                            _30046 = mem[_29979 + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]
                                            mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[_29979 + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649])] = mem[_29979 + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[_29979 + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649])]
                                            mem[64] = (32 * _30046) + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745
                                            mem[(32 * _30046) + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] = 30
                                            mem[(32 * _30046) + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 713] = 'SafeMath: subtraction overflow'
                                            if 1 > mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1 < mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649]
                                            _31224 = mem[(32 * mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]
                                            if not mem[(32 * mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]:
                                                mem[(32 * _30046) + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                mem[(32 * _30046) + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                mem[(32 * _30046) + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _30046) + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                mem[(32 * _30046) + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845] = 0
                                                mem[(32 * _30046) + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                mem[(32 * _30046) + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + sub_1b61e055
                                                mem[(32 * _30046) + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                mem[(32 * _30046) + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                mem[(32 * _30046) + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + sub_1b61e055, token1ToEarnedPath.length, mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _30046) + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                            else:
                                                require mem[(32 * mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]
                                                if mem[(32 * mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] * slippageFactor / mem[(32 * mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] != slippageFactor:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * _30046) + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 846 len 31]
                                                mem[(32 * _30046) + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                mem[(32 * _30046) + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                mem[(32 * _30046) + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _30046) + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                mem[(32 * _30046) + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845] = _31224 * slippageFactor / 1000
                                                mem[(32 * _30046) + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                mem[(32 * _30046) + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + sub_1b61e055
                                                mem[(32 * _30046) + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                mem[(32 * _30046) + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                mem[(32 * _30046) + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], _31224 * slippageFactor / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _30046) + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + sub_1b61e055
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                        else:
                            require mem[(32 * mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 325]
                            if mem[(32 * mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 325] * slippageFactor / mem[(32 * mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 325] != slippageFactor:
                                revert with 0, 
                                            32,
                                            33,
                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 490 len 31]
                            mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 389] = 26
                            mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 421] = 'SafeMath: division by zero'
                            mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token0ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token0ToEarnedPath.length)]
                            require ext_code.size(address(uniRouterAddress))
                            call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0], _14562 * slippageFactor / 1000, Array(len=token0ToEarnedPath.length, data=mem[ceil32(return_data.size) + 293 len floor32(token0ToEarnedPath.length)], mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + floor32(token0ToEarnedPath.length) + 649 len (32 * token0ToEarnedPath.length) - floor32(token0ToEarnedPath.length)]), address(this.address), block.timestamp + sub_1b61e055
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require ext_code.size(token1Address)
                            staticcall token1Address.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if token1Address != earnedAddress:
                                if ext_call.return_data[0] > 0:
                                    require ext_code.size(token1Address)
                                    staticcall token1Address.0xdd62ed3e with:
                                            gas gas_remaining wei
                                           args address(this.address), address(uniRouterAddress)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if 2 * ext_call.return_data[0] < ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 489] = address(uniRouterAddress)
                                    mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 521] = 2 * ext_call.return_data[0]
                                    mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 453] = 68
                                    mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 489 len 28] = Mask(224, 0, stor8)
                                    mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 485 len 4] = approve(address arg1, uint256 arg2)
                                    mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 553] = 32
                                    mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 585] = 'SafeERC20: low-level call failed'
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 
                                                    32,
                                                    38,
                                                    0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c,
                                                    mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 723 len 26]
                                    if ext_code.size(token1Address) <= 0:
                                        revert with 0, 'Address: call to non-contract'
                                    mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 617 len 64] = approve(address arg1, uint256 arg2), Mask(224, 0, stor8), uint32(stor8), Mask(224, 31, ext_call.return_data[0]) >> 31
                                    mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 709 len 4] = 0
                                    mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 681 len 0] = 0
                                    call token1Address with:
                                       funct uint32(stor8)
                                         gas gas_remaining wei
                                        args Mask(224, 31, ext_call.return_data[0]) << 225, mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 681 len 4]
                                    if return_data.size:
                                        mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 617] = return_data.size
                                        mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            if return_data.size > 0:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            revert with 0, 'SafeERC20: low-level call failed'
                                        if return_data.size <= 0:
                                            mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 618] = token1ToEarnedPath.length
                                            if not token1ToEarnedPath.length:
                                                mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = ext_call.return_data[0]
                                                mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 64
                                                mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = token1ToEarnedPath.length
                                                mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 750 len floor32(token1ToEarnedPath.length)] = mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                staticcall address(uniRouterAddress).getAmountsOut(uint256 arg1, address[] arg2) with:
                                                        gas gas_remaining wei
                                                       args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 750 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                require return_data.size >= 32
                                                _24693 = mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28]
                                                require mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                require mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                require mem[mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] <= 4294967296 and mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * mem[mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]) + 32 <= return_data.size
                                                mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = mem[mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                _24827 = mem[_24693 + (32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[_24693 + (32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650])] = mem[_24693 + (32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[_24693 + (32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650])]
                                                mem[64] = (32 * _24827) + (32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 746
                                                mem[(32 * _24827) + (32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] = 30
                                                mem[(32 * _24827) + (32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 714] = 'SafeMath: subtraction overflow'
                                                if 1 > mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1 < mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                _27439 = mem[(32 * mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                if not mem[(32 * mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]:
                                                    mem[(32 * _24827) + (32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + sub_1b61e055, token1ToEarnedPath.length, mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _24827) + (32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                else:
                                                    require mem[(32 * mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                    if mem[(32 * mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] * slippageFactor / mem[(32 * mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] != slippageFactor:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * _24827) + (32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 847 len 31]
                                                    mem[(32 * _24827) + (32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], _27439 * slippageFactor / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _24827) + (32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + sub_1b61e055
                                            else:
                                                mem[0] = 33
                                                mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650] = address(token1ToEarnedPath.field_0)
                                                idx = (32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650
                                                s = 0
                                                while (32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 618 > idx:
                                                    mem[idx + 32] = token1ToEarnedPath[s].field_256
                                                    idx = idx + 32
                                                    s = s + 1
                                                    continue 
                                                mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = ext_call.return_data[0]
                                                mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 64
                                                mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = token1ToEarnedPath.length
                                                mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 750 len floor32(token1ToEarnedPath.length)] = mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                staticcall address(uniRouterAddress).getAmountsOut(uint256 arg1, address[] arg2) with:
                                                        gas gas_remaining wei
                                                       args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 750 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                require return_data.size >= 32
                                                _29973 = mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28]
                                                require mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                require mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                require mem[mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] <= 4294967296 and mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * mem[mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]) + 32 <= return_data.size
                                                mem[(32 * _10744) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = mem[mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                _30043 = mem[_29973 + (32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                mem[(32 * _10744) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[_29973 + (32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650])] = mem[_29973 + (32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[_29973 + (32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650])]
                                                mem[64] = (32 * _30043) + (32 * _10744) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 746
                                                mem[(32 * _30043) + (32 * _10744) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] = 30
                                                mem[(32 * _30043) + (32 * _10744) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 714] = 'SafeMath: subtraction overflow'
                                                if 1 > mem[(32 * _10744) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require mem[(32 * _10744) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1 < mem[(32 * _10744) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                _31215 = mem[(32 * mem[(32 * _10744) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _10744) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                if not mem[(32 * mem[(32 * _10744) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _10744) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]:
                                                    mem[(32 * _30043) + (32 * _10744) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + sub_1b61e055, token1ToEarnedPath.length, mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _30043) + (32 * _10744) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                else:
                                                    require mem[(32 * mem[(32 * _10744) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _10744) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                    if mem[(32 * mem[(32 * _10744) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _10744) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] * slippageFactor / mem[(32 * mem[(32 * _10744) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _10744) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] != slippageFactor:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * _30043) + (32 * _10744) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 847 len 31]
                                                    mem[(32 * _30043) + (32 * _10744) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], _31215 * slippageFactor / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _30043) + (32 * _10744) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + sub_1b61e055
                                        else:
                                            require return_data.size >= 32
                                            if not mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649]:
                                                revert with 0, 
                                                            32,
                                                            42,
                                                            0x775361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                            mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 728 len 22]
                                            mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 618] = token1ToEarnedPath.length
                                            if not token1ToEarnedPath.length:
                                                mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = ext_call.return_data[0]
                                                mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 64
                                                mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = token1ToEarnedPath.length
                                                mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 750 len floor32(token1ToEarnedPath.length)] = mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                staticcall address(uniRouterAddress).getAmountsOut(uint256 arg1, address[] arg2) with:
                                                        gas gas_remaining wei
                                                       args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 750 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                require return_data.size >= 32
                                                _24695 = mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28]
                                                require mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                require mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                require mem[mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] <= 4294967296 and mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * mem[mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]) + 32 <= return_data.size
                                                mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = mem[mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                _24828 = mem[_24695 + (32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[_24695 + (32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650])] = mem[_24695 + (32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[_24695 + (32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650])]
                                                mem[64] = (32 * _24828) + (32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 746
                                                mem[(32 * _24828) + (32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] = 30
                                                mem[(32 * _24828) + (32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 714] = 'SafeMath: subtraction overflow'
                                                if 1 > mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1 < mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                _27442 = mem[(32 * mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                if not mem[(32 * mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]:
                                                    mem[(32 * _24828) + (32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + sub_1b61e055, token1ToEarnedPath.length, mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _24828) + (32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                else:
                                                    require mem[(32 * mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                    if mem[(32 * mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] * slippageFactor / mem[(32 * mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] != slippageFactor:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * _24828) + (32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 847 len 31]
                                                    mem[(32 * _24828) + (32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], _27442 * slippageFactor / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _24828) + (32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + sub_1b61e055
                                            else:
                                                mem[0] = 33
                                                mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650] = address(token1ToEarnedPath.field_0)
                                                idx = (32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650
                                                s = 0
                                                while (32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 618 > idx:
                                                    mem[idx + 32] = token1ToEarnedPath[s].field_256
                                                    idx = idx + 32
                                                    s = s + 1
                                                    continue 
                                                mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = ext_call.return_data[0]
                                                mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 64
                                                mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = token1ToEarnedPath.length
                                                mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 750 len floor32(token1ToEarnedPath.length)] = mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                staticcall address(uniRouterAddress).getAmountsOut(uint256 arg1, address[] arg2) with:
                                                        gas gas_remaining wei
                                                       args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 750 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                require return_data.size >= 32
                                                _29975 = mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28]
                                                require mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                require mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                require mem[mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] <= 4294967296 and mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * mem[mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]) + 32 <= return_data.size
                                                mem[(32 * _10744) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = mem[mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                _30044 = mem[_29975 + (32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                mem[(32 * _10744) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[_29975 + (32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650])] = mem[_29975 + (32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[_29975 + (32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650])]
                                                mem[64] = (32 * _30044) + (32 * _10744) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 746
                                                mem[(32 * _30044) + (32 * _10744) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] = 30
                                                mem[(32 * _30044) + (32 * _10744) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 714] = 'SafeMath: subtraction overflow'
                                                if 1 > mem[(32 * _10744) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require mem[(32 * _10744) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1 < mem[(32 * _10744) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                _31218 = mem[(32 * mem[(32 * _10744) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _10744) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                if not mem[(32 * mem[(32 * _10744) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _10744) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]:
                                                    mem[(32 * _30044) + (32 * _10744) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + sub_1b61e055, token1ToEarnedPath.length, mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _30044) + (32 * _10744) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                else:
                                                    require mem[(32 * mem[(32 * _10744) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _10744) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                    if mem[(32 * mem[(32 * _10744) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _10744) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] * slippageFactor / mem[(32 * mem[(32 * _10744) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _10744) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] != slippageFactor:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * _30044) + (32 * _10744) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 847 len 31]
                                                    mem[(32 * _30044) + (32 * _10744) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], _31218 * slippageFactor / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _10744) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _30044) + (32 * _10744) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + sub_1b61e055
                                    else:
                                        if not ext_call.success:
                                            revert with approve(address arg1, uint256 arg2), Mask(224, 0, stor8), uint32(stor8), 2 * ext_call.return_data[0]
                                        if not approve(address arg1, uint256 arg2), Mask(224, 0, stor8):
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x775361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 727 len 22]
                                        mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 617] = token1ToEarnedPath.length
                                        if not token1ToEarnedPath.length:
                                            mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 653] = ext_call.return_data[0]
                                            mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 685] = 64
                                            mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 717] = token1ToEarnedPath.length
                                            mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 749 len floor32(token1ToEarnedPath.length)] = mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                            require ext_code.size(address(uniRouterAddress))
                                            staticcall address(uniRouterAddress).getAmountsOut(uint256 arg1, address[] arg2) with:
                                                    gas gas_remaining wei
                                                   args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 749 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649
                                            require return_data.size >= 32
                                            _24691 = mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28]
                                            require mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                            require mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                            require mem[mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] <= 4294967296 and mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * mem[mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]) + 32 <= return_data.size
                                            mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] = mem[mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]
                                            _24826 = mem[_24691 + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]
                                            mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[_24691 + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649])] = mem[_24691 + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[_24691 + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649])]
                                            mem[64] = (32 * _24826) + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745
                                            mem[(32 * _24826) + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] = 30
                                            mem[(32 * _24826) + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 713] = 'SafeMath: subtraction overflow'
                                            if 1 > mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1 < mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649]
                                            _27436 = mem[(32 * mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]
                                            if not mem[(32 * mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]:
                                                mem[(32 * _24826) + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                mem[(32 * _24826) + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                mem[(32 * _24826) + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _24826) + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                mem[(32 * _24826) + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845] = 0
                                                mem[(32 * _24826) + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                mem[(32 * _24826) + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + sub_1b61e055
                                                mem[(32 * _24826) + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                mem[(32 * _24826) + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                mem[(32 * _24826) + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + sub_1b61e055, token1ToEarnedPath.length, mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _24826) + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                            else:
                                                require mem[(32 * mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]
                                                if mem[(32 * mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] * slippageFactor / mem[(32 * mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] != slippageFactor:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * _24826) + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 846 len 31]
                                                mem[(32 * _24826) + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                mem[(32 * _24826) + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                mem[(32 * _24826) + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _24826) + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                mem[(32 * _24826) + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845] = _27436 * slippageFactor / 1000
                                                mem[(32 * _24826) + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                mem[(32 * _24826) + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + sub_1b61e055
                                                mem[(32 * _24826) + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                mem[(32 * _24826) + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                mem[(32 * _24826) + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], _27436 * slippageFactor / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _24826) + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + sub_1b61e055
                                        else:
                                            mem[0] = 33
                                            mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649] = address(token1ToEarnedPath.field_0)
                                            idx = (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649
                                            s = 0
                                            while (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 617 > idx:
                                                mem[idx + 32] = token1ToEarnedPath[s].field_256
                                                idx = idx + 32
                                                s = s + 1
                                                continue 
                                            mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 653] = ext_call.return_data[0]
                                            mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 685] = 64
                                            mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 717] = token1ToEarnedPath.length
                                            mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 749 len floor32(token1ToEarnedPath.length)] = mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                            require ext_code.size(address(uniRouterAddress))
                                            staticcall address(uniRouterAddress).getAmountsOut(uint256 arg1, address[] arg2) with:
                                                    gas gas_remaining wei
                                                   args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 749 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649
                                            require return_data.size >= 32
                                            _29971 = mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28]
                                            require mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                            require mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                            require mem[mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] <= 4294967296 and mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * mem[mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]) + 32 <= return_data.size
                                            mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] = mem[mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]
                                            _30042 = mem[_29971 + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]
                                            mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[_29971 + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649])] = mem[_29971 + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[_29971 + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649])]
                                            mem[64] = (32 * _30042) + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745
                                            mem[(32 * _30042) + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] = 30
                                            mem[(32 * _30042) + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 713] = 'SafeMath: subtraction overflow'
                                            if 1 > mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1 < mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649]
                                            _31212 = mem[(32 * mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]
                                            if not mem[(32 * mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]:
                                                mem[(32 * _30042) + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                mem[(32 * _30042) + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                mem[(32 * _30042) + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _30042) + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                mem[(32 * _30042) + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845] = 0
                                                mem[(32 * _30042) + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                mem[(32 * _30042) + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + sub_1b61e055
                                                mem[(32 * _30042) + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                mem[(32 * _30042) + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                mem[(32 * _30042) + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + sub_1b61e055, token1ToEarnedPath.length, mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _30042) + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                            else:
                                                require mem[(32 * mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]
                                                if mem[(32 * mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] * slippageFactor / mem[(32 * mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] != slippageFactor:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * _30042) + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 846 len 31]
                                                mem[(32 * _30042) + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                mem[(32 * _30042) + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                mem[(32 * _30042) + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _30042) + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                mem[(32 * _30042) + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845] = _31212 * slippageFactor / 1000
                                                mem[(32 * _30042) + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                mem[(32 * _30042) + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + sub_1b61e055
                                                mem[(32 * _30042) + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                mem[(32 * _30042) + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                mem[(32 * _30042) + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], _31212 * slippageFactor / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _30042) + (32 * _10744) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + sub_1b61e055
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
}



}
