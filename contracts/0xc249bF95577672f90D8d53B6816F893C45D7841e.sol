contract main {




// =====================  Runtime code  =====================


#
#  - leaveStaking(uint256 arg1)
#  - add(uint256 arg1, address arg2, bool arg3)
#  - enterStaking(uint256 arg1)
#  - withdraw(uint256 arg1, uint256 arg2)
#  - emergencyWithdraw(uint256 arg1)
#  - deposit(uint256 arg1, uint256 arg2)
#
address owner;
address brushAddress;
address wftmAddress;
uint256 brushPerSecond;
address artGalleryAddress;
address routerAddress;
array of struct poolInfo;
uint256 stor7;
uint256 stor8;
uint8 stor9;
mapping of struct userInfo;
uint256 totalAllocPoint;
uint256 startTime;
mapping of uint256 maxBurnAndBuyBackAmounts;
mapping of uint8 stor15;

function poolLength() payable {
    return poolInfo.length
}

function poolInfo(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 < poolInfo.length
    return poolInfo[arg1].field_0, poolInfo[arg1].field_256, poolInfo[arg1].field_512, poolInfo[arg1].field_768
}

function totalAllocPoint() payable {
    return totalAllocPoint
}

function poolExists(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    return bool(stor15[address(arg1)])
}

function artGallery() payable {
    return artGalleryAddress
}

function brushPerSecond() payable {
    return brushPerSecond
}

function brush() payable {
    return brushAddress
}

function startTime() payable {
    return startTime
}

function owner() payable {
    return owner
}

function userInfo(uint256 arg1, address arg2) payable {
    require calldata.size - 4 >= 64
    require arg2 == arg2
    return userInfo[arg1][arg2].field_0, userInfo[arg1][arg2].field_256
}

function wftm() payable {
    return wftmAddress
}

function router() payable {
    return routerAddress
}

function maxBurnAndBuyBackAmounts(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    return maxBurnAndBuyBackAmounts[arg1]
}

function _fallback() payable {
    revert
}

function renounceOwnership() payable {
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    emit OwnershipTransferred(owner, 0);
    owner = 0
}

function setInverseWithdrawFeeLP(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    require arg1 > 0
    stor8 = arg1
}

function setInverseWithdrawFeeSingle(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    require arg1 > 0
    stor7 = arg1
}

function setDepositsDisabled(bool arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    stor9 = uint8(arg1)
}

function transferOwnership(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Ownable: new owner is the zero address'
    emit OwnershipTransferred(owner, arg1);
    owner = arg1
}

function setStartTime(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    require arg1 > block.timestamp
    require startTime > block.timestamp
    startTime = arg1
    idx = 0
    while idx < poolInfo.length:
        mem[0] = 6
        poolInfo[idx].field_512 = startTime
        if idx == -1:
            revert with 0, 17
        idx = idx + 1
        continue 
}

function updatePool(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if arg1 >= poolInfo.length:
        revert with 0, 50
    if block.timestamp > poolInfo[arg1].field_512:
        require ext_code.size(poolInfo[arg1].field_0)
        staticcall poolInfo[arg1].field_0.0x70a08231 with:
                gas gas_remaining wei
               args this.address
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if ext_call.return_data[0]:
            if poolInfo[arg1].field_256:
                if block.timestamp < startTime:
                    if not totalAllocPoint:
                        revert with 0, 'SafeMath: division by zero', 0
                    require ext_code.size(brushAddress)
                    call brushAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args this.address, 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if not 0 / totalAllocPoint:
                        if not ext_call.return_data[0]:
                            revert with 0, 'SafeMath: division by zero', 0
                        if poolInfo[arg1].field_768 > !(0 / ext_call.return_data[0]):
                            revert with 0, 17
                        if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                    else:
                        if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                            revert with 0, 17
                        if not 0 / totalAllocPoint:
                            revert with 0, 18
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not ext_call.return_data[0]:
                            revert with 0, 'SafeMath: division by zero', 0
                        if poolInfo[arg1].field_768 > !(10^12 * 0 / totalAllocPoint / ext_call.return_data[0]):
                            revert with 0, 17
                        if poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                else:
                    if block.timestamp < poolInfo[arg1].field_512:
                        revert with 0, 17
                    if not block.timestamp - poolInfo[arg1].field_512:
                        if not totalAllocPoint:
                            revert with 0, 'SafeMath: division by zero', 0
                        require ext_code.size(brushAddress)
                        call brushAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args this.address, 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if not 0 / totalAllocPoint:
                            if not ext_call.return_data[0]:
                                revert with 0, 'SafeMath: division by zero', 0
                            if poolInfo[arg1].field_768 > !(0 / ext_call.return_data[0]):
                                revert with 0, 17
                            if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                        else:
                            if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                                revert with 0, 17
                            if not 0 / totalAllocPoint:
                                revert with 0, 18
                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not ext_call.return_data[0]:
                                revert with 0, 'SafeMath: division by zero', 0
                            if poolInfo[arg1].field_768 > !(10^12 * 0 / totalAllocPoint / ext_call.return_data[0]):
                                revert with 0, 17
                            if poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                    else:
                        if block.timestamp - poolInfo[arg1].field_512 and brushPerSecond > -1 / block.timestamp - poolInfo[arg1].field_512:
                            revert with 0, 17
                        if not block.timestamp - poolInfo[arg1].field_512:
                            revert with 0, 18
                        if (block.timestamp * brushPerSecond) - (poolInfo[arg1].field_512 * brushPerSecond) / block.timestamp - poolInfo[arg1].field_512 != brushPerSecond:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not (block.timestamp * brushPerSecond) - (poolInfo[arg1].field_512 * brushPerSecond):
                            if not totalAllocPoint:
                                revert with 0, 'SafeMath: division by zero', 0
                            require ext_code.size(brushAddress)
                            call brushAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args this.address, 0 / totalAllocPoint
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if not 0 / totalAllocPoint:
                                if not ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if poolInfo[arg1].field_768 > !(0 / ext_call.return_data[0]):
                                    revert with 0, 17
                                if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                            else:
                                if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                                    revert with 0, 17
                                if not 0 / totalAllocPoint:
                                    revert with 0, 18
                                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if poolInfo[arg1].field_768 > !(10^12 * 0 / totalAllocPoint / ext_call.return_data[0]):
                                    revert with 0, 17
                                if poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                        else:
                            if (block.timestamp * brushPerSecond) - (poolInfo[arg1].field_512 * brushPerSecond) and poolInfo[arg1].field_256 > -1 / (block.timestamp * brushPerSecond) - (poolInfo[arg1].field_512 * brushPerSecond):
                                revert with 0, 17
                            if not (block.timestamp * brushPerSecond) - (poolInfo[arg1].field_512 * brushPerSecond):
                                revert with 0, 18
                            if (block.timestamp * brushPerSecond * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * brushPerSecond * poolInfo[arg1].field_256) / (block.timestamp * brushPerSecond) - (poolInfo[arg1].field_512 * brushPerSecond) != poolInfo[arg1].field_256:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not totalAllocPoint:
                                revert with 0, 'SafeMath: division by zero', 0
                            require ext_code.size(brushAddress)
                            call brushAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args this.address, (block.timestamp * brushPerSecond * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * brushPerSecond * poolInfo[arg1].field_256) / totalAllocPoint
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if not (block.timestamp * brushPerSecond * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * brushPerSecond * poolInfo[arg1].field_256) / totalAllocPoint:
                                if not ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if poolInfo[arg1].field_768 > !(0 / ext_call.return_data[0]):
                                    revert with 0, 17
                                if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                            else:
                                if (block.timestamp * brushPerSecond * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * brushPerSecond * poolInfo[arg1].field_256) / totalAllocPoint and 10^12 > -1 / (block.timestamp * brushPerSecond * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * brushPerSecond * poolInfo[arg1].field_256) / totalAllocPoint:
                                    revert with 0, 17
                                if not (block.timestamp * brushPerSecond * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * brushPerSecond * poolInfo[arg1].field_256) / totalAllocPoint:
                                    revert with 0, 18
                                if 10^12 * (block.timestamp * brushPerSecond * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * brushPerSecond * poolInfo[arg1].field_256) / totalAllocPoint / (block.timestamp * brushPerSecond * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * brushPerSecond * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if poolInfo[arg1].field_768 > !(10^12 * (block.timestamp * brushPerSecond * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * brushPerSecond * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]):
                                    revert with 0, 17
                                if poolInfo[arg1].field_768 + (10^12 * (block.timestamp * brushPerSecond * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * brushPerSecond * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[arg1].field_768 += 10^12 * (block.timestamp * brushPerSecond * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * brushPerSecond * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]
        poolInfo[arg1].field_512 = block.timestamp
}

function massUpdatePools() payable {
    mem[64] = 96
    idx = 0
    while idx < poolInfo.length:
        mem[0] = 6
        if block.timestamp <= poolInfo[idx].field_512:
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        mem[mem[64] + 4] = this.address
        require ext_code.size(poolInfo[idx].field_0)
        staticcall poolInfo[idx].field_0.0x70a08231 with:
                gas gas_remaining wei
               args this.address
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _117 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _118 = mem[_117]
        if not mem[_117]:
            poolInfo[idx].field_512 = block.timestamp
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        if not poolInfo[idx].field_256:
            poolInfo[idx].field_512 = block.timestamp
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        if block.timestamp < startTime:
            _119 = mem[64]
            mem[64] = mem[64] + 64
            mem[_119] = 26
            mem[_119 + 32] = 'SafeMath: division by zero'
            if not totalAllocPoint:
                _122 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _122 + 68] = mem[idx + _119 + 32]
                    idx = idx + 32
                    continue 
                mem[_122 + 94] = 0
                revert with memory
                  from mem[64]
                   len _122 + -mem[64] + 100
            mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = this.address
            mem[mem[64] + 36] = 0 / totalAllocPoint
            require ext_code.size(brushAddress)
            call brushAddress.0x40c10f19 with:
                 gas gas_remaining wei
                args this.address, 0 / totalAllocPoint
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if not 0 / totalAllocPoint:
                _144 = mem[64]
                mem[64] = mem[64] + 64
                mem[_144] = 26
                mem[_144 + 32] = 'SafeMath: division by zero'
                if _118:
                    if poolInfo[idx].field_768 > !(0 / _118):
                        revert with 0, 17
                    if poolInfo[idx].field_768 + (0 / _118) < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 0 / _118
                    poolInfo[idx].field_512 = block.timestamp
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                _149 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _149 + 68] = mem[idx + _144 + 32]
                    idx = idx + 32
                    continue 
                mem[_149 + 94] = 0
                revert with memory
                  from mem[64]
                   len _149 + -mem[64] + 100
            if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                revert with 0, 17
            if not 0 / totalAllocPoint:
                revert with 0, 18
            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                revert with 0, 'SafeMath: multiplication overflow'
            _160 = mem[64]
            mem[64] = mem[64] + 64
            mem[_160] = 26
            mem[_160 + 32] = 'SafeMath: division by zero'
            if _118:
                if poolInfo[idx].field_768 > !(10^12 * 0 / totalAllocPoint / _118):
                    revert with 0, 17
                if poolInfo[idx].field_768 + (10^12 * 0 / totalAllocPoint / _118) < poolInfo[idx].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / _118
                poolInfo[idx].field_512 = block.timestamp
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            _168 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _168 + 68] = mem[idx + _160 + 32]
                idx = idx + 32
                continue 
            mem[_168 + 94] = 0
            revert with memory
              from mem[64]
               len _168 + -mem[64] + 100
        if block.timestamp < poolInfo[idx].field_512:
            revert with 0, 17
        if not block.timestamp - poolInfo[idx].field_512:
            _121 = mem[64]
            mem[64] = mem[64] + 64
            mem[_121] = 26
            mem[_121 + 32] = 'SafeMath: division by zero'
            if not totalAllocPoint:
                _125 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _125 + 68] = mem[idx + _121 + 32]
                    idx = idx + 32
                    continue 
                mem[_125 + 94] = 0
                revert with memory
                  from mem[64]
                   len _125 + -mem[64] + 100
            mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = this.address
            mem[mem[64] + 36] = 0 / totalAllocPoint
            require ext_code.size(brushAddress)
            call brushAddress.0x40c10f19 with:
                 gas gas_remaining wei
                args this.address, 0 / totalAllocPoint
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if not 0 / totalAllocPoint:
                _148 = mem[64]
                mem[64] = mem[64] + 64
                mem[_148] = 26
                mem[_148 + 32] = 'SafeMath: division by zero'
                if _118:
                    if poolInfo[idx].field_768 > !(0 / _118):
                        revert with 0, 17
                    if poolInfo[idx].field_768 + (0 / _118) < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 0 / _118
                    poolInfo[idx].field_512 = block.timestamp
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                _154 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _154 + 68] = mem[idx + _148 + 32]
                    idx = idx + 32
                    continue 
                mem[_154 + 94] = 0
                revert with memory
                  from mem[64]
                   len _154 + -mem[64] + 100
            if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                revert with 0, 17
            if not 0 / totalAllocPoint:
                revert with 0, 18
            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                revert with 0, 'SafeMath: multiplication overflow'
            _166 = mem[64]
            mem[64] = mem[64] + 64
            mem[_166] = 26
            mem[_166 + 32] = 'SafeMath: division by zero'
            if _118:
                if poolInfo[idx].field_768 > !(10^12 * 0 / totalAllocPoint / _118):
                    revert with 0, 17
                if poolInfo[idx].field_768 + (10^12 * 0 / totalAllocPoint / _118) < poolInfo[idx].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / _118
                poolInfo[idx].field_512 = block.timestamp
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            _175 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _175 + 68] = mem[idx + _166 + 32]
                idx = idx + 32
                continue 
            mem[_175 + 94] = 0
            revert with memory
              from mem[64]
               len _175 + -mem[64] + 100
        if block.timestamp - poolInfo[idx].field_512 and brushPerSecond > -1 / block.timestamp - poolInfo[idx].field_512:
            revert with 0, 17
        if not block.timestamp - poolInfo[idx].field_512:
            revert with 0, 18
        if (block.timestamp * brushPerSecond) - (poolInfo[idx].field_512 * brushPerSecond) / block.timestamp - poolInfo[idx].field_512 != brushPerSecond:
            revert with 0, 'SafeMath: multiplication overflow'
        if not (block.timestamp * brushPerSecond) - (poolInfo[idx].field_512 * brushPerSecond):
            _130 = mem[64]
            mem[64] = mem[64] + 64
            mem[_130] = 26
            mem[_130 + 32] = 'SafeMath: division by zero'
            if not totalAllocPoint:
                _136 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _136 + 68] = mem[idx + _130 + 32]
                    idx = idx + 32
                    continue 
                mem[_136 + 94] = 0
                revert with memory
                  from mem[64]
                   len _136 + -mem[64] + 100
            mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = this.address
            mem[mem[64] + 36] = 0 / totalAllocPoint
            require ext_code.size(brushAddress)
            call brushAddress.0x40c10f19 with:
                 gas gas_remaining wei
                args this.address, 0 / totalAllocPoint
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if not 0 / totalAllocPoint:
                _165 = mem[64]
                mem[64] = mem[64] + 64
                mem[_165] = 26
                mem[_165 + 32] = 'SafeMath: division by zero'
                if _118:
                    if poolInfo[idx].field_768 > !(0 / _118):
                        revert with 0, 17
                    if poolInfo[idx].field_768 + (0 / _118) < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 0 / _118
                    poolInfo[idx].field_512 = block.timestamp
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                _174 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _174 + 68] = mem[idx + _165 + 32]
                    idx = idx + 32
                    continue 
                mem[_174 + 94] = 0
                revert with memory
                  from mem[64]
                   len _174 + -mem[64] + 100
            if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                revert with 0, 17
            if not 0 / totalAllocPoint:
                revert with 0, 18
            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                revert with 0, 'SafeMath: multiplication overflow'
            _186 = mem[64]
            mem[64] = mem[64] + 64
            mem[_186] = 26
            mem[_186 + 32] = 'SafeMath: division by zero'
            if _118:
                if poolInfo[idx].field_768 > !(10^12 * 0 / totalAllocPoint / _118):
                    revert with 0, 17
                if poolInfo[idx].field_768 + (10^12 * 0 / totalAllocPoint / _118) < poolInfo[idx].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / _118
                poolInfo[idx].field_512 = block.timestamp
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            _194 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _194 + 68] = mem[idx + _186 + 32]
                idx = idx + 32
                continue 
            mem[_194 + 94] = 0
            revert with memory
              from mem[64]
               len _194 + -mem[64] + 100
        if (block.timestamp * brushPerSecond) - (poolInfo[idx].field_512 * brushPerSecond) and poolInfo[idx].field_256 > -1 / (block.timestamp * brushPerSecond) - (poolInfo[idx].field_512 * brushPerSecond):
            revert with 0, 17
        if not (block.timestamp * brushPerSecond) - (poolInfo[idx].field_512 * brushPerSecond):
            revert with 0, 18
        if (block.timestamp * brushPerSecond * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * brushPerSecond * poolInfo[idx].field_256) / (block.timestamp * brushPerSecond) - (poolInfo[idx].field_512 * brushPerSecond) != poolInfo[idx].field_256:
            revert with 0, 'SafeMath: multiplication overflow'
        _142 = mem[64]
        mem[64] = mem[64] + 64
        mem[_142] = 26
        mem[_142 + 32] = 'SafeMath: division by zero'
        if not totalAllocPoint:
            _147 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _147 + 68] = mem[idx + _142 + 32]
                idx = idx + 32
                continue 
            mem[_147 + 94] = 0
            revert with memory
              from mem[64]
               len _147 + -mem[64] + 100
        mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = this.address
        mem[mem[64] + 36] = (block.timestamp * brushPerSecond * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * brushPerSecond * poolInfo[idx].field_256) / totalAllocPoint
        require ext_code.size(brushAddress)
        call brushAddress.0x40c10f19 with:
             gas gas_remaining wei
            args this.address, (block.timestamp * brushPerSecond * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * brushPerSecond * poolInfo[idx].field_256) / totalAllocPoint
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        if not (block.timestamp * brushPerSecond * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * brushPerSecond * poolInfo[idx].field_256) / totalAllocPoint:
            _185 = mem[64]
            mem[64] = mem[64] + 64
            mem[_185] = 26
            mem[_185 + 32] = 'SafeMath: division by zero'
            if _118:
                if poolInfo[idx].field_768 > !(0 / _118):
                    revert with 0, 17
                if poolInfo[idx].field_768 + (0 / _118) < poolInfo[idx].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                poolInfo[idx].field_768 += 0 / _118
                poolInfo[idx].field_512 = block.timestamp
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            _193 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _193 + 68] = mem[idx + _185 + 32]
                idx = idx + 32
                continue 
            mem[_193 + 94] = 0
            revert with memory
              from mem[64]
               len _193 + -mem[64] + 100
        if (block.timestamp * brushPerSecond * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * brushPerSecond * poolInfo[idx].field_256) / totalAllocPoint and 10^12 > -1 / (block.timestamp * brushPerSecond * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * brushPerSecond * poolInfo[idx].field_256) / totalAllocPoint:
            revert with 0, 17
        if not (block.timestamp * brushPerSecond * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * brushPerSecond * poolInfo[idx].field_256) / totalAllocPoint:
            revert with 0, 18
        if 10^12 * (block.timestamp * brushPerSecond * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * brushPerSecond * poolInfo[idx].field_256) / totalAllocPoint / (block.timestamp * brushPerSecond * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * brushPerSecond * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
            revert with 0, 'SafeMath: multiplication overflow'
        _205 = mem[64]
        mem[64] = mem[64] + 64
        mem[_205] = 26
        mem[_205 + 32] = 'SafeMath: division by zero'
        if _118:
            if poolInfo[idx].field_768 > !(10^12 * (block.timestamp * brushPerSecond * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * brushPerSecond * poolInfo[idx].field_256) / totalAllocPoint / _118):
                revert with 0, 17
            if poolInfo[idx].field_768 + (10^12 * (block.timestamp * brushPerSecond * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * brushPerSecond * poolInfo[idx].field_256) / totalAllocPoint / _118) < poolInfo[idx].field_768:
                revert with 0, 'SafeMath: addition overflow'
            poolInfo[idx].field_768 += 10^12 * (block.timestamp * brushPerSecond * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * brushPerSecond * poolInfo[idx].field_256) / totalAllocPoint / _118
            poolInfo[idx].field_512 = block.timestamp
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        _212 = mem[64]
        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = 32
        mem[mem[64] + 36] = 26
        idx = 0
        while idx < 26:
            mem[idx + _212 + 68] = mem[idx + _205 + 32]
            idx = idx + 32
            continue 
        mem[_212 + 94] = 0
        revert with memory
          from mem[64]
           len _212 + -mem[64] + 100
}

function setBrushPerSecondEmissionRate(uint256 arg1) payable {
    mem[64] = 96
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    idx = 0
    while idx < poolInfo.length:
        mem[0] = 6
        if block.timestamp <= poolInfo[idx].field_512:
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        mem[mem[64] + 4] = this.address
        require ext_code.size(poolInfo[idx].field_0)
        staticcall poolInfo[idx].field_0.0x70a08231 with:
                gas gas_remaining wei
               args this.address
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _119 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _120 = mem[_119]
        if not mem[_119]:
            poolInfo[idx].field_512 = block.timestamp
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        if not poolInfo[idx].field_256:
            poolInfo[idx].field_512 = block.timestamp
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        if block.timestamp < startTime:
            _121 = mem[64]
            mem[64] = mem[64] + 64
            mem[_121] = 26
            mem[_121 + 32] = 'SafeMath: division by zero'
            if not totalAllocPoint:
                _124 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _124 + 68] = mem[idx + _121 + 32]
                    idx = idx + 32
                    continue 
                mem[_124 + 94] = 0
                revert with memory
                  from mem[64]
                   len _124 + -mem[64] + 100
            mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = this.address
            mem[mem[64] + 36] = 0 / totalAllocPoint
            require ext_code.size(brushAddress)
            call brushAddress.0x40c10f19 with:
                 gas gas_remaining wei
                args this.address, 0 / totalAllocPoint
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if not 0 / totalAllocPoint:
                _146 = mem[64]
                mem[64] = mem[64] + 64
                mem[_146] = 26
                mem[_146 + 32] = 'SafeMath: division by zero'
                if _120:
                    if poolInfo[idx].field_768 > !(0 / _120):
                        revert with 0, 17
                    if poolInfo[idx].field_768 + (0 / _120) < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 0 / _120
                    poolInfo[idx].field_512 = block.timestamp
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                _151 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _151 + 68] = mem[idx + _146 + 32]
                    idx = idx + 32
                    continue 
                mem[_151 + 94] = 0
                revert with memory
                  from mem[64]
                   len _151 + -mem[64] + 100
            if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                revert with 0, 17
            if not 0 / totalAllocPoint:
                revert with 0, 18
            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                revert with 0, 'SafeMath: multiplication overflow'
            _162 = mem[64]
            mem[64] = mem[64] + 64
            mem[_162] = 26
            mem[_162 + 32] = 'SafeMath: division by zero'
            if _120:
                if poolInfo[idx].field_768 > !(10^12 * 0 / totalAllocPoint / _120):
                    revert with 0, 17
                if poolInfo[idx].field_768 + (10^12 * 0 / totalAllocPoint / _120) < poolInfo[idx].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / _120
                poolInfo[idx].field_512 = block.timestamp
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            _170 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _170 + 68] = mem[idx + _162 + 32]
                idx = idx + 32
                continue 
            mem[_170 + 94] = 0
            revert with memory
              from mem[64]
               len _170 + -mem[64] + 100
        if block.timestamp < poolInfo[idx].field_512:
            revert with 0, 17
        if not block.timestamp - poolInfo[idx].field_512:
            _123 = mem[64]
            mem[64] = mem[64] + 64
            mem[_123] = 26
            mem[_123 + 32] = 'SafeMath: division by zero'
            if not totalAllocPoint:
                _127 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _127 + 68] = mem[idx + _123 + 32]
                    idx = idx + 32
                    continue 
                mem[_127 + 94] = 0
                revert with memory
                  from mem[64]
                   len _127 + -mem[64] + 100
            mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = this.address
            mem[mem[64] + 36] = 0 / totalAllocPoint
            require ext_code.size(brushAddress)
            call brushAddress.0x40c10f19 with:
                 gas gas_remaining wei
                args this.address, 0 / totalAllocPoint
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if not 0 / totalAllocPoint:
                _150 = mem[64]
                mem[64] = mem[64] + 64
                mem[_150] = 26
                mem[_150 + 32] = 'SafeMath: division by zero'
                if _120:
                    if poolInfo[idx].field_768 > !(0 / _120):
                        revert with 0, 17
                    if poolInfo[idx].field_768 + (0 / _120) < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 0 / _120
                    poolInfo[idx].field_512 = block.timestamp
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                _156 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _156 + 68] = mem[idx + _150 + 32]
                    idx = idx + 32
                    continue 
                mem[_156 + 94] = 0
                revert with memory
                  from mem[64]
                   len _156 + -mem[64] + 100
            if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                revert with 0, 17
            if not 0 / totalAllocPoint:
                revert with 0, 18
            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                revert with 0, 'SafeMath: multiplication overflow'
            _168 = mem[64]
            mem[64] = mem[64] + 64
            mem[_168] = 26
            mem[_168 + 32] = 'SafeMath: division by zero'
            if _120:
                if poolInfo[idx].field_768 > !(10^12 * 0 / totalAllocPoint / _120):
                    revert with 0, 17
                if poolInfo[idx].field_768 + (10^12 * 0 / totalAllocPoint / _120) < poolInfo[idx].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / _120
                poolInfo[idx].field_512 = block.timestamp
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            _177 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _177 + 68] = mem[idx + _168 + 32]
                idx = idx + 32
                continue 
            mem[_177 + 94] = 0
            revert with memory
              from mem[64]
               len _177 + -mem[64] + 100
        if block.timestamp - poolInfo[idx].field_512 and brushPerSecond > -1 / block.timestamp - poolInfo[idx].field_512:
            revert with 0, 17
        if not block.timestamp - poolInfo[idx].field_512:
            revert with 0, 18
        if (block.timestamp * brushPerSecond) - (poolInfo[idx].field_512 * brushPerSecond) / block.timestamp - poolInfo[idx].field_512 != brushPerSecond:
            revert with 0, 'SafeMath: multiplication overflow'
        if not (block.timestamp * brushPerSecond) - (poolInfo[idx].field_512 * brushPerSecond):
            _132 = mem[64]
            mem[64] = mem[64] + 64
            mem[_132] = 26
            mem[_132 + 32] = 'SafeMath: division by zero'
            if not totalAllocPoint:
                _138 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _138 + 68] = mem[idx + _132 + 32]
                    idx = idx + 32
                    continue 
                mem[_138 + 94] = 0
                revert with memory
                  from mem[64]
                   len _138 + -mem[64] + 100
            mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = this.address
            mem[mem[64] + 36] = 0 / totalAllocPoint
            require ext_code.size(brushAddress)
            call brushAddress.0x40c10f19 with:
                 gas gas_remaining wei
                args this.address, 0 / totalAllocPoint
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if not 0 / totalAllocPoint:
                _167 = mem[64]
                mem[64] = mem[64] + 64
                mem[_167] = 26
                mem[_167 + 32] = 'SafeMath: division by zero'
                if _120:
                    if poolInfo[idx].field_768 > !(0 / _120):
                        revert with 0, 17
                    if poolInfo[idx].field_768 + (0 / _120) < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 0 / _120
                    poolInfo[idx].field_512 = block.timestamp
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                _176 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _176 + 68] = mem[idx + _167 + 32]
                    idx = idx + 32
                    continue 
                mem[_176 + 94] = 0
                revert with memory
                  from mem[64]
                   len _176 + -mem[64] + 100
            if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                revert with 0, 17
            if not 0 / totalAllocPoint:
                revert with 0, 18
            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                revert with 0, 'SafeMath: multiplication overflow'
            _188 = mem[64]
            mem[64] = mem[64] + 64
            mem[_188] = 26
            mem[_188 + 32] = 'SafeMath: division by zero'
            if _120:
                if poolInfo[idx].field_768 > !(10^12 * 0 / totalAllocPoint / _120):
                    revert with 0, 17
                if poolInfo[idx].field_768 + (10^12 * 0 / totalAllocPoint / _120) < poolInfo[idx].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / _120
                poolInfo[idx].field_512 = block.timestamp
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            _196 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _196 + 68] = mem[idx + _188 + 32]
                idx = idx + 32
                continue 
            mem[_196 + 94] = 0
            revert with memory
              from mem[64]
               len _196 + -mem[64] + 100
        if (block.timestamp * brushPerSecond) - (poolInfo[idx].field_512 * brushPerSecond) and poolInfo[idx].field_256 > -1 / (block.timestamp * brushPerSecond) - (poolInfo[idx].field_512 * brushPerSecond):
            revert with 0, 17
        if not (block.timestamp * brushPerSecond) - (poolInfo[idx].field_512 * brushPerSecond):
            revert with 0, 18
        if (block.timestamp * brushPerSecond * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * brushPerSecond * poolInfo[idx].field_256) / (block.timestamp * brushPerSecond) - (poolInfo[idx].field_512 * brushPerSecond) != poolInfo[idx].field_256:
            revert with 0, 'SafeMath: multiplication overflow'
        _144 = mem[64]
        mem[64] = mem[64] + 64
        mem[_144] = 26
        mem[_144 + 32] = 'SafeMath: division by zero'
        if not totalAllocPoint:
            _149 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _149 + 68] = mem[idx + _144 + 32]
                idx = idx + 32
                continue 
            mem[_149 + 94] = 0
            revert with memory
              from mem[64]
               len _149 + -mem[64] + 100
        mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = this.address
        mem[mem[64] + 36] = (block.timestamp * brushPerSecond * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * brushPerSecond * poolInfo[idx].field_256) / totalAllocPoint
        require ext_code.size(brushAddress)
        call brushAddress.0x40c10f19 with:
             gas gas_remaining wei
            args this.address, (block.timestamp * brushPerSecond * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * brushPerSecond * poolInfo[idx].field_256) / totalAllocPoint
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        if not (block.timestamp * brushPerSecond * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * brushPerSecond * poolInfo[idx].field_256) / totalAllocPoint:
            _187 = mem[64]
            mem[64] = mem[64] + 64
            mem[_187] = 26
            mem[_187 + 32] = 'SafeMath: division by zero'
            if _120:
                if poolInfo[idx].field_768 > !(0 / _120):
                    revert with 0, 17
                if poolInfo[idx].field_768 + (0 / _120) < poolInfo[idx].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                poolInfo[idx].field_768 += 0 / _120
                poolInfo[idx].field_512 = block.timestamp
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            _195 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _195 + 68] = mem[idx + _187 + 32]
                idx = idx + 32
                continue 
            mem[_195 + 94] = 0
            revert with memory
              from mem[64]
               len _195 + -mem[64] + 100
        if (block.timestamp * brushPerSecond * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * brushPerSecond * poolInfo[idx].field_256) / totalAllocPoint and 10^12 > -1 / (block.timestamp * brushPerSecond * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * brushPerSecond * poolInfo[idx].field_256) / totalAllocPoint:
            revert with 0, 17
        if not (block.timestamp * brushPerSecond * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * brushPerSecond * poolInfo[idx].field_256) / totalAllocPoint:
            revert with 0, 18
        if 10^12 * (block.timestamp * brushPerSecond * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * brushPerSecond * poolInfo[idx].field_256) / totalAllocPoint / (block.timestamp * brushPerSecond * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * brushPerSecond * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
            revert with 0, 'SafeMath: multiplication overflow'
        _207 = mem[64]
        mem[64] = mem[64] + 64
        mem[_207] = 26
        mem[_207 + 32] = 'SafeMath: division by zero'
        if _120:
            if poolInfo[idx].field_768 > !(10^12 * (block.timestamp * brushPerSecond * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * brushPerSecond * poolInfo[idx].field_256) / totalAllocPoint / _120):
                revert with 0, 17
            if poolInfo[idx].field_768 + (10^12 * (block.timestamp * brushPerSecond * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * brushPerSecond * poolInfo[idx].field_256) / totalAllocPoint / _120) < poolInfo[idx].field_768:
                revert with 0, 'SafeMath: addition overflow'
            poolInfo[idx].field_768 += 10^12 * (block.timestamp * brushPerSecond * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * brushPerSecond * poolInfo[idx].field_256) / totalAllocPoint / _120
            poolInfo[idx].field_512 = block.timestamp
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        _214 = mem[64]
        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = 32
        mem[mem[64] + 36] = 26
        idx = 0
        while idx < 26:
            mem[idx + _214 + 68] = mem[idx + _207 + 32]
            idx = idx + 32
            continue 
        mem[_214 + 94] = 0
        revert with memory
          from mem[64]
           len _214 + -mem[64] + 100
    brushPerSecond = arg1
}

function set(uint256 arg1, uint256 arg2, bool arg3) payable {
    mem[64] = 96
    require calldata.size - 4 >= 96
    require arg3 == arg3
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if arg1 >= poolInfo.length:
        revert with 0, 50
    mem[0] = poolInfo[arg1].field_0
    mem[32] = 15
    if not stor15[stor6[arg1].field_0]:
        revert with 0, 'pid does not yet exist'
    if arg3:
        idx = 0
        while idx < poolInfo.length:
            mem[0] = 6
            if block.timestamp <= poolInfo[idx].field_512:
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            mem[mem[64] + 4] = this.address
            require ext_code.size(poolInfo[idx].field_0)
            staticcall poolInfo[idx].field_0.0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _149 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _151 = mem[_149]
            if not mem[_149]:
                poolInfo[idx].field_512 = block.timestamp
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            if not poolInfo[idx].field_256:
                poolInfo[idx].field_512 = block.timestamp
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            if block.timestamp < startTime:
                _158 = mem[64]
                mem[64] = mem[64] + 64
                mem[_158] = 26
                mem[_158 + 32] = 'SafeMath: division by zero'
                if not totalAllocPoint:
                    _161 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _161 + 68] = mem[idx + _158 + 32]
                        idx = idx + 32
                        continue 
                    mem[_161 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _161 + -mem[64] + 100
                mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = 0 / totalAllocPoint
                require ext_code.size(brushAddress)
                call brushAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args this.address, 0 / totalAllocPoint
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if not 0 / totalAllocPoint:
                    _183 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_183] = 26
                    mem[_183 + 32] = 'SafeMath: division by zero'
                    if _151:
                        if poolInfo[idx].field_768 > !(0 / _151):
                            revert with 0, 17
                        if poolInfo[idx].field_768 + (0 / _151) < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / _151
                        poolInfo[idx].field_512 = block.timestamp
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
                    _188 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _188 + 68] = mem[idx + _183 + 32]
                        idx = idx + 32
                        continue 
                    mem[_188 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _188 + -mem[64] + 100
                if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                    revert with 0, 17
                if not 0 / totalAllocPoint:
                    revert with 0, 18
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                _199 = mem[64]
                mem[64] = mem[64] + 64
                mem[_199] = 26
                mem[_199 + 32] = 'SafeMath: division by zero'
                if _151:
                    if poolInfo[idx].field_768 > !(10^12 * 0 / totalAllocPoint / _151):
                        revert with 0, 17
                    if poolInfo[idx].field_768 + (10^12 * 0 / totalAllocPoint / _151) < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / _151
                    poolInfo[idx].field_512 = block.timestamp
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                _207 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _207 + 68] = mem[idx + _199 + 32]
                    idx = idx + 32
                    continue 
                mem[_207 + 94] = 0
                revert with memory
                  from mem[64]
                   len _207 + -mem[64] + 100
            if block.timestamp < poolInfo[idx].field_512:
                revert with 0, 17
            if not block.timestamp - poolInfo[idx].field_512:
                _160 = mem[64]
                mem[64] = mem[64] + 64
                mem[_160] = 26
                mem[_160 + 32] = 'SafeMath: division by zero'
                if not totalAllocPoint:
                    _164 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _164 + 68] = mem[idx + _160 + 32]
                        idx = idx + 32
                        continue 
                    mem[_164 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _164 + -mem[64] + 100
                mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = 0 / totalAllocPoint
                require ext_code.size(brushAddress)
                call brushAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args this.address, 0 / totalAllocPoint
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if not 0 / totalAllocPoint:
                    _187 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_187] = 26
                    mem[_187 + 32] = 'SafeMath: division by zero'
                    if _151:
                        if poolInfo[idx].field_768 > !(0 / _151):
                            revert with 0, 17
                        if poolInfo[idx].field_768 + (0 / _151) < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / _151
                        poolInfo[idx].field_512 = block.timestamp
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
                    _193 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _193 + 68] = mem[idx + _187 + 32]
                        idx = idx + 32
                        continue 
                    mem[_193 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _193 + -mem[64] + 100
                if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                    revert with 0, 17
                if not 0 / totalAllocPoint:
                    revert with 0, 18
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                _205 = mem[64]
                mem[64] = mem[64] + 64
                mem[_205] = 26
                mem[_205 + 32] = 'SafeMath: division by zero'
                if _151:
                    if poolInfo[idx].field_768 > !(10^12 * 0 / totalAllocPoint / _151):
                        revert with 0, 17
                    if poolInfo[idx].field_768 + (10^12 * 0 / totalAllocPoint / _151) < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / _151
                    poolInfo[idx].field_512 = block.timestamp
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                _214 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _214 + 68] = mem[idx + _205 + 32]
                    idx = idx + 32
                    continue 
                mem[_214 + 94] = 0
                revert with memory
                  from mem[64]
                   len _214 + -mem[64] + 100
            if block.timestamp - poolInfo[idx].field_512 and brushPerSecond > -1 / block.timestamp - poolInfo[idx].field_512:
                revert with 0, 17
            if not block.timestamp - poolInfo[idx].field_512:
                revert with 0, 18
            if (block.timestamp * brushPerSecond) - (poolInfo[idx].field_512 * brushPerSecond) / block.timestamp - poolInfo[idx].field_512 != brushPerSecond:
                revert with 0, 'SafeMath: multiplication overflow'
            if not (block.timestamp * brushPerSecond) - (poolInfo[idx].field_512 * brushPerSecond):
                _169 = mem[64]
                mem[64] = mem[64] + 64
                mem[_169] = 26
                mem[_169 + 32] = 'SafeMath: division by zero'
                if not totalAllocPoint:
                    _175 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _175 + 68] = mem[idx + _169 + 32]
                        idx = idx + 32
                        continue 
                    mem[_175 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _175 + -mem[64] + 100
                mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = 0 / totalAllocPoint
                require ext_code.size(brushAddress)
                call brushAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args this.address, 0 / totalAllocPoint
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if not 0 / totalAllocPoint:
                    _204 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_204] = 26
                    mem[_204 + 32] = 'SafeMath: division by zero'
                    if _151:
                        if poolInfo[idx].field_768 > !(0 / _151):
                            revert with 0, 17
                        if poolInfo[idx].field_768 + (0 / _151) < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / _151
                        poolInfo[idx].field_512 = block.timestamp
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
                    _213 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _213 + 68] = mem[idx + _204 + 32]
                        idx = idx + 32
                        continue 
                    mem[_213 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _213 + -mem[64] + 100
                if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                    revert with 0, 17
                if not 0 / totalAllocPoint:
                    revert with 0, 18
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                _225 = mem[64]
                mem[64] = mem[64] + 64
                mem[_225] = 26
                mem[_225 + 32] = 'SafeMath: division by zero'
                if _151:
                    if poolInfo[idx].field_768 > !(10^12 * 0 / totalAllocPoint / _151):
                        revert with 0, 17
                    if poolInfo[idx].field_768 + (10^12 * 0 / totalAllocPoint / _151) < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / _151
                    poolInfo[idx].field_512 = block.timestamp
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                _233 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _233 + 68] = mem[idx + _225 + 32]
                    idx = idx + 32
                    continue 
                mem[_233 + 94] = 0
                revert with memory
                  from mem[64]
                   len _233 + -mem[64] + 100
            if (block.timestamp * brushPerSecond) - (poolInfo[idx].field_512 * brushPerSecond) and poolInfo[idx].field_256 > -1 / (block.timestamp * brushPerSecond) - (poolInfo[idx].field_512 * brushPerSecond):
                revert with 0, 17
            if not (block.timestamp * brushPerSecond) - (poolInfo[idx].field_512 * brushPerSecond):
                revert with 0, 18
            if (block.timestamp * brushPerSecond * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * brushPerSecond * poolInfo[idx].field_256) / (block.timestamp * brushPerSecond) - (poolInfo[idx].field_512 * brushPerSecond) != poolInfo[idx].field_256:
                revert with 0, 'SafeMath: multiplication overflow'
            _181 = mem[64]
            mem[64] = mem[64] + 64
            mem[_181] = 26
            mem[_181 + 32] = 'SafeMath: division by zero'
            if not totalAllocPoint:
                _186 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _186 + 68] = mem[idx + _181 + 32]
                    idx = idx + 32
                    continue 
                mem[_186 + 94] = 0
                revert with memory
                  from mem[64]
                   len _186 + -mem[64] + 100
            mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = this.address
            mem[mem[64] + 36] = (block.timestamp * brushPerSecond * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * brushPerSecond * poolInfo[idx].field_256) / totalAllocPoint
            require ext_code.size(brushAddress)
            call brushAddress.0x40c10f19 with:
                 gas gas_remaining wei
                args this.address, (block.timestamp * brushPerSecond * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * brushPerSecond * poolInfo[idx].field_256) / totalAllocPoint
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if not (block.timestamp * brushPerSecond * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * brushPerSecond * poolInfo[idx].field_256) / totalAllocPoint:
                _224 = mem[64]
                mem[64] = mem[64] + 64
                mem[_224] = 26
                mem[_224 + 32] = 'SafeMath: division by zero'
                if _151:
                    if poolInfo[idx].field_768 > !(0 / _151):
                        revert with 0, 17
                    if poolInfo[idx].field_768 + (0 / _151) < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 0 / _151
                    poolInfo[idx].field_512 = block.timestamp
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                _232 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _232 + 68] = mem[idx + _224 + 32]
                    idx = idx + 32
                    continue 
                mem[_232 + 94] = 0
                revert with memory
                  from mem[64]
                   len _232 + -mem[64] + 100
            if (block.timestamp * brushPerSecond * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * brushPerSecond * poolInfo[idx].field_256) / totalAllocPoint and 10^12 > -1 / (block.timestamp * brushPerSecond * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * brushPerSecond * poolInfo[idx].field_256) / totalAllocPoint:
                revert with 0, 17
            if not (block.timestamp * brushPerSecond * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * brushPerSecond * poolInfo[idx].field_256) / totalAllocPoint:
                revert with 0, 18
            if 10^12 * (block.timestamp * brushPerSecond * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * brushPerSecond * poolInfo[idx].field_256) / totalAllocPoint / (block.timestamp * brushPerSecond * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * brushPerSecond * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                revert with 0, 'SafeMath: multiplication overflow'
            _244 = mem[64]
            mem[64] = mem[64] + 64
            mem[_244] = 26
            mem[_244 + 32] = 'SafeMath: division by zero'
            if _151:
                if poolInfo[idx].field_768 > !(10^12 * (block.timestamp * brushPerSecond * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * brushPerSecond * poolInfo[idx].field_256) / totalAllocPoint / _151):
                    revert with 0, 17
                if poolInfo[idx].field_768 + (10^12 * (block.timestamp * brushPerSecond * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * brushPerSecond * poolInfo[idx].field_256) / totalAllocPoint / _151) < poolInfo[idx].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                poolInfo[idx].field_768 += 10^12 * (block.timestamp * brushPerSecond * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * brushPerSecond * poolInfo[idx].field_256) / totalAllocPoint / _151
                poolInfo[idx].field_512 = block.timestamp
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            _251 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _251 + 68] = mem[idx + _244 + 32]
                idx = idx + 32
                continue 
            mem[_251 + 94] = 0
            revert with memory
              from mem[64]
               len _251 + -mem[64] + 100
    if arg1 >= poolInfo.length:
        revert with 0, 50
    if poolInfo[arg1].field_256 > totalAllocPoint:
        revert with 0, 'SafeMath: subtraction overflow', 0
    if totalAllocPoint < poolInfo[arg1].field_256:
        revert with 0, 17
    if totalAllocPoint - poolInfo[arg1].field_256 > !arg2:
        revert with 0, 17
    if arg2 < 0:
        revert with 0, 'SafeMath: addition overflow'
    totalAllocPoint = totalAllocPoint - poolInfo[arg1].field_256 + arg2
    if arg1 >= poolInfo.length:
        revert with 0, 50
    poolInfo[arg1].field_256 = arg2
}

function pendingBrush(uint256 arg1, address arg2) payable {
    require calldata.size - 4 >= 64
    require arg2 == arg2
    if arg1 >= poolInfo.length:
        revert with 0, 50
    require ext_code.size(poolInfo[arg1].field_0)
    staticcall poolInfo[arg1].field_0.0x70a08231 with:
            gas gas_remaining wei
           args this.address
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if block.timestamp <= poolInfo[arg1].field_512:
        if not userInfo[arg1][address(arg2)].field_0:
            if userInfo[arg1][address(arg2)].field_256 > 0:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if 0 < userInfo[arg1][address(arg2)].field_256:
                revert with 0, 17
            return (-userInfo[arg1][address(arg2)].field_256 / 2)
        if userInfo[arg1][address(arg2)].field_0 and poolInfo[arg1].field_768 > -1 / userInfo[arg1][address(arg2)].field_0:
            revert with 0, 17
        if not userInfo[arg1][address(arg2)].field_0:
            revert with 0, 18
        if userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768 / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768:
            revert with 0, 'SafeMath: multiplication overflow'
        if userInfo[arg1][address(arg2)].field_256 > userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768 / 10^12:
            revert with 0, 'SafeMath: subtraction overflow', 0
        if userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768 / 10^12 < userInfo[arg1][address(arg2)].field_256:
            revert with 0, 17
        return ((userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768 / 10^12) - userInfo[arg1][address(arg2)].field_256 / 2)
    if not ext_call.return_data[0]:
        if not userInfo[arg1][address(arg2)].field_0:
            if userInfo[arg1][address(arg2)].field_256 > 0:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if 0 < userInfo[arg1][address(arg2)].field_256:
                revert with 0, 17
            return (-userInfo[arg1][address(arg2)].field_256 / 2)
        if userInfo[arg1][address(arg2)].field_0 and poolInfo[arg1].field_768 > -1 / userInfo[arg1][address(arg2)].field_0:
            revert with 0, 17
        if not userInfo[arg1][address(arg2)].field_0:
            revert with 0, 18
        if userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768 / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768:
            revert with 0, 'SafeMath: multiplication overflow'
        if userInfo[arg1][address(arg2)].field_256 > userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768 / 10^12:
            revert with 0, 'SafeMath: subtraction overflow', 0
        if userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768 / 10^12 < userInfo[arg1][address(arg2)].field_256:
            revert with 0, 17
        return ((userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768 / 10^12) - userInfo[arg1][address(arg2)].field_256 / 2)
    if block.timestamp < startTime:
        if not totalAllocPoint:
            revert with 0, 'SafeMath: division by zero', 0
        if not 0 / totalAllocPoint:
            if not ext_call.return_data[0]:
                revert with 0, 'SafeMath: division by zero', 0
            if poolInfo[arg1].field_768 > !(0 / ext_call.return_data[0]):
                revert with 0, 17
            if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if 0 < userInfo[arg1][address(arg2)].field_256:
                    revert with 0, 17
                return (-userInfo[arg1][address(arg2)].field_256 / 2)
            if userInfo[arg1][address(arg2)].field_0 and poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) > -1 / userInfo[arg1][address(arg2)].field_0:
                revert with 0, 17
            if not userInfo[arg1][address(arg2)].field_0:
                revert with 0, 18
            if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]):
                revert with 0, 'SafeMath: multiplication overflow'
            if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12 < userInfo[arg1][address(arg2)].field_256:
                revert with 0, 17
            return (((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256 / 2)
        if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
            revert with 0, 17
        if not 0 / totalAllocPoint:
            revert with 0, 18
        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
            revert with 0, 'SafeMath: multiplication overflow'
        if not ext_call.return_data[0]:
            revert with 0, 'SafeMath: division by zero', 0
        if poolInfo[arg1].field_768 > !(10^12 * 0 / totalAllocPoint / ext_call.return_data[0]):
            revert with 0, 17
        if poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
            revert with 0, 'SafeMath: addition overflow'
        if not userInfo[arg1][address(arg2)].field_0:
            if userInfo[arg1][address(arg2)].field_256 > 0:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if 0 < userInfo[arg1][address(arg2)].field_256:
                revert with 0, 17
            return (-userInfo[arg1][address(arg2)].field_256 / 2)
        if userInfo[arg1][address(arg2)].field_0 and poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) > -1 / userInfo[arg1][address(arg2)].field_0:
            revert with 0, 17
        if not userInfo[arg1][address(arg2)].field_0:
            revert with 0, 18
        if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]):
            revert with 0, 'SafeMath: multiplication overflow'
        if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12:
            revert with 0, 'SafeMath: subtraction overflow', 0
        if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12 < userInfo[arg1][address(arg2)].field_256:
            revert with 0, 17
        return (((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256 / 2)
    if block.timestamp < poolInfo[arg1].field_512:
        revert with 0, 17
    if not block.timestamp - poolInfo[arg1].field_512:
        if not totalAllocPoint:
            revert with 0, 'SafeMath: division by zero', 0
        if not 0 / totalAllocPoint:
            if not ext_call.return_data[0]:
                revert with 0, 'SafeMath: division by zero', 0
            if poolInfo[arg1].field_768 > !(0 / ext_call.return_data[0]):
                revert with 0, 17
            if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if 0 < userInfo[arg1][address(arg2)].field_256:
                    revert with 0, 17
                return (-userInfo[arg1][address(arg2)].field_256 / 2)
            if userInfo[arg1][address(arg2)].field_0 and poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) > -1 / userInfo[arg1][address(arg2)].field_0:
                revert with 0, 17
            if not userInfo[arg1][address(arg2)].field_0:
                revert with 0, 18
            if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]):
                revert with 0, 'SafeMath: multiplication overflow'
            if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12 < userInfo[arg1][address(arg2)].field_256:
                revert with 0, 17
            return (((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256 / 2)
        if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
            revert with 0, 17
        if not 0 / totalAllocPoint:
            revert with 0, 18
        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
            revert with 0, 'SafeMath: multiplication overflow'
        if not ext_call.return_data[0]:
            revert with 0, 'SafeMath: division by zero', 0
        if poolInfo[arg1].field_768 > !(10^12 * 0 / totalAllocPoint / ext_call.return_data[0]):
            revert with 0, 17
        if poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
            revert with 0, 'SafeMath: addition overflow'
        if not userInfo[arg1][address(arg2)].field_0:
            if userInfo[arg1][address(arg2)].field_256 > 0:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if 0 < userInfo[arg1][address(arg2)].field_256:
                revert with 0, 17
            return (-userInfo[arg1][address(arg2)].field_256 / 2)
        if userInfo[arg1][address(arg2)].field_0 and poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) > -1 / userInfo[arg1][address(arg2)].field_0:
            revert with 0, 17
        if not userInfo[arg1][address(arg2)].field_0:
            revert with 0, 18
        if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]):
            revert with 0, 'SafeMath: multiplication overflow'
        if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12:
            revert with 0, 'SafeMath: subtraction overflow', 0
        if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12 < userInfo[arg1][address(arg2)].field_256:
            revert with 0, 17
        return (((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256 / 2)
    if block.timestamp - poolInfo[arg1].field_512 and brushPerSecond > -1 / block.timestamp - poolInfo[arg1].field_512:
        revert with 0, 17
    if not block.timestamp - poolInfo[arg1].field_512:
        revert with 0, 18
    if (block.timestamp * brushPerSecond) - (poolInfo[arg1].field_512 * brushPerSecond) / block.timestamp - poolInfo[arg1].field_512 != brushPerSecond:
        revert with 0, 'SafeMath: multiplication overflow'
    if not (block.timestamp * brushPerSecond) - (poolInfo[arg1].field_512 * brushPerSecond):
        if not totalAllocPoint:
            revert with 0, 'SafeMath: division by zero', 0
        if not 0 / totalAllocPoint:
            if not ext_call.return_data[0]:
                revert with 0, 'SafeMath: division by zero', 0
            if poolInfo[arg1].field_768 > !(0 / ext_call.return_data[0]):
                revert with 0, 17
            if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if 0 < userInfo[arg1][address(arg2)].field_256:
                    revert with 0, 17
                return (-userInfo[arg1][address(arg2)].field_256 / 2)
            if userInfo[arg1][address(arg2)].field_0 and poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) > -1 / userInfo[arg1][address(arg2)].field_0:
                revert with 0, 17
            if not userInfo[arg1][address(arg2)].field_0:
                revert with 0, 18
            if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]):
                revert with 0, 'SafeMath: multiplication overflow'
            if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12 < userInfo[arg1][address(arg2)].field_256:
                revert with 0, 17
            return (((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256 / 2)
        if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
            revert with 0, 17
        if not 0 / totalAllocPoint:
            revert with 0, 18
        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
            revert with 0, 'SafeMath: multiplication overflow'
        if not ext_call.return_data[0]:
            revert with 0, 'SafeMath: division by zero', 0
        if poolInfo[arg1].field_768 > !(10^12 * 0 / totalAllocPoint / ext_call.return_data[0]):
            revert with 0, 17
        if poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
            revert with 0, 'SafeMath: addition overflow'
        if not userInfo[arg1][address(arg2)].field_0:
            if userInfo[arg1][address(arg2)].field_256 > 0:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if 0 < userInfo[arg1][address(arg2)].field_256:
                revert with 0, 17
            return (-userInfo[arg1][address(arg2)].field_256 / 2)
        if userInfo[arg1][address(arg2)].field_0 and poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) > -1 / userInfo[arg1][address(arg2)].field_0:
            revert with 0, 17
        if not userInfo[arg1][address(arg2)].field_0:
            revert with 0, 18
        if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]):
            revert with 0, 'SafeMath: multiplication overflow'
        if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12:
            revert with 0, 'SafeMath: subtraction overflow', 0
        if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12 < userInfo[arg1][address(arg2)].field_256:
            revert with 0, 17
        return (((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256 / 2)
    if (block.timestamp * brushPerSecond) - (poolInfo[arg1].field_512 * brushPerSecond) and poolInfo[arg1].field_256 > -1 / (block.timestamp * brushPerSecond) - (poolInfo[arg1].field_512 * brushPerSecond):
        revert with 0, 17
    if not (block.timestamp * brushPerSecond) - (poolInfo[arg1].field_512 * brushPerSecond):
        revert with 0, 18
    if (block.timestamp * brushPerSecond * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * brushPerSecond * poolInfo[arg1].field_256) / (block.timestamp * brushPerSecond) - (poolInfo[arg1].field_512 * brushPerSecond) != poolInfo[arg1].field_256:
        revert with 0, 'SafeMath: multiplication overflow'
    if not totalAllocPoint:
        revert with 0, 'SafeMath: division by zero', 0
    if not (block.timestamp * brushPerSecond * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * brushPerSecond * poolInfo[arg1].field_256) / totalAllocPoint:
        if not ext_call.return_data[0]:
            revert with 0, 'SafeMath: division by zero', 0
        if poolInfo[arg1].field_768 > !(0 / ext_call.return_data[0]):
            revert with 0, 17
        if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
            revert with 0, 'SafeMath: addition overflow'
        if not userInfo[arg1][address(arg2)].field_0:
            if userInfo[arg1][address(arg2)].field_256 > 0:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if 0 < userInfo[arg1][address(arg2)].field_256:
                revert with 0, 17
            return (-userInfo[arg1][address(arg2)].field_256 / 2)
        if userInfo[arg1][address(arg2)].field_0 and poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) > -1 / userInfo[arg1][address(arg2)].field_0:
            revert with 0, 17
        if not userInfo[arg1][address(arg2)].field_0:
            revert with 0, 18
        if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]):
            revert with 0, 'SafeMath: multiplication overflow'
        if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12:
            revert with 0, 'SafeMath: subtraction overflow', 0
        if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12 < userInfo[arg1][address(arg2)].field_256:
            revert with 0, 17
        return (((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256 / 2)
    if (block.timestamp * brushPerSecond * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * brushPerSecond * poolInfo[arg1].field_256) / totalAllocPoint and 10^12 > -1 / (block.timestamp * brushPerSecond * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * brushPerSecond * poolInfo[arg1].field_256) / totalAllocPoint:
        revert with 0, 17
    if not (block.timestamp * brushPerSecond * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * brushPerSecond * poolInfo[arg1].field_256) / totalAllocPoint:
        revert with 0, 18
    if 10^12 * (block.timestamp * brushPerSecond * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * brushPerSecond * poolInfo[arg1].field_256) / totalAllocPoint / (block.timestamp * brushPerSecond * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * brushPerSecond * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
        revert with 0, 'SafeMath: multiplication overflow'
    if not ext_call.return_data[0]:
        revert with 0, 'SafeMath: division by zero', 0
    if poolInfo[arg1].field_768 > !(10^12 * (block.timestamp * brushPerSecond * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * brushPerSecond * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]):
        revert with 0, 17
    if poolInfo[arg1].field_768 + (10^12 * (block.timestamp * brushPerSecond * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * brushPerSecond * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
        revert with 0, 'SafeMath: addition overflow'
    if not userInfo[arg1][address(arg2)].field_0:
        if userInfo[arg1][address(arg2)].field_256 > 0:
            revert with 0, 'SafeMath: subtraction overflow', 0
        if 0 < userInfo[arg1][address(arg2)].field_256:
            revert with 0, 17
        return (-userInfo[arg1][address(arg2)].field_256 / 2)
    if userInfo[arg1][address(arg2)].field_0 and poolInfo[arg1].field_768 + (10^12 * (block.timestamp * brushPerSecond * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * brushPerSecond * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) > -1 / userInfo[arg1][address(arg2)].field_0:
        revert with 0, 17
    if not userInfo[arg1][address(arg2)].field_0:
        revert with 0, 18
    if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (block.timestamp * brushPerSecond * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * brushPerSecond * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (10^12 * (block.timestamp * brushPerSecond * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * brushPerSecond * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]):
        revert with 0, 'SafeMath: multiplication overflow'
    if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (block.timestamp * brushPerSecond * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * brushPerSecond * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12:
        revert with 0, 'SafeMath: subtraction overflow', 0
    if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (block.timestamp * brushPerSecond * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * brushPerSecond * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12 < userInfo[arg1][address(arg2)].field_256:
        revert with 0, 17
    return (((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (block.timestamp * brushPerSecond * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * brushPerSecond * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256 / 2)
}

function buyBackAndBurn(address arg1, uint256 arg2) payable {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    require arg2 > 0
    mem[0] = arg1
    mem[32] = 13
    require arg2 <= maxBurnAndBuyBackAmounts[address(arg1)]
    require ext_code.size(arg1)
    staticcall arg1.token0() with:
            gas gas_remaining wei
    mem[96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    require ext_code.size(arg1)
    staticcall arg1.token1() with:
            gas gas_remaining wei
    mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    if 60 > !block.timestamp:
        revert with 0, 17
    mem[(2 * ceil32(return_data.size)) + 132] = address(ext_call.return_data[0])
    mem[(2 * ceil32(return_data.size)) + 164] = arg2
    mem[(2 * ceil32(return_data.size)) + 196] = 1
    mem[(2 * ceil32(return_data.size)) + 228] = 1
    mem[(2 * ceil32(return_data.size)) + 260] = this.address
    mem[(2 * ceil32(return_data.size)) + 292] = block.timestamp + 60
    require ext_code.size(routerAddress)
    call routerAddress.removeLiquidity(address rg1, address rg2, uint256 rg3, uint256 rg4, uint256 rg5, address rg6, uint256 rg7) with:
         gas gas_remaining wei
        args address(ext_call.return_data[0]), address(ext_call.return_data[0]), arg2, 1, 1, address(this.address), block.timestamp + 60
    mem[(2 * ceil32(return_data.size)) + 96 len 64] = ext_call.return_data[0 len 64]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 64
    if 10000 > !block.timestamp:
        revert with 0, 17
    if brushAddress == address(ext_call.return_data[0]):
        mem[(4 * ceil32(return_data.size)) + 128] = address(ext_call.return_data[0])
        mem[(4 * ceil32(return_data.size)) + 160] = brushAddress
        if brushAddress == address(ext_call.return_data[0]):
            if ext_call.return_data[32] > -1:
                revert with 0, 17
            mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
            mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
            mem[(4 * ceil32(return_data.size)) + 228] = 0
            mem[(4 * ceil32(return_data.size)) + 260] = 160
            mem[(4 * ceil32(return_data.size)) + 356] = 2
            idx = 0
            s = (4 * ceil32(return_data.size)) + 388
            t = (4 * ceil32(return_data.size)) + 128
            while idx < 2:
                mem[s] = mem[t + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[(4 * ceil32(return_data.size)) + 292] = this.address
            mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
            require ext_code.size(routerAddress)
            call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                 gas gas_remaining wei
                args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = (6 * ceil32(return_data.size)) + 192
            require return_data.size >= 32
            _3450 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
            require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
            require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
            _3529 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
            if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                revert with 0, 65
            if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                revert with 0, 65
            mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
            require return_data.size >= _3450 + (32 * _3529) + 32
            mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3529] = mem[(4 * ceil32(return_data.size)) + _3450 + 224 len 32 * _3529]
            if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                revert with 0, 17
            maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
            if 1 >= _3529:
                revert with 0, 50
        else:
            if wftmAddress == address(ext_call.return_data[0]):
                if ext_call.return_data[32] > -1:
                    revert with 0, 17
                mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                mem[(4 * ceil32(return_data.size)) + 228] = 0
                mem[(4 * ceil32(return_data.size)) + 260] = 160
                mem[(4 * ceil32(return_data.size)) + 356] = 2
                idx = 0
                s = (4 * ceil32(return_data.size)) + 388
                t = (4 * ceil32(return_data.size)) + 128
                while idx < 2:
                    mem[s] = mem[t + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[(4 * ceil32(return_data.size)) + 292] = this.address
                mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                require ext_code.size(routerAddress)
                call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                     gas gas_remaining wei
                    args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = (6 * ceil32(return_data.size)) + 192
                require return_data.size >= 32
                _3448 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                _3527 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                    revert with 0, 65
                if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                    revert with 0, 65
                mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                require return_data.size >= _3448 + (32 * _3527) + 32
                mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3527] = mem[(4 * ceil32(return_data.size)) + _3448 + 224 len 32 * _3527]
                if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                    revert with 0, 17
                maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                if 1 >= _3527:
                    revert with 0, 50
            else:
                if ext_call.return_data[0] > -1:
                    revert with 0, 17
                mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                mem[(4 * ceil32(return_data.size)) + 228] = 0
                mem[(4 * ceil32(return_data.size)) + 260] = 160
                mem[(4 * ceil32(return_data.size)) + 356] = 2
                idx = 0
                s = (4 * ceil32(return_data.size)) + 388
                t = (4 * ceil32(return_data.size)) + 128
                while idx < 2:
                    mem[s] = mem[t + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[(4 * ceil32(return_data.size)) + 292] = this.address
                mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                require ext_code.size(routerAddress)
                call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                     gas gas_remaining wei
                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = (6 * ceil32(return_data.size)) + 192
                require return_data.size >= 32
                _3449 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                _3528 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                    revert with 0, 65
                if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                    revert with 0, 65
                mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                require return_data.size >= _3449 + (32 * _3528) + 32
                mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3528] = mem[(4 * ceil32(return_data.size)) + _3449 + 224 len 32 * _3528]
                if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                    revert with 0, 17
                maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                if 1 >= _3528:
                    revert with 0, 50
        if mem[(6 * ceil32(return_data.size)) + 256] > !ext_call.return_data[0]:
            revert with 0, 17
        require ext_code.size(brushAddress)
        call brushAddress.0x42966c68 with:
             gas gas_remaining wei
            args (mem[(6 * ceil32(return_data.size)) + 256] + ext_call.return_data[0])
    else:
        if brushAddress == address(ext_call.return_data[0]):
            mem[(4 * ceil32(return_data.size)) + 128] = address(ext_call.return_data[0])
            mem[(4 * ceil32(return_data.size)) + 160] = brushAddress
            if brushAddress == address(ext_call.return_data[0]):
                if brushAddress != address(ext_call.return_data[0]):
                    if wftmAddress == address(ext_call.return_data[0]):
                        if brushAddress != address(ext_call.return_data[0]):
                            if wftmAddress == address(ext_call.return_data[0]):
                                if ext_call.return_data[32] > -1:
                                    revert with 0, 17
                                mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                                mem[(4 * ceil32(return_data.size)) + 228] = 0
                                mem[(4 * ceil32(return_data.size)) + 260] = 160
                                mem[(4 * ceil32(return_data.size)) + 356] = 2
                                idx = 0
                                s = (4 * ceil32(return_data.size)) + 388
                                t = (4 * ceil32(return_data.size)) + 128
                                while idx < 2:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (6 * ceil32(return_data.size)) + 192
                                require return_data.size >= 32
                                _3451 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                                require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                _3530 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                                    revert with 0, 65
                                if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                                    revert with 0, 65
                                mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                require return_data.size >= _3451 + (32 * _3530) + 32
                                mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3530] = mem[(4 * ceil32(return_data.size)) + _3451 + 224 len 32 * _3530]
                                if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                    revert with 0, 17
                                maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                if 1 >= _3530:
                                    revert with 0, 50
                            else:
                                if ext_call.return_data[0] > -1:
                                    revert with 0, 17
                                mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                                mem[(4 * ceil32(return_data.size)) + 228] = 0
                                mem[(4 * ceil32(return_data.size)) + 260] = 160
                                mem[(4 * ceil32(return_data.size)) + 356] = 2
                                idx = 0
                                s = (4 * ceil32(return_data.size)) + 388
                                t = (4 * ceil32(return_data.size)) + 128
                                while idx < 2:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (6 * ceil32(return_data.size)) + 192
                                require return_data.size >= 32
                                _3452 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                                require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                _3531 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                                    revert with 0, 65
                                if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                                    revert with 0, 65
                                mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                require return_data.size >= _3452 + (32 * _3531) + 32
                                mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3531] = mem[(4 * ceil32(return_data.size)) + _3452 + 224 len 32 * _3531]
                                if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                    revert with 0, 17
                                maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                if 1 >= _3531:
                                    revert with 0, 50
                        else:
                            if brushAddress == address(ext_call.return_data[0]):
                                if ext_call.return_data[32] > -1:
                                    revert with 0, 17
                                mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                                mem[(4 * ceil32(return_data.size)) + 228] = 0
                                mem[(4 * ceil32(return_data.size)) + 260] = 160
                                mem[(4 * ceil32(return_data.size)) + 356] = 2
                                idx = 0
                                s = (4 * ceil32(return_data.size)) + 388
                                t = (4 * ceil32(return_data.size)) + 128
                                while idx < 2:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (6 * ceil32(return_data.size)) + 192
                                require return_data.size >= 32
                                _3453 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                                require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                _3532 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                                    revert with 0, 65
                                if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                                    revert with 0, 65
                                mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                require return_data.size >= _3453 + (32 * _3532) + 32
                                mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3532] = mem[(4 * ceil32(return_data.size)) + _3453 + 224 len 32 * _3532]
                                if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                    revert with 0, 17
                                maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                if 1 >= _3532:
                                    revert with 0, 50
                            else:
                                if brushAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[0] > -1:
                                        revert with 0, 17
                                    mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                                    mem[(4 * ceil32(return_data.size)) + 228] = 0
                                    mem[(4 * ceil32(return_data.size)) + 260] = 160
                                    mem[(4 * ceil32(return_data.size)) + 356] = 2
                                    idx = 0
                                    s = (4 * ceil32(return_data.size)) + 388
                                    t = (4 * ceil32(return_data.size)) + 128
                                    while idx < 2:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                    mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = (6 * ceil32(return_data.size)) + 192
                                    require return_data.size >= 32
                                    _3454 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                                    require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                    _3533 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                    if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                                        revert with 0, 65
                                    if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                                        revert with 0, 65
                                    mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                    require return_data.size >= _3454 + (32 * _3533) + 32
                                    mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3533] = mem[(4 * ceil32(return_data.size)) + _3454 + 224 len 32 * _3533]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                    if 1 >= _3533:
                                        revert with 0, 50
                                else:
                                    if wftmAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[32] > -1:
                                            revert with 0, 17
                                        mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                                        mem[(4 * ceil32(return_data.size)) + 228] = 0
                                        mem[(4 * ceil32(return_data.size)) + 260] = 160
                                        mem[(4 * ceil32(return_data.size)) + 356] = 2
                                        idx = 0
                                        s = (4 * ceil32(return_data.size)) + 388
                                        t = (4 * ceil32(return_data.size)) + 128
                                        while idx < 2:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                        mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = (6 * ceil32(return_data.size)) + 192
                                        require return_data.size >= 32
                                        _3455 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                                        require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                                        require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                        _3534 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                        if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                                            revert with 0, 65
                                        if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                                            revert with 0, 65
                                        mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                        require return_data.size >= _3455 + (32 * _3534) + 32
                                        mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3534] = mem[(4 * ceil32(return_data.size)) + _3455 + 224 len 32 * _3534]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                        if 1 >= _3534:
                                            revert with 0, 50
                                    else:
                                        if ext_call.return_data[0] > -1:
                                            revert with 0, 17
                                        mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                                        mem[(4 * ceil32(return_data.size)) + 228] = 0
                                        mem[(4 * ceil32(return_data.size)) + 260] = 160
                                        mem[(4 * ceil32(return_data.size)) + 356] = 2
                                        idx = 0
                                        s = (4 * ceil32(return_data.size)) + 388
                                        t = (4 * ceil32(return_data.size)) + 128
                                        while idx < 2:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                        mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = (6 * ceil32(return_data.size)) + 192
                                        require return_data.size >= 32
                                        _3456 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                                        require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                        require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                        _3535 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                        if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                                            revert with 0, 65
                                        if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                                            revert with 0, 65
                                        mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                        require return_data.size >= _3456 + (32 * _3535) + 32
                                        mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3535] = mem[(4 * ceil32(return_data.size)) + _3456 + 224 len 32 * _3535]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                        if 1 >= _3535:
                                            revert with 0, 50
                    else:
                        if brushAddress != address(ext_call.return_data[0]):
                            if wftmAddress == address(ext_call.return_data[0]):
                                if ext_call.return_data[32] > -1:
                                    revert with 0, 17
                                mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                                mem[(4 * ceil32(return_data.size)) + 228] = 0
                                mem[(4 * ceil32(return_data.size)) + 260] = 160
                                mem[(4 * ceil32(return_data.size)) + 356] = 2
                                idx = 0
                                s = (4 * ceil32(return_data.size)) + 388
                                t = (4 * ceil32(return_data.size)) + 128
                                while idx < 2:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (6 * ceil32(return_data.size)) + 192
                                require return_data.size >= 32
                                _3457 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                                require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                _3536 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                                    revert with 0, 65
                                if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                                    revert with 0, 65
                                mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                require return_data.size >= _3457 + (32 * _3536) + 32
                                mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3536] = mem[(4 * ceil32(return_data.size)) + _3457 + 224 len 32 * _3536]
                                if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                    revert with 0, 17
                                maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                if 1 >= _3536:
                                    revert with 0, 50
                            else:
                                if ext_call.return_data[0] > -1:
                                    revert with 0, 17
                                mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                                mem[(4 * ceil32(return_data.size)) + 228] = 0
                                mem[(4 * ceil32(return_data.size)) + 260] = 160
                                mem[(4 * ceil32(return_data.size)) + 356] = 2
                                idx = 0
                                s = (4 * ceil32(return_data.size)) + 388
                                t = (4 * ceil32(return_data.size)) + 128
                                while idx < 2:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (6 * ceil32(return_data.size)) + 192
                                require return_data.size >= 32
                                _3458 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                                require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                _3537 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                                    revert with 0, 65
                                if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                                    revert with 0, 65
                                mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                require return_data.size >= _3458 + (32 * _3537) + 32
                                mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3537] = mem[(4 * ceil32(return_data.size)) + _3458 + 224 len 32 * _3537]
                                if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                    revert with 0, 17
                                maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                if 1 >= _3537:
                                    revert with 0, 50
                        else:
                            if brushAddress == address(ext_call.return_data[0]):
                                if ext_call.return_data[32] > -1:
                                    revert with 0, 17
                                mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                                mem[(4 * ceil32(return_data.size)) + 228] = 0
                                mem[(4 * ceil32(return_data.size)) + 260] = 160
                                mem[(4 * ceil32(return_data.size)) + 356] = 2
                                idx = 0
                                s = (4 * ceil32(return_data.size)) + 388
                                t = (4 * ceil32(return_data.size)) + 128
                                while idx < 2:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (6 * ceil32(return_data.size)) + 192
                                require return_data.size >= 32
                                _3459 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                                require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                _3538 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                                    revert with 0, 65
                                if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                                    revert with 0, 65
                                mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                require return_data.size >= _3459 + (32 * _3538) + 32
                                mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3538] = mem[(4 * ceil32(return_data.size)) + _3459 + 224 len 32 * _3538]
                                if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                    revert with 0, 17
                                maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                if 1 >= _3538:
                                    revert with 0, 50
                            else:
                                if brushAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[0] > -1:
                                        revert with 0, 17
                                    mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                                    mem[(4 * ceil32(return_data.size)) + 228] = 0
                                    mem[(4 * ceil32(return_data.size)) + 260] = 160
                                    mem[(4 * ceil32(return_data.size)) + 356] = 2
                                    idx = 0
                                    s = (4 * ceil32(return_data.size)) + 388
                                    t = (4 * ceil32(return_data.size)) + 128
                                    while idx < 2:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                    mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = (6 * ceil32(return_data.size)) + 192
                                    require return_data.size >= 32
                                    _3460 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                                    require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                    _3539 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                    if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                                        revert with 0, 65
                                    if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                                        revert with 0, 65
                                    mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                    require return_data.size >= _3460 + (32 * _3539) + 32
                                    mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3539] = mem[(4 * ceil32(return_data.size)) + _3460 + 224 len 32 * _3539]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                    if 1 >= _3539:
                                        revert with 0, 50
                                else:
                                    if wftmAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[32] > -1:
                                            revert with 0, 17
                                        mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                                        mem[(4 * ceil32(return_data.size)) + 228] = 0
                                        mem[(4 * ceil32(return_data.size)) + 260] = 160
                                        mem[(4 * ceil32(return_data.size)) + 356] = 2
                                        idx = 0
                                        s = (4 * ceil32(return_data.size)) + 388
                                        t = (4 * ceil32(return_data.size)) + 128
                                        while idx < 2:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                        mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = (6 * ceil32(return_data.size)) + 192
                                        require return_data.size >= 32
                                        _3461 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                                        require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                                        require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                        _3540 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                        if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                                            revert with 0, 65
                                        if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                                            revert with 0, 65
                                        mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                        require return_data.size >= _3461 + (32 * _3540) + 32
                                        mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3540] = mem[(4 * ceil32(return_data.size)) + _3461 + 224 len 32 * _3540]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                        if 1 >= _3540:
                                            revert with 0, 50
                                    else:
                                        if ext_call.return_data[0] > -1:
                                            revert with 0, 17
                                        mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                                        mem[(4 * ceil32(return_data.size)) + 228] = 0
                                        mem[(4 * ceil32(return_data.size)) + 260] = 160
                                        mem[(4 * ceil32(return_data.size)) + 356] = 2
                                        idx = 0
                                        s = (4 * ceil32(return_data.size)) + 388
                                        t = (4 * ceil32(return_data.size)) + 128
                                        while idx < 2:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                        mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = (6 * ceil32(return_data.size)) + 192
                                        require return_data.size >= 32
                                        _3462 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                                        require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                        require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                        _3541 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                        if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                                            revert with 0, 65
                                        if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                                            revert with 0, 65
                                        mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                        require return_data.size >= _3462 + (32 * _3541) + 32
                                        mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3541] = mem[(4 * ceil32(return_data.size)) + _3462 + 224 len 32 * _3541]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                        if 1 >= _3541:
                                            revert with 0, 50
                else:
                    if brushAddress == address(ext_call.return_data[0]):
                        if brushAddress != address(ext_call.return_data[0]):
                            if wftmAddress == address(ext_call.return_data[0]):
                                if ext_call.return_data[32] > -1:
                                    revert with 0, 17
                                mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                                mem[(4 * ceil32(return_data.size)) + 228] = 0
                                mem[(4 * ceil32(return_data.size)) + 260] = 160
                                mem[(4 * ceil32(return_data.size)) + 356] = 2
                                idx = 0
                                s = (4 * ceil32(return_data.size)) + 388
                                t = (4 * ceil32(return_data.size)) + 128
                                while idx < 2:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (6 * ceil32(return_data.size)) + 192
                                require return_data.size >= 32
                                _3463 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                                require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                _3542 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                                    revert with 0, 65
                                if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                                    revert with 0, 65
                                mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                require return_data.size >= _3463 + (32 * _3542) + 32
                                mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3542] = mem[(4 * ceil32(return_data.size)) + _3463 + 224 len 32 * _3542]
                                if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                    revert with 0, 17
                                maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                if 1 >= _3542:
                                    revert with 0, 50
                            else:
                                if ext_call.return_data[0] > -1:
                                    revert with 0, 17
                                mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                                mem[(4 * ceil32(return_data.size)) + 228] = 0
                                mem[(4 * ceil32(return_data.size)) + 260] = 160
                                mem[(4 * ceil32(return_data.size)) + 356] = 2
                                idx = 0
                                s = (4 * ceil32(return_data.size)) + 388
                                t = (4 * ceil32(return_data.size)) + 128
                                while idx < 2:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (6 * ceil32(return_data.size)) + 192
                                require return_data.size >= 32
                                _3464 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                                require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                _3543 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                                    revert with 0, 65
                                if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                                    revert with 0, 65
                                mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                require return_data.size >= _3464 + (32 * _3543) + 32
                                mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3543] = mem[(4 * ceil32(return_data.size)) + _3464 + 224 len 32 * _3543]
                                if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                    revert with 0, 17
                                maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                if 1 >= _3543:
                                    revert with 0, 50
                        else:
                            if brushAddress == address(ext_call.return_data[0]):
                                if ext_call.return_data[32] > -1:
                                    revert with 0, 17
                                mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                                mem[(4 * ceil32(return_data.size)) + 228] = 0
                                mem[(4 * ceil32(return_data.size)) + 260] = 160
                                mem[(4 * ceil32(return_data.size)) + 356] = 2
                                idx = 0
                                s = (4 * ceil32(return_data.size)) + 388
                                t = (4 * ceil32(return_data.size)) + 128
                                while idx < 2:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (6 * ceil32(return_data.size)) + 192
                                require return_data.size >= 32
                                _3465 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                                require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                _3544 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                                    revert with 0, 65
                                if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                                    revert with 0, 65
                                mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                require return_data.size >= _3465 + (32 * _3544) + 32
                                mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3544] = mem[(4 * ceil32(return_data.size)) + _3465 + 224 len 32 * _3544]
                                if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                    revert with 0, 17
                                maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                if 1 >= _3544:
                                    revert with 0, 50
                            else:
                                if brushAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[0] > -1:
                                        revert with 0, 17
                                    mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                                    mem[(4 * ceil32(return_data.size)) + 228] = 0
                                    mem[(4 * ceil32(return_data.size)) + 260] = 160
                                    mem[(4 * ceil32(return_data.size)) + 356] = 2
                                    idx = 0
                                    s = (4 * ceil32(return_data.size)) + 388
                                    t = (4 * ceil32(return_data.size)) + 128
                                    while idx < 2:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                    mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = (6 * ceil32(return_data.size)) + 192
                                    require return_data.size >= 32
                                    _3466 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                                    require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                    _3545 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                    if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                                        revert with 0, 65
                                    if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                                        revert with 0, 65
                                    mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                    require return_data.size >= _3466 + (32 * _3545) + 32
                                    mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3545] = mem[(4 * ceil32(return_data.size)) + _3466 + 224 len 32 * _3545]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                    if 1 >= _3545:
                                        revert with 0, 50
                                else:
                                    if wftmAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[32] > -1:
                                            revert with 0, 17
                                        mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                                        mem[(4 * ceil32(return_data.size)) + 228] = 0
                                        mem[(4 * ceil32(return_data.size)) + 260] = 160
                                        mem[(4 * ceil32(return_data.size)) + 356] = 2
                                        idx = 0
                                        s = (4 * ceil32(return_data.size)) + 388
                                        t = (4 * ceil32(return_data.size)) + 128
                                        while idx < 2:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                        mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = (6 * ceil32(return_data.size)) + 192
                                        require return_data.size >= 32
                                        _3467 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                                        require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                                        require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                        _3546 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                        if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                                            revert with 0, 65
                                        if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                                            revert with 0, 65
                                        mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                        require return_data.size >= _3467 + (32 * _3546) + 32
                                        mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3546] = mem[(4 * ceil32(return_data.size)) + _3467 + 224 len 32 * _3546]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                        if 1 >= _3546:
                                            revert with 0, 50
                                    else:
                                        if ext_call.return_data[0] > -1:
                                            revert with 0, 17
                                        mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                                        mem[(4 * ceil32(return_data.size)) + 228] = 0
                                        mem[(4 * ceil32(return_data.size)) + 260] = 160
                                        mem[(4 * ceil32(return_data.size)) + 356] = 2
                                        idx = 0
                                        s = (4 * ceil32(return_data.size)) + 388
                                        t = (4 * ceil32(return_data.size)) + 128
                                        while idx < 2:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                        mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = (6 * ceil32(return_data.size)) + 192
                                        require return_data.size >= 32
                                        _3468 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                                        require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                        require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                        _3547 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                        if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                                            revert with 0, 65
                                        if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                                            revert with 0, 65
                                        mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                        require return_data.size >= _3468 + (32 * _3547) + 32
                                        mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3547] = mem[(4 * ceil32(return_data.size)) + _3468 + 224 len 32 * _3547]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                        if 1 >= _3547:
                                            revert with 0, 50
                    else:
                        if brushAddress == address(ext_call.return_data[0]):
                            if brushAddress != address(ext_call.return_data[0]):
                                if wftmAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > -1:
                                        revert with 0, 17
                                    mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                                    mem[(4 * ceil32(return_data.size)) + 228] = 0
                                    mem[(4 * ceil32(return_data.size)) + 260] = 160
                                    mem[(4 * ceil32(return_data.size)) + 356] = 2
                                    idx = 0
                                    s = (4 * ceil32(return_data.size)) + 388
                                    t = (4 * ceil32(return_data.size)) + 128
                                    while idx < 2:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                    mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = (6 * ceil32(return_data.size)) + 192
                                    require return_data.size >= 32
                                    _3469 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                                    require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                                    require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                    _3548 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                    if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                                        revert with 0, 65
                                    if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                                        revert with 0, 65
                                    mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                    require return_data.size >= _3469 + (32 * _3548) + 32
                                    mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3548] = mem[(4 * ceil32(return_data.size)) + _3469 + 224 len 32 * _3548]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                    if 1 >= _3548:
                                        revert with 0, 50
                                else:
                                    if ext_call.return_data[0] > -1:
                                        revert with 0, 17
                                    mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                                    mem[(4 * ceil32(return_data.size)) + 228] = 0
                                    mem[(4 * ceil32(return_data.size)) + 260] = 160
                                    mem[(4 * ceil32(return_data.size)) + 356] = 2
                                    idx = 0
                                    s = (4 * ceil32(return_data.size)) + 388
                                    t = (4 * ceil32(return_data.size)) + 128
                                    while idx < 2:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                    mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = (6 * ceil32(return_data.size)) + 192
                                    require return_data.size >= 32
                                    _3470 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                                    require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                    _3549 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                    if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                                        revert with 0, 65
                                    if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                                        revert with 0, 65
                                    mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                    require return_data.size >= _3470 + (32 * _3549) + 32
                                    mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3549] = mem[(4 * ceil32(return_data.size)) + _3470 + 224 len 32 * _3549]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                    if 1 >= _3549:
                                        revert with 0, 50
                            else:
                                if brushAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > -1:
                                        revert with 0, 17
                                    mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                                    mem[(4 * ceil32(return_data.size)) + 228] = 0
                                    mem[(4 * ceil32(return_data.size)) + 260] = 160
                                    mem[(4 * ceil32(return_data.size)) + 356] = 2
                                    idx = 0
                                    s = (4 * ceil32(return_data.size)) + 388
                                    t = (4 * ceil32(return_data.size)) + 128
                                    while idx < 2:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                    mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = (6 * ceil32(return_data.size)) + 192
                                    require return_data.size >= 32
                                    _3471 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                                    require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                                    require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                    _3550 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                    if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                                        revert with 0, 65
                                    if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                                        revert with 0, 65
                                    mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                    require return_data.size >= _3471 + (32 * _3550) + 32
                                    mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3550] = mem[(4 * ceil32(return_data.size)) + _3471 + 224 len 32 * _3550]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                    if 1 >= _3550:
                                        revert with 0, 50
                                else:
                                    if brushAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[0] > -1:
                                            revert with 0, 17
                                        mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                                        mem[(4 * ceil32(return_data.size)) + 228] = 0
                                        mem[(4 * ceil32(return_data.size)) + 260] = 160
                                        mem[(4 * ceil32(return_data.size)) + 356] = 2
                                        idx = 0
                                        s = (4 * ceil32(return_data.size)) + 388
                                        t = (4 * ceil32(return_data.size)) + 128
                                        while idx < 2:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                        mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = (6 * ceil32(return_data.size)) + 192
                                        require return_data.size >= 32
                                        _3472 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                                        require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                        require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                        _3551 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                        if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                                            revert with 0, 65
                                        if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                                            revert with 0, 65
                                        mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                        require return_data.size >= _3472 + (32 * _3551) + 32
                                        mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3551] = mem[(4 * ceil32(return_data.size)) + _3472 + 224 len 32 * _3551]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                        if 1 >= _3551:
                                            revert with 0, 50
                                    else:
                                        if wftmAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > -1:
                                                revert with 0, 17
                                            mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                                            mem[(4 * ceil32(return_data.size)) + 228] = 0
                                            mem[(4 * ceil32(return_data.size)) + 260] = 160
                                            mem[(4 * ceil32(return_data.size)) + 356] = 2
                                            idx = 0
                                            s = (4 * ceil32(return_data.size)) + 388
                                            t = (4 * ceil32(return_data.size)) + 128
                                            while idx < 2:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                            mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                 gas gas_remaining wei
                                                args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = (6 * ceil32(return_data.size)) + 192
                                            require return_data.size >= 32
                                            _3473 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                                            require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                                            require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                            _3552 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                            if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                                                revert with 0, 65
                                            if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                                                revert with 0, 65
                                            mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                            require return_data.size >= _3473 + (32 * _3552) + 32
                                            mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3552] = mem[(4 * ceil32(return_data.size)) + _3473 + 224 len 32 * _3552]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                            if 1 >= _3552:
                                                revert with 0, 50
                                        else:
                                            if ext_call.return_data[0] > -1:
                                                revert with 0, 17
                                            mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                                            mem[(4 * ceil32(return_data.size)) + 228] = 0
                                            mem[(4 * ceil32(return_data.size)) + 260] = 160
                                            mem[(4 * ceil32(return_data.size)) + 356] = 2
                                            idx = 0
                                            s = (4 * ceil32(return_data.size)) + 388
                                            t = (4 * ceil32(return_data.size)) + 128
                                            while idx < 2:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                            mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                 gas gas_remaining wei
                                                args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = (6 * ceil32(return_data.size)) + 192
                                            require return_data.size >= 32
                                            _3474 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                                            require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                            require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                            _3553 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                            if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                                                revert with 0, 65
                                            if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                                                revert with 0, 65
                                            mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                            require return_data.size >= _3474 + (32 * _3553) + 32
                                            mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3553] = mem[(4 * ceil32(return_data.size)) + _3474 + 224 len 32 * _3553]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                            if 1 >= _3553:
                                                revert with 0, 50
                        else:
                            if wftmAddress == address(ext_call.return_data[0]):
                                if brushAddress != address(ext_call.return_data[0]):
                                    if wftmAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[32] > -1:
                                            revert with 0, 17
                                        mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                                        mem[(4 * ceil32(return_data.size)) + 228] = 0
                                        mem[(4 * ceil32(return_data.size)) + 260] = 160
                                        mem[(4 * ceil32(return_data.size)) + 356] = 2
                                        idx = 0
                                        s = (4 * ceil32(return_data.size)) + 388
                                        t = (4 * ceil32(return_data.size)) + 128
                                        while idx < 2:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                        mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = (6 * ceil32(return_data.size)) + 192
                                        require return_data.size >= 32
                                        _3475 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                                        require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                                        require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                        _3554 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                        if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                                            revert with 0, 65
                                        if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                                            revert with 0, 65
                                        mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                        require return_data.size >= _3475 + (32 * _3554) + 32
                                        mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3554] = mem[(4 * ceil32(return_data.size)) + _3475 + 224 len 32 * _3554]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                        if 1 >= _3554:
                                            revert with 0, 50
                                    else:
                                        if ext_call.return_data[0] > -1:
                                            revert with 0, 17
                                        mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                                        mem[(4 * ceil32(return_data.size)) + 228] = 0
                                        mem[(4 * ceil32(return_data.size)) + 260] = 160
                                        mem[(4 * ceil32(return_data.size)) + 356] = 2
                                        idx = 0
                                        s = (4 * ceil32(return_data.size)) + 388
                                        t = (4 * ceil32(return_data.size)) + 128
                                        while idx < 2:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                        mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = (6 * ceil32(return_data.size)) + 192
                                        require return_data.size >= 32
                                        _3476 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                                        require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                        require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                        _3555 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                        if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                                            revert with 0, 65
                                        if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                                            revert with 0, 65
                                        mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                        require return_data.size >= _3476 + (32 * _3555) + 32
                                        mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3555] = mem[(4 * ceil32(return_data.size)) + _3476 + 224 len 32 * _3555]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                        if 1 >= _3555:
                                            revert with 0, 50
                                else:
                                    if brushAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[32] > -1:
                                            revert with 0, 17
                                        mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                                        mem[(4 * ceil32(return_data.size)) + 228] = 0
                                        mem[(4 * ceil32(return_data.size)) + 260] = 160
                                        mem[(4 * ceil32(return_data.size)) + 356] = 2
                                        idx = 0
                                        s = (4 * ceil32(return_data.size)) + 388
                                        t = (4 * ceil32(return_data.size)) + 128
                                        while idx < 2:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                        mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = (6 * ceil32(return_data.size)) + 192
                                        require return_data.size >= 32
                                        _3477 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                                        require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                                        require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                        _3556 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                        if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                                            revert with 0, 65
                                        if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                                            revert with 0, 65
                                        mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                        require return_data.size >= _3477 + (32 * _3556) + 32
                                        mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3556] = mem[(4 * ceil32(return_data.size)) + _3477 + 224 len 32 * _3556]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                        if 1 >= _3556:
                                            revert with 0, 50
                                    else:
                                        if brushAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[0] > -1:
                                                revert with 0, 17
                                            mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                                            mem[(4 * ceil32(return_data.size)) + 228] = 0
                                            mem[(4 * ceil32(return_data.size)) + 260] = 160
                                            mem[(4 * ceil32(return_data.size)) + 356] = 2
                                            idx = 0
                                            s = (4 * ceil32(return_data.size)) + 388
                                            t = (4 * ceil32(return_data.size)) + 128
                                            while idx < 2:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                            mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                 gas gas_remaining wei
                                                args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = (6 * ceil32(return_data.size)) + 192
                                            require return_data.size >= 32
                                            _3478 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                                            require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                            require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                            _3557 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                            if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                                                revert with 0, 65
                                            if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                                                revert with 0, 65
                                            mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                            require return_data.size >= _3478 + (32 * _3557) + 32
                                            mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3557] = mem[(4 * ceil32(return_data.size)) + _3478 + 224 len 32 * _3557]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                            if 1 >= _3557:
                                                revert with 0, 50
                                        else:
                                            if wftmAddress == address(ext_call.return_data[0]):
                                                if ext_call.return_data[32] > -1:
                                                    revert with 0, 17
                                                mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                                                mem[(4 * ceil32(return_data.size)) + 228] = 0
                                                mem[(4 * ceil32(return_data.size)) + 260] = 160
                                                mem[(4 * ceil32(return_data.size)) + 356] = 2
                                                idx = 0
                                                s = (4 * ceil32(return_data.size)) + 388
                                                t = (4 * ceil32(return_data.size)) + 128
                                                while idx < 2:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                                mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                                require ext_code.size(routerAddress)
                                                call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (6 * ceil32(return_data.size)) + 192
                                                require return_data.size >= 32
                                                _3479 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                                                require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                                                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                                _3558 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                                                    revert with 0, 65
                                                if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                                require return_data.size >= _3479 + (32 * _3558) + 32
                                                mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3558] = mem[(4 * ceil32(return_data.size)) + _3479 + 224 len 32 * _3558]
                                                if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                    revert with 0, 17
                                                maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                                if 1 >= _3558:
                                                    revert with 0, 50
                                            else:
                                                if ext_call.return_data[0] > -1:
                                                    revert with 0, 17
                                                mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                                                mem[(4 * ceil32(return_data.size)) + 228] = 0
                                                mem[(4 * ceil32(return_data.size)) + 260] = 160
                                                mem[(4 * ceil32(return_data.size)) + 356] = 2
                                                idx = 0
                                                s = (4 * ceil32(return_data.size)) + 388
                                                t = (4 * ceil32(return_data.size)) + 128
                                                while idx < 2:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                                mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                                require ext_code.size(routerAddress)
                                                call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (6 * ceil32(return_data.size)) + 192
                                                require return_data.size >= 32
                                                _3480 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                                                require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                                _3559 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                                                    revert with 0, 65
                                                if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                                require return_data.size >= _3480 + (32 * _3559) + 32
                                                mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3559] = mem[(4 * ceil32(return_data.size)) + _3480 + 224 len 32 * _3559]
                                                if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                    revert with 0, 17
                                                maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                                if 1 >= _3559:
                                                    revert with 0, 50
                            else:
                                if brushAddress != address(ext_call.return_data[0]):
                                    if wftmAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[32] > -1:
                                            revert with 0, 17
                                        mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                                        mem[(4 * ceil32(return_data.size)) + 228] = 0
                                        mem[(4 * ceil32(return_data.size)) + 260] = 160
                                        mem[(4 * ceil32(return_data.size)) + 356] = 2
                                        idx = 0
                                        s = (4 * ceil32(return_data.size)) + 388
                                        t = (4 * ceil32(return_data.size)) + 128
                                        while idx < 2:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                        mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = (6 * ceil32(return_data.size)) + 192
                                        require return_data.size >= 32
                                        _3481 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                                        require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                                        require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                        _3560 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                        if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                                            revert with 0, 65
                                        if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                                            revert with 0, 65
                                        mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                        require return_data.size >= _3481 + (32 * _3560) + 32
                                        mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3560] = mem[(4 * ceil32(return_data.size)) + _3481 + 224 len 32 * _3560]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                        if 1 >= _3560:
                                            revert with 0, 50
                                    else:
                                        if ext_call.return_data[0] > -1:
                                            revert with 0, 17
                                        mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                                        mem[(4 * ceil32(return_data.size)) + 228] = 0
                                        mem[(4 * ceil32(return_data.size)) + 260] = 160
                                        mem[(4 * ceil32(return_data.size)) + 356] = 2
                                        idx = 0
                                        s = (4 * ceil32(return_data.size)) + 388
                                        t = (4 * ceil32(return_data.size)) + 128
                                        while idx < 2:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                        mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = (6 * ceil32(return_data.size)) + 192
                                        require return_data.size >= 32
                                        _3482 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                                        require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                        require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                        _3561 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                        if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                                            revert with 0, 65
                                        if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                                            revert with 0, 65
                                        mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                        require return_data.size >= _3482 + (32 * _3561) + 32
                                        mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3561] = mem[(4 * ceil32(return_data.size)) + _3482 + 224 len 32 * _3561]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                        if 1 >= _3561:
                                            revert with 0, 50
                                else:
                                    if brushAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[32] > -1:
                                            revert with 0, 17
                                        mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                                        mem[(4 * ceil32(return_data.size)) + 228] = 0
                                        mem[(4 * ceil32(return_data.size)) + 260] = 160
                                        mem[(4 * ceil32(return_data.size)) + 356] = 2
                                        idx = 0
                                        s = (4 * ceil32(return_data.size)) + 388
                                        t = (4 * ceil32(return_data.size)) + 128
                                        while idx < 2:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                        mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = (6 * ceil32(return_data.size)) + 192
                                        require return_data.size >= 32
                                        _3483 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                                        require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                                        require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                        _3562 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                        if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                                            revert with 0, 65
                                        if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                                            revert with 0, 65
                                        mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                        require return_data.size >= _3483 + (32 * _3562) + 32
                                        mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3562] = mem[(4 * ceil32(return_data.size)) + _3483 + 224 len 32 * _3562]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                        if 1 >= _3562:
                                            revert with 0, 50
                                    else:
                                        if brushAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[0] > -1:
                                                revert with 0, 17
                                            mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                                            mem[(4 * ceil32(return_data.size)) + 228] = 0
                                            mem[(4 * ceil32(return_data.size)) + 260] = 160
                                            mem[(4 * ceil32(return_data.size)) + 356] = 2
                                            idx = 0
                                            s = (4 * ceil32(return_data.size)) + 388
                                            t = (4 * ceil32(return_data.size)) + 128
                                            while idx < 2:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                            mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                 gas gas_remaining wei
                                                args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = (6 * ceil32(return_data.size)) + 192
                                            require return_data.size >= 32
                                            _3484 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                                            require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                            require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                            _3563 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                            if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                                                revert with 0, 65
                                            if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                                                revert with 0, 65
                                            mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                            require return_data.size >= _3484 + (32 * _3563) + 32
                                            mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3563] = mem[(4 * ceil32(return_data.size)) + _3484 + 224 len 32 * _3563]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                            if 1 >= _3563:
                                                revert with 0, 50
                                        else:
                                            if wftmAddress == address(ext_call.return_data[0]):
                                                if ext_call.return_data[32] > -1:
                                                    revert with 0, 17
                                                mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                                                mem[(4 * ceil32(return_data.size)) + 228] = 0
                                                mem[(4 * ceil32(return_data.size)) + 260] = 160
                                                mem[(4 * ceil32(return_data.size)) + 356] = 2
                                                idx = 0
                                                s = (4 * ceil32(return_data.size)) + 388
                                                t = (4 * ceil32(return_data.size)) + 128
                                                while idx < 2:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                                mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                                require ext_code.size(routerAddress)
                                                call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (6 * ceil32(return_data.size)) + 192
                                                require return_data.size >= 32
                                                _3485 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                                                require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                                                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                                _3564 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                                                    revert with 0, 65
                                                if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                                require return_data.size >= _3485 + (32 * _3564) + 32
                                                mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3564] = mem[(4 * ceil32(return_data.size)) + _3485 + 224 len 32 * _3564]
                                                if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                    revert with 0, 17
                                                maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                                if 1 >= _3564:
                                                    revert with 0, 50
                                            else:
                                                if ext_call.return_data[0] > -1:
                                                    revert with 0, 17
                                                mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                                                mem[(4 * ceil32(return_data.size)) + 228] = 0
                                                mem[(4 * ceil32(return_data.size)) + 260] = 160
                                                mem[(4 * ceil32(return_data.size)) + 356] = 2
                                                idx = 0
                                                s = (4 * ceil32(return_data.size)) + 388
                                                t = (4 * ceil32(return_data.size)) + 128
                                                while idx < 2:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                                mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                                require ext_code.size(routerAddress)
                                                call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (6 * ceil32(return_data.size)) + 192
                                                require return_data.size >= 32
                                                _3486 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                                                require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                                _3565 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                                                    revert with 0, 65
                                                if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                                require return_data.size >= _3486 + (32 * _3565) + 32
                                                mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3565] = mem[(4 * ceil32(return_data.size)) + _3486 + 224 len 32 * _3565]
                                                if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                    revert with 0, 17
                                                maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                                if 1 >= _3565:
                                                    revert with 0, 50
                if mem[(6 * ceil32(return_data.size)) + 256] > !ext_call.return_data[0]:
                    revert with 0, 17
                require ext_code.size(brushAddress)
                call brushAddress.0x42966c68 with:
                     gas gas_remaining wei
                    args (mem[(6 * ceil32(return_data.size)) + 256] + ext_call.return_data[0])
            else:
                if brushAddress != address(ext_call.return_data[0]):
                    if wftmAddress == address(ext_call.return_data[0]):
                        if brushAddress != address(ext_call.return_data[0]):
                            if wftmAddress == address(ext_call.return_data[0]):
                                if ext_call.return_data[32] > -1:
                                    revert with 0, 17
                                mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                                mem[(4 * ceil32(return_data.size)) + 228] = 0
                                mem[(4 * ceil32(return_data.size)) + 260] = 160
                                mem[(4 * ceil32(return_data.size)) + 356] = 2
                                idx = 0
                                s = (4 * ceil32(return_data.size)) + 388
                                t = (4 * ceil32(return_data.size)) + 128
                                while idx < 2:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (6 * ceil32(return_data.size)) + 192
                                require return_data.size >= 32
                                _3487 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                                require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                _3566 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                                    revert with 0, 65
                                if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                                    revert with 0, 65
                                mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                require return_data.size >= _3487 + (32 * _3566) + 32
                                mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3566] = mem[(4 * ceil32(return_data.size)) + _3487 + 224 len 32 * _3566]
                                if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                    revert with 0, 17
                                maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                if 1 >= _3566:
                                    revert with 0, 50
                            else:
                                if ext_call.return_data[0] > -1:
                                    revert with 0, 17
                                mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                                mem[(4 * ceil32(return_data.size)) + 228] = 0
                                mem[(4 * ceil32(return_data.size)) + 260] = 160
                                mem[(4 * ceil32(return_data.size)) + 356] = 2
                                idx = 0
                                s = (4 * ceil32(return_data.size)) + 388
                                t = (4 * ceil32(return_data.size)) + 128
                                while idx < 2:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (6 * ceil32(return_data.size)) + 192
                                require return_data.size >= 32
                                _3488 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                                require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                _3567 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                                    revert with 0, 65
                                if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                                    revert with 0, 65
                                mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                require return_data.size >= _3488 + (32 * _3567) + 32
                                mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3567] = mem[(4 * ceil32(return_data.size)) + _3488 + 224 len 32 * _3567]
                                if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                    revert with 0, 17
                                maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                if 1 >= _3567:
                                    revert with 0, 50
                        else:
                            if brushAddress == address(ext_call.return_data[0]):
                                if ext_call.return_data[32] > -1:
                                    revert with 0, 17
                                mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                                mem[(4 * ceil32(return_data.size)) + 228] = 0
                                mem[(4 * ceil32(return_data.size)) + 260] = 160
                                mem[(4 * ceil32(return_data.size)) + 356] = 2
                                idx = 0
                                s = (4 * ceil32(return_data.size)) + 388
                                t = (4 * ceil32(return_data.size)) + 128
                                while idx < 2:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (6 * ceil32(return_data.size)) + 192
                                require return_data.size >= 32
                                _3489 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                                require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                _3568 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                                    revert with 0, 65
                                if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                                    revert with 0, 65
                                mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                require return_data.size >= _3489 + (32 * _3568) + 32
                                mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3568] = mem[(4 * ceil32(return_data.size)) + _3489 + 224 len 32 * _3568]
                                if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                    revert with 0, 17
                                maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                if 1 >= _3568:
                                    revert with 0, 50
                            else:
                                if brushAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[0] > -1:
                                        revert with 0, 17
                                    mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                                    mem[(4 * ceil32(return_data.size)) + 228] = 0
                                    mem[(4 * ceil32(return_data.size)) + 260] = 160
                                    mem[(4 * ceil32(return_data.size)) + 356] = 2
                                    idx = 0
                                    s = (4 * ceil32(return_data.size)) + 388
                                    t = (4 * ceil32(return_data.size)) + 128
                                    while idx < 2:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                    mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = (6 * ceil32(return_data.size)) + 192
                                    require return_data.size >= 32
                                    _3490 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                                    require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                    _3569 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                    if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                                        revert with 0, 65
                                    if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                                        revert with 0, 65
                                    mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                    require return_data.size >= _3490 + (32 * _3569) + 32
                                    mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3569] = mem[(4 * ceil32(return_data.size)) + _3490 + 224 len 32 * _3569]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                    if 1 >= _3569:
                                        revert with 0, 50
                                else:
                                    if wftmAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[32] > -1:
                                            revert with 0, 17
                                        mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                                        mem[(4 * ceil32(return_data.size)) + 228] = 0
                                        mem[(4 * ceil32(return_data.size)) + 260] = 160
                                        mem[(4 * ceil32(return_data.size)) + 356] = 2
                                        idx = 0
                                        s = (4 * ceil32(return_data.size)) + 388
                                        t = (4 * ceil32(return_data.size)) + 128
                                        while idx < 2:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                        mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = (6 * ceil32(return_data.size)) + 192
                                        require return_data.size >= 32
                                        _3491 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                                        require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                                        require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                        _3570 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                        if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                                            revert with 0, 65
                                        if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                                            revert with 0, 65
                                        mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                        require return_data.size >= _3491 + (32 * _3570) + 32
                                        mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3570] = mem[(4 * ceil32(return_data.size)) + _3491 + 224 len 32 * _3570]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                        if 1 >= _3570:
                                            revert with 0, 50
                                    else:
                                        if ext_call.return_data[0] > -1:
                                            revert with 0, 17
                                        mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                                        mem[(4 * ceil32(return_data.size)) + 228] = 0
                                        mem[(4 * ceil32(return_data.size)) + 260] = 160
                                        mem[(4 * ceil32(return_data.size)) + 356] = 2
                                        idx = 0
                                        s = (4 * ceil32(return_data.size)) + 388
                                        t = (4 * ceil32(return_data.size)) + 128
                                        while idx < 2:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                        mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = (6 * ceil32(return_data.size)) + 192
                                        require return_data.size >= 32
                                        _3492 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                                        require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                        require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                        _3571 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                        if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                                            revert with 0, 65
                                        if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                                            revert with 0, 65
                                        mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                        require return_data.size >= _3492 + (32 * _3571) + 32
                                        mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3571] = mem[(4 * ceil32(return_data.size)) + _3492 + 224 len 32 * _3571]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                        if 1 >= _3571:
                                            revert with 0, 50
                    else:
                        if brushAddress != address(ext_call.return_data[0]):
                            if wftmAddress == address(ext_call.return_data[0]):
                                if ext_call.return_data[32] > -1:
                                    revert with 0, 17
                                mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                                mem[(4 * ceil32(return_data.size)) + 228] = 0
                                mem[(4 * ceil32(return_data.size)) + 260] = 160
                                mem[(4 * ceil32(return_data.size)) + 356] = 2
                                idx = 0
                                s = (4 * ceil32(return_data.size)) + 388
                                t = (4 * ceil32(return_data.size)) + 128
                                while idx < 2:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (6 * ceil32(return_data.size)) + 192
                                require return_data.size >= 32
                                _3493 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                                require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                _3572 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                                    revert with 0, 65
                                if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                                    revert with 0, 65
                                mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                require return_data.size >= _3493 + (32 * _3572) + 32
                                mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3572] = mem[(4 * ceil32(return_data.size)) + _3493 + 224 len 32 * _3572]
                                if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                    revert with 0, 17
                                maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                if 1 >= _3572:
                                    revert with 0, 50
                            else:
                                if ext_call.return_data[0] > -1:
                                    revert with 0, 17
                                mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                                mem[(4 * ceil32(return_data.size)) + 228] = 0
                                mem[(4 * ceil32(return_data.size)) + 260] = 160
                                mem[(4 * ceil32(return_data.size)) + 356] = 2
                                idx = 0
                                s = (4 * ceil32(return_data.size)) + 388
                                t = (4 * ceil32(return_data.size)) + 128
                                while idx < 2:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (6 * ceil32(return_data.size)) + 192
                                require return_data.size >= 32
                                _3494 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                                require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                _3573 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                                    revert with 0, 65
                                if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                                    revert with 0, 65
                                mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                require return_data.size >= _3494 + (32 * _3573) + 32
                                mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3573] = mem[(4 * ceil32(return_data.size)) + _3494 + 224 len 32 * _3573]
                                if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                    revert with 0, 17
                                maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                if 1 >= _3573:
                                    revert with 0, 50
                        else:
                            if brushAddress == address(ext_call.return_data[0]):
                                if ext_call.return_data[32] > -1:
                                    revert with 0, 17
                                mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                                mem[(4 * ceil32(return_data.size)) + 228] = 0
                                mem[(4 * ceil32(return_data.size)) + 260] = 160
                                mem[(4 * ceil32(return_data.size)) + 356] = 2
                                idx = 0
                                s = (4 * ceil32(return_data.size)) + 388
                                t = (4 * ceil32(return_data.size)) + 128
                                while idx < 2:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (6 * ceil32(return_data.size)) + 192
                                require return_data.size >= 32
                                _3495 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                                require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                _3574 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                                    revert with 0, 65
                                if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                                    revert with 0, 65
                                mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                require return_data.size >= _3495 + (32 * _3574) + 32
                                mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3574] = mem[(4 * ceil32(return_data.size)) + _3495 + 224 len 32 * _3574]
                                if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                    revert with 0, 17
                                maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                if 1 >= _3574:
                                    revert with 0, 50
                            else:
                                if brushAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[0] > -1:
                                        revert with 0, 17
                                    mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                                    mem[(4 * ceil32(return_data.size)) + 228] = 0
                                    mem[(4 * ceil32(return_data.size)) + 260] = 160
                                    mem[(4 * ceil32(return_data.size)) + 356] = 2
                                    idx = 0
                                    s = (4 * ceil32(return_data.size)) + 388
                                    t = (4 * ceil32(return_data.size)) + 128
                                    while idx < 2:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                    mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = (6 * ceil32(return_data.size)) + 192
                                    require return_data.size >= 32
                                    _3496 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                                    require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                    _3575 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                    if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                                        revert with 0, 65
                                    if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                                        revert with 0, 65
                                    mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                    require return_data.size >= _3496 + (32 * _3575) + 32
                                    mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3575] = mem[(4 * ceil32(return_data.size)) + _3496 + 224 len 32 * _3575]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                    if 1 >= _3575:
                                        revert with 0, 50
                                else:
                                    if wftmAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[32] > -1:
                                            revert with 0, 17
                                        mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                                        mem[(4 * ceil32(return_data.size)) + 228] = 0
                                        mem[(4 * ceil32(return_data.size)) + 260] = 160
                                        mem[(4 * ceil32(return_data.size)) + 356] = 2
                                        idx = 0
                                        s = (4 * ceil32(return_data.size)) + 388
                                        t = (4 * ceil32(return_data.size)) + 128
                                        while idx < 2:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                        mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = (6 * ceil32(return_data.size)) + 192
                                        require return_data.size >= 32
                                        _3497 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                                        require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                                        require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                        _3576 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                        if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                                            revert with 0, 65
                                        if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                                            revert with 0, 65
                                        mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                        require return_data.size >= _3497 + (32 * _3576) + 32
                                        mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3576] = mem[(4 * ceil32(return_data.size)) + _3497 + 224 len 32 * _3576]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                        if 1 >= _3576:
                                            revert with 0, 50
                                    else:
                                        if ext_call.return_data[0] > -1:
                                            revert with 0, 17
                                        mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                                        mem[(4 * ceil32(return_data.size)) + 228] = 0
                                        mem[(4 * ceil32(return_data.size)) + 260] = 160
                                        mem[(4 * ceil32(return_data.size)) + 356] = 2
                                        idx = 0
                                        s = (4 * ceil32(return_data.size)) + 388
                                        t = (4 * ceil32(return_data.size)) + 128
                                        while idx < 2:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                        mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = (6 * ceil32(return_data.size)) + 192
                                        require return_data.size >= 32
                                        _3498 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                                        require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                        require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                        _3577 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                        if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                                            revert with 0, 65
                                        if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                                            revert with 0, 65
                                        mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                        require return_data.size >= _3498 + (32 * _3577) + 32
                                        mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3577] = mem[(4 * ceil32(return_data.size)) + _3498 + 224 len 32 * _3577]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                        if 1 >= _3577:
                                            revert with 0, 50
                else:
                    if brushAddress == address(ext_call.return_data[0]):
                        if brushAddress != address(ext_call.return_data[0]):
                            if wftmAddress == address(ext_call.return_data[0]):
                                if ext_call.return_data[32] > -1:
                                    revert with 0, 17
                                mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                                mem[(4 * ceil32(return_data.size)) + 228] = 0
                                mem[(4 * ceil32(return_data.size)) + 260] = 160
                                mem[(4 * ceil32(return_data.size)) + 356] = 2
                                idx = 0
                                s = (4 * ceil32(return_data.size)) + 388
                                t = (4 * ceil32(return_data.size)) + 128
                                while idx < 2:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (6 * ceil32(return_data.size)) + 192
                                require return_data.size >= 32
                                _3499 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                                require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                _3578 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                                    revert with 0, 65
                                if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                                    revert with 0, 65
                                mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                require return_data.size >= _3499 + (32 * _3578) + 32
                                mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3578] = mem[(4 * ceil32(return_data.size)) + _3499 + 224 len 32 * _3578]
                                if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                    revert with 0, 17
                                maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                if 1 >= _3578:
                                    revert with 0, 50
                            else:
                                if ext_call.return_data[0] > -1:
                                    revert with 0, 17
                                mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                                mem[(4 * ceil32(return_data.size)) + 228] = 0
                                mem[(4 * ceil32(return_data.size)) + 260] = 160
                                mem[(4 * ceil32(return_data.size)) + 356] = 2
                                idx = 0
                                s = (4 * ceil32(return_data.size)) + 388
                                t = (4 * ceil32(return_data.size)) + 128
                                while idx < 2:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (6 * ceil32(return_data.size)) + 192
                                require return_data.size >= 32
                                _3500 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                                require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                _3579 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                                    revert with 0, 65
                                if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                                    revert with 0, 65
                                mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                require return_data.size >= _3500 + (32 * _3579) + 32
                                mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3579] = mem[(4 * ceil32(return_data.size)) + _3500 + 224 len 32 * _3579]
                                if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                    revert with 0, 17
                                maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                if 1 >= _3579:
                                    revert with 0, 50
                        else:
                            if brushAddress == address(ext_call.return_data[0]):
                                if ext_call.return_data[32] > -1:
                                    revert with 0, 17
                                mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                                mem[(4 * ceil32(return_data.size)) + 228] = 0
                                mem[(4 * ceil32(return_data.size)) + 260] = 160
                                mem[(4 * ceil32(return_data.size)) + 356] = 2
                                idx = 0
                                s = (4 * ceil32(return_data.size)) + 388
                                t = (4 * ceil32(return_data.size)) + 128
                                while idx < 2:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (6 * ceil32(return_data.size)) + 192
                                require return_data.size >= 32
                                _3501 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                                require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                _3580 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                                    revert with 0, 65
                                if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                                    revert with 0, 65
                                mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                require return_data.size >= _3501 + (32 * _3580) + 32
                                mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3580] = mem[(4 * ceil32(return_data.size)) + _3501 + 224 len 32 * _3580]
                                if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                    revert with 0, 17
                                maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                if 1 >= _3580:
                                    revert with 0, 50
                            else:
                                if brushAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[0] > -1:
                                        revert with 0, 17
                                    mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                                    mem[(4 * ceil32(return_data.size)) + 228] = 0
                                    mem[(4 * ceil32(return_data.size)) + 260] = 160
                                    mem[(4 * ceil32(return_data.size)) + 356] = 2
                                    idx = 0
                                    s = (4 * ceil32(return_data.size)) + 388
                                    t = (4 * ceil32(return_data.size)) + 128
                                    while idx < 2:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                    mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = (6 * ceil32(return_data.size)) + 192
                                    require return_data.size >= 32
                                    _3502 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                                    require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                    _3581 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                    if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                                        revert with 0, 65
                                    if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                                        revert with 0, 65
                                    mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                    require return_data.size >= _3502 + (32 * _3581) + 32
                                    mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3581] = mem[(4 * ceil32(return_data.size)) + _3502 + 224 len 32 * _3581]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                    if 1 >= _3581:
                                        revert with 0, 50
                                else:
                                    if wftmAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[32] > -1:
                                            revert with 0, 17
                                        mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                                        mem[(4 * ceil32(return_data.size)) + 228] = 0
                                        mem[(4 * ceil32(return_data.size)) + 260] = 160
                                        mem[(4 * ceil32(return_data.size)) + 356] = 2
                                        idx = 0
                                        s = (4 * ceil32(return_data.size)) + 388
                                        t = (4 * ceil32(return_data.size)) + 128
                                        while idx < 2:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                        mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = (6 * ceil32(return_data.size)) + 192
                                        require return_data.size >= 32
                                        _3503 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                                        require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                                        require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                        _3582 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                        if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                                            revert with 0, 65
                                        if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                                            revert with 0, 65
                                        mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                        require return_data.size >= _3503 + (32 * _3582) + 32
                                        mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3582] = mem[(4 * ceil32(return_data.size)) + _3503 + 224 len 32 * _3582]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                        if 1 >= _3582:
                                            revert with 0, 50
                                    else:
                                        if ext_call.return_data[0] > -1:
                                            revert with 0, 17
                                        mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                                        mem[(4 * ceil32(return_data.size)) + 228] = 0
                                        mem[(4 * ceil32(return_data.size)) + 260] = 160
                                        mem[(4 * ceil32(return_data.size)) + 356] = 2
                                        idx = 0
                                        s = (4 * ceil32(return_data.size)) + 388
                                        t = (4 * ceil32(return_data.size)) + 128
                                        while idx < 2:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                        mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = (6 * ceil32(return_data.size)) + 192
                                        require return_data.size >= 32
                                        _3504 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                                        require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                        require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                        _3583 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                        if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                                            revert with 0, 65
                                        if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                                            revert with 0, 65
                                        mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                        require return_data.size >= _3504 + (32 * _3583) + 32
                                        mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3583] = mem[(4 * ceil32(return_data.size)) + _3504 + 224 len 32 * _3583]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                        if 1 >= _3583:
                                            revert with 0, 50
                    else:
                        if brushAddress == address(ext_call.return_data[0]):
                            if brushAddress != address(ext_call.return_data[0]):
                                if wftmAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > -1:
                                        revert with 0, 17
                                    mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                                    mem[(4 * ceil32(return_data.size)) + 228] = 0
                                    mem[(4 * ceil32(return_data.size)) + 260] = 160
                                    mem[(4 * ceil32(return_data.size)) + 356] = 2
                                    idx = 0
                                    s = (4 * ceil32(return_data.size)) + 388
                                    t = (4 * ceil32(return_data.size)) + 128
                                    while idx < 2:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                    mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = (6 * ceil32(return_data.size)) + 192
                                    require return_data.size >= 32
                                    _3505 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                                    require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                                    require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                    _3584 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                    if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                                        revert with 0, 65
                                    if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                                        revert with 0, 65
                                    mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                    require return_data.size >= _3505 + (32 * _3584) + 32
                                    mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3584] = mem[(4 * ceil32(return_data.size)) + _3505 + 224 len 32 * _3584]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                    if 1 >= _3584:
                                        revert with 0, 50
                                else:
                                    if ext_call.return_data[0] > -1:
                                        revert with 0, 17
                                    mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                                    mem[(4 * ceil32(return_data.size)) + 228] = 0
                                    mem[(4 * ceil32(return_data.size)) + 260] = 160
                                    mem[(4 * ceil32(return_data.size)) + 356] = 2
                                    idx = 0
                                    s = (4 * ceil32(return_data.size)) + 388
                                    t = (4 * ceil32(return_data.size)) + 128
                                    while idx < 2:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                    mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = (6 * ceil32(return_data.size)) + 192
                                    require return_data.size >= 32
                                    _3506 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                                    require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                    _3585 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                    if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                                        revert with 0, 65
                                    if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                                        revert with 0, 65
                                    mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                    require return_data.size >= _3506 + (32 * _3585) + 32
                                    mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3585] = mem[(4 * ceil32(return_data.size)) + _3506 + 224 len 32 * _3585]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                    if 1 >= _3585:
                                        revert with 0, 50
                            else:
                                if brushAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > -1:
                                        revert with 0, 17
                                    mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                                    mem[(4 * ceil32(return_data.size)) + 228] = 0
                                    mem[(4 * ceil32(return_data.size)) + 260] = 160
                                    mem[(4 * ceil32(return_data.size)) + 356] = 2
                                    idx = 0
                                    s = (4 * ceil32(return_data.size)) + 388
                                    t = (4 * ceil32(return_data.size)) + 128
                                    while idx < 2:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                    mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = (6 * ceil32(return_data.size)) + 192
                                    require return_data.size >= 32
                                    _3507 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                                    require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                                    require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                    _3586 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                    if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                                        revert with 0, 65
                                    if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                                        revert with 0, 65
                                    mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                    require return_data.size >= _3507 + (32 * _3586) + 32
                                    mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3586] = mem[(4 * ceil32(return_data.size)) + _3507 + 224 len 32 * _3586]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                    if 1 >= _3586:
                                        revert with 0, 50
                                else:
                                    if brushAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[0] > -1:
                                            revert with 0, 17
                                        mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                                        mem[(4 * ceil32(return_data.size)) + 228] = 0
                                        mem[(4 * ceil32(return_data.size)) + 260] = 160
                                        mem[(4 * ceil32(return_data.size)) + 356] = 2
                                        idx = 0
                                        s = (4 * ceil32(return_data.size)) + 388
                                        t = (4 * ceil32(return_data.size)) + 128
                                        while idx < 2:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                        mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = (6 * ceil32(return_data.size)) + 192
                                        require return_data.size >= 32
                                        _3508 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                                        require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                        require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                        _3587 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                        if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                                            revert with 0, 65
                                        if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                                            revert with 0, 65
                                        mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                        require return_data.size >= _3508 + (32 * _3587) + 32
                                        mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3587] = mem[(4 * ceil32(return_data.size)) + _3508 + 224 len 32 * _3587]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                        if 1 >= _3587:
                                            revert with 0, 50
                                    else:
                                        if wftmAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > -1:
                                                revert with 0, 17
                                            mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                                            mem[(4 * ceil32(return_data.size)) + 228] = 0
                                            mem[(4 * ceil32(return_data.size)) + 260] = 160
                                            mem[(4 * ceil32(return_data.size)) + 356] = 2
                                            idx = 0
                                            s = (4 * ceil32(return_data.size)) + 388
                                            t = (4 * ceil32(return_data.size)) + 128
                                            while idx < 2:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                            mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                 gas gas_remaining wei
                                                args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = (6 * ceil32(return_data.size)) + 192
                                            require return_data.size >= 32
                                            _3509 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                                            require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                                            require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                            _3588 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                            if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                                                revert with 0, 65
                                            if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                                                revert with 0, 65
                                            mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                            require return_data.size >= _3509 + (32 * _3588) + 32
                                            mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3588] = mem[(4 * ceil32(return_data.size)) + _3509 + 224 len 32 * _3588]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                            if 1 >= _3588:
                                                revert with 0, 50
                                        else:
                                            if ext_call.return_data[0] > -1:
                                                revert with 0, 17
                                            mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                                            mem[(4 * ceil32(return_data.size)) + 228] = 0
                                            mem[(4 * ceil32(return_data.size)) + 260] = 160
                                            mem[(4 * ceil32(return_data.size)) + 356] = 2
                                            idx = 0
                                            s = (4 * ceil32(return_data.size)) + 388
                                            t = (4 * ceil32(return_data.size)) + 128
                                            while idx < 2:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                            mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                 gas gas_remaining wei
                                                args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = (6 * ceil32(return_data.size)) + 192
                                            require return_data.size >= 32
                                            _3510 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                                            require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                            require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                            _3589 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                            if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                                                revert with 0, 65
                                            if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                                                revert with 0, 65
                                            mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                            require return_data.size >= _3510 + (32 * _3589) + 32
                                            mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3589] = mem[(4 * ceil32(return_data.size)) + _3510 + 224 len 32 * _3589]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                            if 1 >= _3589:
                                                revert with 0, 50
                        else:
                            if wftmAddress == address(ext_call.return_data[0]):
                                if brushAddress != address(ext_call.return_data[0]):
                                    if wftmAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[32] > -1:
                                            revert with 0, 17
                                        mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                                        mem[(4 * ceil32(return_data.size)) + 228] = 0
                                        mem[(4 * ceil32(return_data.size)) + 260] = 160
                                        mem[(4 * ceil32(return_data.size)) + 356] = 2
                                        idx = 0
                                        s = (4 * ceil32(return_data.size)) + 388
                                        t = (4 * ceil32(return_data.size)) + 128
                                        while idx < 2:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                        mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = (6 * ceil32(return_data.size)) + 192
                                        require return_data.size >= 32
                                        _3511 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                                        require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                                        require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                        _3590 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                        if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                                            revert with 0, 65
                                        if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                                            revert with 0, 65
                                        mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                        require return_data.size >= _3511 + (32 * _3590) + 32
                                        mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3590] = mem[(4 * ceil32(return_data.size)) + _3511 + 224 len 32 * _3590]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                        if 1 >= _3590:
                                            revert with 0, 50
                                    else:
                                        if ext_call.return_data[0] > -1:
                                            revert with 0, 17
                                        mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                                        mem[(4 * ceil32(return_data.size)) + 228] = 0
                                        mem[(4 * ceil32(return_data.size)) + 260] = 160
                                        mem[(4 * ceil32(return_data.size)) + 356] = 2
                                        idx = 0
                                        s = (4 * ceil32(return_data.size)) + 388
                                        t = (4 * ceil32(return_data.size)) + 128
                                        while idx < 2:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                        mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = (6 * ceil32(return_data.size)) + 192
                                        require return_data.size >= 32
                                        _3512 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                                        require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                        require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                        _3591 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                        if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                                            revert with 0, 65
                                        if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                                            revert with 0, 65
                                        mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                        require return_data.size >= _3512 + (32 * _3591) + 32
                                        mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3591] = mem[(4 * ceil32(return_data.size)) + _3512 + 224 len 32 * _3591]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                        if 1 >= _3591:
                                            revert with 0, 50
                                else:
                                    if brushAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[32] > -1:
                                            revert with 0, 17
                                        mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                                        mem[(4 * ceil32(return_data.size)) + 228] = 0
                                        mem[(4 * ceil32(return_data.size)) + 260] = 160
                                        mem[(4 * ceil32(return_data.size)) + 356] = 2
                                        idx = 0
                                        s = (4 * ceil32(return_data.size)) + 388
                                        t = (4 * ceil32(return_data.size)) + 128
                                        while idx < 2:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                        mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = (6 * ceil32(return_data.size)) + 192
                                        require return_data.size >= 32
                                        _3513 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                                        require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                                        require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                        _3592 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                        if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                                            revert with 0, 65
                                        if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                                            revert with 0, 65
                                        mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                        require return_data.size >= _3513 + (32 * _3592) + 32
                                        mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3592] = mem[(4 * ceil32(return_data.size)) + _3513 + 224 len 32 * _3592]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                        if 1 >= _3592:
                                            revert with 0, 50
                                    else:
                                        if brushAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[0] > -1:
                                                revert with 0, 17
                                            mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                                            mem[(4 * ceil32(return_data.size)) + 228] = 0
                                            mem[(4 * ceil32(return_data.size)) + 260] = 160
                                            mem[(4 * ceil32(return_data.size)) + 356] = 2
                                            idx = 0
                                            s = (4 * ceil32(return_data.size)) + 388
                                            t = (4 * ceil32(return_data.size)) + 128
                                            while idx < 2:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                            mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                 gas gas_remaining wei
                                                args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = (6 * ceil32(return_data.size)) + 192
                                            require return_data.size >= 32
                                            _3514 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                                            require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                            require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                            _3593 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                            if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                                                revert with 0, 65
                                            if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                                                revert with 0, 65
                                            mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                            require return_data.size >= _3514 + (32 * _3593) + 32
                                            mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3593] = mem[(4 * ceil32(return_data.size)) + _3514 + 224 len 32 * _3593]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                            if 1 >= _3593:
                                                revert with 0, 50
                                        else:
                                            if wftmAddress == address(ext_call.return_data[0]):
                                                if ext_call.return_data[32] > -1:
                                                    revert with 0, 17
                                                mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                                                mem[(4 * ceil32(return_data.size)) + 228] = 0
                                                mem[(4 * ceil32(return_data.size)) + 260] = 160
                                                mem[(4 * ceil32(return_data.size)) + 356] = 2
                                                idx = 0
                                                s = (4 * ceil32(return_data.size)) + 388
                                                t = (4 * ceil32(return_data.size)) + 128
                                                while idx < 2:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                                mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                                require ext_code.size(routerAddress)
                                                call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (6 * ceil32(return_data.size)) + 192
                                                require return_data.size >= 32
                                                _3515 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                                                require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                                                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                                _3594 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                                                    revert with 0, 65
                                                if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                                require return_data.size >= _3515 + (32 * _3594) + 32
                                                mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3594] = mem[(4 * ceil32(return_data.size)) + _3515 + 224 len 32 * _3594]
                                                if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                    revert with 0, 17
                                                maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                                if 1 >= _3594:
                                                    revert with 0, 50
                                            else:
                                                if ext_call.return_data[0] > -1:
                                                    revert with 0, 17
                                                mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                                                mem[(4 * ceil32(return_data.size)) + 228] = 0
                                                mem[(4 * ceil32(return_data.size)) + 260] = 160
                                                mem[(4 * ceil32(return_data.size)) + 356] = 2
                                                idx = 0
                                                s = (4 * ceil32(return_data.size)) + 388
                                                t = (4 * ceil32(return_data.size)) + 128
                                                while idx < 2:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                                mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                                require ext_code.size(routerAddress)
                                                call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (6 * ceil32(return_data.size)) + 192
                                                require return_data.size >= 32
                                                _3516 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                                                require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                                _3595 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                                                    revert with 0, 65
                                                if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                                require return_data.size >= _3516 + (32 * _3595) + 32
                                                mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3595] = mem[(4 * ceil32(return_data.size)) + _3516 + 224 len 32 * _3595]
                                                if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                    revert with 0, 17
                                                maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                                if 1 >= _3595:
                                                    revert with 0, 50
                            else:
                                if brushAddress != address(ext_call.return_data[0]):
                                    if wftmAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[32] > -1:
                                            revert with 0, 17
                                        mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                                        mem[(4 * ceil32(return_data.size)) + 228] = 0
                                        mem[(4 * ceil32(return_data.size)) + 260] = 160
                                        mem[(4 * ceil32(return_data.size)) + 356] = 2
                                        idx = 0
                                        s = (4 * ceil32(return_data.size)) + 388
                                        t = (4 * ceil32(return_data.size)) + 128
                                        while idx < 2:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                        mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = (6 * ceil32(return_data.size)) + 192
                                        require return_data.size >= 32
                                        _3517 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                                        require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                                        require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                        _3596 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                        if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                                            revert with 0, 65
                                        if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                                            revert with 0, 65
                                        mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                        require return_data.size >= _3517 + (32 * _3596) + 32
                                        mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3596] = mem[(4 * ceil32(return_data.size)) + _3517 + 224 len 32 * _3596]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                        if 1 >= _3596:
                                            revert with 0, 50
                                    else:
                                        if ext_call.return_data[0] > -1:
                                            revert with 0, 17
                                        mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                                        mem[(4 * ceil32(return_data.size)) + 228] = 0
                                        mem[(4 * ceil32(return_data.size)) + 260] = 160
                                        mem[(4 * ceil32(return_data.size)) + 356] = 2
                                        idx = 0
                                        s = (4 * ceil32(return_data.size)) + 388
                                        t = (4 * ceil32(return_data.size)) + 128
                                        while idx < 2:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                        mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = (6 * ceil32(return_data.size)) + 192
                                        require return_data.size >= 32
                                        _3518 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                                        require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                        require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                        _3597 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                        if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                                            revert with 0, 65
                                        if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                                            revert with 0, 65
                                        mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                        require return_data.size >= _3518 + (32 * _3597) + 32
                                        mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3597] = mem[(4 * ceil32(return_data.size)) + _3518 + 224 len 32 * _3597]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                        if 1 >= _3597:
                                            revert with 0, 50
                                else:
                                    if brushAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[32] > -1:
                                            revert with 0, 17
                                        mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                                        mem[(4 * ceil32(return_data.size)) + 228] = 0
                                        mem[(4 * ceil32(return_data.size)) + 260] = 160
                                        mem[(4 * ceil32(return_data.size)) + 356] = 2
                                        idx = 0
                                        s = (4 * ceil32(return_data.size)) + 388
                                        t = (4 * ceil32(return_data.size)) + 128
                                        while idx < 2:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                        mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = (6 * ceil32(return_data.size)) + 192
                                        require return_data.size >= 32
                                        _3519 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                                        require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                                        require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                        _3598 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                        if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                                            revert with 0, 65
                                        if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                                            revert with 0, 65
                                        mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                        require return_data.size >= _3519 + (32 * _3598) + 32
                                        mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3598] = mem[(4 * ceil32(return_data.size)) + _3519 + 224 len 32 * _3598]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                        if 1 >= _3598:
                                            revert with 0, 50
                                    else:
                                        if brushAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[0] > -1:
                                                revert with 0, 17
                                            mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                                            mem[(4 * ceil32(return_data.size)) + 228] = 0
                                            mem[(4 * ceil32(return_data.size)) + 260] = 160
                                            mem[(4 * ceil32(return_data.size)) + 356] = 2
                                            idx = 0
                                            s = (4 * ceil32(return_data.size)) + 388
                                            t = (4 * ceil32(return_data.size)) + 128
                                            while idx < 2:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                            mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                 gas gas_remaining wei
                                                args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = (6 * ceil32(return_data.size)) + 192
                                            require return_data.size >= 32
                                            _3520 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                                            require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                            require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                            _3599 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                            if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                                                revert with 0, 65
                                            if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                                                revert with 0, 65
                                            mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                            require return_data.size >= _3520 + (32 * _3599) + 32
                                            mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3599] = mem[(4 * ceil32(return_data.size)) + _3520 + 224 len 32 * _3599]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                            if 1 >= _3599:
                                                revert with 0, 50
                                        else:
                                            if wftmAddress == address(ext_call.return_data[0]):
                                                if ext_call.return_data[32] > -1:
                                                    revert with 0, 17
                                                mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                                                mem[(4 * ceil32(return_data.size)) + 228] = 0
                                                mem[(4 * ceil32(return_data.size)) + 260] = 160
                                                mem[(4 * ceil32(return_data.size)) + 356] = 2
                                                idx = 0
                                                s = (4 * ceil32(return_data.size)) + 388
                                                t = (4 * ceil32(return_data.size)) + 128
                                                while idx < 2:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                                mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                                require ext_code.size(routerAddress)
                                                call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (6 * ceil32(return_data.size)) + 192
                                                require return_data.size >= 32
                                                _3521 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                                                require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                                                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                                _3600 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                                                    revert with 0, 65
                                                if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                                require return_data.size >= _3521 + (32 * _3600) + 32
                                                mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3600] = mem[(4 * ceil32(return_data.size)) + _3521 + 224 len 32 * _3600]
                                                if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                    revert with 0, 17
                                                maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                                if 1 >= _3600:
                                                    revert with 0, 50
                                            else:
                                                if ext_call.return_data[0] > -1:
                                                    revert with 0, 17
                                                mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                                                mem[(4 * ceil32(return_data.size)) + 228] = 0
                                                mem[(4 * ceil32(return_data.size)) + 260] = 160
                                                mem[(4 * ceil32(return_data.size)) + 356] = 2
                                                idx = 0
                                                s = (4 * ceil32(return_data.size)) + 388
                                                t = (4 * ceil32(return_data.size)) + 128
                                                while idx < 2:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                                mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                                require ext_code.size(routerAddress)
                                                call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (6 * ceil32(return_data.size)) + 192
                                                require return_data.size >= 32
                                                _3522 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                                                require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                                _3601 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                                                    revert with 0, 65
                                                if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                                require return_data.size >= _3522 + (32 * _3601) + 32
                                                mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3601] = mem[(4 * ceil32(return_data.size)) + _3522 + 224 len 32 * _3601]
                                                if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                    revert with 0, 17
                                                maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                                if 1 >= _3601:
                                                    revert with 0, 50
                if mem[(6 * ceil32(return_data.size)) + 256] > !ext_call.return_data[32]:
                    revert with 0, 17
                require ext_code.size(brushAddress)
                call brushAddress.0x42966c68 with:
                     gas gas_remaining wei
                    args (mem[(6 * ceil32(return_data.size)) + 256] + ext_call.return_data[32])
        else:
            mem[(4 * ceil32(return_data.size)) + 96] = 2
            mem[(4 * ceil32(return_data.size)) + 128] = address(ext_call.return_data[0])
            mem[(4 * ceil32(return_data.size)) + 160] = wftmAddress
            mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
            if wftmAddress == address(ext_call.return_data[0]):
                if wftmAddress == address(ext_call.return_data[0]):
                    mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                    mem[(4 * ceil32(return_data.size)) + 228] = 0
                    mem[(4 * ceil32(return_data.size)) + 260] = 160
                    mem[(4 * ceil32(return_data.size)) + 356] = 2
                    idx = 0
                    s = (4 * ceil32(return_data.size)) + 388
                    t = (4 * ceil32(return_data.size)) + 128
                    while idx < 2:
                        mem[s] = mem[t + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[(4 * ceil32(return_data.size)) + 292] = this.address
                    mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                    require ext_code.size(routerAddress)
                    call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                         gas gas_remaining wei
                        args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = (6 * ceil32(return_data.size)) + 192
                    require return_data.size >= 32
                    _3523 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                    require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                    require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                    _3602 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                    if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                        revert with 0, 65
                    if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                        revert with 0, 65
                    mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193
                    mem[(6 * ceil32(return_data.size)) + 192] = _3602
                    require return_data.size >= _3523 + (32 * _3602) + 32
                    mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3602] = mem[(4 * ceil32(return_data.size)) + _3523 + 224 len 32 * _3602]
                    if 1 >= _3602:
                        revert with 0, 50
                    _6373 = mem[(6 * ceil32(return_data.size)) + 256]
                    _6377 = mem[64]
                    mem[mem[64]] = 2
                    mem[64] = mem[64] + 96
                    if 0 >= mem[_6377]:
                        revert with 0, 50
                    mem[_6377 + 32] = address(ext_call.return_data[0])
                    if 1 >= mem[_6377]:
                        revert with 0, 50
                    mem[_6377 + 64] = brushAddress
                    if brushAddress != address(ext_call.return_data[0]):
                        if wftmAddress == address(ext_call.return_data[0]):
                            if brushAddress != address(ext_call.return_data[0]):
                                if wftmAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_6373:
                                        revert with 0, 17
                                    mem[_6377 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_6377 + 100] = ext_call.return_data[32] + _6373
                                    mem[_6377 + 132] = 0
                                    mem[_6377 + 164] = 160
                                    mem[_6377 + 260] = mem[_6377]
                                    idx = 0
                                    s = _6377 + 292
                                    t = _6377 + 32
                                    while idx < mem[_6377]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_6377 + 196] = this.address
                                    mem[_6377 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _6377 + (32 * mem[_6377]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9033 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _9177 = mem[_9033]
                                    require mem[_9033] <= test266151307()
                                    require _9033 + mem[_9033] + 31 < _9033 + return_data.size
                                    _9321 = mem[_9033 + mem[_9033]]
                                    if mem[_9033 + mem[_9033]] > test266151307():
                                        revert with 0, 65
                                    if _9033 + ceil32(return_data.size) + ceil32(32 * mem[_9033 + mem[_9033]]) + 1 > test266151307() or ceil32(32 * mem[_9033 + mem[_9033]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _9033 + ceil32(return_data.size) + ceil32(32 * mem[_9033 + mem[_9033]]) + 1
                                    mem[_9033 + ceil32(return_data.size)] = _9321
                                    require return_data.size >= _9177 + (32 * _9321) + 32
                                    mem[_9033 + ceil32(return_data.size) + 32 len 32 * _9321] = mem[_9033 + _9177 + 32 len 32 * _9321]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                    if 1 >= _9321:
                                        revert with 0, 50
                                    if mem[_9033 + ceil32(return_data.size) + 64] > -1:
                                        revert with 0, 17
                                    require ext_code.size(brushAddress)
                                    call brushAddress.0x42966c68 with:
                                         gas gas_remaining wei
                                        args mem[_9033 + ceil32(return_data.size) + 64]
                                else:
                                    if ext_call.return_data[0] > !_6373:
                                        revert with 0, 17
                                    mem[_6377 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_6377 + 100] = ext_call.return_data[0] + _6373
                                    mem[_6377 + 132] = 0
                                    mem[_6377 + 164] = 160
                                    mem[_6377 + 260] = mem[_6377]
                                    idx = 0
                                    s = _6377 + 292
                                    t = _6377 + 32
                                    while idx < mem[_6377]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_6377 + 196] = this.address
                                    mem[_6377 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _6377 + (32 * mem[_6377]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9034 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _9178 = mem[_9034]
                                    require mem[_9034] <= test266151307()
                                    require _9034 + mem[_9034] + 31 < _9034 + return_data.size
                                    _9322 = mem[_9034 + mem[_9034]]
                                    if mem[_9034 + mem[_9034]] > test266151307():
                                        revert with 0, 65
                                    if _9034 + ceil32(return_data.size) + ceil32(32 * mem[_9034 + mem[_9034]]) + 1 > test266151307() or ceil32(32 * mem[_9034 + mem[_9034]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _9034 + ceil32(return_data.size) + ceil32(32 * mem[_9034 + mem[_9034]]) + 1
                                    mem[_9034 + ceil32(return_data.size)] = _9322
                                    require return_data.size >= _9178 + (32 * _9322) + 32
                                    mem[_9034 + ceil32(return_data.size) + 32 len 32 * _9322] = mem[_9034 + _9178 + 32 len 32 * _9322]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                    if 1 >= _9322:
                                        revert with 0, 50
                                    if mem[_9034 + ceil32(return_data.size) + 64] > -1:
                                        revert with 0, 17
                                    require ext_code.size(brushAddress)
                                    call brushAddress.0x42966c68 with:
                                         gas gas_remaining wei
                                        args mem[_9034 + ceil32(return_data.size) + 64]
                            else:
                                if brushAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_6373:
                                        revert with 0, 17
                                    mem[_6377 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_6377 + 100] = ext_call.return_data[32] + _6373
                                    mem[_6377 + 132] = 0
                                    mem[_6377 + 164] = 160
                                    mem[_6377 + 260] = mem[_6377]
                                    idx = 0
                                    s = _6377 + 292
                                    t = _6377 + 32
                                    while idx < mem[_6377]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_6377 + 196] = this.address
                                    mem[_6377 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _6377 + (32 * mem[_6377]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9035 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _9179 = mem[_9035]
                                    require mem[_9035] <= test266151307()
                                    require _9035 + mem[_9035] + 31 < _9035 + return_data.size
                                    _9323 = mem[_9035 + mem[_9035]]
                                    if mem[_9035 + mem[_9035]] > test266151307():
                                        revert with 0, 65
                                    if _9035 + ceil32(return_data.size) + ceil32(32 * mem[_9035 + mem[_9035]]) + 1 > test266151307() or ceil32(32 * mem[_9035 + mem[_9035]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _9035 + ceil32(return_data.size) + ceil32(32 * mem[_9035 + mem[_9035]]) + 1
                                    mem[_9035 + ceil32(return_data.size)] = _9323
                                    require return_data.size >= _9179 + (32 * _9323) + 32
                                    mem[_9035 + ceil32(return_data.size) + 32 len 32 * _9323] = mem[_9035 + _9179 + 32 len 32 * _9323]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                    if 1 >= _9323:
                                        revert with 0, 50
                                    if mem[_9035 + ceil32(return_data.size) + 64] > -1:
                                        revert with 0, 17
                                    require ext_code.size(brushAddress)
                                    call brushAddress.0x42966c68 with:
                                         gas gas_remaining wei
                                        args mem[_9035 + ceil32(return_data.size) + 64]
                                else:
                                    if brushAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[0] > !_6373:
                                            revert with 0, 17
                                        mem[_6377 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_6377 + 100] = ext_call.return_data[0] + _6373
                                        mem[_6377 + 132] = 0
                                        mem[_6377 + 164] = 160
                                        mem[_6377 + 260] = mem[_6377]
                                        idx = 0
                                        s = _6377 + 292
                                        t = _6377 + 32
                                        while idx < mem[_6377]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_6377 + 196] = this.address
                                        mem[_6377 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _6377 + (32 * mem[_6377]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9036 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _9180 = mem[_9036]
                                        require mem[_9036] <= test266151307()
                                        require _9036 + mem[_9036] + 31 < _9036 + return_data.size
                                        _9324 = mem[_9036 + mem[_9036]]
                                        if mem[_9036 + mem[_9036]] > test266151307():
                                            revert with 0, 65
                                        if _9036 + ceil32(return_data.size) + ceil32(32 * mem[_9036 + mem[_9036]]) + 1 > test266151307() or ceil32(32 * mem[_9036 + mem[_9036]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _9036 + ceil32(return_data.size) + ceil32(32 * mem[_9036 + mem[_9036]]) + 1
                                        mem[_9036 + ceil32(return_data.size)] = _9324
                                        require return_data.size >= _9180 + (32 * _9324) + 32
                                        mem[_9036 + ceil32(return_data.size) + 32 len 32 * _9324] = mem[_9036 + _9180 + 32 len 32 * _9324]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                        if 1 >= _9324:
                                            revert with 0, 50
                                        if mem[_9036 + ceil32(return_data.size) + 64] > -1:
                                            revert with 0, 17
                                        require ext_code.size(brushAddress)
                                        call brushAddress.0x42966c68 with:
                                             gas gas_remaining wei
                                            args mem[_9036 + ceil32(return_data.size) + 64]
                                    else:
                                        if wftmAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_6373:
                                                revert with 0, 17
                                            mem[_6377 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_6377 + 100] = ext_call.return_data[32] + _6373
                                            mem[_6377 + 132] = 0
                                            mem[_6377 + 164] = 160
                                            mem[_6377 + 260] = mem[_6377]
                                            idx = 0
                                            s = _6377 + 292
                                            t = _6377 + 32
                                            while idx < mem[_6377]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_6377 + 196] = this.address
                                            mem[_6377 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _6377 + (32 * mem[_6377]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9037 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _9181 = mem[_9037]
                                            require mem[_9037] <= test266151307()
                                            require _9037 + mem[_9037] + 31 < _9037 + return_data.size
                                            _9325 = mem[_9037 + mem[_9037]]
                                            if mem[_9037 + mem[_9037]] > test266151307():
                                                revert with 0, 65
                                            if _9037 + ceil32(return_data.size) + ceil32(32 * mem[_9037 + mem[_9037]]) + 1 > test266151307() or ceil32(32 * mem[_9037 + mem[_9037]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _9037 + ceil32(return_data.size) + ceil32(32 * mem[_9037 + mem[_9037]]) + 1
                                            mem[_9037 + ceil32(return_data.size)] = _9325
                                            require return_data.size >= _9181 + (32 * _9325) + 32
                                            mem[_9037 + ceil32(return_data.size) + 32 len 32 * _9325] = mem[_9037 + _9181 + 32 len 32 * _9325]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                            if 1 >= _9325:
                                                revert with 0, 50
                                            if mem[_9037 + ceil32(return_data.size) + 64] > -1:
                                                revert with 0, 17
                                            require ext_code.size(brushAddress)
                                            call brushAddress.0x42966c68 with:
                                                 gas gas_remaining wei
                                                args mem[_9037 + ceil32(return_data.size) + 64]
                                        else:
                                            if ext_call.return_data[0] > !_6373:
                                                revert with 0, 17
                                            mem[_6377 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_6377 + 100] = ext_call.return_data[0] + _6373
                                            mem[_6377 + 132] = 0
                                            mem[_6377 + 164] = 160
                                            mem[_6377 + 260] = mem[_6377]
                                            idx = 0
                                            s = _6377 + 292
                                            t = _6377 + 32
                                            while idx < mem[_6377]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_6377 + 196] = this.address
                                            mem[_6377 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _6377 + (32 * mem[_6377]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9038 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _9182 = mem[_9038]
                                            require mem[_9038] <= test266151307()
                                            require _9038 + mem[_9038] + 31 < _9038 + return_data.size
                                            _9326 = mem[_9038 + mem[_9038]]
                                            if mem[_9038 + mem[_9038]] > test266151307():
                                                revert with 0, 65
                                            if _9038 + ceil32(return_data.size) + ceil32(32 * mem[_9038 + mem[_9038]]) + 1 > test266151307() or ceil32(32 * mem[_9038 + mem[_9038]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _9038 + ceil32(return_data.size) + ceil32(32 * mem[_9038 + mem[_9038]]) + 1
                                            mem[_9038 + ceil32(return_data.size)] = _9326
                                            require return_data.size >= _9182 + (32 * _9326) + 32
                                            mem[_9038 + ceil32(return_data.size) + 32 len 32 * _9326] = mem[_9038 + _9182 + 32 len 32 * _9326]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                            if 1 >= _9326:
                                                revert with 0, 50
                                            if mem[_9038 + ceil32(return_data.size) + 64] > -1:
                                                revert with 0, 17
                                            require ext_code.size(brushAddress)
                                            call brushAddress.0x42966c68 with:
                                                 gas gas_remaining wei
                                                args mem[_9038 + ceil32(return_data.size) + 64]
                        else:
                            if brushAddress != address(ext_call.return_data[0]):
                                if wftmAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_6373:
                                        revert with 0, 17
                                    mem[_6377 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_6377 + 100] = ext_call.return_data[32] + _6373
                                    mem[_6377 + 132] = 0
                                    mem[_6377 + 164] = 160
                                    mem[_6377 + 260] = mem[_6377]
                                    idx = 0
                                    s = _6377 + 292
                                    t = _6377 + 32
                                    while idx < mem[_6377]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_6377 + 196] = this.address
                                    mem[_6377 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _6377 + (32 * mem[_6377]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9039 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _9183 = mem[_9039]
                                    require mem[_9039] <= test266151307()
                                    require _9039 + mem[_9039] + 31 < _9039 + return_data.size
                                    _9327 = mem[_9039 + mem[_9039]]
                                    if mem[_9039 + mem[_9039]] > test266151307():
                                        revert with 0, 65
                                    if _9039 + ceil32(return_data.size) + ceil32(32 * mem[_9039 + mem[_9039]]) + 1 > test266151307() or ceil32(32 * mem[_9039 + mem[_9039]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _9039 + ceil32(return_data.size) + ceil32(32 * mem[_9039 + mem[_9039]]) + 1
                                    mem[_9039 + ceil32(return_data.size)] = _9327
                                    require return_data.size >= _9183 + (32 * _9327) + 32
                                    mem[_9039 + ceil32(return_data.size) + 32 len 32 * _9327] = mem[_9039 + _9183 + 32 len 32 * _9327]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                    if 1 >= _9327:
                                        revert with 0, 50
                                    if mem[_9039 + ceil32(return_data.size) + 64] > -1:
                                        revert with 0, 17
                                    require ext_code.size(brushAddress)
                                    call brushAddress.0x42966c68 with:
                                         gas gas_remaining wei
                                        args mem[_9039 + ceil32(return_data.size) + 64]
                                else:
                                    if ext_call.return_data[0] > !_6373:
                                        revert with 0, 17
                                    mem[_6377 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_6377 + 100] = ext_call.return_data[0] + _6373
                                    mem[_6377 + 132] = 0
                                    mem[_6377 + 164] = 160
                                    mem[_6377 + 260] = mem[_6377]
                                    idx = 0
                                    s = _6377 + 292
                                    t = _6377 + 32
                                    while idx < mem[_6377]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_6377 + 196] = this.address
                                    mem[_6377 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _6377 + (32 * mem[_6377]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9040 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _9184 = mem[_9040]
                                    require mem[_9040] <= test266151307()
                                    require _9040 + mem[_9040] + 31 < _9040 + return_data.size
                                    _9328 = mem[_9040 + mem[_9040]]
                                    if mem[_9040 + mem[_9040]] > test266151307():
                                        revert with 0, 65
                                    if _9040 + ceil32(return_data.size) + ceil32(32 * mem[_9040 + mem[_9040]]) + 1 > test266151307() or ceil32(32 * mem[_9040 + mem[_9040]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _9040 + ceil32(return_data.size) + ceil32(32 * mem[_9040 + mem[_9040]]) + 1
                                    mem[_9040 + ceil32(return_data.size)] = _9328
                                    require return_data.size >= _9184 + (32 * _9328) + 32
                                    mem[_9040 + ceil32(return_data.size) + 32 len 32 * _9328] = mem[_9040 + _9184 + 32 len 32 * _9328]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                    if 1 >= _9328:
                                        revert with 0, 50
                                    if mem[_9040 + ceil32(return_data.size) + 64] > -1:
                                        revert with 0, 17
                                    require ext_code.size(brushAddress)
                                    call brushAddress.0x42966c68 with:
                                         gas gas_remaining wei
                                        args mem[_9040 + ceil32(return_data.size) + 64]
                            else:
                                if brushAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_6373:
                                        revert with 0, 17
                                    mem[_6377 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_6377 + 100] = ext_call.return_data[32] + _6373
                                    mem[_6377 + 132] = 0
                                    mem[_6377 + 164] = 160
                                    mem[_6377 + 260] = mem[_6377]
                                    idx = 0
                                    s = _6377 + 292
                                    t = _6377 + 32
                                    while idx < mem[_6377]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_6377 + 196] = this.address
                                    mem[_6377 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _6377 + (32 * mem[_6377]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9041 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _9185 = mem[_9041]
                                    require mem[_9041] <= test266151307()
                                    require _9041 + mem[_9041] + 31 < _9041 + return_data.size
                                    _9329 = mem[_9041 + mem[_9041]]
                                    if mem[_9041 + mem[_9041]] > test266151307():
                                        revert with 0, 65
                                    if _9041 + ceil32(return_data.size) + ceil32(32 * mem[_9041 + mem[_9041]]) + 1 > test266151307() or ceil32(32 * mem[_9041 + mem[_9041]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _9041 + ceil32(return_data.size) + ceil32(32 * mem[_9041 + mem[_9041]]) + 1
                                    mem[_9041 + ceil32(return_data.size)] = _9329
                                    require return_data.size >= _9185 + (32 * _9329) + 32
                                    mem[_9041 + ceil32(return_data.size) + 32 len 32 * _9329] = mem[_9041 + _9185 + 32 len 32 * _9329]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                    if 1 >= _9329:
                                        revert with 0, 50
                                    if mem[_9041 + ceil32(return_data.size) + 64] > -1:
                                        revert with 0, 17
                                    require ext_code.size(brushAddress)
                                    call brushAddress.0x42966c68 with:
                                         gas gas_remaining wei
                                        args mem[_9041 + ceil32(return_data.size) + 64]
                                else:
                                    if brushAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[0] > !_6373:
                                            revert with 0, 17
                                        mem[_6377 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_6377 + 100] = ext_call.return_data[0] + _6373
                                        mem[_6377 + 132] = 0
                                        mem[_6377 + 164] = 160
                                        mem[_6377 + 260] = mem[_6377]
                                        idx = 0
                                        s = _6377 + 292
                                        t = _6377 + 32
                                        while idx < mem[_6377]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_6377 + 196] = this.address
                                        mem[_6377 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _6377 + (32 * mem[_6377]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9042 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _9186 = mem[_9042]
                                        require mem[_9042] <= test266151307()
                                        require _9042 + mem[_9042] + 31 < _9042 + return_data.size
                                        _9330 = mem[_9042 + mem[_9042]]
                                        if mem[_9042 + mem[_9042]] > test266151307():
                                            revert with 0, 65
                                        if _9042 + ceil32(return_data.size) + ceil32(32 * mem[_9042 + mem[_9042]]) + 1 > test266151307() or ceil32(32 * mem[_9042 + mem[_9042]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _9042 + ceil32(return_data.size) + ceil32(32 * mem[_9042 + mem[_9042]]) + 1
                                        mem[_9042 + ceil32(return_data.size)] = _9330
                                        require return_data.size >= _9186 + (32 * _9330) + 32
                                        mem[_9042 + ceil32(return_data.size) + 32 len 32 * _9330] = mem[_9042 + _9186 + 32 len 32 * _9330]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                        if 1 >= _9330:
                                            revert with 0, 50
                                        if mem[_9042 + ceil32(return_data.size) + 64] > -1:
                                            revert with 0, 17
                                        require ext_code.size(brushAddress)
                                        call brushAddress.0x42966c68 with:
                                             gas gas_remaining wei
                                            args mem[_9042 + ceil32(return_data.size) + 64]
                                    else:
                                        if wftmAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_6373:
                                                revert with 0, 17
                                            mem[_6377 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_6377 + 100] = ext_call.return_data[32] + _6373
                                            mem[_6377 + 132] = 0
                                            mem[_6377 + 164] = 160
                                            mem[_6377 + 260] = mem[_6377]
                                            idx = 0
                                            s = _6377 + 292
                                            t = _6377 + 32
                                            while idx < mem[_6377]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_6377 + 196] = this.address
                                            mem[_6377 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _6377 + (32 * mem[_6377]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9043 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _9187 = mem[_9043]
                                            require mem[_9043] <= test266151307()
                                            require _9043 + mem[_9043] + 31 < _9043 + return_data.size
                                            _9331 = mem[_9043 + mem[_9043]]
                                            if mem[_9043 + mem[_9043]] > test266151307():
                                                revert with 0, 65
                                            if _9043 + ceil32(return_data.size) + ceil32(32 * mem[_9043 + mem[_9043]]) + 1 > test266151307() or ceil32(32 * mem[_9043 + mem[_9043]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _9043 + ceil32(return_data.size) + ceil32(32 * mem[_9043 + mem[_9043]]) + 1
                                            mem[_9043 + ceil32(return_data.size)] = _9331
                                            require return_data.size >= _9187 + (32 * _9331) + 32
                                            mem[_9043 + ceil32(return_data.size) + 32 len 32 * _9331] = mem[_9043 + _9187 + 32 len 32 * _9331]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                            if 1 >= _9331:
                                                revert with 0, 50
                                            if mem[_9043 + ceil32(return_data.size) + 64] > -1:
                                                revert with 0, 17
                                            require ext_code.size(brushAddress)
                                            call brushAddress.0x42966c68 with:
                                                 gas gas_remaining wei
                                                args mem[_9043 + ceil32(return_data.size) + 64]
                                        else:
                                            if ext_call.return_data[0] > !_6373:
                                                revert with 0, 17
                                            mem[_6377 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_6377 + 100] = ext_call.return_data[0] + _6373
                                            mem[_6377 + 132] = 0
                                            mem[_6377 + 164] = 160
                                            mem[_6377 + 260] = mem[_6377]
                                            idx = 0
                                            s = _6377 + 292
                                            t = _6377 + 32
                                            while idx < mem[_6377]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_6377 + 196] = this.address
                                            mem[_6377 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _6377 + (32 * mem[_6377]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9044 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _9188 = mem[_9044]
                                            require mem[_9044] <= test266151307()
                                            require _9044 + mem[_9044] + 31 < _9044 + return_data.size
                                            _9332 = mem[_9044 + mem[_9044]]
                                            if mem[_9044 + mem[_9044]] > test266151307():
                                                revert with 0, 65
                                            if _9044 + ceil32(return_data.size) + ceil32(32 * mem[_9044 + mem[_9044]]) + 1 > test266151307() or ceil32(32 * mem[_9044 + mem[_9044]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _9044 + ceil32(return_data.size) + ceil32(32 * mem[_9044 + mem[_9044]]) + 1
                                            mem[_9044 + ceil32(return_data.size)] = _9332
                                            require return_data.size >= _9188 + (32 * _9332) + 32
                                            mem[_9044 + ceil32(return_data.size) + 32 len 32 * _9332] = mem[_9044 + _9188 + 32 len 32 * _9332]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                            if 1 >= _9332:
                                                revert with 0, 50
                                            if mem[_9044 + ceil32(return_data.size) + 64] > -1:
                                                revert with 0, 17
                                            require ext_code.size(brushAddress)
                                            call brushAddress.0x42966c68 with:
                                                 gas gas_remaining wei
                                                args mem[_9044 + ceil32(return_data.size) + 64]
                    else:
                        if brushAddress == address(ext_call.return_data[0]):
                            if brushAddress != address(ext_call.return_data[0]):
                                if wftmAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_6373:
                                        revert with 0, 17
                                    mem[_6377 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_6377 + 100] = ext_call.return_data[32] + _6373
                                    mem[_6377 + 132] = 0
                                    mem[_6377 + 164] = 160
                                    mem[_6377 + 260] = mem[_6377]
                                    idx = 0
                                    s = _6377 + 292
                                    t = _6377 + 32
                                    while idx < mem[_6377]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_6377 + 196] = this.address
                                    mem[_6377 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _6377 + (32 * mem[_6377]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9045 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _9189 = mem[_9045]
                                    require mem[_9045] <= test266151307()
                                    require _9045 + mem[_9045] + 31 < _9045 + return_data.size
                                    _9333 = mem[_9045 + mem[_9045]]
                                    if mem[_9045 + mem[_9045]] > test266151307():
                                        revert with 0, 65
                                    if _9045 + ceil32(return_data.size) + ceil32(32 * mem[_9045 + mem[_9045]]) + 1 > test266151307() or ceil32(32 * mem[_9045 + mem[_9045]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _9045 + ceil32(return_data.size) + ceil32(32 * mem[_9045 + mem[_9045]]) + 1
                                    mem[_9045 + ceil32(return_data.size)] = _9333
                                    require return_data.size >= _9189 + (32 * _9333) + 32
                                    mem[_9045 + ceil32(return_data.size) + 32 len 32 * _9333] = mem[_9045 + _9189 + 32 len 32 * _9333]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                    if 1 >= _9333:
                                        revert with 0, 50
                                    if mem[_9045 + ceil32(return_data.size) + 64] > -1:
                                        revert with 0, 17
                                    require ext_code.size(brushAddress)
                                    call brushAddress.0x42966c68 with:
                                         gas gas_remaining wei
                                        args mem[_9045 + ceil32(return_data.size) + 64]
                                else:
                                    if ext_call.return_data[0] > !_6373:
                                        revert with 0, 17
                                    mem[_6377 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_6377 + 100] = ext_call.return_data[0] + _6373
                                    mem[_6377 + 132] = 0
                                    mem[_6377 + 164] = 160
                                    mem[_6377 + 260] = mem[_6377]
                                    idx = 0
                                    s = _6377 + 292
                                    t = _6377 + 32
                                    while idx < mem[_6377]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_6377 + 196] = this.address
                                    mem[_6377 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _6377 + (32 * mem[_6377]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9046 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _9190 = mem[_9046]
                                    require mem[_9046] <= test266151307()
                                    require _9046 + mem[_9046] + 31 < _9046 + return_data.size
                                    _9334 = mem[_9046 + mem[_9046]]
                                    if mem[_9046 + mem[_9046]] > test266151307():
                                        revert with 0, 65
                                    if _9046 + ceil32(return_data.size) + ceil32(32 * mem[_9046 + mem[_9046]]) + 1 > test266151307() or ceil32(32 * mem[_9046 + mem[_9046]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _9046 + ceil32(return_data.size) + ceil32(32 * mem[_9046 + mem[_9046]]) + 1
                                    mem[_9046 + ceil32(return_data.size)] = _9334
                                    require return_data.size >= _9190 + (32 * _9334) + 32
                                    mem[_9046 + ceil32(return_data.size) + 32 len 32 * _9334] = mem[_9046 + _9190 + 32 len 32 * _9334]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                    if 1 >= _9334:
                                        revert with 0, 50
                                    if mem[_9046 + ceil32(return_data.size) + 64] > -1:
                                        revert with 0, 17
                                    require ext_code.size(brushAddress)
                                    call brushAddress.0x42966c68 with:
                                         gas gas_remaining wei
                                        args mem[_9046 + ceil32(return_data.size) + 64]
                            else:
                                if brushAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_6373:
                                        revert with 0, 17
                                    mem[_6377 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_6377 + 100] = ext_call.return_data[32] + _6373
                                    mem[_6377 + 132] = 0
                                    mem[_6377 + 164] = 160
                                    mem[_6377 + 260] = mem[_6377]
                                    idx = 0
                                    s = _6377 + 292
                                    t = _6377 + 32
                                    while idx < mem[_6377]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_6377 + 196] = this.address
                                    mem[_6377 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _6377 + (32 * mem[_6377]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9047 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _9191 = mem[_9047]
                                    require mem[_9047] <= test266151307()
                                    require _9047 + mem[_9047] + 31 < _9047 + return_data.size
                                    _9335 = mem[_9047 + mem[_9047]]
                                    if mem[_9047 + mem[_9047]] > test266151307():
                                        revert with 0, 65
                                    if _9047 + ceil32(return_data.size) + ceil32(32 * mem[_9047 + mem[_9047]]) + 1 > test266151307() or ceil32(32 * mem[_9047 + mem[_9047]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _9047 + ceil32(return_data.size) + ceil32(32 * mem[_9047 + mem[_9047]]) + 1
                                    mem[_9047 + ceil32(return_data.size)] = _9335
                                    require return_data.size >= _9191 + (32 * _9335) + 32
                                    mem[_9047 + ceil32(return_data.size) + 32 len 32 * _9335] = mem[_9047 + _9191 + 32 len 32 * _9335]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                    if 1 >= _9335:
                                        revert with 0, 50
                                    if mem[_9047 + ceil32(return_data.size) + 64] > -1:
                                        revert with 0, 17
                                    require ext_code.size(brushAddress)
                                    call brushAddress.0x42966c68 with:
                                         gas gas_remaining wei
                                        args mem[_9047 + ceil32(return_data.size) + 64]
                                else:
                                    if brushAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[0] > !_6373:
                                            revert with 0, 17
                                        mem[_6377 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_6377 + 100] = ext_call.return_data[0] + _6373
                                        mem[_6377 + 132] = 0
                                        mem[_6377 + 164] = 160
                                        mem[_6377 + 260] = mem[_6377]
                                        idx = 0
                                        s = _6377 + 292
                                        t = _6377 + 32
                                        while idx < mem[_6377]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_6377 + 196] = this.address
                                        mem[_6377 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _6377 + (32 * mem[_6377]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9048 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _9192 = mem[_9048]
                                        require mem[_9048] <= test266151307()
                                        require _9048 + mem[_9048] + 31 < _9048 + return_data.size
                                        _9336 = mem[_9048 + mem[_9048]]
                                        if mem[_9048 + mem[_9048]] > test266151307():
                                            revert with 0, 65
                                        if _9048 + ceil32(return_data.size) + ceil32(32 * mem[_9048 + mem[_9048]]) + 1 > test266151307() or ceil32(32 * mem[_9048 + mem[_9048]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _9048 + ceil32(return_data.size) + ceil32(32 * mem[_9048 + mem[_9048]]) + 1
                                        mem[_9048 + ceil32(return_data.size)] = _9336
                                        require return_data.size >= _9192 + (32 * _9336) + 32
                                        mem[_9048 + ceil32(return_data.size) + 32 len 32 * _9336] = mem[_9048 + _9192 + 32 len 32 * _9336]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                        if 1 >= _9336:
                                            revert with 0, 50
                                        if mem[_9048 + ceil32(return_data.size) + 64] > -1:
                                            revert with 0, 17
                                        require ext_code.size(brushAddress)
                                        call brushAddress.0x42966c68 with:
                                             gas gas_remaining wei
                                            args mem[_9048 + ceil32(return_data.size) + 64]
                                    else:
                                        if wftmAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_6373:
                                                revert with 0, 17
                                            mem[_6377 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_6377 + 100] = ext_call.return_data[32] + _6373
                                            mem[_6377 + 132] = 0
                                            mem[_6377 + 164] = 160
                                            mem[_6377 + 260] = mem[_6377]
                                            idx = 0
                                            s = _6377 + 292
                                            t = _6377 + 32
                                            while idx < mem[_6377]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_6377 + 196] = this.address
                                            mem[_6377 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _6377 + (32 * mem[_6377]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9049 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _9193 = mem[_9049]
                                            require mem[_9049] <= test266151307()
                                            require _9049 + mem[_9049] + 31 < _9049 + return_data.size
                                            _9337 = mem[_9049 + mem[_9049]]
                                            if mem[_9049 + mem[_9049]] > test266151307():
                                                revert with 0, 65
                                            if _9049 + ceil32(return_data.size) + ceil32(32 * mem[_9049 + mem[_9049]]) + 1 > test266151307() or ceil32(32 * mem[_9049 + mem[_9049]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _9049 + ceil32(return_data.size) + ceil32(32 * mem[_9049 + mem[_9049]]) + 1
                                            mem[_9049 + ceil32(return_data.size)] = _9337
                                            require return_data.size >= _9193 + (32 * _9337) + 32
                                            mem[_9049 + ceil32(return_data.size) + 32 len 32 * _9337] = mem[_9049 + _9193 + 32 len 32 * _9337]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                            if 1 >= _9337:
                                                revert with 0, 50
                                            if mem[_9049 + ceil32(return_data.size) + 64] > -1:
                                                revert with 0, 17
                                            require ext_code.size(brushAddress)
                                            call brushAddress.0x42966c68 with:
                                                 gas gas_remaining wei
                                                args mem[_9049 + ceil32(return_data.size) + 64]
                                        else:
                                            if ext_call.return_data[0] > !_6373:
                                                revert with 0, 17
                                            mem[_6377 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_6377 + 100] = ext_call.return_data[0] + _6373
                                            mem[_6377 + 132] = 0
                                            mem[_6377 + 164] = 160
                                            mem[_6377 + 260] = mem[_6377]
                                            idx = 0
                                            s = _6377 + 292
                                            t = _6377 + 32
                                            while idx < mem[_6377]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_6377 + 196] = this.address
                                            mem[_6377 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _6377 + (32 * mem[_6377]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9050 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _9194 = mem[_9050]
                                            require mem[_9050] <= test266151307()
                                            require _9050 + mem[_9050] + 31 < _9050 + return_data.size
                                            _9338 = mem[_9050 + mem[_9050]]
                                            if mem[_9050 + mem[_9050]] > test266151307():
                                                revert with 0, 65
                                            if _9050 + ceil32(return_data.size) + ceil32(32 * mem[_9050 + mem[_9050]]) + 1 > test266151307() or ceil32(32 * mem[_9050 + mem[_9050]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _9050 + ceil32(return_data.size) + ceil32(32 * mem[_9050 + mem[_9050]]) + 1
                                            mem[_9050 + ceil32(return_data.size)] = _9338
                                            require return_data.size >= _9194 + (32 * _9338) + 32
                                            mem[_9050 + ceil32(return_data.size) + 32 len 32 * _9338] = mem[_9050 + _9194 + 32 len 32 * _9338]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                            if 1 >= _9338:
                                                revert with 0, 50
                                            if mem[_9050 + ceil32(return_data.size) + 64] > -1:
                                                revert with 0, 17
                                            require ext_code.size(brushAddress)
                                            call brushAddress.0x42966c68 with:
                                                 gas gas_remaining wei
                                                args mem[_9050 + ceil32(return_data.size) + 64]
                        else:
                            if brushAddress == address(ext_call.return_data[0]):
                                if brushAddress != address(ext_call.return_data[0]):
                                    if wftmAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[32] > !_6373:
                                            revert with 0, 17
                                        mem[_6377 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_6377 + 100] = ext_call.return_data[32] + _6373
                                        mem[_6377 + 132] = 0
                                        mem[_6377 + 164] = 160
                                        mem[_6377 + 260] = mem[_6377]
                                        idx = 0
                                        s = _6377 + 292
                                        t = _6377 + 32
                                        while idx < mem[_6377]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_6377 + 196] = this.address
                                        mem[_6377 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _6377 + (32 * mem[_6377]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9051 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _9195 = mem[_9051]
                                        require mem[_9051] <= test266151307()
                                        require _9051 + mem[_9051] + 31 < _9051 + return_data.size
                                        _9339 = mem[_9051 + mem[_9051]]
                                        if mem[_9051 + mem[_9051]] > test266151307():
                                            revert with 0, 65
                                        if _9051 + ceil32(return_data.size) + ceil32(32 * mem[_9051 + mem[_9051]]) + 1 > test266151307() or ceil32(32 * mem[_9051 + mem[_9051]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _9051 + ceil32(return_data.size) + ceil32(32 * mem[_9051 + mem[_9051]]) + 1
                                        mem[_9051 + ceil32(return_data.size)] = _9339
                                        require return_data.size >= _9195 + (32 * _9339) + 32
                                        mem[_9051 + ceil32(return_data.size) + 32 len 32 * _9339] = mem[_9051 + _9195 + 32 len 32 * _9339]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                        if 1 >= _9339:
                                            revert with 0, 50
                                        if mem[_9051 + ceil32(return_data.size) + 64] > -1:
                                            revert with 0, 17
                                        require ext_code.size(brushAddress)
                                        call brushAddress.0x42966c68 with:
                                             gas gas_remaining wei
                                            args mem[_9051 + ceil32(return_data.size) + 64]
                                    else:
                                        if ext_call.return_data[0] > !_6373:
                                            revert with 0, 17
                                        mem[_6377 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_6377 + 100] = ext_call.return_data[0] + _6373
                                        mem[_6377 + 132] = 0
                                        mem[_6377 + 164] = 160
                                        mem[_6377 + 260] = mem[_6377]
                                        idx = 0
                                        s = _6377 + 292
                                        t = _6377 + 32
                                        while idx < mem[_6377]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_6377 + 196] = this.address
                                        mem[_6377 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _6377 + (32 * mem[_6377]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9052 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _9196 = mem[_9052]
                                        require mem[_9052] <= test266151307()
                                        require _9052 + mem[_9052] + 31 < _9052 + return_data.size
                                        _9340 = mem[_9052 + mem[_9052]]
                                        if mem[_9052 + mem[_9052]] > test266151307():
                                            revert with 0, 65
                                        if _9052 + ceil32(return_data.size) + ceil32(32 * mem[_9052 + mem[_9052]]) + 1 > test266151307() or ceil32(32 * mem[_9052 + mem[_9052]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _9052 + ceil32(return_data.size) + ceil32(32 * mem[_9052 + mem[_9052]]) + 1
                                        mem[_9052 + ceil32(return_data.size)] = _9340
                                        require return_data.size >= _9196 + (32 * _9340) + 32
                                        mem[_9052 + ceil32(return_data.size) + 32 len 32 * _9340] = mem[_9052 + _9196 + 32 len 32 * _9340]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                        if 1 >= _9340:
                                            revert with 0, 50
                                        if mem[_9052 + ceil32(return_data.size) + 64] > -1:
                                            revert with 0, 17
                                        require ext_code.size(brushAddress)
                                        call brushAddress.0x42966c68 with:
                                             gas gas_remaining wei
                                            args mem[_9052 + ceil32(return_data.size) + 64]
                                else:
                                    if brushAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[32] > !_6373:
                                            revert with 0, 17
                                        mem[_6377 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_6377 + 100] = ext_call.return_data[32] + _6373
                                        mem[_6377 + 132] = 0
                                        mem[_6377 + 164] = 160
                                        mem[_6377 + 260] = mem[_6377]
                                        idx = 0
                                        s = _6377 + 292
                                        t = _6377 + 32
                                        while idx < mem[_6377]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_6377 + 196] = this.address
                                        mem[_6377 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _6377 + (32 * mem[_6377]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9053 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _9197 = mem[_9053]
                                        require mem[_9053] <= test266151307()
                                        require _9053 + mem[_9053] + 31 < _9053 + return_data.size
                                        _9341 = mem[_9053 + mem[_9053]]
                                        if mem[_9053 + mem[_9053]] > test266151307():
                                            revert with 0, 65
                                        if _9053 + ceil32(return_data.size) + ceil32(32 * mem[_9053 + mem[_9053]]) + 1 > test266151307() or ceil32(32 * mem[_9053 + mem[_9053]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _9053 + ceil32(return_data.size) + ceil32(32 * mem[_9053 + mem[_9053]]) + 1
                                        mem[_9053 + ceil32(return_data.size)] = _9341
                                        require return_data.size >= _9197 + (32 * _9341) + 32
                                        mem[_9053 + ceil32(return_data.size) + 32 len 32 * _9341] = mem[_9053 + _9197 + 32 len 32 * _9341]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                        if 1 >= _9341:
                                            revert with 0, 50
                                        if mem[_9053 + ceil32(return_data.size) + 64] > -1:
                                            revert with 0, 17
                                        require ext_code.size(brushAddress)
                                        call brushAddress.0x42966c68 with:
                                             gas gas_remaining wei
                                            args mem[_9053 + ceil32(return_data.size) + 64]
                                    else:
                                        if brushAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[0] > !_6373:
                                                revert with 0, 17
                                            mem[_6377 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_6377 + 100] = ext_call.return_data[0] + _6373
                                            mem[_6377 + 132] = 0
                                            mem[_6377 + 164] = 160
                                            mem[_6377 + 260] = mem[_6377]
                                            idx = 0
                                            s = _6377 + 292
                                            t = _6377 + 32
                                            while idx < mem[_6377]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_6377 + 196] = this.address
                                            mem[_6377 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _6377 + (32 * mem[_6377]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9054 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _9198 = mem[_9054]
                                            require mem[_9054] <= test266151307()
                                            require _9054 + mem[_9054] + 31 < _9054 + return_data.size
                                            _9342 = mem[_9054 + mem[_9054]]
                                            if mem[_9054 + mem[_9054]] > test266151307():
                                                revert with 0, 65
                                            if _9054 + ceil32(return_data.size) + ceil32(32 * mem[_9054 + mem[_9054]]) + 1 > test266151307() or ceil32(32 * mem[_9054 + mem[_9054]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _9054 + ceil32(return_data.size) + ceil32(32 * mem[_9054 + mem[_9054]]) + 1
                                            mem[_9054 + ceil32(return_data.size)] = _9342
                                            require return_data.size >= _9198 + (32 * _9342) + 32
                                            mem[_9054 + ceil32(return_data.size) + 32 len 32 * _9342] = mem[_9054 + _9198 + 32 len 32 * _9342]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                            if 1 >= _9342:
                                                revert with 0, 50
                                            if mem[_9054 + ceil32(return_data.size) + 64] > -1:
                                                revert with 0, 17
                                            require ext_code.size(brushAddress)
                                            call brushAddress.0x42966c68 with:
                                                 gas gas_remaining wei
                                                args mem[_9054 + ceil32(return_data.size) + 64]
                                        else:
                                            if wftmAddress == address(ext_call.return_data[0]):
                                                if ext_call.return_data[32] > !_6373:
                                                    revert with 0, 17
                                                mem[_6377 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[_6377 + 100] = ext_call.return_data[32] + _6373
                                                mem[_6377 + 132] = 0
                                                mem[_6377 + 164] = 160
                                                mem[_6377 + 260] = mem[_6377]
                                                idx = 0
                                                s = _6377 + 292
                                                t = _6377 + 32
                                                while idx < mem[_6377]:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[_6377 + 196] = this.address
                                                mem[_6377 + 228] = block.timestamp + 10000
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len _6377 + (32 * mem[_6377]) + -mem[64] + 288]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _9055 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _9199 = mem[_9055]
                                                require mem[_9055] <= test266151307()
                                                require _9055 + mem[_9055] + 31 < _9055 + return_data.size
                                                _9343 = mem[_9055 + mem[_9055]]
                                                if mem[_9055 + mem[_9055]] > test266151307():
                                                    revert with 0, 65
                                                if _9055 + ceil32(return_data.size) + ceil32(32 * mem[_9055 + mem[_9055]]) + 1 > test266151307() or ceil32(32 * mem[_9055 + mem[_9055]]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[64] = _9055 + ceil32(return_data.size) + ceil32(32 * mem[_9055 + mem[_9055]]) + 1
                                                mem[_9055 + ceil32(return_data.size)] = _9343
                                                require return_data.size >= _9199 + (32 * _9343) + 32
                                                mem[_9055 + ceil32(return_data.size) + 32 len 32 * _9343] = mem[_9055 + _9199 + 32 len 32 * _9343]
                                                if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                    revert with 0, 17
                                                maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                                if 1 >= _9343:
                                                    revert with 0, 50
                                                if mem[_9055 + ceil32(return_data.size) + 64] > -1:
                                                    revert with 0, 17
                                                require ext_code.size(brushAddress)
                                                call brushAddress.0x42966c68 with:
                                                     gas gas_remaining wei
                                                    args mem[_9055 + ceil32(return_data.size) + 64]
                                            else:
                                                if ext_call.return_data[0] > !_6373:
                                                    revert with 0, 17
                                                mem[_6377 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[_6377 + 100] = ext_call.return_data[0] + _6373
                                                mem[_6377 + 132] = 0
                                                mem[_6377 + 164] = 160
                                                mem[_6377 + 260] = mem[_6377]
                                                idx = 0
                                                s = _6377 + 292
                                                t = _6377 + 32
                                                while idx < mem[_6377]:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[_6377 + 196] = this.address
                                                mem[_6377 + 228] = block.timestamp + 10000
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len _6377 + (32 * mem[_6377]) + -mem[64] + 288]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _9056 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _9200 = mem[_9056]
                                                require mem[_9056] <= test266151307()
                                                require _9056 + mem[_9056] + 31 < _9056 + return_data.size
                                                _9344 = mem[_9056 + mem[_9056]]
                                                if mem[_9056 + mem[_9056]] > test266151307():
                                                    revert with 0, 65
                                                if _9056 + ceil32(return_data.size) + ceil32(32 * mem[_9056 + mem[_9056]]) + 1 > test266151307() or ceil32(32 * mem[_9056 + mem[_9056]]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[64] = _9056 + ceil32(return_data.size) + ceil32(32 * mem[_9056 + mem[_9056]]) + 1
                                                mem[_9056 + ceil32(return_data.size)] = _9344
                                                require return_data.size >= _9200 + (32 * _9344) + 32
                                                mem[_9056 + ceil32(return_data.size) + 32 len 32 * _9344] = mem[_9056 + _9200 + 32 len 32 * _9344]
                                                if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                    revert with 0, 17
                                                maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                                if 1 >= _9344:
                                                    revert with 0, 50
                                                if mem[_9056 + ceil32(return_data.size) + 64] > -1:
                                                    revert with 0, 17
                                                require ext_code.size(brushAddress)
                                                call brushAddress.0x42966c68 with:
                                                     gas gas_remaining wei
                                                    args mem[_9056 + ceil32(return_data.size) + 64]
                            else:
                                if wftmAddress == address(ext_call.return_data[0]):
                                    if brushAddress != address(ext_call.return_data[0]):
                                        if wftmAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_6373:
                                                revert with 0, 17
                                            mem[_6377 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_6377 + 100] = ext_call.return_data[32] + _6373
                                            mem[_6377 + 132] = 0
                                            mem[_6377 + 164] = 160
                                            mem[_6377 + 260] = mem[_6377]
                                            idx = 0
                                            s = _6377 + 292
                                            t = _6377 + 32
                                            while idx < mem[_6377]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_6377 + 196] = this.address
                                            mem[_6377 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _6377 + (32 * mem[_6377]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9057 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _9201 = mem[_9057]
                                            require mem[_9057] <= test266151307()
                                            require _9057 + mem[_9057] + 31 < _9057 + return_data.size
                                            _9345 = mem[_9057 + mem[_9057]]
                                            if mem[_9057 + mem[_9057]] > test266151307():
                                                revert with 0, 65
                                            if _9057 + ceil32(return_data.size) + ceil32(32 * mem[_9057 + mem[_9057]]) + 1 > test266151307() or ceil32(32 * mem[_9057 + mem[_9057]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _9057 + ceil32(return_data.size) + ceil32(32 * mem[_9057 + mem[_9057]]) + 1
                                            mem[_9057 + ceil32(return_data.size)] = _9345
                                            require return_data.size >= _9201 + (32 * _9345) + 32
                                            mem[_9057 + ceil32(return_data.size) + 32 len 32 * _9345] = mem[_9057 + _9201 + 32 len 32 * _9345]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                            if 1 >= _9345:
                                                revert with 0, 50
                                            if mem[_9057 + ceil32(return_data.size) + 64] > -1:
                                                revert with 0, 17
                                            require ext_code.size(brushAddress)
                                            call brushAddress.0x42966c68 with:
                                                 gas gas_remaining wei
                                                args mem[_9057 + ceil32(return_data.size) + 64]
                                        else:
                                            if ext_call.return_data[0] > !_6373:
                                                revert with 0, 17
                                            mem[_6377 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_6377 + 100] = ext_call.return_data[0] + _6373
                                            mem[_6377 + 132] = 0
                                            mem[_6377 + 164] = 160
                                            mem[_6377 + 260] = mem[_6377]
                                            idx = 0
                                            s = _6377 + 292
                                            t = _6377 + 32
                                            while idx < mem[_6377]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_6377 + 196] = this.address
                                            mem[_6377 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _6377 + (32 * mem[_6377]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9058 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _9202 = mem[_9058]
                                            require mem[_9058] <= test266151307()
                                            require _9058 + mem[_9058] + 31 < _9058 + return_data.size
                                            _9346 = mem[_9058 + mem[_9058]]
                                            if mem[_9058 + mem[_9058]] > test266151307():
                                                revert with 0, 65
                                            if _9058 + ceil32(return_data.size) + ceil32(32 * mem[_9058 + mem[_9058]]) + 1 > test266151307() or ceil32(32 * mem[_9058 + mem[_9058]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _9058 + ceil32(return_data.size) + ceil32(32 * mem[_9058 + mem[_9058]]) + 1
                                            mem[_9058 + ceil32(return_data.size)] = _9346
                                            require return_data.size >= _9202 + (32 * _9346) + 32
                                            mem[_9058 + ceil32(return_data.size) + 32 len 32 * _9346] = mem[_9058 + _9202 + 32 len 32 * _9346]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                            if 1 >= _9346:
                                                revert with 0, 50
                                            if mem[_9058 + ceil32(return_data.size) + 64] > -1:
                                                revert with 0, 17
                                            require ext_code.size(brushAddress)
                                            call brushAddress.0x42966c68 with:
                                                 gas gas_remaining wei
                                                args mem[_9058 + ceil32(return_data.size) + 64]
                                    else:
                                        if brushAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_6373:
                                                revert with 0, 17
                                            mem[_6377 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_6377 + 100] = ext_call.return_data[32] + _6373
                                            mem[_6377 + 132] = 0
                                            mem[_6377 + 164] = 160
                                            mem[_6377 + 260] = mem[_6377]
                                            idx = 0
                                            s = _6377 + 292
                                            t = _6377 + 32
                                            while idx < mem[_6377]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_6377 + 196] = this.address
                                            mem[_6377 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _6377 + (32 * mem[_6377]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9059 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _9203 = mem[_9059]
                                            require mem[_9059] <= test266151307()
                                            require _9059 + mem[_9059] + 31 < _9059 + return_data.size
                                            _9347 = mem[_9059 + mem[_9059]]
                                            if mem[_9059 + mem[_9059]] > test266151307():
                                                revert with 0, 65
                                            if _9059 + ceil32(return_data.size) + ceil32(32 * mem[_9059 + mem[_9059]]) + 1 > test266151307() or ceil32(32 * mem[_9059 + mem[_9059]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _9059 + ceil32(return_data.size) + ceil32(32 * mem[_9059 + mem[_9059]]) + 1
                                            mem[_9059 + ceil32(return_data.size)] = _9347
                                            require return_data.size >= _9203 + (32 * _9347) + 32
                                            mem[_9059 + ceil32(return_data.size) + 32 len 32 * _9347] = mem[_9059 + _9203 + 32 len 32 * _9347]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                            if 1 >= _9347:
                                                revert with 0, 50
                                            if mem[_9059 + ceil32(return_data.size) + 64] > -1:
                                                revert with 0, 17
                                            require ext_code.size(brushAddress)
                                            call brushAddress.0x42966c68 with:
                                                 gas gas_remaining wei
                                                args mem[_9059 + ceil32(return_data.size) + 64]
                                        else:
                                            if brushAddress == address(ext_call.return_data[0]):
                                                if ext_call.return_data[0] > !_6373:
                                                    revert with 0, 17
                                                mem[_6377 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[_6377 + 100] = ext_call.return_data[0] + _6373
                                                mem[_6377 + 132] = 0
                                                mem[_6377 + 164] = 160
                                                mem[_6377 + 260] = mem[_6377]
                                                idx = 0
                                                s = _6377 + 292
                                                t = _6377 + 32
                                                while idx < mem[_6377]:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[_6377 + 196] = this.address
                                                mem[_6377 + 228] = block.timestamp + 10000
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len _6377 + (32 * mem[_6377]) + -mem[64] + 288]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _9060 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _9204 = mem[_9060]
                                                require mem[_9060] <= test266151307()
                                                require _9060 + mem[_9060] + 31 < _9060 + return_data.size
                                                _9348 = mem[_9060 + mem[_9060]]
                                                if mem[_9060 + mem[_9060]] > test266151307():
                                                    revert with 0, 65
                                                if _9060 + ceil32(return_data.size) + ceil32(32 * mem[_9060 + mem[_9060]]) + 1 > test266151307() or ceil32(32 * mem[_9060 + mem[_9060]]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[64] = _9060 + ceil32(return_data.size) + ceil32(32 * mem[_9060 + mem[_9060]]) + 1
                                                mem[_9060 + ceil32(return_data.size)] = _9348
                                                require return_data.size >= _9204 + (32 * _9348) + 32
                                                mem[_9060 + ceil32(return_data.size) + 32 len 32 * _9348] = mem[_9060 + _9204 + 32 len 32 * _9348]
                                                if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                    revert with 0, 17
                                                maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                                if 1 >= _9348:
                                                    revert with 0, 50
                                                if mem[_9060 + ceil32(return_data.size) + 64] > -1:
                                                    revert with 0, 17
                                                require ext_code.size(brushAddress)
                                                call brushAddress.0x42966c68 with:
                                                     gas gas_remaining wei
                                                    args mem[_9060 + ceil32(return_data.size) + 64]
                                            else:
                                                if wftmAddress == address(ext_call.return_data[0]):
                                                    if ext_call.return_data[32] > !_6373:
                                                        revert with 0, 17
                                                    mem[_6377 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[_6377 + 100] = ext_call.return_data[32] + _6373
                                                    mem[_6377 + 132] = 0
                                                    mem[_6377 + 164] = 160
                                                    mem[_6377 + 260] = mem[_6377]
                                                    idx = 0
                                                    s = _6377 + 292
                                                    t = _6377 + 32
                                                    while idx < mem[_6377]:
                                                        mem[s] = mem[t + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[_6377 + 196] = this.address
                                                    mem[_6377 + 228] = block.timestamp + 10000
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len _6377 + (32 * mem[_6377]) + -mem[64] + 288]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _9061 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _9205 = mem[_9061]
                                                    require mem[_9061] <= test266151307()
                                                    require _9061 + mem[_9061] + 31 < _9061 + return_data.size
                                                    _9349 = mem[_9061 + mem[_9061]]
                                                    if mem[_9061 + mem[_9061]] > test266151307():
                                                        revert with 0, 65
                                                    if _9061 + ceil32(return_data.size) + ceil32(32 * mem[_9061 + mem[_9061]]) + 1 > test266151307() or ceil32(32 * mem[_9061 + mem[_9061]]) + 1 < 0:
                                                        revert with 0, 65
                                                    mem[64] = _9061 + ceil32(return_data.size) + ceil32(32 * mem[_9061 + mem[_9061]]) + 1
                                                    mem[_9061 + ceil32(return_data.size)] = _9349
                                                    require return_data.size >= _9205 + (32 * _9349) + 32
                                                    mem[_9061 + ceil32(return_data.size) + 32 len 32 * _9349] = mem[_9061 + _9205 + 32 len 32 * _9349]
                                                    if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                        revert with 0, 17
                                                    maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                                    if 1 >= _9349:
                                                        revert with 0, 50
                                                    if mem[_9061 + ceil32(return_data.size) + 64] > -1:
                                                        revert with 0, 17
                                                    require ext_code.size(brushAddress)
                                                    call brushAddress.0x42966c68 with:
                                                         gas gas_remaining wei
                                                        args mem[_9061 + ceil32(return_data.size) + 64]
                                                else:
                                                    if ext_call.return_data[0] > !_6373:
                                                        revert with 0, 17
                                                    mem[_6377 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[_6377 + 100] = ext_call.return_data[0] + _6373
                                                    mem[_6377 + 132] = 0
                                                    mem[_6377 + 164] = 160
                                                    mem[_6377 + 260] = mem[_6377]
                                                    idx = 0
                                                    s = _6377 + 292
                                                    t = _6377 + 32
                                                    while idx < mem[_6377]:
                                                        mem[s] = mem[t + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[_6377 + 196] = this.address
                                                    mem[_6377 + 228] = block.timestamp + 10000
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len _6377 + (32 * mem[_6377]) + -mem[64] + 288]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _9062 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _9206 = mem[_9062]
                                                    require mem[_9062] <= test266151307()
                                                    require _9062 + mem[_9062] + 31 < _9062 + return_data.size
                                                    _9350 = mem[_9062 + mem[_9062]]
                                                    if mem[_9062 + mem[_9062]] > test266151307():
                                                        revert with 0, 65
                                                    if _9062 + ceil32(return_data.size) + ceil32(32 * mem[_9062 + mem[_9062]]) + 1 > test266151307() or ceil32(32 * mem[_9062 + mem[_9062]]) + 1 < 0:
                                                        revert with 0, 65
                                                    mem[64] = _9062 + ceil32(return_data.size) + ceil32(32 * mem[_9062 + mem[_9062]]) + 1
                                                    mem[_9062 + ceil32(return_data.size)] = _9350
                                                    require return_data.size >= _9206 + (32 * _9350) + 32
                                                    mem[_9062 + ceil32(return_data.size) + 32 len 32 * _9350] = mem[_9062 + _9206 + 32 len 32 * _9350]
                                                    if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                        revert with 0, 17
                                                    maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                                    if 1 >= _9350:
                                                        revert with 0, 50
                                                    if mem[_9062 + ceil32(return_data.size) + 64] > -1:
                                                        revert with 0, 17
                                                    require ext_code.size(brushAddress)
                                                    call brushAddress.0x42966c68 with:
                                                         gas gas_remaining wei
                                                        args mem[_9062 + ceil32(return_data.size) + 64]
                                else:
                                    if brushAddress != address(ext_call.return_data[0]):
                                        if wftmAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_6373:
                                                revert with 0, 17
                                            mem[_6377 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_6377 + 100] = ext_call.return_data[32] + _6373
                                            mem[_6377 + 132] = 0
                                            mem[_6377 + 164] = 160
                                            mem[_6377 + 260] = mem[_6377]
                                            idx = 0
                                            s = _6377 + 292
                                            t = _6377 + 32
                                            while idx < mem[_6377]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_6377 + 196] = this.address
                                            mem[_6377 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _6377 + (32 * mem[_6377]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9063 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _9207 = mem[_9063]
                                            require mem[_9063] <= test266151307()
                                            require _9063 + mem[_9063] + 31 < _9063 + return_data.size
                                            _9351 = mem[_9063 + mem[_9063]]
                                            if mem[_9063 + mem[_9063]] > test266151307():
                                                revert with 0, 65
                                            if _9063 + ceil32(return_data.size) + ceil32(32 * mem[_9063 + mem[_9063]]) + 1 > test266151307() or ceil32(32 * mem[_9063 + mem[_9063]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _9063 + ceil32(return_data.size) + ceil32(32 * mem[_9063 + mem[_9063]]) + 1
                                            mem[_9063 + ceil32(return_data.size)] = _9351
                                            require return_data.size >= _9207 + (32 * _9351) + 32
                                            mem[_9063 + ceil32(return_data.size) + 32 len 32 * _9351] = mem[_9063 + _9207 + 32 len 32 * _9351]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                            if 1 >= _9351:
                                                revert with 0, 50
                                            if mem[_9063 + ceil32(return_data.size) + 64] > -1:
                                                revert with 0, 17
                                            require ext_code.size(brushAddress)
                                            call brushAddress.0x42966c68 with:
                                                 gas gas_remaining wei
                                                args mem[_9063 + ceil32(return_data.size) + 64]
                                        else:
                                            if ext_call.return_data[0] > !_6373:
                                                revert with 0, 17
                                            mem[_6377 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_6377 + 100] = ext_call.return_data[0] + _6373
                                            mem[_6377 + 132] = 0
                                            mem[_6377 + 164] = 160
                                            mem[_6377 + 260] = mem[_6377]
                                            idx = 0
                                            s = _6377 + 292
                                            t = _6377 + 32
                                            while idx < mem[_6377]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_6377 + 196] = this.address
                                            mem[_6377 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _6377 + (32 * mem[_6377]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9064 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _9208 = mem[_9064]
                                            require mem[_9064] <= test266151307()
                                            require _9064 + mem[_9064] + 31 < _9064 + return_data.size
                                            _9352 = mem[_9064 + mem[_9064]]
                                            if mem[_9064 + mem[_9064]] > test266151307():
                                                revert with 0, 65
                                            if _9064 + ceil32(return_data.size) + ceil32(32 * mem[_9064 + mem[_9064]]) + 1 > test266151307() or ceil32(32 * mem[_9064 + mem[_9064]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _9064 + ceil32(return_data.size) + ceil32(32 * mem[_9064 + mem[_9064]]) + 1
                                            mem[_9064 + ceil32(return_data.size)] = _9352
                                            require return_data.size >= _9208 + (32 * _9352) + 32
                                            mem[_9064 + ceil32(return_data.size) + 32 len 32 * _9352] = mem[_9064 + _9208 + 32 len 32 * _9352]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                            if 1 >= _9352:
                                                revert with 0, 50
                                            if mem[_9064 + ceil32(return_data.size) + 64] > -1:
                                                revert with 0, 17
                                            require ext_code.size(brushAddress)
                                            call brushAddress.0x42966c68 with:
                                                 gas gas_remaining wei
                                                args mem[_9064 + ceil32(return_data.size) + 64]
                                    else:
                                        if brushAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_6373:
                                                revert with 0, 17
                                            mem[_6377 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_6377 + 100] = ext_call.return_data[32] + _6373
                                            mem[_6377 + 132] = 0
                                            mem[_6377 + 164] = 160
                                            mem[_6377 + 260] = mem[_6377]
                                            idx = 0
                                            s = _6377 + 292
                                            t = _6377 + 32
                                            while idx < mem[_6377]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_6377 + 196] = this.address
                                            mem[_6377 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _6377 + (32 * mem[_6377]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9065 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _9209 = mem[_9065]
                                            require mem[_9065] <= test266151307()
                                            require _9065 + mem[_9065] + 31 < _9065 + return_data.size
                                            _9353 = mem[_9065 + mem[_9065]]
                                            if mem[_9065 + mem[_9065]] > test266151307():
                                                revert with 0, 65
                                            if _9065 + ceil32(return_data.size) + ceil32(32 * mem[_9065 + mem[_9065]]) + 1 > test266151307() or ceil32(32 * mem[_9065 + mem[_9065]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _9065 + ceil32(return_data.size) + ceil32(32 * mem[_9065 + mem[_9065]]) + 1
                                            mem[_9065 + ceil32(return_data.size)] = _9353
                                            require return_data.size >= _9209 + (32 * _9353) + 32
                                            mem[_9065 + ceil32(return_data.size) + 32 len 32 * _9353] = mem[_9065 + _9209 + 32 len 32 * _9353]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                            if 1 >= _9353:
                                                revert with 0, 50
                                            if mem[_9065 + ceil32(return_data.size) + 64] > -1:
                                                revert with 0, 17
                                            require ext_code.size(brushAddress)
                                            call brushAddress.0x42966c68 with:
                                                 gas gas_remaining wei
                                                args mem[_9065 + ceil32(return_data.size) + 64]
                                        else:
                                            if brushAddress == address(ext_call.return_data[0]):
                                                if ext_call.return_data[0] > !_6373:
                                                    revert with 0, 17
                                                mem[_6377 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[_6377 + 100] = ext_call.return_data[0] + _6373
                                                mem[_6377 + 132] = 0
                                                mem[_6377 + 164] = 160
                                                mem[_6377 + 260] = mem[_6377]
                                                idx = 0
                                                s = _6377 + 292
                                                t = _6377 + 32
                                                while idx < mem[_6377]:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[_6377 + 196] = this.address
                                                mem[_6377 + 228] = block.timestamp + 10000
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len _6377 + (32 * mem[_6377]) + -mem[64] + 288]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _9066 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _9210 = mem[_9066]
                                                require mem[_9066] <= test266151307()
                                                require _9066 + mem[_9066] + 31 < _9066 + return_data.size
                                                _9354 = mem[_9066 + mem[_9066]]
                                                if mem[_9066 + mem[_9066]] > test266151307():
                                                    revert with 0, 65
                                                if _9066 + ceil32(return_data.size) + ceil32(32 * mem[_9066 + mem[_9066]]) + 1 > test266151307() or ceil32(32 * mem[_9066 + mem[_9066]]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[64] = _9066 + ceil32(return_data.size) + ceil32(32 * mem[_9066 + mem[_9066]]) + 1
                                                mem[_9066 + ceil32(return_data.size)] = _9354
                                                require return_data.size >= _9210 + (32 * _9354) + 32
                                                mem[_9066 + ceil32(return_data.size) + 32 len 32 * _9354] = mem[_9066 + _9210 + 32 len 32 * _9354]
                                                if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                    revert with 0, 17
                                                maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                                if 1 >= _9354:
                                                    revert with 0, 50
                                                if mem[_9066 + ceil32(return_data.size) + 64] > -1:
                                                    revert with 0, 17
                                                require ext_code.size(brushAddress)
                                                call brushAddress.0x42966c68 with:
                                                     gas gas_remaining wei
                                                    args mem[_9066 + ceil32(return_data.size) + 64]
                                            else:
                                                if wftmAddress == address(ext_call.return_data[0]):
                                                    if ext_call.return_data[32] > !_6373:
                                                        revert with 0, 17
                                                    mem[_6377 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[_6377 + 100] = ext_call.return_data[32] + _6373
                                                    mem[_6377 + 132] = 0
                                                    mem[_6377 + 164] = 160
                                                    mem[_6377 + 260] = mem[_6377]
                                                    idx = 0
                                                    s = _6377 + 292
                                                    t = _6377 + 32
                                                    while idx < mem[_6377]:
                                                        mem[s] = mem[t + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[_6377 + 196] = this.address
                                                    mem[_6377 + 228] = block.timestamp + 10000
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len _6377 + (32 * mem[_6377]) + -mem[64] + 288]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _9067 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _9211 = mem[_9067]
                                                    require mem[_9067] <= test266151307()
                                                    require _9067 + mem[_9067] + 31 < _9067 + return_data.size
                                                    _9355 = mem[_9067 + mem[_9067]]
                                                    if mem[_9067 + mem[_9067]] > test266151307():
                                                        revert with 0, 65
                                                    if _9067 + ceil32(return_data.size) + ceil32(32 * mem[_9067 + mem[_9067]]) + 1 > test266151307() or ceil32(32 * mem[_9067 + mem[_9067]]) + 1 < 0:
                                                        revert with 0, 65
                                                    mem[64] = _9067 + ceil32(return_data.size) + ceil32(32 * mem[_9067 + mem[_9067]]) + 1
                                                    mem[_9067 + ceil32(return_data.size)] = _9355
                                                    require return_data.size >= _9211 + (32 * _9355) + 32
                                                    mem[_9067 + ceil32(return_data.size) + 32 len 32 * _9355] = mem[_9067 + _9211 + 32 len 32 * _9355]
                                                    if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                        revert with 0, 17
                                                    maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                                    if 1 >= _9355:
                                                        revert with 0, 50
                                                    if mem[_9067 + ceil32(return_data.size) + 64] > -1:
                                                        revert with 0, 17
                                                    require ext_code.size(brushAddress)
                                                    call brushAddress.0x42966c68 with:
                                                         gas gas_remaining wei
                                                        args mem[_9067 + ceil32(return_data.size) + 64]
                                                else:
                                                    if ext_call.return_data[0] > !_6373:
                                                        revert with 0, 17
                                                    mem[_6377 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[_6377 + 100] = ext_call.return_data[0] + _6373
                                                    mem[_6377 + 132] = 0
                                                    mem[_6377 + 164] = 160
                                                    mem[_6377 + 260] = mem[_6377]
                                                    idx = 0
                                                    s = _6377 + 292
                                                    t = _6377 + 32
                                                    while idx < mem[_6377]:
                                                        mem[s] = mem[t + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[_6377 + 196] = this.address
                                                    mem[_6377 + 228] = block.timestamp + 10000
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len _6377 + (32 * mem[_6377]) + -mem[64] + 288]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _9068 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _9212 = mem[_9068]
                                                    require mem[_9068] <= test266151307()
                                                    require _9068 + mem[_9068] + 31 < _9068 + return_data.size
                                                    _9356 = mem[_9068 + mem[_9068]]
                                                    if mem[_9068 + mem[_9068]] > test266151307():
                                                        revert with 0, 65
                                                    if _9068 + ceil32(return_data.size) + ceil32(32 * mem[_9068 + mem[_9068]]) + 1 > test266151307() or ceil32(32 * mem[_9068 + mem[_9068]]) + 1 < 0:
                                                        revert with 0, 65
                                                    mem[64] = _9068 + ceil32(return_data.size) + ceil32(32 * mem[_9068 + mem[_9068]]) + 1
                                                    mem[_9068 + ceil32(return_data.size)] = _9356
                                                    require return_data.size >= _9212 + (32 * _9356) + 32
                                                    mem[_9068 + ceil32(return_data.size) + 32 len 32 * _9356] = mem[_9068 + _9212 + 32 len 32 * _9356]
                                                    if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                        revert with 0, 17
                                                    maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                                    if 1 >= _9356:
                                                        revert with 0, 50
                                                    if mem[_9068 + ceil32(return_data.size) + 64] > -1:
                                                        revert with 0, 17
                                                    require ext_code.size(brushAddress)
                                                    call brushAddress.0x42966c68 with:
                                                         gas gas_remaining wei
                                                        args mem[_9068 + ceil32(return_data.size) + 64]
                else:
                    mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                    mem[(4 * ceil32(return_data.size)) + 228] = 0
                    mem[(4 * ceil32(return_data.size)) + 260] = 160
                    mem[(4 * ceil32(return_data.size)) + 356] = 2
                    idx = 0
                    s = (4 * ceil32(return_data.size)) + 388
                    t = (4 * ceil32(return_data.size)) + 128
                    while idx < 2:
                        mem[s] = mem[t + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[(4 * ceil32(return_data.size)) + 292] = this.address
                    mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                    require ext_code.size(routerAddress)
                    call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                         gas gas_remaining wei
                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = (6 * ceil32(return_data.size)) + 192
                    require return_data.size >= 32
                    _3524 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                    require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                    require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                    _3603 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                    if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                        revert with 0, 65
                    if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                        revert with 0, 65
                    mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193
                    mem[(6 * ceil32(return_data.size)) + 192] = _3603
                    require return_data.size >= _3524 + (32 * _3603) + 32
                    mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3603] = mem[(4 * ceil32(return_data.size)) + _3524 + 224 len 32 * _3603]
                    if 1 >= _3603:
                        revert with 0, 50
                    _6374 = mem[(6 * ceil32(return_data.size)) + 256]
                    _6378 = mem[64]
                    mem[mem[64]] = 2
                    mem[64] = mem[64] + 96
                    if 0 >= mem[_6378]:
                        revert with 0, 50
                    mem[_6378 + 32] = address(ext_call.return_data[0])
                    if 1 >= mem[_6378]:
                        revert with 0, 50
                    mem[_6378 + 64] = brushAddress
                    if brushAddress != address(ext_call.return_data[0]):
                        if wftmAddress == address(ext_call.return_data[0]):
                            if brushAddress != address(ext_call.return_data[0]):
                                if wftmAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_6374:
                                        revert with 0, 17
                                    mem[_6378 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_6378 + 100] = ext_call.return_data[32] + _6374
                                    mem[_6378 + 132] = 0
                                    mem[_6378 + 164] = 160
                                    mem[_6378 + 260] = mem[_6378]
                                    idx = 0
                                    s = _6378 + 292
                                    t = _6378 + 32
                                    while idx < mem[_6378]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_6378 + 196] = this.address
                                    mem[_6378 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _6378 + (32 * mem[_6378]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9069 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _9213 = mem[_9069]
                                    require mem[_9069] <= test266151307()
                                    require _9069 + mem[_9069] + 31 < _9069 + return_data.size
                                    _9357 = mem[_9069 + mem[_9069]]
                                    if mem[_9069 + mem[_9069]] > test266151307():
                                        revert with 0, 65
                                    if _9069 + ceil32(return_data.size) + ceil32(32 * mem[_9069 + mem[_9069]]) + 1 > test266151307() or ceil32(32 * mem[_9069 + mem[_9069]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _9069 + ceil32(return_data.size) + ceil32(32 * mem[_9069 + mem[_9069]]) + 1
                                    mem[_9069 + ceil32(return_data.size)] = _9357
                                    require return_data.size >= _9213 + (32 * _9357) + 32
                                    mem[_9069 + ceil32(return_data.size) + 32 len 32 * _9357] = mem[_9069 + _9213 + 32 len 32 * _9357]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                    if 1 >= _9357:
                                        revert with 0, 50
                                    if mem[_9069 + ceil32(return_data.size) + 64] > -1:
                                        revert with 0, 17
                                    require ext_code.size(brushAddress)
                                    call brushAddress.0x42966c68 with:
                                         gas gas_remaining wei
                                        args mem[_9069 + ceil32(return_data.size) + 64]
                                else:
                                    if ext_call.return_data[0] > !_6374:
                                        revert with 0, 17
                                    mem[_6378 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_6378 + 100] = ext_call.return_data[0] + _6374
                                    mem[_6378 + 132] = 0
                                    mem[_6378 + 164] = 160
                                    mem[_6378 + 260] = mem[_6378]
                                    idx = 0
                                    s = _6378 + 292
                                    t = _6378 + 32
                                    while idx < mem[_6378]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_6378 + 196] = this.address
                                    mem[_6378 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _6378 + (32 * mem[_6378]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9070 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _9214 = mem[_9070]
                                    require mem[_9070] <= test266151307()
                                    require _9070 + mem[_9070] + 31 < _9070 + return_data.size
                                    _9358 = mem[_9070 + mem[_9070]]
                                    if mem[_9070 + mem[_9070]] > test266151307():
                                        revert with 0, 65
                                    if _9070 + ceil32(return_data.size) + ceil32(32 * mem[_9070 + mem[_9070]]) + 1 > test266151307() or ceil32(32 * mem[_9070 + mem[_9070]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _9070 + ceil32(return_data.size) + ceil32(32 * mem[_9070 + mem[_9070]]) + 1
                                    mem[_9070 + ceil32(return_data.size)] = _9358
                                    require return_data.size >= _9214 + (32 * _9358) + 32
                                    mem[_9070 + ceil32(return_data.size) + 32 len 32 * _9358] = mem[_9070 + _9214 + 32 len 32 * _9358]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                    if 1 >= _9358:
                                        revert with 0, 50
                                    if mem[_9070 + ceil32(return_data.size) + 64] > -1:
                                        revert with 0, 17
                                    require ext_code.size(brushAddress)
                                    call brushAddress.0x42966c68 with:
                                         gas gas_remaining wei
                                        args mem[_9070 + ceil32(return_data.size) + 64]
                            else:
                                if brushAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_6374:
                                        revert with 0, 17
                                    mem[_6378 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_6378 + 100] = ext_call.return_data[32] + _6374
                                    mem[_6378 + 132] = 0
                                    mem[_6378 + 164] = 160
                                    mem[_6378 + 260] = mem[_6378]
                                    idx = 0
                                    s = _6378 + 292
                                    t = _6378 + 32
                                    while idx < mem[_6378]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_6378 + 196] = this.address
                                    mem[_6378 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _6378 + (32 * mem[_6378]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9071 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _9215 = mem[_9071]
                                    require mem[_9071] <= test266151307()
                                    require _9071 + mem[_9071] + 31 < _9071 + return_data.size
                                    _9359 = mem[_9071 + mem[_9071]]
                                    if mem[_9071 + mem[_9071]] > test266151307():
                                        revert with 0, 65
                                    if _9071 + ceil32(return_data.size) + ceil32(32 * mem[_9071 + mem[_9071]]) + 1 > test266151307() or ceil32(32 * mem[_9071 + mem[_9071]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _9071 + ceil32(return_data.size) + ceil32(32 * mem[_9071 + mem[_9071]]) + 1
                                    mem[_9071 + ceil32(return_data.size)] = _9359
                                    require return_data.size >= _9215 + (32 * _9359) + 32
                                    mem[_9071 + ceil32(return_data.size) + 32 len 32 * _9359] = mem[_9071 + _9215 + 32 len 32 * _9359]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                    if 1 >= _9359:
                                        revert with 0, 50
                                    if mem[_9071 + ceil32(return_data.size) + 64] > -1:
                                        revert with 0, 17
                                    require ext_code.size(brushAddress)
                                    call brushAddress.0x42966c68 with:
                                         gas gas_remaining wei
                                        args mem[_9071 + ceil32(return_data.size) + 64]
                                else:
                                    if brushAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[0] > !_6374:
                                            revert with 0, 17
                                        mem[_6378 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_6378 + 100] = ext_call.return_data[0] + _6374
                                        mem[_6378 + 132] = 0
                                        mem[_6378 + 164] = 160
                                        mem[_6378 + 260] = mem[_6378]
                                        idx = 0
                                        s = _6378 + 292
                                        t = _6378 + 32
                                        while idx < mem[_6378]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_6378 + 196] = this.address
                                        mem[_6378 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _6378 + (32 * mem[_6378]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9072 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _9216 = mem[_9072]
                                        require mem[_9072] <= test266151307()
                                        require _9072 + mem[_9072] + 31 < _9072 + return_data.size
                                        _9360 = mem[_9072 + mem[_9072]]
                                        if mem[_9072 + mem[_9072]] > test266151307():
                                            revert with 0, 65
                                        if _9072 + ceil32(return_data.size) + ceil32(32 * mem[_9072 + mem[_9072]]) + 1 > test266151307() or ceil32(32 * mem[_9072 + mem[_9072]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _9072 + ceil32(return_data.size) + ceil32(32 * mem[_9072 + mem[_9072]]) + 1
                                        mem[_9072 + ceil32(return_data.size)] = _9360
                                        require return_data.size >= _9216 + (32 * _9360) + 32
                                        mem[_9072 + ceil32(return_data.size) + 32 len 32 * _9360] = mem[_9072 + _9216 + 32 len 32 * _9360]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                        if 1 >= _9360:
                                            revert with 0, 50
                                        if mem[_9072 + ceil32(return_data.size) + 64] > -1:
                                            revert with 0, 17
                                        require ext_code.size(brushAddress)
                                        call brushAddress.0x42966c68 with:
                                             gas gas_remaining wei
                                            args mem[_9072 + ceil32(return_data.size) + 64]
                                    else:
                                        if wftmAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_6374:
                                                revert with 0, 17
                                            mem[_6378 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_6378 + 100] = ext_call.return_data[32] + _6374
                                            mem[_6378 + 132] = 0
                                            mem[_6378 + 164] = 160
                                            mem[_6378 + 260] = mem[_6378]
                                            idx = 0
                                            s = _6378 + 292
                                            t = _6378 + 32
                                            while idx < mem[_6378]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_6378 + 196] = this.address
                                            mem[_6378 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _6378 + (32 * mem[_6378]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9073 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _9217 = mem[_9073]
                                            require mem[_9073] <= test266151307()
                                            require _9073 + mem[_9073] + 31 < _9073 + return_data.size
                                            _9361 = mem[_9073 + mem[_9073]]
                                            if mem[_9073 + mem[_9073]] > test266151307():
                                                revert with 0, 65
                                            if _9073 + ceil32(return_data.size) + ceil32(32 * mem[_9073 + mem[_9073]]) + 1 > test266151307() or ceil32(32 * mem[_9073 + mem[_9073]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _9073 + ceil32(return_data.size) + ceil32(32 * mem[_9073 + mem[_9073]]) + 1
                                            mem[_9073 + ceil32(return_data.size)] = _9361
                                            require return_data.size >= _9217 + (32 * _9361) + 32
                                            mem[_9073 + ceil32(return_data.size) + 32 len 32 * _9361] = mem[_9073 + _9217 + 32 len 32 * _9361]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                            if 1 >= _9361:
                                                revert with 0, 50
                                            if mem[_9073 + ceil32(return_data.size) + 64] > -1:
                                                revert with 0, 17
                                            require ext_code.size(brushAddress)
                                            call brushAddress.0x42966c68 with:
                                                 gas gas_remaining wei
                                                args mem[_9073 + ceil32(return_data.size) + 64]
                                        else:
                                            if ext_call.return_data[0] > !_6374:
                                                revert with 0, 17
                                            mem[_6378 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_6378 + 100] = ext_call.return_data[0] + _6374
                                            mem[_6378 + 132] = 0
                                            mem[_6378 + 164] = 160
                                            mem[_6378 + 260] = mem[_6378]
                                            idx = 0
                                            s = _6378 + 292
                                            t = _6378 + 32
                                            while idx < mem[_6378]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_6378 + 196] = this.address
                                            mem[_6378 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _6378 + (32 * mem[_6378]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9074 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _9218 = mem[_9074]
                                            require mem[_9074] <= test266151307()
                                            require _9074 + mem[_9074] + 31 < _9074 + return_data.size
                                            _9362 = mem[_9074 + mem[_9074]]
                                            if mem[_9074 + mem[_9074]] > test266151307():
                                                revert with 0, 65
                                            if _9074 + ceil32(return_data.size) + ceil32(32 * mem[_9074 + mem[_9074]]) + 1 > test266151307() or ceil32(32 * mem[_9074 + mem[_9074]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _9074 + ceil32(return_data.size) + ceil32(32 * mem[_9074 + mem[_9074]]) + 1
                                            mem[_9074 + ceil32(return_data.size)] = _9362
                                            require return_data.size >= _9218 + (32 * _9362) + 32
                                            mem[_9074 + ceil32(return_data.size) + 32 len 32 * _9362] = mem[_9074 + _9218 + 32 len 32 * _9362]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                            if 1 >= _9362:
                                                revert with 0, 50
                                            if mem[_9074 + ceil32(return_data.size) + 64] > -1:
                                                revert with 0, 17
                                            require ext_code.size(brushAddress)
                                            call brushAddress.0x42966c68 with:
                                                 gas gas_remaining wei
                                                args mem[_9074 + ceil32(return_data.size) + 64]
                        else:
                            if brushAddress != address(ext_call.return_data[0]):
                                if wftmAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_6374:
                                        revert with 0, 17
                                    mem[_6378 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_6378 + 100] = ext_call.return_data[32] + _6374
                                    mem[_6378 + 132] = 0
                                    mem[_6378 + 164] = 160
                                    mem[_6378 + 260] = mem[_6378]
                                    idx = 0
                                    s = _6378 + 292
                                    t = _6378 + 32
                                    while idx < mem[_6378]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_6378 + 196] = this.address
                                    mem[_6378 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _6378 + (32 * mem[_6378]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9075 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _9219 = mem[_9075]
                                    require mem[_9075] <= test266151307()
                                    require _9075 + mem[_9075] + 31 < _9075 + return_data.size
                                    _9363 = mem[_9075 + mem[_9075]]
                                    if mem[_9075 + mem[_9075]] > test266151307():
                                        revert with 0, 65
                                    if _9075 + ceil32(return_data.size) + ceil32(32 * mem[_9075 + mem[_9075]]) + 1 > test266151307() or ceil32(32 * mem[_9075 + mem[_9075]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _9075 + ceil32(return_data.size) + ceil32(32 * mem[_9075 + mem[_9075]]) + 1
                                    mem[_9075 + ceil32(return_data.size)] = _9363
                                    require return_data.size >= _9219 + (32 * _9363) + 32
                                    mem[_9075 + ceil32(return_data.size) + 32 len 32 * _9363] = mem[_9075 + _9219 + 32 len 32 * _9363]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                    if 1 >= _9363:
                                        revert with 0, 50
                                    if mem[_9075 + ceil32(return_data.size) + 64] > -1:
                                        revert with 0, 17
                                    require ext_code.size(brushAddress)
                                    call brushAddress.0x42966c68 with:
                                         gas gas_remaining wei
                                        args mem[_9075 + ceil32(return_data.size) + 64]
                                else:
                                    if ext_call.return_data[0] > !_6374:
                                        revert with 0, 17
                                    mem[_6378 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_6378 + 100] = ext_call.return_data[0] + _6374
                                    mem[_6378 + 132] = 0
                                    mem[_6378 + 164] = 160
                                    mem[_6378 + 260] = mem[_6378]
                                    idx = 0
                                    s = _6378 + 292
                                    t = _6378 + 32
                                    while idx < mem[_6378]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_6378 + 196] = this.address
                                    mem[_6378 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _6378 + (32 * mem[_6378]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9076 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _9220 = mem[_9076]
                                    require mem[_9076] <= test266151307()
                                    require _9076 + mem[_9076] + 31 < _9076 + return_data.size
                                    _9364 = mem[_9076 + mem[_9076]]
                                    if mem[_9076 + mem[_9076]] > test266151307():
                                        revert with 0, 65
                                    if _9076 + ceil32(return_data.size) + ceil32(32 * mem[_9076 + mem[_9076]]) + 1 > test266151307() or ceil32(32 * mem[_9076 + mem[_9076]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _9076 + ceil32(return_data.size) + ceil32(32 * mem[_9076 + mem[_9076]]) + 1
                                    mem[_9076 + ceil32(return_data.size)] = _9364
                                    require return_data.size >= _9220 + (32 * _9364) + 32
                                    mem[_9076 + ceil32(return_data.size) + 32 len 32 * _9364] = mem[_9076 + _9220 + 32 len 32 * _9364]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                    if 1 >= _9364:
                                        revert with 0, 50
                                    if mem[_9076 + ceil32(return_data.size) + 64] > -1:
                                        revert with 0, 17
                                    require ext_code.size(brushAddress)
                                    call brushAddress.0x42966c68 with:
                                         gas gas_remaining wei
                                        args mem[_9076 + ceil32(return_data.size) + 64]
                            else:
                                if brushAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_6374:
                                        revert with 0, 17
                                    mem[_6378 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_6378 + 100] = ext_call.return_data[32] + _6374
                                    mem[_6378 + 132] = 0
                                    mem[_6378 + 164] = 160
                                    mem[_6378 + 260] = mem[_6378]
                                    idx = 0
                                    s = _6378 + 292
                                    t = _6378 + 32
                                    while idx < mem[_6378]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_6378 + 196] = this.address
                                    mem[_6378 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _6378 + (32 * mem[_6378]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9077 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _9221 = mem[_9077]
                                    require mem[_9077] <= test266151307()
                                    require _9077 + mem[_9077] + 31 < _9077 + return_data.size
                                    _9365 = mem[_9077 + mem[_9077]]
                                    if mem[_9077 + mem[_9077]] > test266151307():
                                        revert with 0, 65
                                    if _9077 + ceil32(return_data.size) + ceil32(32 * mem[_9077 + mem[_9077]]) + 1 > test266151307() or ceil32(32 * mem[_9077 + mem[_9077]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _9077 + ceil32(return_data.size) + ceil32(32 * mem[_9077 + mem[_9077]]) + 1
                                    mem[_9077 + ceil32(return_data.size)] = _9365
                                    require return_data.size >= _9221 + (32 * _9365) + 32
                                    mem[_9077 + ceil32(return_data.size) + 32 len 32 * _9365] = mem[_9077 + _9221 + 32 len 32 * _9365]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                    if 1 >= _9365:
                                        revert with 0, 50
                                    if mem[_9077 + ceil32(return_data.size) + 64] > -1:
                                        revert with 0, 17
                                    require ext_code.size(brushAddress)
                                    call brushAddress.0x42966c68 with:
                                         gas gas_remaining wei
                                        args mem[_9077 + ceil32(return_data.size) + 64]
                                else:
                                    if brushAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[0] > !_6374:
                                            revert with 0, 17
                                        mem[_6378 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_6378 + 100] = ext_call.return_data[0] + _6374
                                        mem[_6378 + 132] = 0
                                        mem[_6378 + 164] = 160
                                        mem[_6378 + 260] = mem[_6378]
                                        idx = 0
                                        s = _6378 + 292
                                        t = _6378 + 32
                                        while idx < mem[_6378]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_6378 + 196] = this.address
                                        mem[_6378 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _6378 + (32 * mem[_6378]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9078 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _9222 = mem[_9078]
                                        require mem[_9078] <= test266151307()
                                        require _9078 + mem[_9078] + 31 < _9078 + return_data.size
                                        _9366 = mem[_9078 + mem[_9078]]
                                        if mem[_9078 + mem[_9078]] > test266151307():
                                            revert with 0, 65
                                        if _9078 + ceil32(return_data.size) + ceil32(32 * mem[_9078 + mem[_9078]]) + 1 > test266151307() or ceil32(32 * mem[_9078 + mem[_9078]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _9078 + ceil32(return_data.size) + ceil32(32 * mem[_9078 + mem[_9078]]) + 1
                                        mem[_9078 + ceil32(return_data.size)] = _9366
                                        require return_data.size >= _9222 + (32 * _9366) + 32
                                        mem[_9078 + ceil32(return_data.size) + 32 len 32 * _9366] = mem[_9078 + _9222 + 32 len 32 * _9366]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                        if 1 >= _9366:
                                            revert with 0, 50
                                        if mem[_9078 + ceil32(return_data.size) + 64] > -1:
                                            revert with 0, 17
                                        require ext_code.size(brushAddress)
                                        call brushAddress.0x42966c68 with:
                                             gas gas_remaining wei
                                            args mem[_9078 + ceil32(return_data.size) + 64]
                                    else:
                                        if wftmAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_6374:
                                                revert with 0, 17
                                            mem[_6378 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_6378 + 100] = ext_call.return_data[32] + _6374
                                            mem[_6378 + 132] = 0
                                            mem[_6378 + 164] = 160
                                            mem[_6378 + 260] = mem[_6378]
                                            idx = 0
                                            s = _6378 + 292
                                            t = _6378 + 32
                                            while idx < mem[_6378]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_6378 + 196] = this.address
                                            mem[_6378 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _6378 + (32 * mem[_6378]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9079 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _9223 = mem[_9079]
                                            require mem[_9079] <= test266151307()
                                            require _9079 + mem[_9079] + 31 < _9079 + return_data.size
                                            _9367 = mem[_9079 + mem[_9079]]
                                            if mem[_9079 + mem[_9079]] > test266151307():
                                                revert with 0, 65
                                            if _9079 + ceil32(return_data.size) + ceil32(32 * mem[_9079 + mem[_9079]]) + 1 > test266151307() or ceil32(32 * mem[_9079 + mem[_9079]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _9079 + ceil32(return_data.size) + ceil32(32 * mem[_9079 + mem[_9079]]) + 1
                                            mem[_9079 + ceil32(return_data.size)] = _9367
                                            require return_data.size >= _9223 + (32 * _9367) + 32
                                            mem[_9079 + ceil32(return_data.size) + 32 len 32 * _9367] = mem[_9079 + _9223 + 32 len 32 * _9367]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                            if 1 >= _9367:
                                                revert with 0, 50
                                            if mem[_9079 + ceil32(return_data.size) + 64] > -1:
                                                revert with 0, 17
                                            require ext_code.size(brushAddress)
                                            call brushAddress.0x42966c68 with:
                                                 gas gas_remaining wei
                                                args mem[_9079 + ceil32(return_data.size) + 64]
                                        else:
                                            if ext_call.return_data[0] > !_6374:
                                                revert with 0, 17
                                            mem[_6378 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_6378 + 100] = ext_call.return_data[0] + _6374
                                            mem[_6378 + 132] = 0
                                            mem[_6378 + 164] = 160
                                            mem[_6378 + 260] = mem[_6378]
                                            idx = 0
                                            s = _6378 + 292
                                            t = _6378 + 32
                                            while idx < mem[_6378]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_6378 + 196] = this.address
                                            mem[_6378 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _6378 + (32 * mem[_6378]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9080 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _9224 = mem[_9080]
                                            require mem[_9080] <= test266151307()
                                            require _9080 + mem[_9080] + 31 < _9080 + return_data.size
                                            _9368 = mem[_9080 + mem[_9080]]
                                            if mem[_9080 + mem[_9080]] > test266151307():
                                                revert with 0, 65
                                            if _9080 + ceil32(return_data.size) + ceil32(32 * mem[_9080 + mem[_9080]]) + 1 > test266151307() or ceil32(32 * mem[_9080 + mem[_9080]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _9080 + ceil32(return_data.size) + ceil32(32 * mem[_9080 + mem[_9080]]) + 1
                                            mem[_9080 + ceil32(return_data.size)] = _9368
                                            require return_data.size >= _9224 + (32 * _9368) + 32
                                            mem[_9080 + ceil32(return_data.size) + 32 len 32 * _9368] = mem[_9080 + _9224 + 32 len 32 * _9368]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                            if 1 >= _9368:
                                                revert with 0, 50
                                            if mem[_9080 + ceil32(return_data.size) + 64] > -1:
                                                revert with 0, 17
                                            require ext_code.size(brushAddress)
                                            call brushAddress.0x42966c68 with:
                                                 gas gas_remaining wei
                                                args mem[_9080 + ceil32(return_data.size) + 64]
                    else:
                        if brushAddress == address(ext_call.return_data[0]):
                            if brushAddress != address(ext_call.return_data[0]):
                                if wftmAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_6374:
                                        revert with 0, 17
                                    mem[_6378 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_6378 + 100] = ext_call.return_data[32] + _6374
                                    mem[_6378 + 132] = 0
                                    mem[_6378 + 164] = 160
                                    mem[_6378 + 260] = mem[_6378]
                                    idx = 0
                                    s = _6378 + 292
                                    t = _6378 + 32
                                    while idx < mem[_6378]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_6378 + 196] = this.address
                                    mem[_6378 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _6378 + (32 * mem[_6378]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9081 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _9225 = mem[_9081]
                                    require mem[_9081] <= test266151307()
                                    require _9081 + mem[_9081] + 31 < _9081 + return_data.size
                                    _9369 = mem[_9081 + mem[_9081]]
                                    if mem[_9081 + mem[_9081]] > test266151307():
                                        revert with 0, 65
                                    if _9081 + ceil32(return_data.size) + ceil32(32 * mem[_9081 + mem[_9081]]) + 1 > test266151307() or ceil32(32 * mem[_9081 + mem[_9081]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _9081 + ceil32(return_data.size) + ceil32(32 * mem[_9081 + mem[_9081]]) + 1
                                    mem[_9081 + ceil32(return_data.size)] = _9369
                                    require return_data.size >= _9225 + (32 * _9369) + 32
                                    mem[_9081 + ceil32(return_data.size) + 32 len 32 * _9369] = mem[_9081 + _9225 + 32 len 32 * _9369]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                    if 1 >= _9369:
                                        revert with 0, 50
                                    if mem[_9081 + ceil32(return_data.size) + 64] > -1:
                                        revert with 0, 17
                                    require ext_code.size(brushAddress)
                                    call brushAddress.0x42966c68 with:
                                         gas gas_remaining wei
                                        args mem[_9081 + ceil32(return_data.size) + 64]
                                else:
                                    if ext_call.return_data[0] > !_6374:
                                        revert with 0, 17
                                    mem[_6378 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_6378 + 100] = ext_call.return_data[0] + _6374
                                    mem[_6378 + 132] = 0
                                    mem[_6378 + 164] = 160
                                    mem[_6378 + 260] = mem[_6378]
                                    idx = 0
                                    s = _6378 + 292
                                    t = _6378 + 32
                                    while idx < mem[_6378]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_6378 + 196] = this.address
                                    mem[_6378 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _6378 + (32 * mem[_6378]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9082 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _9226 = mem[_9082]
                                    require mem[_9082] <= test266151307()
                                    require _9082 + mem[_9082] + 31 < _9082 + return_data.size
                                    _9370 = mem[_9082 + mem[_9082]]
                                    if mem[_9082 + mem[_9082]] > test266151307():
                                        revert with 0, 65
                                    if _9082 + ceil32(return_data.size) + ceil32(32 * mem[_9082 + mem[_9082]]) + 1 > test266151307() or ceil32(32 * mem[_9082 + mem[_9082]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _9082 + ceil32(return_data.size) + ceil32(32 * mem[_9082 + mem[_9082]]) + 1
                                    mem[_9082 + ceil32(return_data.size)] = _9370
                                    require return_data.size >= _9226 + (32 * _9370) + 32
                                    mem[_9082 + ceil32(return_data.size) + 32 len 32 * _9370] = mem[_9082 + _9226 + 32 len 32 * _9370]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                    if 1 >= _9370:
                                        revert with 0, 50
                                    if mem[_9082 + ceil32(return_data.size) + 64] > -1:
                                        revert with 0, 17
                                    require ext_code.size(brushAddress)
                                    call brushAddress.0x42966c68 with:
                                         gas gas_remaining wei
                                        args mem[_9082 + ceil32(return_data.size) + 64]
                            else:
                                if brushAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_6374:
                                        revert with 0, 17
                                    mem[_6378 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_6378 + 100] = ext_call.return_data[32] + _6374
                                    mem[_6378 + 132] = 0
                                    mem[_6378 + 164] = 160
                                    mem[_6378 + 260] = mem[_6378]
                                    idx = 0
                                    s = _6378 + 292
                                    t = _6378 + 32
                                    while idx < mem[_6378]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_6378 + 196] = this.address
                                    mem[_6378 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _6378 + (32 * mem[_6378]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9083 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _9227 = mem[_9083]
                                    require mem[_9083] <= test266151307()
                                    require _9083 + mem[_9083] + 31 < _9083 + return_data.size
                                    _9371 = mem[_9083 + mem[_9083]]
                                    if mem[_9083 + mem[_9083]] > test266151307():
                                        revert with 0, 65
                                    if _9083 + ceil32(return_data.size) + ceil32(32 * mem[_9083 + mem[_9083]]) + 1 > test266151307() or ceil32(32 * mem[_9083 + mem[_9083]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _9083 + ceil32(return_data.size) + ceil32(32 * mem[_9083 + mem[_9083]]) + 1
                                    mem[_9083 + ceil32(return_data.size)] = _9371
                                    require return_data.size >= _9227 + (32 * _9371) + 32
                                    mem[_9083 + ceil32(return_data.size) + 32 len 32 * _9371] = mem[_9083 + _9227 + 32 len 32 * _9371]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                    if 1 >= _9371:
                                        revert with 0, 50
                                    if mem[_9083 + ceil32(return_data.size) + 64] > -1:
                                        revert with 0, 17
                                    require ext_code.size(brushAddress)
                                    call brushAddress.0x42966c68 with:
                                         gas gas_remaining wei
                                        args mem[_9083 + ceil32(return_data.size) + 64]
                                else:
                                    if brushAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[0] > !_6374:
                                            revert with 0, 17
                                        mem[_6378 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_6378 + 100] = ext_call.return_data[0] + _6374
                                        mem[_6378 + 132] = 0
                                        mem[_6378 + 164] = 160
                                        mem[_6378 + 260] = mem[_6378]
                                        idx = 0
                                        s = _6378 + 292
                                        t = _6378 + 32
                                        while idx < mem[_6378]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_6378 + 196] = this.address
                                        mem[_6378 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _6378 + (32 * mem[_6378]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9084 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _9228 = mem[_9084]
                                        require mem[_9084] <= test266151307()
                                        require _9084 + mem[_9084] + 31 < _9084 + return_data.size
                                        _9372 = mem[_9084 + mem[_9084]]
                                        if mem[_9084 + mem[_9084]] > test266151307():
                                            revert with 0, 65
                                        if _9084 + ceil32(return_data.size) + ceil32(32 * mem[_9084 + mem[_9084]]) + 1 > test266151307() or ceil32(32 * mem[_9084 + mem[_9084]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _9084 + ceil32(return_data.size) + ceil32(32 * mem[_9084 + mem[_9084]]) + 1
                                        mem[_9084 + ceil32(return_data.size)] = _9372
                                        require return_data.size >= _9228 + (32 * _9372) + 32
                                        mem[_9084 + ceil32(return_data.size) + 32 len 32 * _9372] = mem[_9084 + _9228 + 32 len 32 * _9372]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                        if 1 >= _9372:
                                            revert with 0, 50
                                        if mem[_9084 + ceil32(return_data.size) + 64] > -1:
                                            revert with 0, 17
                                        require ext_code.size(brushAddress)
                                        call brushAddress.0x42966c68 with:
                                             gas gas_remaining wei
                                            args mem[_9084 + ceil32(return_data.size) + 64]
                                    else:
                                        if wftmAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_6374:
                                                revert with 0, 17
                                            mem[_6378 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_6378 + 100] = ext_call.return_data[32] + _6374
                                            mem[_6378 + 132] = 0
                                            mem[_6378 + 164] = 160
                                            mem[_6378 + 260] = mem[_6378]
                                            idx = 0
                                            s = _6378 + 292
                                            t = _6378 + 32
                                            while idx < mem[_6378]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_6378 + 196] = this.address
                                            mem[_6378 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _6378 + (32 * mem[_6378]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9085 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _9229 = mem[_9085]
                                            require mem[_9085] <= test266151307()
                                            require _9085 + mem[_9085] + 31 < _9085 + return_data.size
                                            _9373 = mem[_9085 + mem[_9085]]
                                            if mem[_9085 + mem[_9085]] > test266151307():
                                                revert with 0, 65
                                            if _9085 + ceil32(return_data.size) + ceil32(32 * mem[_9085 + mem[_9085]]) + 1 > test266151307() or ceil32(32 * mem[_9085 + mem[_9085]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _9085 + ceil32(return_data.size) + ceil32(32 * mem[_9085 + mem[_9085]]) + 1
                                            mem[_9085 + ceil32(return_data.size)] = _9373
                                            require return_data.size >= _9229 + (32 * _9373) + 32
                                            mem[_9085 + ceil32(return_data.size) + 32 len 32 * _9373] = mem[_9085 + _9229 + 32 len 32 * _9373]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                            if 1 >= _9373:
                                                revert with 0, 50
                                            if mem[_9085 + ceil32(return_data.size) + 64] > -1:
                                                revert with 0, 17
                                            require ext_code.size(brushAddress)
                                            call brushAddress.0x42966c68 with:
                                                 gas gas_remaining wei
                                                args mem[_9085 + ceil32(return_data.size) + 64]
                                        else:
                                            if ext_call.return_data[0] > !_6374:
                                                revert with 0, 17
                                            mem[_6378 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_6378 + 100] = ext_call.return_data[0] + _6374
                                            mem[_6378 + 132] = 0
                                            mem[_6378 + 164] = 160
                                            mem[_6378 + 260] = mem[_6378]
                                            idx = 0
                                            s = _6378 + 292
                                            t = _6378 + 32
                                            while idx < mem[_6378]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_6378 + 196] = this.address
                                            mem[_6378 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _6378 + (32 * mem[_6378]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9086 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _9230 = mem[_9086]
                                            require mem[_9086] <= test266151307()
                                            require _9086 + mem[_9086] + 31 < _9086 + return_data.size
                                            _9374 = mem[_9086 + mem[_9086]]
                                            if mem[_9086 + mem[_9086]] > test266151307():
                                                revert with 0, 65
                                            if _9086 + ceil32(return_data.size) + ceil32(32 * mem[_9086 + mem[_9086]]) + 1 > test266151307() or ceil32(32 * mem[_9086 + mem[_9086]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _9086 + ceil32(return_data.size) + ceil32(32 * mem[_9086 + mem[_9086]]) + 1
                                            mem[_9086 + ceil32(return_data.size)] = _9374
                                            require return_data.size >= _9230 + (32 * _9374) + 32
                                            mem[_9086 + ceil32(return_data.size) + 32 len 32 * _9374] = mem[_9086 + _9230 + 32 len 32 * _9374]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                            if 1 >= _9374:
                                                revert with 0, 50
                                            if mem[_9086 + ceil32(return_data.size) + 64] > -1:
                                                revert with 0, 17
                                            require ext_code.size(brushAddress)
                                            call brushAddress.0x42966c68 with:
                                                 gas gas_remaining wei
                                                args mem[_9086 + ceil32(return_data.size) + 64]
                        else:
                            if brushAddress == address(ext_call.return_data[0]):
                                if brushAddress != address(ext_call.return_data[0]):
                                    if wftmAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[32] > !_6374:
                                            revert with 0, 17
                                        mem[_6378 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_6378 + 100] = ext_call.return_data[32] + _6374
                                        mem[_6378 + 132] = 0
                                        mem[_6378 + 164] = 160
                                        mem[_6378 + 260] = mem[_6378]
                                        idx = 0
                                        s = _6378 + 292
                                        t = _6378 + 32
                                        while idx < mem[_6378]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_6378 + 196] = this.address
                                        mem[_6378 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _6378 + (32 * mem[_6378]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9087 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _9231 = mem[_9087]
                                        require mem[_9087] <= test266151307()
                                        require _9087 + mem[_9087] + 31 < _9087 + return_data.size
                                        _9375 = mem[_9087 + mem[_9087]]
                                        if mem[_9087 + mem[_9087]] > test266151307():
                                            revert with 0, 65
                                        if _9087 + ceil32(return_data.size) + ceil32(32 * mem[_9087 + mem[_9087]]) + 1 > test266151307() or ceil32(32 * mem[_9087 + mem[_9087]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _9087 + ceil32(return_data.size) + ceil32(32 * mem[_9087 + mem[_9087]]) + 1
                                        mem[_9087 + ceil32(return_data.size)] = _9375
                                        require return_data.size >= _9231 + (32 * _9375) + 32
                                        mem[_9087 + ceil32(return_data.size) + 32 len 32 * _9375] = mem[_9087 + _9231 + 32 len 32 * _9375]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                        if 1 >= _9375:
                                            revert with 0, 50
                                        if mem[_9087 + ceil32(return_data.size) + 64] > -1:
                                            revert with 0, 17
                                        require ext_code.size(brushAddress)
                                        call brushAddress.0x42966c68 with:
                                             gas gas_remaining wei
                                            args mem[_9087 + ceil32(return_data.size) + 64]
                                    else:
                                        if ext_call.return_data[0] > !_6374:
                                            revert with 0, 17
                                        mem[_6378 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_6378 + 100] = ext_call.return_data[0] + _6374
                                        mem[_6378 + 132] = 0
                                        mem[_6378 + 164] = 160
                                        mem[_6378 + 260] = mem[_6378]
                                        idx = 0
                                        s = _6378 + 292
                                        t = _6378 + 32
                                        while idx < mem[_6378]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_6378 + 196] = this.address
                                        mem[_6378 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _6378 + (32 * mem[_6378]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9088 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _9232 = mem[_9088]
                                        require mem[_9088] <= test266151307()
                                        require _9088 + mem[_9088] + 31 < _9088 + return_data.size
                                        _9376 = mem[_9088 + mem[_9088]]
                                        if mem[_9088 + mem[_9088]] > test266151307():
                                            revert with 0, 65
                                        if _9088 + ceil32(return_data.size) + ceil32(32 * mem[_9088 + mem[_9088]]) + 1 > test266151307() or ceil32(32 * mem[_9088 + mem[_9088]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _9088 + ceil32(return_data.size) + ceil32(32 * mem[_9088 + mem[_9088]]) + 1
                                        mem[_9088 + ceil32(return_data.size)] = _9376
                                        require return_data.size >= _9232 + (32 * _9376) + 32
                                        mem[_9088 + ceil32(return_data.size) + 32 len 32 * _9376] = mem[_9088 + _9232 + 32 len 32 * _9376]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                        if 1 >= _9376:
                                            revert with 0, 50
                                        if mem[_9088 + ceil32(return_data.size) + 64] > -1:
                                            revert with 0, 17
                                        require ext_code.size(brushAddress)
                                        call brushAddress.0x42966c68 with:
                                             gas gas_remaining wei
                                            args mem[_9088 + ceil32(return_data.size) + 64]
                                else:
                                    if brushAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[32] > !_6374:
                                            revert with 0, 17
                                        mem[_6378 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_6378 + 100] = ext_call.return_data[32] + _6374
                                        mem[_6378 + 132] = 0
                                        mem[_6378 + 164] = 160
                                        mem[_6378 + 260] = mem[_6378]
                                        idx = 0
                                        s = _6378 + 292
                                        t = _6378 + 32
                                        while idx < mem[_6378]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_6378 + 196] = this.address
                                        mem[_6378 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _6378 + (32 * mem[_6378]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9089 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _9233 = mem[_9089]
                                        require mem[_9089] <= test266151307()
                                        require _9089 + mem[_9089] + 31 < _9089 + return_data.size
                                        _9377 = mem[_9089 + mem[_9089]]
                                        if mem[_9089 + mem[_9089]] > test266151307():
                                            revert with 0, 65
                                        if _9089 + ceil32(return_data.size) + ceil32(32 * mem[_9089 + mem[_9089]]) + 1 > test266151307() or ceil32(32 * mem[_9089 + mem[_9089]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _9089 + ceil32(return_data.size) + ceil32(32 * mem[_9089 + mem[_9089]]) + 1
                                        mem[_9089 + ceil32(return_data.size)] = _9377
                                        require return_data.size >= _9233 + (32 * _9377) + 32
                                        mem[_9089 + ceil32(return_data.size) + 32 len 32 * _9377] = mem[_9089 + _9233 + 32 len 32 * _9377]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                        if 1 >= _9377:
                                            revert with 0, 50
                                        if mem[_9089 + ceil32(return_data.size) + 64] > -1:
                                            revert with 0, 17
                                        require ext_code.size(brushAddress)
                                        call brushAddress.0x42966c68 with:
                                             gas gas_remaining wei
                                            args mem[_9089 + ceil32(return_data.size) + 64]
                                    else:
                                        if brushAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[0] > !_6374:
                                                revert with 0, 17
                                            mem[_6378 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_6378 + 100] = ext_call.return_data[0] + _6374
                                            mem[_6378 + 132] = 0
                                            mem[_6378 + 164] = 160
                                            mem[_6378 + 260] = mem[_6378]
                                            idx = 0
                                            s = _6378 + 292
                                            t = _6378 + 32
                                            while idx < mem[_6378]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_6378 + 196] = this.address
                                            mem[_6378 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _6378 + (32 * mem[_6378]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9090 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _9234 = mem[_9090]
                                            require mem[_9090] <= test266151307()
                                            require _9090 + mem[_9090] + 31 < _9090 + return_data.size
                                            _9378 = mem[_9090 + mem[_9090]]
                                            if mem[_9090 + mem[_9090]] > test266151307():
                                                revert with 0, 65
                                            if _9090 + ceil32(return_data.size) + ceil32(32 * mem[_9090 + mem[_9090]]) + 1 > test266151307() or ceil32(32 * mem[_9090 + mem[_9090]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _9090 + ceil32(return_data.size) + ceil32(32 * mem[_9090 + mem[_9090]]) + 1
                                            mem[_9090 + ceil32(return_data.size)] = _9378
                                            require return_data.size >= _9234 + (32 * _9378) + 32
                                            mem[_9090 + ceil32(return_data.size) + 32 len 32 * _9378] = mem[_9090 + _9234 + 32 len 32 * _9378]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                            if 1 >= _9378:
                                                revert with 0, 50
                                            if mem[_9090 + ceil32(return_data.size) + 64] > -1:
                                                revert with 0, 17
                                            require ext_code.size(brushAddress)
                                            call brushAddress.0x42966c68 with:
                                                 gas gas_remaining wei
                                                args mem[_9090 + ceil32(return_data.size) + 64]
                                        else:
                                            if wftmAddress == address(ext_call.return_data[0]):
                                                if ext_call.return_data[32] > !_6374:
                                                    revert with 0, 17
                                                mem[_6378 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[_6378 + 100] = ext_call.return_data[32] + _6374
                                                mem[_6378 + 132] = 0
                                                mem[_6378 + 164] = 160
                                                mem[_6378 + 260] = mem[_6378]
                                                idx = 0
                                                s = _6378 + 292
                                                t = _6378 + 32
                                                while idx < mem[_6378]:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[_6378 + 196] = this.address
                                                mem[_6378 + 228] = block.timestamp + 10000
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len _6378 + (32 * mem[_6378]) + -mem[64] + 288]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _9091 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _9235 = mem[_9091]
                                                require mem[_9091] <= test266151307()
                                                require _9091 + mem[_9091] + 31 < _9091 + return_data.size
                                                _9379 = mem[_9091 + mem[_9091]]
                                                if mem[_9091 + mem[_9091]] > test266151307():
                                                    revert with 0, 65
                                                if _9091 + ceil32(return_data.size) + ceil32(32 * mem[_9091 + mem[_9091]]) + 1 > test266151307() or ceil32(32 * mem[_9091 + mem[_9091]]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[64] = _9091 + ceil32(return_data.size) + ceil32(32 * mem[_9091 + mem[_9091]]) + 1
                                                mem[_9091 + ceil32(return_data.size)] = _9379
                                                require return_data.size >= _9235 + (32 * _9379) + 32
                                                mem[_9091 + ceil32(return_data.size) + 32 len 32 * _9379] = mem[_9091 + _9235 + 32 len 32 * _9379]
                                                if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                    revert with 0, 17
                                                maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                                if 1 >= _9379:
                                                    revert with 0, 50
                                                if mem[_9091 + ceil32(return_data.size) + 64] > -1:
                                                    revert with 0, 17
                                                require ext_code.size(brushAddress)
                                                call brushAddress.0x42966c68 with:
                                                     gas gas_remaining wei
                                                    args mem[_9091 + ceil32(return_data.size) + 64]
                                            else:
                                                if ext_call.return_data[0] > !_6374:
                                                    revert with 0, 17
                                                mem[_6378 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[_6378 + 100] = ext_call.return_data[0] + _6374
                                                mem[_6378 + 132] = 0
                                                mem[_6378 + 164] = 160
                                                mem[_6378 + 260] = mem[_6378]
                                                idx = 0
                                                s = _6378 + 292
                                                t = _6378 + 32
                                                while idx < mem[_6378]:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[_6378 + 196] = this.address
                                                mem[_6378 + 228] = block.timestamp + 10000
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len _6378 + (32 * mem[_6378]) + -mem[64] + 288]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _9092 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _9236 = mem[_9092]
                                                require mem[_9092] <= test266151307()
                                                require _9092 + mem[_9092] + 31 < _9092 + return_data.size
                                                _9380 = mem[_9092 + mem[_9092]]
                                                if mem[_9092 + mem[_9092]] > test266151307():
                                                    revert with 0, 65
                                                if _9092 + ceil32(return_data.size) + ceil32(32 * mem[_9092 + mem[_9092]]) + 1 > test266151307() or ceil32(32 * mem[_9092 + mem[_9092]]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[64] = _9092 + ceil32(return_data.size) + ceil32(32 * mem[_9092 + mem[_9092]]) + 1
                                                mem[_9092 + ceil32(return_data.size)] = _9380
                                                require return_data.size >= _9236 + (32 * _9380) + 32
                                                mem[_9092 + ceil32(return_data.size) + 32 len 32 * _9380] = mem[_9092 + _9236 + 32 len 32 * _9380]
                                                if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                    revert with 0, 17
                                                maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                                if 1 >= _9380:
                                                    revert with 0, 50
                                                if mem[_9092 + ceil32(return_data.size) + 64] > -1:
                                                    revert with 0, 17
                                                require ext_code.size(brushAddress)
                                                call brushAddress.0x42966c68 with:
                                                     gas gas_remaining wei
                                                    args mem[_9092 + ceil32(return_data.size) + 64]
                            else:
                                if wftmAddress == address(ext_call.return_data[0]):
                                    if brushAddress != address(ext_call.return_data[0]):
                                        if wftmAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_6374:
                                                revert with 0, 17
                                            mem[_6378 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_6378 + 100] = ext_call.return_data[32] + _6374
                                            mem[_6378 + 132] = 0
                                            mem[_6378 + 164] = 160
                                            mem[_6378 + 260] = mem[_6378]
                                            idx = 0
                                            s = _6378 + 292
                                            t = _6378 + 32
                                            while idx < mem[_6378]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_6378 + 196] = this.address
                                            mem[_6378 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _6378 + (32 * mem[_6378]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9093 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _9237 = mem[_9093]
                                            require mem[_9093] <= test266151307()
                                            require _9093 + mem[_9093] + 31 < _9093 + return_data.size
                                            _9381 = mem[_9093 + mem[_9093]]
                                            if mem[_9093 + mem[_9093]] > test266151307():
                                                revert with 0, 65
                                            if _9093 + ceil32(return_data.size) + ceil32(32 * mem[_9093 + mem[_9093]]) + 1 > test266151307() or ceil32(32 * mem[_9093 + mem[_9093]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _9093 + ceil32(return_data.size) + ceil32(32 * mem[_9093 + mem[_9093]]) + 1
                                            mem[_9093 + ceil32(return_data.size)] = _9381
                                            require return_data.size >= _9237 + (32 * _9381) + 32
                                            mem[_9093 + ceil32(return_data.size) + 32 len 32 * _9381] = mem[_9093 + _9237 + 32 len 32 * _9381]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                            if 1 >= _9381:
                                                revert with 0, 50
                                            if mem[_9093 + ceil32(return_data.size) + 64] > -1:
                                                revert with 0, 17
                                            require ext_code.size(brushAddress)
                                            call brushAddress.0x42966c68 with:
                                                 gas gas_remaining wei
                                                args mem[_9093 + ceil32(return_data.size) + 64]
                                        else:
                                            if ext_call.return_data[0] > !_6374:
                                                revert with 0, 17
                                            mem[_6378 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_6378 + 100] = ext_call.return_data[0] + _6374
                                            mem[_6378 + 132] = 0
                                            mem[_6378 + 164] = 160
                                            mem[_6378 + 260] = mem[_6378]
                                            idx = 0
                                            s = _6378 + 292
                                            t = _6378 + 32
                                            while idx < mem[_6378]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_6378 + 196] = this.address
                                            mem[_6378 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _6378 + (32 * mem[_6378]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9094 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _9238 = mem[_9094]
                                            require mem[_9094] <= test266151307()
                                            require _9094 + mem[_9094] + 31 < _9094 + return_data.size
                                            _9382 = mem[_9094 + mem[_9094]]
                                            if mem[_9094 + mem[_9094]] > test266151307():
                                                revert with 0, 65
                                            if _9094 + ceil32(return_data.size) + ceil32(32 * mem[_9094 + mem[_9094]]) + 1 > test266151307() or ceil32(32 * mem[_9094 + mem[_9094]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _9094 + ceil32(return_data.size) + ceil32(32 * mem[_9094 + mem[_9094]]) + 1
                                            mem[_9094 + ceil32(return_data.size)] = _9382
                                            require return_data.size >= _9238 + (32 * _9382) + 32
                                            mem[_9094 + ceil32(return_data.size) + 32 len 32 * _9382] = mem[_9094 + _9238 + 32 len 32 * _9382]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                            if 1 >= _9382:
                                                revert with 0, 50
                                            if mem[_9094 + ceil32(return_data.size) + 64] > -1:
                                                revert with 0, 17
                                            require ext_code.size(brushAddress)
                                            call brushAddress.0x42966c68 with:
                                                 gas gas_remaining wei
                                                args mem[_9094 + ceil32(return_data.size) + 64]
                                    else:
                                        if brushAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_6374:
                                                revert with 0, 17
                                            mem[_6378 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_6378 + 100] = ext_call.return_data[32] + _6374
                                            mem[_6378 + 132] = 0
                                            mem[_6378 + 164] = 160
                                            mem[_6378 + 260] = mem[_6378]
                                            idx = 0
                                            s = _6378 + 292
                                            t = _6378 + 32
                                            while idx < mem[_6378]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_6378 + 196] = this.address
                                            mem[_6378 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _6378 + (32 * mem[_6378]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9095 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _9239 = mem[_9095]
                                            require mem[_9095] <= test266151307()
                                            require _9095 + mem[_9095] + 31 < _9095 + return_data.size
                                            _9383 = mem[_9095 + mem[_9095]]
                                            if mem[_9095 + mem[_9095]] > test266151307():
                                                revert with 0, 65
                                            if _9095 + ceil32(return_data.size) + ceil32(32 * mem[_9095 + mem[_9095]]) + 1 > test266151307() or ceil32(32 * mem[_9095 + mem[_9095]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _9095 + ceil32(return_data.size) + ceil32(32 * mem[_9095 + mem[_9095]]) + 1
                                            mem[_9095 + ceil32(return_data.size)] = _9383
                                            require return_data.size >= _9239 + (32 * _9383) + 32
                                            mem[_9095 + ceil32(return_data.size) + 32 len 32 * _9383] = mem[_9095 + _9239 + 32 len 32 * _9383]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                            if 1 >= _9383:
                                                revert with 0, 50
                                            if mem[_9095 + ceil32(return_data.size) + 64] > -1:
                                                revert with 0, 17
                                            require ext_code.size(brushAddress)
                                            call brushAddress.0x42966c68 with:
                                                 gas gas_remaining wei
                                                args mem[_9095 + ceil32(return_data.size) + 64]
                                        else:
                                            if brushAddress == address(ext_call.return_data[0]):
                                                if ext_call.return_data[0] > !_6374:
                                                    revert with 0, 17
                                                mem[_6378 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[_6378 + 100] = ext_call.return_data[0] + _6374
                                                mem[_6378 + 132] = 0
                                                mem[_6378 + 164] = 160
                                                mem[_6378 + 260] = mem[_6378]
                                                idx = 0
                                                s = _6378 + 292
                                                t = _6378 + 32
                                                while idx < mem[_6378]:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[_6378 + 196] = this.address
                                                mem[_6378 + 228] = block.timestamp + 10000
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len _6378 + (32 * mem[_6378]) + -mem[64] + 288]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _9096 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _9240 = mem[_9096]
                                                require mem[_9096] <= test266151307()
                                                require _9096 + mem[_9096] + 31 < _9096 + return_data.size
                                                _9384 = mem[_9096 + mem[_9096]]
                                                if mem[_9096 + mem[_9096]] > test266151307():
                                                    revert with 0, 65
                                                if _9096 + ceil32(return_data.size) + ceil32(32 * mem[_9096 + mem[_9096]]) + 1 > test266151307() or ceil32(32 * mem[_9096 + mem[_9096]]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[64] = _9096 + ceil32(return_data.size) + ceil32(32 * mem[_9096 + mem[_9096]]) + 1
                                                mem[_9096 + ceil32(return_data.size)] = _9384
                                                require return_data.size >= _9240 + (32 * _9384) + 32
                                                mem[_9096 + ceil32(return_data.size) + 32 len 32 * _9384] = mem[_9096 + _9240 + 32 len 32 * _9384]
                                                if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                    revert with 0, 17
                                                maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                                if 1 >= _9384:
                                                    revert with 0, 50
                                                if mem[_9096 + ceil32(return_data.size) + 64] > -1:
                                                    revert with 0, 17
                                                require ext_code.size(brushAddress)
                                                call brushAddress.0x42966c68 with:
                                                     gas gas_remaining wei
                                                    args mem[_9096 + ceil32(return_data.size) + 64]
                                            else:
                                                if wftmAddress == address(ext_call.return_data[0]):
                                                    if ext_call.return_data[32] > !_6374:
                                                        revert with 0, 17
                                                    mem[_6378 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[_6378 + 100] = ext_call.return_data[32] + _6374
                                                    mem[_6378 + 132] = 0
                                                    mem[_6378 + 164] = 160
                                                    mem[_6378 + 260] = mem[_6378]
                                                    idx = 0
                                                    s = _6378 + 292
                                                    t = _6378 + 32
                                                    while idx < mem[_6378]:
                                                        mem[s] = mem[t + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[_6378 + 196] = this.address
                                                    mem[_6378 + 228] = block.timestamp + 10000
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len _6378 + (32 * mem[_6378]) + -mem[64] + 288]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _9097 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _9241 = mem[_9097]
                                                    require mem[_9097] <= test266151307()
                                                    require _9097 + mem[_9097] + 31 < _9097 + return_data.size
                                                    _9385 = mem[_9097 + mem[_9097]]
                                                    if mem[_9097 + mem[_9097]] > test266151307():
                                                        revert with 0, 65
                                                    if _9097 + ceil32(return_data.size) + ceil32(32 * mem[_9097 + mem[_9097]]) + 1 > test266151307() or ceil32(32 * mem[_9097 + mem[_9097]]) + 1 < 0:
                                                        revert with 0, 65
                                                    mem[64] = _9097 + ceil32(return_data.size) + ceil32(32 * mem[_9097 + mem[_9097]]) + 1
                                                    mem[_9097 + ceil32(return_data.size)] = _9385
                                                    require return_data.size >= _9241 + (32 * _9385) + 32
                                                    mem[_9097 + ceil32(return_data.size) + 32 len 32 * _9385] = mem[_9097 + _9241 + 32 len 32 * _9385]
                                                    if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                        revert with 0, 17
                                                    maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                                    if 1 >= _9385:
                                                        revert with 0, 50
                                                    if mem[_9097 + ceil32(return_data.size) + 64] > -1:
                                                        revert with 0, 17
                                                    require ext_code.size(brushAddress)
                                                    call brushAddress.0x42966c68 with:
                                                         gas gas_remaining wei
                                                        args mem[_9097 + ceil32(return_data.size) + 64]
                                                else:
                                                    if ext_call.return_data[0] > !_6374:
                                                        revert with 0, 17
                                                    mem[_6378 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[_6378 + 100] = ext_call.return_data[0] + _6374
                                                    mem[_6378 + 132] = 0
                                                    mem[_6378 + 164] = 160
                                                    mem[_6378 + 260] = mem[_6378]
                                                    idx = 0
                                                    s = _6378 + 292
                                                    t = _6378 + 32
                                                    while idx < mem[_6378]:
                                                        mem[s] = mem[t + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[_6378 + 196] = this.address
                                                    mem[_6378 + 228] = block.timestamp + 10000
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len _6378 + (32 * mem[_6378]) + -mem[64] + 288]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _9098 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _9242 = mem[_9098]
                                                    require mem[_9098] <= test266151307()
                                                    require _9098 + mem[_9098] + 31 < _9098 + return_data.size
                                                    _9386 = mem[_9098 + mem[_9098]]
                                                    if mem[_9098 + mem[_9098]] > test266151307():
                                                        revert with 0, 65
                                                    if _9098 + ceil32(return_data.size) + ceil32(32 * mem[_9098 + mem[_9098]]) + 1 > test266151307() or ceil32(32 * mem[_9098 + mem[_9098]]) + 1 < 0:
                                                        revert with 0, 65
                                                    mem[64] = _9098 + ceil32(return_data.size) + ceil32(32 * mem[_9098 + mem[_9098]]) + 1
                                                    mem[_9098 + ceil32(return_data.size)] = _9386
                                                    require return_data.size >= _9242 + (32 * _9386) + 32
                                                    mem[_9098 + ceil32(return_data.size) + 32 len 32 * _9386] = mem[_9098 + _9242 + 32 len 32 * _9386]
                                                    if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                        revert with 0, 17
                                                    maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                                    if 1 >= _9386:
                                                        revert with 0, 50
                                                    if mem[_9098 + ceil32(return_data.size) + 64] > -1:
                                                        revert with 0, 17
                                                    require ext_code.size(brushAddress)
                                                    call brushAddress.0x42966c68 with:
                                                         gas gas_remaining wei
                                                        args mem[_9098 + ceil32(return_data.size) + 64]
                                else:
                                    if brushAddress != address(ext_call.return_data[0]):
                                        if wftmAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_6374:
                                                revert with 0, 17
                                            mem[_6378 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_6378 + 100] = ext_call.return_data[32] + _6374
                                            mem[_6378 + 132] = 0
                                            mem[_6378 + 164] = 160
                                            mem[_6378 + 260] = mem[_6378]
                                            idx = 0
                                            s = _6378 + 292
                                            t = _6378 + 32
                                            while idx < mem[_6378]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_6378 + 196] = this.address
                                            mem[_6378 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _6378 + (32 * mem[_6378]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9099 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _9243 = mem[_9099]
                                            require mem[_9099] <= test266151307()
                                            require _9099 + mem[_9099] + 31 < _9099 + return_data.size
                                            _9387 = mem[_9099 + mem[_9099]]
                                            if mem[_9099 + mem[_9099]] > test266151307():
                                                revert with 0, 65
                                            if _9099 + ceil32(return_data.size) + ceil32(32 * mem[_9099 + mem[_9099]]) + 1 > test266151307() or ceil32(32 * mem[_9099 + mem[_9099]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _9099 + ceil32(return_data.size) + ceil32(32 * mem[_9099 + mem[_9099]]) + 1
                                            mem[_9099 + ceil32(return_data.size)] = _9387
                                            require return_data.size >= _9243 + (32 * _9387) + 32
                                            mem[_9099 + ceil32(return_data.size) + 32 len 32 * _9387] = mem[_9099 + _9243 + 32 len 32 * _9387]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                            if 1 >= _9387:
                                                revert with 0, 50
                                            if mem[_9099 + ceil32(return_data.size) + 64] > -1:
                                                revert with 0, 17
                                            require ext_code.size(brushAddress)
                                            call brushAddress.0x42966c68 with:
                                                 gas gas_remaining wei
                                                args mem[_9099 + ceil32(return_data.size) + 64]
                                        else:
                                            if ext_call.return_data[0] > !_6374:
                                                revert with 0, 17
                                            mem[_6378 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_6378 + 100] = ext_call.return_data[0] + _6374
                                            mem[_6378 + 132] = 0
                                            mem[_6378 + 164] = 160
                                            mem[_6378 + 260] = mem[_6378]
                                            idx = 0
                                            s = _6378 + 292
                                            t = _6378 + 32
                                            while idx < mem[_6378]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_6378 + 196] = this.address
                                            mem[_6378 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _6378 + (32 * mem[_6378]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9100 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _9244 = mem[_9100]
                                            require mem[_9100] <= test266151307()
                                            require _9100 + mem[_9100] + 31 < _9100 + return_data.size
                                            _9388 = mem[_9100 + mem[_9100]]
                                            if mem[_9100 + mem[_9100]] > test266151307():
                                                revert with 0, 65
                                            if _9100 + ceil32(return_data.size) + ceil32(32 * mem[_9100 + mem[_9100]]) + 1 > test266151307() or ceil32(32 * mem[_9100 + mem[_9100]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _9100 + ceil32(return_data.size) + ceil32(32 * mem[_9100 + mem[_9100]]) + 1
                                            mem[_9100 + ceil32(return_data.size)] = _9388
                                            require return_data.size >= _9244 + (32 * _9388) + 32
                                            mem[_9100 + ceil32(return_data.size) + 32 len 32 * _9388] = mem[_9100 + _9244 + 32 len 32 * _9388]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                            if 1 >= _9388:
                                                revert with 0, 50
                                            if mem[_9100 + ceil32(return_data.size) + 64] > -1:
                                                revert with 0, 17
                                            require ext_code.size(brushAddress)
                                            call brushAddress.0x42966c68 with:
                                                 gas gas_remaining wei
                                                args mem[_9100 + ceil32(return_data.size) + 64]
                                    else:
                                        if brushAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_6374:
                                                revert with 0, 17
                                            mem[_6378 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_6378 + 100] = ext_call.return_data[32] + _6374
                                            mem[_6378 + 132] = 0
                                            mem[_6378 + 164] = 160
                                            mem[_6378 + 260] = mem[_6378]
                                            idx = 0
                                            s = _6378 + 292
                                            t = _6378 + 32
                                            while idx < mem[_6378]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_6378 + 196] = this.address
                                            mem[_6378 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _6378 + (32 * mem[_6378]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9101 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _9245 = mem[_9101]
                                            require mem[_9101] <= test266151307()
                                            require _9101 + mem[_9101] + 31 < _9101 + return_data.size
                                            _9389 = mem[_9101 + mem[_9101]]
                                            if mem[_9101 + mem[_9101]] > test266151307():
                                                revert with 0, 65
                                            if _9101 + ceil32(return_data.size) + ceil32(32 * mem[_9101 + mem[_9101]]) + 1 > test266151307() or ceil32(32 * mem[_9101 + mem[_9101]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _9101 + ceil32(return_data.size) + ceil32(32 * mem[_9101 + mem[_9101]]) + 1
                                            mem[_9101 + ceil32(return_data.size)] = _9389
                                            require return_data.size >= _9245 + (32 * _9389) + 32
                                            mem[_9101 + ceil32(return_data.size) + 32 len 32 * _9389] = mem[_9101 + _9245 + 32 len 32 * _9389]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                            if 1 >= _9389:
                                                revert with 0, 50
                                            if mem[_9101 + ceil32(return_data.size) + 64] > -1:
                                                revert with 0, 17
                                            require ext_code.size(brushAddress)
                                            call brushAddress.0x42966c68 with:
                                                 gas gas_remaining wei
                                                args mem[_9101 + ceil32(return_data.size) + 64]
                                        else:
                                            if brushAddress == address(ext_call.return_data[0]):
                                                if ext_call.return_data[0] > !_6374:
                                                    revert with 0, 17
                                                mem[_6378 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[_6378 + 100] = ext_call.return_data[0] + _6374
                                                mem[_6378 + 132] = 0
                                                mem[_6378 + 164] = 160
                                                mem[_6378 + 260] = mem[_6378]
                                                idx = 0
                                                s = _6378 + 292
                                                t = _6378 + 32
                                                while idx < mem[_6378]:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[_6378 + 196] = this.address
                                                mem[_6378 + 228] = block.timestamp + 10000
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len _6378 + (32 * mem[_6378]) + -mem[64] + 288]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _9102 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _9246 = mem[_9102]
                                                require mem[_9102] <= test266151307()
                                                require _9102 + mem[_9102] + 31 < _9102 + return_data.size
                                                _9390 = mem[_9102 + mem[_9102]]
                                                if mem[_9102 + mem[_9102]] > test266151307():
                                                    revert with 0, 65
                                                if _9102 + ceil32(return_data.size) + ceil32(32 * mem[_9102 + mem[_9102]]) + 1 > test266151307() or ceil32(32 * mem[_9102 + mem[_9102]]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[64] = _9102 + ceil32(return_data.size) + ceil32(32 * mem[_9102 + mem[_9102]]) + 1
                                                mem[_9102 + ceil32(return_data.size)] = _9390
                                                require return_data.size >= _9246 + (32 * _9390) + 32
                                                mem[_9102 + ceil32(return_data.size) + 32 len 32 * _9390] = mem[_9102 + _9246 + 32 len 32 * _9390]
                                                if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                    revert with 0, 17
                                                maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                                if 1 >= _9390:
                                                    revert with 0, 50
                                                if mem[_9102 + ceil32(return_data.size) + 64] > -1:
                                                    revert with 0, 17
                                                require ext_code.size(brushAddress)
                                                call brushAddress.0x42966c68 with:
                                                     gas gas_remaining wei
                                                    args mem[_9102 + ceil32(return_data.size) + 64]
                                            else:
                                                if wftmAddress == address(ext_call.return_data[0]):
                                                    if ext_call.return_data[32] > !_6374:
                                                        revert with 0, 17
                                                    mem[_6378 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[_6378 + 100] = ext_call.return_data[32] + _6374
                                                    mem[_6378 + 132] = 0
                                                    mem[_6378 + 164] = 160
                                                    mem[_6378 + 260] = mem[_6378]
                                                    idx = 0
                                                    s = _6378 + 292
                                                    t = _6378 + 32
                                                    while idx < mem[_6378]:
                                                        mem[s] = mem[t + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[_6378 + 196] = this.address
                                                    mem[_6378 + 228] = block.timestamp + 10000
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len _6378 + (32 * mem[_6378]) + -mem[64] + 288]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _9103 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _9247 = mem[_9103]
                                                    require mem[_9103] <= test266151307()
                                                    require _9103 + mem[_9103] + 31 < _9103 + return_data.size
                                                    _9391 = mem[_9103 + mem[_9103]]
                                                    if mem[_9103 + mem[_9103]] > test266151307():
                                                        revert with 0, 65
                                                    if _9103 + ceil32(return_data.size) + ceil32(32 * mem[_9103 + mem[_9103]]) + 1 > test266151307() or ceil32(32 * mem[_9103 + mem[_9103]]) + 1 < 0:
                                                        revert with 0, 65
                                                    mem[64] = _9103 + ceil32(return_data.size) + ceil32(32 * mem[_9103 + mem[_9103]]) + 1
                                                    mem[_9103 + ceil32(return_data.size)] = _9391
                                                    require return_data.size >= _9247 + (32 * _9391) + 32
                                                    mem[_9103 + ceil32(return_data.size) + 32 len 32 * _9391] = mem[_9103 + _9247 + 32 len 32 * _9391]
                                                    if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                        revert with 0, 17
                                                    maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                                    if 1 >= _9391:
                                                        revert with 0, 50
                                                    if mem[_9103 + ceil32(return_data.size) + 64] > -1:
                                                        revert with 0, 17
                                                    require ext_code.size(brushAddress)
                                                    call brushAddress.0x42966c68 with:
                                                         gas gas_remaining wei
                                                        args mem[_9103 + ceil32(return_data.size) + 64]
                                                else:
                                                    if ext_call.return_data[0] > !_6374:
                                                        revert with 0, 17
                                                    mem[_6378 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[_6378 + 100] = ext_call.return_data[0] + _6374
                                                    mem[_6378 + 132] = 0
                                                    mem[_6378 + 164] = 160
                                                    mem[_6378 + 260] = mem[_6378]
                                                    idx = 0
                                                    s = _6378 + 292
                                                    t = _6378 + 32
                                                    while idx < mem[_6378]:
                                                        mem[s] = mem[t + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[_6378 + 196] = this.address
                                                    mem[_6378 + 228] = block.timestamp + 10000
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len _6378 + (32 * mem[_6378]) + -mem[64] + 288]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _9104 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _9248 = mem[_9104]
                                                    require mem[_9104] <= test266151307()
                                                    require _9104 + mem[_9104] + 31 < _9104 + return_data.size
                                                    _9392 = mem[_9104 + mem[_9104]]
                                                    if mem[_9104 + mem[_9104]] > test266151307():
                                                        revert with 0, 65
                                                    if _9104 + ceil32(return_data.size) + ceil32(32 * mem[_9104 + mem[_9104]]) + 1 > test266151307() or ceil32(32 * mem[_9104 + mem[_9104]]) + 1 < 0:
                                                        revert with 0, 65
                                                    mem[64] = _9104 + ceil32(return_data.size) + ceil32(32 * mem[_9104 + mem[_9104]]) + 1
                                                    mem[_9104 + ceil32(return_data.size)] = _9392
                                                    require return_data.size >= _9248 + (32 * _9392) + 32
                                                    mem[_9104 + ceil32(return_data.size) + 32 len 32 * _9392] = mem[_9104 + _9248 + 32 len 32 * _9392]
                                                    if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                        revert with 0, 17
                                                    maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                                    if 1 >= _9392:
                                                        revert with 0, 50
                                                    if mem[_9104 + ceil32(return_data.size) + 64] > -1:
                                                        revert with 0, 17
                                                    require ext_code.size(brushAddress)
                                                    call brushAddress.0x42966c68 with:
                                                         gas gas_remaining wei
                                                        args mem[_9104 + ceil32(return_data.size) + 64]
            else:
                if wftmAddress == address(ext_call.return_data[0]):
                    mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                    mem[(4 * ceil32(return_data.size)) + 228] = 0
                    mem[(4 * ceil32(return_data.size)) + 260] = 160
                    mem[(4 * ceil32(return_data.size)) + 356] = 2
                    idx = 0
                    s = (4 * ceil32(return_data.size)) + 388
                    t = (4 * ceil32(return_data.size)) + 128
                    while idx < 2:
                        mem[s] = mem[t + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[(4 * ceil32(return_data.size)) + 292] = this.address
                    mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                    require ext_code.size(routerAddress)
                    call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                         gas gas_remaining wei
                        args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = (6 * ceil32(return_data.size)) + 192
                    require return_data.size >= 32
                    _3525 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                    require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                    require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                    _3604 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                    if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                        revert with 0, 65
                    if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                        revert with 0, 65
                    mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193
                    mem[(6 * ceil32(return_data.size)) + 192] = _3604
                    require return_data.size >= _3525 + (32 * _3604) + 32
                    mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3604] = mem[(4 * ceil32(return_data.size)) + _3525 + 224 len 32 * _3604]
                    if 1 >= _3604:
                        revert with 0, 50
                    _6375 = mem[(6 * ceil32(return_data.size)) + 256]
                    _6379 = mem[64]
                    mem[mem[64]] = 2
                    mem[64] = mem[64] + 96
                    if 0 >= mem[_6379]:
                        revert with 0, 50
                    mem[_6379 + 32] = address(ext_call.return_data[0])
                    if 1 >= mem[_6379]:
                        revert with 0, 50
                    mem[_6379 + 64] = brushAddress
                    if brushAddress != address(ext_call.return_data[0]):
                        if wftmAddress == address(ext_call.return_data[0]):
                            if brushAddress != address(ext_call.return_data[0]):
                                if wftmAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_6375:
                                        revert with 0, 17
                                    mem[_6379 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_6379 + 100] = ext_call.return_data[32] + _6375
                                    mem[_6379 + 132] = 0
                                    mem[_6379 + 164] = 160
                                    mem[_6379 + 260] = mem[_6379]
                                    idx = 0
                                    s = _6379 + 292
                                    t = _6379 + 32
                                    while idx < mem[_6379]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_6379 + 196] = this.address
                                    mem[_6379 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _6379 + (32 * mem[_6379]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9105 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _9249 = mem[_9105]
                                    require mem[_9105] <= test266151307()
                                    require _9105 + mem[_9105] + 31 < _9105 + return_data.size
                                    _9393 = mem[_9105 + mem[_9105]]
                                    if mem[_9105 + mem[_9105]] > test266151307():
                                        revert with 0, 65
                                    if _9105 + ceil32(return_data.size) + ceil32(32 * mem[_9105 + mem[_9105]]) + 1 > test266151307() or ceil32(32 * mem[_9105 + mem[_9105]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _9105 + ceil32(return_data.size) + ceil32(32 * mem[_9105 + mem[_9105]]) + 1
                                    mem[_9105 + ceil32(return_data.size)] = _9393
                                    require return_data.size >= _9249 + (32 * _9393) + 32
                                    mem[_9105 + ceil32(return_data.size) + 32 len 32 * _9393] = mem[_9105 + _9249 + 32 len 32 * _9393]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                    if 1 >= _9393:
                                        revert with 0, 50
                                    if mem[_9105 + ceil32(return_data.size) + 64] > -1:
                                        revert with 0, 17
                                    require ext_code.size(brushAddress)
                                    call brushAddress.0x42966c68 with:
                                         gas gas_remaining wei
                                        args mem[_9105 + ceil32(return_data.size) + 64]
                                else:
                                    if ext_call.return_data[0] > !_6375:
                                        revert with 0, 17
                                    mem[_6379 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_6379 + 100] = ext_call.return_data[0] + _6375
                                    mem[_6379 + 132] = 0
                                    mem[_6379 + 164] = 160
                                    mem[_6379 + 260] = mem[_6379]
                                    idx = 0
                                    s = _6379 + 292
                                    t = _6379 + 32
                                    while idx < mem[_6379]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_6379 + 196] = this.address
                                    mem[_6379 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _6379 + (32 * mem[_6379]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9106 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _9250 = mem[_9106]
                                    require mem[_9106] <= test266151307()
                                    require _9106 + mem[_9106] + 31 < _9106 + return_data.size
                                    _9394 = mem[_9106 + mem[_9106]]
                                    if mem[_9106 + mem[_9106]] > test266151307():
                                        revert with 0, 65
                                    if _9106 + ceil32(return_data.size) + ceil32(32 * mem[_9106 + mem[_9106]]) + 1 > test266151307() or ceil32(32 * mem[_9106 + mem[_9106]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _9106 + ceil32(return_data.size) + ceil32(32 * mem[_9106 + mem[_9106]]) + 1
                                    mem[_9106 + ceil32(return_data.size)] = _9394
                                    require return_data.size >= _9250 + (32 * _9394) + 32
                                    mem[_9106 + ceil32(return_data.size) + 32 len 32 * _9394] = mem[_9106 + _9250 + 32 len 32 * _9394]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                    if 1 >= _9394:
                                        revert with 0, 50
                                    if mem[_9106 + ceil32(return_data.size) + 64] > -1:
                                        revert with 0, 17
                                    require ext_code.size(brushAddress)
                                    call brushAddress.0x42966c68 with:
                                         gas gas_remaining wei
                                        args mem[_9106 + ceil32(return_data.size) + 64]
                            else:
                                if brushAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_6375:
                                        revert with 0, 17
                                    mem[_6379 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_6379 + 100] = ext_call.return_data[32] + _6375
                                    mem[_6379 + 132] = 0
                                    mem[_6379 + 164] = 160
                                    mem[_6379 + 260] = mem[_6379]
                                    idx = 0
                                    s = _6379 + 292
                                    t = _6379 + 32
                                    while idx < mem[_6379]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_6379 + 196] = this.address
                                    mem[_6379 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _6379 + (32 * mem[_6379]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9107 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _9251 = mem[_9107]
                                    require mem[_9107] <= test266151307()
                                    require _9107 + mem[_9107] + 31 < _9107 + return_data.size
                                    _9395 = mem[_9107 + mem[_9107]]
                                    if mem[_9107 + mem[_9107]] > test266151307():
                                        revert with 0, 65
                                    if _9107 + ceil32(return_data.size) + ceil32(32 * mem[_9107 + mem[_9107]]) + 1 > test266151307() or ceil32(32 * mem[_9107 + mem[_9107]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _9107 + ceil32(return_data.size) + ceil32(32 * mem[_9107 + mem[_9107]]) + 1
                                    mem[_9107 + ceil32(return_data.size)] = _9395
                                    require return_data.size >= _9251 + (32 * _9395) + 32
                                    mem[_9107 + ceil32(return_data.size) + 32 len 32 * _9395] = mem[_9107 + _9251 + 32 len 32 * _9395]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                    if 1 >= _9395:
                                        revert with 0, 50
                                    if mem[_9107 + ceil32(return_data.size) + 64] > -1:
                                        revert with 0, 17
                                    require ext_code.size(brushAddress)
                                    call brushAddress.0x42966c68 with:
                                         gas gas_remaining wei
                                        args mem[_9107 + ceil32(return_data.size) + 64]
                                else:
                                    if brushAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[0] > !_6375:
                                            revert with 0, 17
                                        mem[_6379 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_6379 + 100] = ext_call.return_data[0] + _6375
                                        mem[_6379 + 132] = 0
                                        mem[_6379 + 164] = 160
                                        mem[_6379 + 260] = mem[_6379]
                                        idx = 0
                                        s = _6379 + 292
                                        t = _6379 + 32
                                        while idx < mem[_6379]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_6379 + 196] = this.address
                                        mem[_6379 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _6379 + (32 * mem[_6379]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9108 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _9252 = mem[_9108]
                                        require mem[_9108] <= test266151307()
                                        require _9108 + mem[_9108] + 31 < _9108 + return_data.size
                                        _9396 = mem[_9108 + mem[_9108]]
                                        if mem[_9108 + mem[_9108]] > test266151307():
                                            revert with 0, 65
                                        if _9108 + ceil32(return_data.size) + ceil32(32 * mem[_9108 + mem[_9108]]) + 1 > test266151307() or ceil32(32 * mem[_9108 + mem[_9108]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _9108 + ceil32(return_data.size) + ceil32(32 * mem[_9108 + mem[_9108]]) + 1
                                        mem[_9108 + ceil32(return_data.size)] = _9396
                                        require return_data.size >= _9252 + (32 * _9396) + 32
                                        mem[_9108 + ceil32(return_data.size) + 32 len 32 * _9396] = mem[_9108 + _9252 + 32 len 32 * _9396]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                        if 1 >= _9396:
                                            revert with 0, 50
                                        if mem[_9108 + ceil32(return_data.size) + 64] > -1:
                                            revert with 0, 17
                                        require ext_code.size(brushAddress)
                                        call brushAddress.0x42966c68 with:
                                             gas gas_remaining wei
                                            args mem[_9108 + ceil32(return_data.size) + 64]
                                    else:
                                        if wftmAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_6375:
                                                revert with 0, 17
                                            mem[_6379 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_6379 + 100] = ext_call.return_data[32] + _6375
                                            mem[_6379 + 132] = 0
                                            mem[_6379 + 164] = 160
                                            mem[_6379 + 260] = mem[_6379]
                                            idx = 0
                                            s = _6379 + 292
                                            t = _6379 + 32
                                            while idx < mem[_6379]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_6379 + 196] = this.address
                                            mem[_6379 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _6379 + (32 * mem[_6379]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9109 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _9253 = mem[_9109]
                                            require mem[_9109] <= test266151307()
                                            require _9109 + mem[_9109] + 31 < _9109 + return_data.size
                                            _9397 = mem[_9109 + mem[_9109]]
                                            if mem[_9109 + mem[_9109]] > test266151307():
                                                revert with 0, 65
                                            if _9109 + ceil32(return_data.size) + ceil32(32 * mem[_9109 + mem[_9109]]) + 1 > test266151307() or ceil32(32 * mem[_9109 + mem[_9109]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _9109 + ceil32(return_data.size) + ceil32(32 * mem[_9109 + mem[_9109]]) + 1
                                            mem[_9109 + ceil32(return_data.size)] = _9397
                                            require return_data.size >= _9253 + (32 * _9397) + 32
                                            mem[_9109 + ceil32(return_data.size) + 32 len 32 * _9397] = mem[_9109 + _9253 + 32 len 32 * _9397]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                            if 1 >= _9397:
                                                revert with 0, 50
                                            if mem[_9109 + ceil32(return_data.size) + 64] > -1:
                                                revert with 0, 17
                                            require ext_code.size(brushAddress)
                                            call brushAddress.0x42966c68 with:
                                                 gas gas_remaining wei
                                                args mem[_9109 + ceil32(return_data.size) + 64]
                                        else:
                                            if ext_call.return_data[0] > !_6375:
                                                revert with 0, 17
                                            mem[_6379 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_6379 + 100] = ext_call.return_data[0] + _6375
                                            mem[_6379 + 132] = 0
                                            mem[_6379 + 164] = 160
                                            mem[_6379 + 260] = mem[_6379]
                                            idx = 0
                                            s = _6379 + 292
                                            t = _6379 + 32
                                            while idx < mem[_6379]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_6379 + 196] = this.address
                                            mem[_6379 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _6379 + (32 * mem[_6379]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9110 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _9254 = mem[_9110]
                                            require mem[_9110] <= test266151307()
                                            require _9110 + mem[_9110] + 31 < _9110 + return_data.size
                                            _9398 = mem[_9110 + mem[_9110]]
                                            if mem[_9110 + mem[_9110]] > test266151307():
                                                revert with 0, 65
                                            if _9110 + ceil32(return_data.size) + ceil32(32 * mem[_9110 + mem[_9110]]) + 1 > test266151307() or ceil32(32 * mem[_9110 + mem[_9110]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _9110 + ceil32(return_data.size) + ceil32(32 * mem[_9110 + mem[_9110]]) + 1
                                            mem[_9110 + ceil32(return_data.size)] = _9398
                                            require return_data.size >= _9254 + (32 * _9398) + 32
                                            mem[_9110 + ceil32(return_data.size) + 32 len 32 * _9398] = mem[_9110 + _9254 + 32 len 32 * _9398]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                            if 1 >= _9398:
                                                revert with 0, 50
                                            if mem[_9110 + ceil32(return_data.size) + 64] > -1:
                                                revert with 0, 17
                                            require ext_code.size(brushAddress)
                                            call brushAddress.0x42966c68 with:
                                                 gas gas_remaining wei
                                                args mem[_9110 + ceil32(return_data.size) + 64]
                        else:
                            if brushAddress != address(ext_call.return_data[0]):
                                if wftmAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_6375:
                                        revert with 0, 17
                                    mem[_6379 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_6379 + 100] = ext_call.return_data[32] + _6375
                                    mem[_6379 + 132] = 0
                                    mem[_6379 + 164] = 160
                                    mem[_6379 + 260] = mem[_6379]
                                    idx = 0
                                    s = _6379 + 292
                                    t = _6379 + 32
                                    while idx < mem[_6379]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_6379 + 196] = this.address
                                    mem[_6379 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _6379 + (32 * mem[_6379]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9111 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _9255 = mem[_9111]
                                    require mem[_9111] <= test266151307()
                                    require _9111 + mem[_9111] + 31 < _9111 + return_data.size
                                    _9399 = mem[_9111 + mem[_9111]]
                                    if mem[_9111 + mem[_9111]] > test266151307():
                                        revert with 0, 65
                                    if _9111 + ceil32(return_data.size) + ceil32(32 * mem[_9111 + mem[_9111]]) + 1 > test266151307() or ceil32(32 * mem[_9111 + mem[_9111]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _9111 + ceil32(return_data.size) + ceil32(32 * mem[_9111 + mem[_9111]]) + 1
                                    mem[_9111 + ceil32(return_data.size)] = _9399
                                    require return_data.size >= _9255 + (32 * _9399) + 32
                                    mem[_9111 + ceil32(return_data.size) + 32 len 32 * _9399] = mem[_9111 + _9255 + 32 len 32 * _9399]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                    if 1 >= _9399:
                                        revert with 0, 50
                                    if mem[_9111 + ceil32(return_data.size) + 64] > -1:
                                        revert with 0, 17
                                    require ext_code.size(brushAddress)
                                    call brushAddress.0x42966c68 with:
                                         gas gas_remaining wei
                                        args mem[_9111 + ceil32(return_data.size) + 64]
                                else:
                                    if ext_call.return_data[0] > !_6375:
                                        revert with 0, 17
                                    mem[_6379 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_6379 + 100] = ext_call.return_data[0] + _6375
                                    mem[_6379 + 132] = 0
                                    mem[_6379 + 164] = 160
                                    mem[_6379 + 260] = mem[_6379]
                                    idx = 0
                                    s = _6379 + 292
                                    t = _6379 + 32
                                    while idx < mem[_6379]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_6379 + 196] = this.address
                                    mem[_6379 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _6379 + (32 * mem[_6379]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9112 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _9256 = mem[_9112]
                                    require mem[_9112] <= test266151307()
                                    require _9112 + mem[_9112] + 31 < _9112 + return_data.size
                                    _9400 = mem[_9112 + mem[_9112]]
                                    if mem[_9112 + mem[_9112]] > test266151307():
                                        revert with 0, 65
                                    if _9112 + ceil32(return_data.size) + ceil32(32 * mem[_9112 + mem[_9112]]) + 1 > test266151307() or ceil32(32 * mem[_9112 + mem[_9112]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _9112 + ceil32(return_data.size) + ceil32(32 * mem[_9112 + mem[_9112]]) + 1
                                    mem[_9112 + ceil32(return_data.size)] = _9400
                                    require return_data.size >= _9256 + (32 * _9400) + 32
                                    mem[_9112 + ceil32(return_data.size) + 32 len 32 * _9400] = mem[_9112 + _9256 + 32 len 32 * _9400]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                    if 1 >= _9400:
                                        revert with 0, 50
                                    if mem[_9112 + ceil32(return_data.size) + 64] > -1:
                                        revert with 0, 17
                                    require ext_code.size(brushAddress)
                                    call brushAddress.0x42966c68 with:
                                         gas gas_remaining wei
                                        args mem[_9112 + ceil32(return_data.size) + 64]
                            else:
                                if brushAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_6375:
                                        revert with 0, 17
                                    mem[_6379 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_6379 + 100] = ext_call.return_data[32] + _6375
                                    mem[_6379 + 132] = 0
                                    mem[_6379 + 164] = 160
                                    mem[_6379 + 260] = mem[_6379]
                                    idx = 0
                                    s = _6379 + 292
                                    t = _6379 + 32
                                    while idx < mem[_6379]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_6379 + 196] = this.address
                                    mem[_6379 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _6379 + (32 * mem[_6379]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9113 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _9257 = mem[_9113]
                                    require mem[_9113] <= test266151307()
                                    require _9113 + mem[_9113] + 31 < _9113 + return_data.size
                                    _9401 = mem[_9113 + mem[_9113]]
                                    if mem[_9113 + mem[_9113]] > test266151307():
                                        revert with 0, 65
                                    if _9113 + ceil32(return_data.size) + ceil32(32 * mem[_9113 + mem[_9113]]) + 1 > test266151307() or ceil32(32 * mem[_9113 + mem[_9113]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _9113 + ceil32(return_data.size) + ceil32(32 * mem[_9113 + mem[_9113]]) + 1
                                    mem[_9113 + ceil32(return_data.size)] = _9401
                                    require return_data.size >= _9257 + (32 * _9401) + 32
                                    mem[_9113 + ceil32(return_data.size) + 32 len 32 * _9401] = mem[_9113 + _9257 + 32 len 32 * _9401]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                    if 1 >= _9401:
                                        revert with 0, 50
                                    if mem[_9113 + ceil32(return_data.size) + 64] > -1:
                                        revert with 0, 17
                                    require ext_code.size(brushAddress)
                                    call brushAddress.0x42966c68 with:
                                         gas gas_remaining wei
                                        args mem[_9113 + ceil32(return_data.size) + 64]
                                else:
                                    if brushAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[0] > !_6375:
                                            revert with 0, 17
                                        mem[_6379 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_6379 + 100] = ext_call.return_data[0] + _6375
                                        mem[_6379 + 132] = 0
                                        mem[_6379 + 164] = 160
                                        mem[_6379 + 260] = mem[_6379]
                                        idx = 0
                                        s = _6379 + 292
                                        t = _6379 + 32
                                        while idx < mem[_6379]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_6379 + 196] = this.address
                                        mem[_6379 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _6379 + (32 * mem[_6379]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9114 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _9258 = mem[_9114]
                                        require mem[_9114] <= test266151307()
                                        require _9114 + mem[_9114] + 31 < _9114 + return_data.size
                                        _9402 = mem[_9114 + mem[_9114]]
                                        if mem[_9114 + mem[_9114]] > test266151307():
                                            revert with 0, 65
                                        if _9114 + ceil32(return_data.size) + ceil32(32 * mem[_9114 + mem[_9114]]) + 1 > test266151307() or ceil32(32 * mem[_9114 + mem[_9114]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _9114 + ceil32(return_data.size) + ceil32(32 * mem[_9114 + mem[_9114]]) + 1
                                        mem[_9114 + ceil32(return_data.size)] = _9402
                                        require return_data.size >= _9258 + (32 * _9402) + 32
                                        mem[_9114 + ceil32(return_data.size) + 32 len 32 * _9402] = mem[_9114 + _9258 + 32 len 32 * _9402]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                        if 1 >= _9402:
                                            revert with 0, 50
                                        if mem[_9114 + ceil32(return_data.size) + 64] > -1:
                                            revert with 0, 17
                                        require ext_code.size(brushAddress)
                                        call brushAddress.0x42966c68 with:
                                             gas gas_remaining wei
                                            args mem[_9114 + ceil32(return_data.size) + 64]
                                    else:
                                        if wftmAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_6375:
                                                revert with 0, 17
                                            mem[_6379 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_6379 + 100] = ext_call.return_data[32] + _6375
                                            mem[_6379 + 132] = 0
                                            mem[_6379 + 164] = 160
                                            mem[_6379 + 260] = mem[_6379]
                                            idx = 0
                                            s = _6379 + 292
                                            t = _6379 + 32
                                            while idx < mem[_6379]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_6379 + 196] = this.address
                                            mem[_6379 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _6379 + (32 * mem[_6379]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9115 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _9259 = mem[_9115]
                                            require mem[_9115] <= test266151307()
                                            require _9115 + mem[_9115] + 31 < _9115 + return_data.size
                                            _9403 = mem[_9115 + mem[_9115]]
                                            if mem[_9115 + mem[_9115]] > test266151307():
                                                revert with 0, 65
                                            if _9115 + ceil32(return_data.size) + ceil32(32 * mem[_9115 + mem[_9115]]) + 1 > test266151307() or ceil32(32 * mem[_9115 + mem[_9115]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _9115 + ceil32(return_data.size) + ceil32(32 * mem[_9115 + mem[_9115]]) + 1
                                            mem[_9115 + ceil32(return_data.size)] = _9403
                                            require return_data.size >= _9259 + (32 * _9403) + 32
                                            mem[_9115 + ceil32(return_data.size) + 32 len 32 * _9403] = mem[_9115 + _9259 + 32 len 32 * _9403]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                            if 1 >= _9403:
                                                revert with 0, 50
                                            if mem[_9115 + ceil32(return_data.size) + 64] > -1:
                                                revert with 0, 17
                                            require ext_code.size(brushAddress)
                                            call brushAddress.0x42966c68 with:
                                                 gas gas_remaining wei
                                                args mem[_9115 + ceil32(return_data.size) + 64]
                                        else:
                                            if ext_call.return_data[0] > !_6375:
                                                revert with 0, 17
                                            mem[_6379 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_6379 + 100] = ext_call.return_data[0] + _6375
                                            mem[_6379 + 132] = 0
                                            mem[_6379 + 164] = 160
                                            mem[_6379 + 260] = mem[_6379]
                                            idx = 0
                                            s = _6379 + 292
                                            t = _6379 + 32
                                            while idx < mem[_6379]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_6379 + 196] = this.address
                                            mem[_6379 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _6379 + (32 * mem[_6379]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9116 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _9260 = mem[_9116]
                                            require mem[_9116] <= test266151307()
                                            require _9116 + mem[_9116] + 31 < _9116 + return_data.size
                                            _9404 = mem[_9116 + mem[_9116]]
                                            if mem[_9116 + mem[_9116]] > test266151307():
                                                revert with 0, 65
                                            if _9116 + ceil32(return_data.size) + ceil32(32 * mem[_9116 + mem[_9116]]) + 1 > test266151307() or ceil32(32 * mem[_9116 + mem[_9116]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _9116 + ceil32(return_data.size) + ceil32(32 * mem[_9116 + mem[_9116]]) + 1
                                            mem[_9116 + ceil32(return_data.size)] = _9404
                                            require return_data.size >= _9260 + (32 * _9404) + 32
                                            mem[_9116 + ceil32(return_data.size) + 32 len 32 * _9404] = mem[_9116 + _9260 + 32 len 32 * _9404]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                            if 1 >= _9404:
                                                revert with 0, 50
                                            if mem[_9116 + ceil32(return_data.size) + 64] > -1:
                                                revert with 0, 17
                                            require ext_code.size(brushAddress)
                                            call brushAddress.0x42966c68 with:
                                                 gas gas_remaining wei
                                                args mem[_9116 + ceil32(return_data.size) + 64]
                    else:
                        if brushAddress == address(ext_call.return_data[0]):
                            if brushAddress != address(ext_call.return_data[0]):
                                if wftmAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_6375:
                                        revert with 0, 17
                                    mem[_6379 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_6379 + 100] = ext_call.return_data[32] + _6375
                                    mem[_6379 + 132] = 0
                                    mem[_6379 + 164] = 160
                                    mem[_6379 + 260] = mem[_6379]
                                    idx = 0
                                    s = _6379 + 292
                                    t = _6379 + 32
                                    while idx < mem[_6379]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_6379 + 196] = this.address
                                    mem[_6379 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _6379 + (32 * mem[_6379]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9117 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _9261 = mem[_9117]
                                    require mem[_9117] <= test266151307()
                                    require _9117 + mem[_9117] + 31 < _9117 + return_data.size
                                    _9405 = mem[_9117 + mem[_9117]]
                                    if mem[_9117 + mem[_9117]] > test266151307():
                                        revert with 0, 65
                                    if _9117 + ceil32(return_data.size) + ceil32(32 * mem[_9117 + mem[_9117]]) + 1 > test266151307() or ceil32(32 * mem[_9117 + mem[_9117]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _9117 + ceil32(return_data.size) + ceil32(32 * mem[_9117 + mem[_9117]]) + 1
                                    mem[_9117 + ceil32(return_data.size)] = _9405
                                    require return_data.size >= _9261 + (32 * _9405) + 32
                                    mem[_9117 + ceil32(return_data.size) + 32 len 32 * _9405] = mem[_9117 + _9261 + 32 len 32 * _9405]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                    if 1 >= _9405:
                                        revert with 0, 50
                                    if mem[_9117 + ceil32(return_data.size) + 64] > -1:
                                        revert with 0, 17
                                    require ext_code.size(brushAddress)
                                    call brushAddress.0x42966c68 with:
                                         gas gas_remaining wei
                                        args mem[_9117 + ceil32(return_data.size) + 64]
                                else:
                                    if ext_call.return_data[0] > !_6375:
                                        revert with 0, 17
                                    mem[_6379 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_6379 + 100] = ext_call.return_data[0] + _6375
                                    mem[_6379 + 132] = 0
                                    mem[_6379 + 164] = 160
                                    mem[_6379 + 260] = mem[_6379]
                                    idx = 0
                                    s = _6379 + 292
                                    t = _6379 + 32
                                    while idx < mem[_6379]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_6379 + 196] = this.address
                                    mem[_6379 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _6379 + (32 * mem[_6379]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9118 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _9262 = mem[_9118]
                                    require mem[_9118] <= test266151307()
                                    require _9118 + mem[_9118] + 31 < _9118 + return_data.size
                                    _9406 = mem[_9118 + mem[_9118]]
                                    if mem[_9118 + mem[_9118]] > test266151307():
                                        revert with 0, 65
                                    if _9118 + ceil32(return_data.size) + ceil32(32 * mem[_9118 + mem[_9118]]) + 1 > test266151307() or ceil32(32 * mem[_9118 + mem[_9118]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _9118 + ceil32(return_data.size) + ceil32(32 * mem[_9118 + mem[_9118]]) + 1
                                    mem[_9118 + ceil32(return_data.size)] = _9406
                                    require return_data.size >= _9262 + (32 * _9406) + 32
                                    mem[_9118 + ceil32(return_data.size) + 32 len 32 * _9406] = mem[_9118 + _9262 + 32 len 32 * _9406]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                    if 1 >= _9406:
                                        revert with 0, 50
                                    if mem[_9118 + ceil32(return_data.size) + 64] > -1:
                                        revert with 0, 17
                                    require ext_code.size(brushAddress)
                                    call brushAddress.0x42966c68 with:
                                         gas gas_remaining wei
                                        args mem[_9118 + ceil32(return_data.size) + 64]
                            else:
                                if brushAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_6375:
                                        revert with 0, 17
                                    mem[_6379 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_6379 + 100] = ext_call.return_data[32] + _6375
                                    mem[_6379 + 132] = 0
                                    mem[_6379 + 164] = 160
                                    mem[_6379 + 260] = mem[_6379]
                                    idx = 0
                                    s = _6379 + 292
                                    t = _6379 + 32
                                    while idx < mem[_6379]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_6379 + 196] = this.address
                                    mem[_6379 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _6379 + (32 * mem[_6379]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9119 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _9263 = mem[_9119]
                                    require mem[_9119] <= test266151307()
                                    require _9119 + mem[_9119] + 31 < _9119 + return_data.size
                                    _9407 = mem[_9119 + mem[_9119]]
                                    if mem[_9119 + mem[_9119]] > test266151307():
                                        revert with 0, 65
                                    if _9119 + ceil32(return_data.size) + ceil32(32 * mem[_9119 + mem[_9119]]) + 1 > test266151307() or ceil32(32 * mem[_9119 + mem[_9119]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _9119 + ceil32(return_data.size) + ceil32(32 * mem[_9119 + mem[_9119]]) + 1
                                    mem[_9119 + ceil32(return_data.size)] = _9407
                                    require return_data.size >= _9263 + (32 * _9407) + 32
                                    mem[_9119 + ceil32(return_data.size) + 32 len 32 * _9407] = mem[_9119 + _9263 + 32 len 32 * _9407]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                    if 1 >= _9407:
                                        revert with 0, 50
                                    if mem[_9119 + ceil32(return_data.size) + 64] > -1:
                                        revert with 0, 17
                                    require ext_code.size(brushAddress)
                                    call brushAddress.0x42966c68 with:
                                         gas gas_remaining wei
                                        args mem[_9119 + ceil32(return_data.size) + 64]
                                else:
                                    if brushAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[0] > !_6375:
                                            revert with 0, 17
                                        mem[_6379 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_6379 + 100] = ext_call.return_data[0] + _6375
                                        mem[_6379 + 132] = 0
                                        mem[_6379 + 164] = 160
                                        mem[_6379 + 260] = mem[_6379]
                                        idx = 0
                                        s = _6379 + 292
                                        t = _6379 + 32
                                        while idx < mem[_6379]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_6379 + 196] = this.address
                                        mem[_6379 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _6379 + (32 * mem[_6379]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9120 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _9264 = mem[_9120]
                                        require mem[_9120] <= test266151307()
                                        require _9120 + mem[_9120] + 31 < _9120 + return_data.size
                                        _9408 = mem[_9120 + mem[_9120]]
                                        if mem[_9120 + mem[_9120]] > test266151307():
                                            revert with 0, 65
                                        if _9120 + ceil32(return_data.size) + ceil32(32 * mem[_9120 + mem[_9120]]) + 1 > test266151307() or ceil32(32 * mem[_9120 + mem[_9120]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _9120 + ceil32(return_data.size) + ceil32(32 * mem[_9120 + mem[_9120]]) + 1
                                        mem[_9120 + ceil32(return_data.size)] = _9408
                                        require return_data.size >= _9264 + (32 * _9408) + 32
                                        mem[_9120 + ceil32(return_data.size) + 32 len 32 * _9408] = mem[_9120 + _9264 + 32 len 32 * _9408]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                        if 1 >= _9408:
                                            revert with 0, 50
                                        if mem[_9120 + ceil32(return_data.size) + 64] > -1:
                                            revert with 0, 17
                                        require ext_code.size(brushAddress)
                                        call brushAddress.0x42966c68 with:
                                             gas gas_remaining wei
                                            args mem[_9120 + ceil32(return_data.size) + 64]
                                    else:
                                        if wftmAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_6375:
                                                revert with 0, 17
                                            mem[_6379 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_6379 + 100] = ext_call.return_data[32] + _6375
                                            mem[_6379 + 132] = 0
                                            mem[_6379 + 164] = 160
                                            mem[_6379 + 260] = mem[_6379]
                                            idx = 0
                                            s = _6379 + 292
                                            t = _6379 + 32
                                            while idx < mem[_6379]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_6379 + 196] = this.address
                                            mem[_6379 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _6379 + (32 * mem[_6379]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9121 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _9265 = mem[_9121]
                                            require mem[_9121] <= test266151307()
                                            require _9121 + mem[_9121] + 31 < _9121 + return_data.size
                                            _9409 = mem[_9121 + mem[_9121]]
                                            if mem[_9121 + mem[_9121]] > test266151307():
                                                revert with 0, 65
                                            if _9121 + ceil32(return_data.size) + ceil32(32 * mem[_9121 + mem[_9121]]) + 1 > test266151307() or ceil32(32 * mem[_9121 + mem[_9121]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _9121 + ceil32(return_data.size) + ceil32(32 * mem[_9121 + mem[_9121]]) + 1
                                            mem[_9121 + ceil32(return_data.size)] = _9409
                                            require return_data.size >= _9265 + (32 * _9409) + 32
                                            mem[_9121 + ceil32(return_data.size) + 32 len 32 * _9409] = mem[_9121 + _9265 + 32 len 32 * _9409]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                            if 1 >= _9409:
                                                revert with 0, 50
                                            if mem[_9121 + ceil32(return_data.size) + 64] > -1:
                                                revert with 0, 17
                                            require ext_code.size(brushAddress)
                                            call brushAddress.0x42966c68 with:
                                                 gas gas_remaining wei
                                                args mem[_9121 + ceil32(return_data.size) + 64]
                                        else:
                                            if ext_call.return_data[0] > !_6375:
                                                revert with 0, 17
                                            mem[_6379 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_6379 + 100] = ext_call.return_data[0] + _6375
                                            mem[_6379 + 132] = 0
                                            mem[_6379 + 164] = 160
                                            mem[_6379 + 260] = mem[_6379]
                                            idx = 0
                                            s = _6379 + 292
                                            t = _6379 + 32
                                            while idx < mem[_6379]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_6379 + 196] = this.address
                                            mem[_6379 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _6379 + (32 * mem[_6379]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9122 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _9266 = mem[_9122]
                                            require mem[_9122] <= test266151307()
                                            require _9122 + mem[_9122] + 31 < _9122 + return_data.size
                                            _9410 = mem[_9122 + mem[_9122]]
                                            if mem[_9122 + mem[_9122]] > test266151307():
                                                revert with 0, 65
                                            if _9122 + ceil32(return_data.size) + ceil32(32 * mem[_9122 + mem[_9122]]) + 1 > test266151307() or ceil32(32 * mem[_9122 + mem[_9122]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _9122 + ceil32(return_data.size) + ceil32(32 * mem[_9122 + mem[_9122]]) + 1
                                            mem[_9122 + ceil32(return_data.size)] = _9410
                                            require return_data.size >= _9266 + (32 * _9410) + 32
                                            mem[_9122 + ceil32(return_data.size) + 32 len 32 * _9410] = mem[_9122 + _9266 + 32 len 32 * _9410]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                            if 1 >= _9410:
                                                revert with 0, 50
                                            if mem[_9122 + ceil32(return_data.size) + 64] > -1:
                                                revert with 0, 17
                                            require ext_code.size(brushAddress)
                                            call brushAddress.0x42966c68 with:
                                                 gas gas_remaining wei
                                                args mem[_9122 + ceil32(return_data.size) + 64]
                        else:
                            if brushAddress == address(ext_call.return_data[0]):
                                if brushAddress != address(ext_call.return_data[0]):
                                    if wftmAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[32] > !_6375:
                                            revert with 0, 17
                                        mem[_6379 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_6379 + 100] = ext_call.return_data[32] + _6375
                                        mem[_6379 + 132] = 0
                                        mem[_6379 + 164] = 160
                                        mem[_6379 + 260] = mem[_6379]
                                        idx = 0
                                        s = _6379 + 292
                                        t = _6379 + 32
                                        while idx < mem[_6379]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_6379 + 196] = this.address
                                        mem[_6379 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _6379 + (32 * mem[_6379]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9123 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _9267 = mem[_9123]
                                        require mem[_9123] <= test266151307()
                                        require _9123 + mem[_9123] + 31 < _9123 + return_data.size
                                        _9411 = mem[_9123 + mem[_9123]]
                                        if mem[_9123 + mem[_9123]] > test266151307():
                                            revert with 0, 65
                                        if _9123 + ceil32(return_data.size) + ceil32(32 * mem[_9123 + mem[_9123]]) + 1 > test266151307() or ceil32(32 * mem[_9123 + mem[_9123]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _9123 + ceil32(return_data.size) + ceil32(32 * mem[_9123 + mem[_9123]]) + 1
                                        mem[_9123 + ceil32(return_data.size)] = _9411
                                        require return_data.size >= _9267 + (32 * _9411) + 32
                                        mem[_9123 + ceil32(return_data.size) + 32 len 32 * _9411] = mem[_9123 + _9267 + 32 len 32 * _9411]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                        if 1 >= _9411:
                                            revert with 0, 50
                                        if mem[_9123 + ceil32(return_data.size) + 64] > -1:
                                            revert with 0, 17
                                        require ext_code.size(brushAddress)
                                        call brushAddress.0x42966c68 with:
                                             gas gas_remaining wei
                                            args mem[_9123 + ceil32(return_data.size) + 64]
                                    else:
                                        if ext_call.return_data[0] > !_6375:
                                            revert with 0, 17
                                        mem[_6379 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_6379 + 100] = ext_call.return_data[0] + _6375
                                        mem[_6379 + 132] = 0
                                        mem[_6379 + 164] = 160
                                        mem[_6379 + 260] = mem[_6379]
                                        idx = 0
                                        s = _6379 + 292
                                        t = _6379 + 32
                                        while idx < mem[_6379]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_6379 + 196] = this.address
                                        mem[_6379 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _6379 + (32 * mem[_6379]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9124 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _9268 = mem[_9124]
                                        require mem[_9124] <= test266151307()
                                        require _9124 + mem[_9124] + 31 < _9124 + return_data.size
                                        _9412 = mem[_9124 + mem[_9124]]
                                        if mem[_9124 + mem[_9124]] > test266151307():
                                            revert with 0, 65
                                        if _9124 + ceil32(return_data.size) + ceil32(32 * mem[_9124 + mem[_9124]]) + 1 > test266151307() or ceil32(32 * mem[_9124 + mem[_9124]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _9124 + ceil32(return_data.size) + ceil32(32 * mem[_9124 + mem[_9124]]) + 1
                                        mem[_9124 + ceil32(return_data.size)] = _9412
                                        require return_data.size >= _9268 + (32 * _9412) + 32
                                        mem[_9124 + ceil32(return_data.size) + 32 len 32 * _9412] = mem[_9124 + _9268 + 32 len 32 * _9412]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                        if 1 >= _9412:
                                            revert with 0, 50
                                        if mem[_9124 + ceil32(return_data.size) + 64] > -1:
                                            revert with 0, 17
                                        require ext_code.size(brushAddress)
                                        call brushAddress.0x42966c68 with:
                                             gas gas_remaining wei
                                            args mem[_9124 + ceil32(return_data.size) + 64]
                                else:
                                    if brushAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[32] > !_6375:
                                            revert with 0, 17
                                        mem[_6379 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_6379 + 100] = ext_call.return_data[32] + _6375
                                        mem[_6379 + 132] = 0
                                        mem[_6379 + 164] = 160
                                        mem[_6379 + 260] = mem[_6379]
                                        idx = 0
                                        s = _6379 + 292
                                        t = _6379 + 32
                                        while idx < mem[_6379]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_6379 + 196] = this.address
                                        mem[_6379 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _6379 + (32 * mem[_6379]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9125 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _9269 = mem[_9125]
                                        require mem[_9125] <= test266151307()
                                        require _9125 + mem[_9125] + 31 < _9125 + return_data.size
                                        _9413 = mem[_9125 + mem[_9125]]
                                        if mem[_9125 + mem[_9125]] > test266151307():
                                            revert with 0, 65
                                        if _9125 + ceil32(return_data.size) + ceil32(32 * mem[_9125 + mem[_9125]]) + 1 > test266151307() or ceil32(32 * mem[_9125 + mem[_9125]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _9125 + ceil32(return_data.size) + ceil32(32 * mem[_9125 + mem[_9125]]) + 1
                                        mem[_9125 + ceil32(return_data.size)] = _9413
                                        require return_data.size >= _9269 + (32 * _9413) + 32
                                        mem[_9125 + ceil32(return_data.size) + 32 len 32 * _9413] = mem[_9125 + _9269 + 32 len 32 * _9413]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                        if 1 >= _9413:
                                            revert with 0, 50
                                        if mem[_9125 + ceil32(return_data.size) + 64] > -1:
                                            revert with 0, 17
                                        require ext_code.size(brushAddress)
                                        call brushAddress.0x42966c68 with:
                                             gas gas_remaining wei
                                            args mem[_9125 + ceil32(return_data.size) + 64]
                                    else:
                                        if brushAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[0] > !_6375:
                                                revert with 0, 17
                                            mem[_6379 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_6379 + 100] = ext_call.return_data[0] + _6375
                                            mem[_6379 + 132] = 0
                                            mem[_6379 + 164] = 160
                                            mem[_6379 + 260] = mem[_6379]
                                            idx = 0
                                            s = _6379 + 292
                                            t = _6379 + 32
                                            while idx < mem[_6379]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_6379 + 196] = this.address
                                            mem[_6379 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _6379 + (32 * mem[_6379]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9126 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _9270 = mem[_9126]
                                            require mem[_9126] <= test266151307()
                                            require _9126 + mem[_9126] + 31 < _9126 + return_data.size
                                            _9414 = mem[_9126 + mem[_9126]]
                                            if mem[_9126 + mem[_9126]] > test266151307():
                                                revert with 0, 65
                                            if _9126 + ceil32(return_data.size) + ceil32(32 * mem[_9126 + mem[_9126]]) + 1 > test266151307() or ceil32(32 * mem[_9126 + mem[_9126]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _9126 + ceil32(return_data.size) + ceil32(32 * mem[_9126 + mem[_9126]]) + 1
                                            mem[_9126 + ceil32(return_data.size)] = _9414
                                            require return_data.size >= _9270 + (32 * _9414) + 32
                                            mem[_9126 + ceil32(return_data.size) + 32 len 32 * _9414] = mem[_9126 + _9270 + 32 len 32 * _9414]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                            if 1 >= _9414:
                                                revert with 0, 50
                                            if mem[_9126 + ceil32(return_data.size) + 64] > -1:
                                                revert with 0, 17
                                            require ext_code.size(brushAddress)
                                            call brushAddress.0x42966c68 with:
                                                 gas gas_remaining wei
                                                args mem[_9126 + ceil32(return_data.size) + 64]
                                        else:
                                            if wftmAddress == address(ext_call.return_data[0]):
                                                if ext_call.return_data[32] > !_6375:
                                                    revert with 0, 17
                                                mem[_6379 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[_6379 + 100] = ext_call.return_data[32] + _6375
                                                mem[_6379 + 132] = 0
                                                mem[_6379 + 164] = 160
                                                mem[_6379 + 260] = mem[_6379]
                                                idx = 0
                                                s = _6379 + 292
                                                t = _6379 + 32
                                                while idx < mem[_6379]:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[_6379 + 196] = this.address
                                                mem[_6379 + 228] = block.timestamp + 10000
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len _6379 + (32 * mem[_6379]) + -mem[64] + 288]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _9127 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _9271 = mem[_9127]
                                                require mem[_9127] <= test266151307()
                                                require _9127 + mem[_9127] + 31 < _9127 + return_data.size
                                                _9415 = mem[_9127 + mem[_9127]]
                                                if mem[_9127 + mem[_9127]] > test266151307():
                                                    revert with 0, 65
                                                if _9127 + ceil32(return_data.size) + ceil32(32 * mem[_9127 + mem[_9127]]) + 1 > test266151307() or ceil32(32 * mem[_9127 + mem[_9127]]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[64] = _9127 + ceil32(return_data.size) + ceil32(32 * mem[_9127 + mem[_9127]]) + 1
                                                mem[_9127 + ceil32(return_data.size)] = _9415
                                                require return_data.size >= _9271 + (32 * _9415) + 32
                                                mem[_9127 + ceil32(return_data.size) + 32 len 32 * _9415] = mem[_9127 + _9271 + 32 len 32 * _9415]
                                                if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                    revert with 0, 17
                                                maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                                if 1 >= _9415:
                                                    revert with 0, 50
                                                if mem[_9127 + ceil32(return_data.size) + 64] > -1:
                                                    revert with 0, 17
                                                require ext_code.size(brushAddress)
                                                call brushAddress.0x42966c68 with:
                                                     gas gas_remaining wei
                                                    args mem[_9127 + ceil32(return_data.size) + 64]
                                            else:
                                                if ext_call.return_data[0] > !_6375:
                                                    revert with 0, 17
                                                mem[_6379 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[_6379 + 100] = ext_call.return_data[0] + _6375
                                                mem[_6379 + 132] = 0
                                                mem[_6379 + 164] = 160
                                                mem[_6379 + 260] = mem[_6379]
                                                idx = 0
                                                s = _6379 + 292
                                                t = _6379 + 32
                                                while idx < mem[_6379]:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[_6379 + 196] = this.address
                                                mem[_6379 + 228] = block.timestamp + 10000
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len _6379 + (32 * mem[_6379]) + -mem[64] + 288]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _9128 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _9272 = mem[_9128]
                                                require mem[_9128] <= test266151307()
                                                require _9128 + mem[_9128] + 31 < _9128 + return_data.size
                                                _9416 = mem[_9128 + mem[_9128]]
                                                if mem[_9128 + mem[_9128]] > test266151307():
                                                    revert with 0, 65
                                                if _9128 + ceil32(return_data.size) + ceil32(32 * mem[_9128 + mem[_9128]]) + 1 > test266151307() or ceil32(32 * mem[_9128 + mem[_9128]]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[64] = _9128 + ceil32(return_data.size) + ceil32(32 * mem[_9128 + mem[_9128]]) + 1
                                                mem[_9128 + ceil32(return_data.size)] = _9416
                                                require return_data.size >= _9272 + (32 * _9416) + 32
                                                mem[_9128 + ceil32(return_data.size) + 32 len 32 * _9416] = mem[_9128 + _9272 + 32 len 32 * _9416]
                                                if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                    revert with 0, 17
                                                maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                                if 1 >= _9416:
                                                    revert with 0, 50
                                                if mem[_9128 + ceil32(return_data.size) + 64] > -1:
                                                    revert with 0, 17
                                                require ext_code.size(brushAddress)
                                                call brushAddress.0x42966c68 with:
                                                     gas gas_remaining wei
                                                    args mem[_9128 + ceil32(return_data.size) + 64]
                            else:
                                if wftmAddress == address(ext_call.return_data[0]):
                                    if brushAddress != address(ext_call.return_data[0]):
                                        if wftmAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_6375:
                                                revert with 0, 17
                                            mem[_6379 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_6379 + 100] = ext_call.return_data[32] + _6375
                                            mem[_6379 + 132] = 0
                                            mem[_6379 + 164] = 160
                                            mem[_6379 + 260] = mem[_6379]
                                            idx = 0
                                            s = _6379 + 292
                                            t = _6379 + 32
                                            while idx < mem[_6379]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_6379 + 196] = this.address
                                            mem[_6379 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _6379 + (32 * mem[_6379]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9129 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _9273 = mem[_9129]
                                            require mem[_9129] <= test266151307()
                                            require _9129 + mem[_9129] + 31 < _9129 + return_data.size
                                            _9417 = mem[_9129 + mem[_9129]]
                                            if mem[_9129 + mem[_9129]] > test266151307():
                                                revert with 0, 65
                                            if _9129 + ceil32(return_data.size) + ceil32(32 * mem[_9129 + mem[_9129]]) + 1 > test266151307() or ceil32(32 * mem[_9129 + mem[_9129]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _9129 + ceil32(return_data.size) + ceil32(32 * mem[_9129 + mem[_9129]]) + 1
                                            mem[_9129 + ceil32(return_data.size)] = _9417
                                            require return_data.size >= _9273 + (32 * _9417) + 32
                                            mem[_9129 + ceil32(return_data.size) + 32 len 32 * _9417] = mem[_9129 + _9273 + 32 len 32 * _9417]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                            if 1 >= _9417:
                                                revert with 0, 50
                                            if mem[_9129 + ceil32(return_data.size) + 64] > -1:
                                                revert with 0, 17
                                            require ext_code.size(brushAddress)
                                            call brushAddress.0x42966c68 with:
                                                 gas gas_remaining wei
                                                args mem[_9129 + ceil32(return_data.size) + 64]
                                        else:
                                            if ext_call.return_data[0] > !_6375:
                                                revert with 0, 17
                                            mem[_6379 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_6379 + 100] = ext_call.return_data[0] + _6375
                                            mem[_6379 + 132] = 0
                                            mem[_6379 + 164] = 160
                                            mem[_6379 + 260] = mem[_6379]
                                            idx = 0
                                            s = _6379 + 292
                                            t = _6379 + 32
                                            while idx < mem[_6379]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_6379 + 196] = this.address
                                            mem[_6379 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _6379 + (32 * mem[_6379]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9130 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _9274 = mem[_9130]
                                            require mem[_9130] <= test266151307()
                                            require _9130 + mem[_9130] + 31 < _9130 + return_data.size
                                            _9418 = mem[_9130 + mem[_9130]]
                                            if mem[_9130 + mem[_9130]] > test266151307():
                                                revert with 0, 65
                                            if _9130 + ceil32(return_data.size) + ceil32(32 * mem[_9130 + mem[_9130]]) + 1 > test266151307() or ceil32(32 * mem[_9130 + mem[_9130]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _9130 + ceil32(return_data.size) + ceil32(32 * mem[_9130 + mem[_9130]]) + 1
                                            mem[_9130 + ceil32(return_data.size)] = _9418
                                            require return_data.size >= _9274 + (32 * _9418) + 32
                                            mem[_9130 + ceil32(return_data.size) + 32 len 32 * _9418] = mem[_9130 + _9274 + 32 len 32 * _9418]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                            if 1 >= _9418:
                                                revert with 0, 50
                                            if mem[_9130 + ceil32(return_data.size) + 64] > -1:
                                                revert with 0, 17
                                            require ext_code.size(brushAddress)
                                            call brushAddress.0x42966c68 with:
                                                 gas gas_remaining wei
                                                args mem[_9130 + ceil32(return_data.size) + 64]
                                    else:
                                        if brushAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_6375:
                                                revert with 0, 17
                                            mem[_6379 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_6379 + 100] = ext_call.return_data[32] + _6375
                                            mem[_6379 + 132] = 0
                                            mem[_6379 + 164] = 160
                                            mem[_6379 + 260] = mem[_6379]
                                            idx = 0
                                            s = _6379 + 292
                                            t = _6379 + 32
                                            while idx < mem[_6379]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_6379 + 196] = this.address
                                            mem[_6379 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _6379 + (32 * mem[_6379]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9131 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _9275 = mem[_9131]
                                            require mem[_9131] <= test266151307()
                                            require _9131 + mem[_9131] + 31 < _9131 + return_data.size
                                            _9419 = mem[_9131 + mem[_9131]]
                                            if mem[_9131 + mem[_9131]] > test266151307():
                                                revert with 0, 65
                                            if _9131 + ceil32(return_data.size) + ceil32(32 * mem[_9131 + mem[_9131]]) + 1 > test266151307() or ceil32(32 * mem[_9131 + mem[_9131]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _9131 + ceil32(return_data.size) + ceil32(32 * mem[_9131 + mem[_9131]]) + 1
                                            mem[_9131 + ceil32(return_data.size)] = _9419
                                            require return_data.size >= _9275 + (32 * _9419) + 32
                                            mem[_9131 + ceil32(return_data.size) + 32 len 32 * _9419] = mem[_9131 + _9275 + 32 len 32 * _9419]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                            if 1 >= _9419:
                                                revert with 0, 50
                                            if mem[_9131 + ceil32(return_data.size) + 64] > -1:
                                                revert with 0, 17
                                            require ext_code.size(brushAddress)
                                            call brushAddress.0x42966c68 with:
                                                 gas gas_remaining wei
                                                args mem[_9131 + ceil32(return_data.size) + 64]
                                        else:
                                            if brushAddress == address(ext_call.return_data[0]):
                                                if ext_call.return_data[0] > !_6375:
                                                    revert with 0, 17
                                                mem[_6379 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[_6379 + 100] = ext_call.return_data[0] + _6375
                                                mem[_6379 + 132] = 0
                                                mem[_6379 + 164] = 160
                                                mem[_6379 + 260] = mem[_6379]
                                                idx = 0
                                                s = _6379 + 292
                                                t = _6379 + 32
                                                while idx < mem[_6379]:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[_6379 + 196] = this.address
                                                mem[_6379 + 228] = block.timestamp + 10000
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len _6379 + (32 * mem[_6379]) + -mem[64] + 288]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _9132 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _9276 = mem[_9132]
                                                require mem[_9132] <= test266151307()
                                                require _9132 + mem[_9132] + 31 < _9132 + return_data.size
                                                _9420 = mem[_9132 + mem[_9132]]
                                                if mem[_9132 + mem[_9132]] > test266151307():
                                                    revert with 0, 65
                                                if _9132 + ceil32(return_data.size) + ceil32(32 * mem[_9132 + mem[_9132]]) + 1 > test266151307() or ceil32(32 * mem[_9132 + mem[_9132]]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[64] = _9132 + ceil32(return_data.size) + ceil32(32 * mem[_9132 + mem[_9132]]) + 1
                                                mem[_9132 + ceil32(return_data.size)] = _9420
                                                require return_data.size >= _9276 + (32 * _9420) + 32
                                                mem[_9132 + ceil32(return_data.size) + 32 len 32 * _9420] = mem[_9132 + _9276 + 32 len 32 * _9420]
                                                if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                    revert with 0, 17
                                                maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                                if 1 >= _9420:
                                                    revert with 0, 50
                                                if mem[_9132 + ceil32(return_data.size) + 64] > -1:
                                                    revert with 0, 17
                                                require ext_code.size(brushAddress)
                                                call brushAddress.0x42966c68 with:
                                                     gas gas_remaining wei
                                                    args mem[_9132 + ceil32(return_data.size) + 64]
                                            else:
                                                if wftmAddress == address(ext_call.return_data[0]):
                                                    if ext_call.return_data[32] > !_6375:
                                                        revert with 0, 17
                                                    mem[_6379 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[_6379 + 100] = ext_call.return_data[32] + _6375
                                                    mem[_6379 + 132] = 0
                                                    mem[_6379 + 164] = 160
                                                    mem[_6379 + 260] = mem[_6379]
                                                    idx = 0
                                                    s = _6379 + 292
                                                    t = _6379 + 32
                                                    while idx < mem[_6379]:
                                                        mem[s] = mem[t + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[_6379 + 196] = this.address
                                                    mem[_6379 + 228] = block.timestamp + 10000
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len _6379 + (32 * mem[_6379]) + -mem[64] + 288]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _9133 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _9277 = mem[_9133]
                                                    require mem[_9133] <= test266151307()
                                                    require _9133 + mem[_9133] + 31 < _9133 + return_data.size
                                                    _9421 = mem[_9133 + mem[_9133]]
                                                    if mem[_9133 + mem[_9133]] > test266151307():
                                                        revert with 0, 65
                                                    if _9133 + ceil32(return_data.size) + ceil32(32 * mem[_9133 + mem[_9133]]) + 1 > test266151307() or ceil32(32 * mem[_9133 + mem[_9133]]) + 1 < 0:
                                                        revert with 0, 65
                                                    mem[64] = _9133 + ceil32(return_data.size) + ceil32(32 * mem[_9133 + mem[_9133]]) + 1
                                                    mem[_9133 + ceil32(return_data.size)] = _9421
                                                    require return_data.size >= _9277 + (32 * _9421) + 32
                                                    mem[_9133 + ceil32(return_data.size) + 32 len 32 * _9421] = mem[_9133 + _9277 + 32 len 32 * _9421]
                                                    if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                        revert with 0, 17
                                                    maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                                    if 1 >= _9421:
                                                        revert with 0, 50
                                                    if mem[_9133 + ceil32(return_data.size) + 64] > -1:
                                                        revert with 0, 17
                                                    require ext_code.size(brushAddress)
                                                    call brushAddress.0x42966c68 with:
                                                         gas gas_remaining wei
                                                        args mem[_9133 + ceil32(return_data.size) + 64]
                                                else:
                                                    if ext_call.return_data[0] > !_6375:
                                                        revert with 0, 17
                                                    mem[_6379 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[_6379 + 100] = ext_call.return_data[0] + _6375
                                                    mem[_6379 + 132] = 0
                                                    mem[_6379 + 164] = 160
                                                    mem[_6379 + 260] = mem[_6379]
                                                    idx = 0
                                                    s = _6379 + 292
                                                    t = _6379 + 32
                                                    while idx < mem[_6379]:
                                                        mem[s] = mem[t + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[_6379 + 196] = this.address
                                                    mem[_6379 + 228] = block.timestamp + 10000
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len _6379 + (32 * mem[_6379]) + -mem[64] + 288]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _9134 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _9278 = mem[_9134]
                                                    require mem[_9134] <= test266151307()
                                                    require _9134 + mem[_9134] + 31 < _9134 + return_data.size
                                                    _9422 = mem[_9134 + mem[_9134]]
                                                    if mem[_9134 + mem[_9134]] > test266151307():
                                                        revert with 0, 65
                                                    if _9134 + ceil32(return_data.size) + ceil32(32 * mem[_9134 + mem[_9134]]) + 1 > test266151307() or ceil32(32 * mem[_9134 + mem[_9134]]) + 1 < 0:
                                                        revert with 0, 65
                                                    mem[64] = _9134 + ceil32(return_data.size) + ceil32(32 * mem[_9134 + mem[_9134]]) + 1
                                                    mem[_9134 + ceil32(return_data.size)] = _9422
                                                    require return_data.size >= _9278 + (32 * _9422) + 32
                                                    mem[_9134 + ceil32(return_data.size) + 32 len 32 * _9422] = mem[_9134 + _9278 + 32 len 32 * _9422]
                                                    if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                        revert with 0, 17
                                                    maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                                    if 1 >= _9422:
                                                        revert with 0, 50
                                                    if mem[_9134 + ceil32(return_data.size) + 64] > -1:
                                                        revert with 0, 17
                                                    require ext_code.size(brushAddress)
                                                    call brushAddress.0x42966c68 with:
                                                         gas gas_remaining wei
                                                        args mem[_9134 + ceil32(return_data.size) + 64]
                                else:
                                    if brushAddress != address(ext_call.return_data[0]):
                                        if wftmAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_6375:
                                                revert with 0, 17
                                            mem[_6379 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_6379 + 100] = ext_call.return_data[32] + _6375
                                            mem[_6379 + 132] = 0
                                            mem[_6379 + 164] = 160
                                            mem[_6379 + 260] = mem[_6379]
                                            idx = 0
                                            s = _6379 + 292
                                            t = _6379 + 32
                                            while idx < mem[_6379]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_6379 + 196] = this.address
                                            mem[_6379 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _6379 + (32 * mem[_6379]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9135 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _9279 = mem[_9135]
                                            require mem[_9135] <= test266151307()
                                            require _9135 + mem[_9135] + 31 < _9135 + return_data.size
                                            _9423 = mem[_9135 + mem[_9135]]
                                            if mem[_9135 + mem[_9135]] > test266151307():
                                                revert with 0, 65
                                            if _9135 + ceil32(return_data.size) + ceil32(32 * mem[_9135 + mem[_9135]]) + 1 > test266151307() or ceil32(32 * mem[_9135 + mem[_9135]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _9135 + ceil32(return_data.size) + ceil32(32 * mem[_9135 + mem[_9135]]) + 1
                                            mem[_9135 + ceil32(return_data.size)] = _9423
                                            require return_data.size >= _9279 + (32 * _9423) + 32
                                            mem[_9135 + ceil32(return_data.size) + 32 len 32 * _9423] = mem[_9135 + _9279 + 32 len 32 * _9423]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                            if 1 >= _9423:
                                                revert with 0, 50
                                            if mem[_9135 + ceil32(return_data.size) + 64] > -1:
                                                revert with 0, 17
                                            require ext_code.size(brushAddress)
                                            call brushAddress.0x42966c68 with:
                                                 gas gas_remaining wei
                                                args mem[_9135 + ceil32(return_data.size) + 64]
                                        else:
                                            if ext_call.return_data[0] > !_6375:
                                                revert with 0, 17
                                            mem[_6379 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_6379 + 100] = ext_call.return_data[0] + _6375
                                            mem[_6379 + 132] = 0
                                            mem[_6379 + 164] = 160
                                            mem[_6379 + 260] = mem[_6379]
                                            idx = 0
                                            s = _6379 + 292
                                            t = _6379 + 32
                                            while idx < mem[_6379]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_6379 + 196] = this.address
                                            mem[_6379 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _6379 + (32 * mem[_6379]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9136 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _9280 = mem[_9136]
                                            require mem[_9136] <= test266151307()
                                            require _9136 + mem[_9136] + 31 < _9136 + return_data.size
                                            _9424 = mem[_9136 + mem[_9136]]
                                            if mem[_9136 + mem[_9136]] > test266151307():
                                                revert with 0, 65
                                            if _9136 + ceil32(return_data.size) + ceil32(32 * mem[_9136 + mem[_9136]]) + 1 > test266151307() or ceil32(32 * mem[_9136 + mem[_9136]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _9136 + ceil32(return_data.size) + ceil32(32 * mem[_9136 + mem[_9136]]) + 1
                                            mem[_9136 + ceil32(return_data.size)] = _9424
                                            require return_data.size >= _9280 + (32 * _9424) + 32
                                            mem[_9136 + ceil32(return_data.size) + 32 len 32 * _9424] = mem[_9136 + _9280 + 32 len 32 * _9424]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                            if 1 >= _9424:
                                                revert with 0, 50
                                            if mem[_9136 + ceil32(return_data.size) + 64] > -1:
                                                revert with 0, 17
                                            require ext_code.size(brushAddress)
                                            call brushAddress.0x42966c68 with:
                                                 gas gas_remaining wei
                                                args mem[_9136 + ceil32(return_data.size) + 64]
                                    else:
                                        if brushAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_6375:
                                                revert with 0, 17
                                            mem[_6379 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_6379 + 100] = ext_call.return_data[32] + _6375
                                            mem[_6379 + 132] = 0
                                            mem[_6379 + 164] = 160
                                            mem[_6379 + 260] = mem[_6379]
                                            idx = 0
                                            s = _6379 + 292
                                            t = _6379 + 32
                                            while idx < mem[_6379]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_6379 + 196] = this.address
                                            mem[_6379 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _6379 + (32 * mem[_6379]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9137 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _9281 = mem[_9137]
                                            require mem[_9137] <= test266151307()
                                            require _9137 + mem[_9137] + 31 < _9137 + return_data.size
                                            _9425 = mem[_9137 + mem[_9137]]
                                            if mem[_9137 + mem[_9137]] > test266151307():
                                                revert with 0, 65
                                            if _9137 + ceil32(return_data.size) + ceil32(32 * mem[_9137 + mem[_9137]]) + 1 > test266151307() or ceil32(32 * mem[_9137 + mem[_9137]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _9137 + ceil32(return_data.size) + ceil32(32 * mem[_9137 + mem[_9137]]) + 1
                                            mem[_9137 + ceil32(return_data.size)] = _9425
                                            require return_data.size >= _9281 + (32 * _9425) + 32
                                            mem[_9137 + ceil32(return_data.size) + 32 len 32 * _9425] = mem[_9137 + _9281 + 32 len 32 * _9425]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                            if 1 >= _9425:
                                                revert with 0, 50
                                            if mem[_9137 + ceil32(return_data.size) + 64] > -1:
                                                revert with 0, 17
                                            require ext_code.size(brushAddress)
                                            call brushAddress.0x42966c68 with:
                                                 gas gas_remaining wei
                                                args mem[_9137 + ceil32(return_data.size) + 64]
                                        else:
                                            if brushAddress == address(ext_call.return_data[0]):
                                                if ext_call.return_data[0] > !_6375:
                                                    revert with 0, 17
                                                mem[_6379 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[_6379 + 100] = ext_call.return_data[0] + _6375
                                                mem[_6379 + 132] = 0
                                                mem[_6379 + 164] = 160
                                                mem[_6379 + 260] = mem[_6379]
                                                idx = 0
                                                s = _6379 + 292
                                                t = _6379 + 32
                                                while idx < mem[_6379]:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[_6379 + 196] = this.address
                                                mem[_6379 + 228] = block.timestamp + 10000
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len _6379 + (32 * mem[_6379]) + -mem[64] + 288]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _9138 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _9282 = mem[_9138]
                                                require mem[_9138] <= test266151307()
                                                require _9138 + mem[_9138] + 31 < _9138 + return_data.size
                                                _9426 = mem[_9138 + mem[_9138]]
                                                if mem[_9138 + mem[_9138]] > test266151307():
                                                    revert with 0, 65
                                                if _9138 + ceil32(return_data.size) + ceil32(32 * mem[_9138 + mem[_9138]]) + 1 > test266151307() or ceil32(32 * mem[_9138 + mem[_9138]]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[64] = _9138 + ceil32(return_data.size) + ceil32(32 * mem[_9138 + mem[_9138]]) + 1
                                                mem[_9138 + ceil32(return_data.size)] = _9426
                                                require return_data.size >= _9282 + (32 * _9426) + 32
                                                mem[_9138 + ceil32(return_data.size) + 32 len 32 * _9426] = mem[_9138 + _9282 + 32 len 32 * _9426]
                                                if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                    revert with 0, 17
                                                maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                                if 1 >= _9426:
                                                    revert with 0, 50
                                                if mem[_9138 + ceil32(return_data.size) + 64] > -1:
                                                    revert with 0, 17
                                                require ext_code.size(brushAddress)
                                                call brushAddress.0x42966c68 with:
                                                     gas gas_remaining wei
                                                    args mem[_9138 + ceil32(return_data.size) + 64]
                                            else:
                                                if wftmAddress == address(ext_call.return_data[0]):
                                                    if ext_call.return_data[32] > !_6375:
                                                        revert with 0, 17
                                                    mem[_6379 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[_6379 + 100] = ext_call.return_data[32] + _6375
                                                    mem[_6379 + 132] = 0
                                                    mem[_6379 + 164] = 160
                                                    mem[_6379 + 260] = mem[_6379]
                                                    idx = 0
                                                    s = _6379 + 292
                                                    t = _6379 + 32
                                                    while idx < mem[_6379]:
                                                        mem[s] = mem[t + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[_6379 + 196] = this.address
                                                    mem[_6379 + 228] = block.timestamp + 10000
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len _6379 + (32 * mem[_6379]) + -mem[64] + 288]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _9139 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _9283 = mem[_9139]
                                                    require mem[_9139] <= test266151307()
                                                    require _9139 + mem[_9139] + 31 < _9139 + return_data.size
                                                    _9427 = mem[_9139 + mem[_9139]]
                                                    if mem[_9139 + mem[_9139]] > test266151307():
                                                        revert with 0, 65
                                                    if _9139 + ceil32(return_data.size) + ceil32(32 * mem[_9139 + mem[_9139]]) + 1 > test266151307() or ceil32(32 * mem[_9139 + mem[_9139]]) + 1 < 0:
                                                        revert with 0, 65
                                                    mem[64] = _9139 + ceil32(return_data.size) + ceil32(32 * mem[_9139 + mem[_9139]]) + 1
                                                    mem[_9139 + ceil32(return_data.size)] = _9427
                                                    require return_data.size >= _9283 + (32 * _9427) + 32
                                                    mem[_9139 + ceil32(return_data.size) + 32 len 32 * _9427] = mem[_9139 + _9283 + 32 len 32 * _9427]
                                                    if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                        revert with 0, 17
                                                    maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                                    if 1 >= _9427:
                                                        revert with 0, 50
                                                    if mem[_9139 + ceil32(return_data.size) + 64] > -1:
                                                        revert with 0, 17
                                                    require ext_code.size(brushAddress)
                                                    call brushAddress.0x42966c68 with:
                                                         gas gas_remaining wei
                                                        args mem[_9139 + ceil32(return_data.size) + 64]
                                                else:
                                                    if ext_call.return_data[0] > !_6375:
                                                        revert with 0, 17
                                                    mem[_6379 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[_6379 + 100] = ext_call.return_data[0] + _6375
                                                    mem[_6379 + 132] = 0
                                                    mem[_6379 + 164] = 160
                                                    mem[_6379 + 260] = mem[_6379]
                                                    idx = 0
                                                    s = _6379 + 292
                                                    t = _6379 + 32
                                                    while idx < mem[_6379]:
                                                        mem[s] = mem[t + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[_6379 + 196] = this.address
                                                    mem[_6379 + 228] = block.timestamp + 10000
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len _6379 + (32 * mem[_6379]) + -mem[64] + 288]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _9140 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _9284 = mem[_9140]
                                                    require mem[_9140] <= test266151307()
                                                    require _9140 + mem[_9140] + 31 < _9140 + return_data.size
                                                    _9428 = mem[_9140 + mem[_9140]]
                                                    if mem[_9140 + mem[_9140]] > test266151307():
                                                        revert with 0, 65
                                                    if _9140 + ceil32(return_data.size) + ceil32(32 * mem[_9140 + mem[_9140]]) + 1 > test266151307() or ceil32(32 * mem[_9140 + mem[_9140]]) + 1 < 0:
                                                        revert with 0, 65
                                                    mem[64] = _9140 + ceil32(return_data.size) + ceil32(32 * mem[_9140 + mem[_9140]]) + 1
                                                    mem[_9140 + ceil32(return_data.size)] = _9428
                                                    require return_data.size >= _9284 + (32 * _9428) + 32
                                                    mem[_9140 + ceil32(return_data.size) + 32 len 32 * _9428] = mem[_9140 + _9284 + 32 len 32 * _9428]
                                                    if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                        revert with 0, 17
                                                    maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                                    if 1 >= _9428:
                                                        revert with 0, 50
                                                    if mem[_9140 + ceil32(return_data.size) + 64] > -1:
                                                        revert with 0, 17
                                                    require ext_code.size(brushAddress)
                                                    call brushAddress.0x42966c68 with:
                                                         gas gas_remaining wei
                                                        args mem[_9140 + ceil32(return_data.size) + 64]
                else:
                    mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                    mem[(4 * ceil32(return_data.size)) + 228] = 0
                    mem[(4 * ceil32(return_data.size)) + 260] = 160
                    mem[(4 * ceil32(return_data.size)) + 356] = 2
                    idx = 0
                    s = (4 * ceil32(return_data.size)) + 388
                    t = (4 * ceil32(return_data.size)) + 128
                    while idx < 2:
                        mem[s] = mem[t + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[(4 * ceil32(return_data.size)) + 292] = this.address
                    mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                    require ext_code.size(routerAddress)
                    call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                         gas gas_remaining wei
                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = (6 * ceil32(return_data.size)) + 192
                    require return_data.size >= 32
                    _3526 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                    require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                    require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                    _3605 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                    if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                        revert with 0, 65
                    if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                        revert with 0, 65
                    mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193
                    mem[(6 * ceil32(return_data.size)) + 192] = _3605
                    require return_data.size >= _3526 + (32 * _3605) + 32
                    mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3605] = mem[(4 * ceil32(return_data.size)) + _3526 + 224 len 32 * _3605]
                    if 1 >= _3605:
                        revert with 0, 50
                    _6376 = mem[(6 * ceil32(return_data.size)) + 256]
                    _6380 = mem[64]
                    mem[mem[64]] = 2
                    mem[64] = mem[64] + 96
                    if 0 >= mem[_6380]:
                        revert with 0, 50
                    mem[_6380 + 32] = address(ext_call.return_data[0])
                    if 1 >= mem[_6380]:
                        revert with 0, 50
                    mem[_6380 + 64] = brushAddress
                    if brushAddress != address(ext_call.return_data[0]):
                        if wftmAddress == address(ext_call.return_data[0]):
                            if brushAddress != address(ext_call.return_data[0]):
                                if wftmAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_6376:
                                        revert with 0, 17
                                    mem[_6380 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_6380 + 100] = ext_call.return_data[32] + _6376
                                    mem[_6380 + 132] = 0
                                    mem[_6380 + 164] = 160
                                    mem[_6380 + 260] = mem[_6380]
                                    idx = 0
                                    s = _6380 + 292
                                    t = _6380 + 32
                                    while idx < mem[_6380]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_6380 + 196] = this.address
                                    mem[_6380 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _6380 + (32 * mem[_6380]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9141 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _9285 = mem[_9141]
                                    require mem[_9141] <= test266151307()
                                    require _9141 + mem[_9141] + 31 < _9141 + return_data.size
                                    _9429 = mem[_9141 + mem[_9141]]
                                    if mem[_9141 + mem[_9141]] > test266151307():
                                        revert with 0, 65
                                    if _9141 + ceil32(return_data.size) + ceil32(32 * mem[_9141 + mem[_9141]]) + 1 > test266151307() or ceil32(32 * mem[_9141 + mem[_9141]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _9141 + ceil32(return_data.size) + ceil32(32 * mem[_9141 + mem[_9141]]) + 1
                                    mem[_9141 + ceil32(return_data.size)] = _9429
                                    require return_data.size >= _9285 + (32 * _9429) + 32
                                    mem[_9141 + ceil32(return_data.size) + 32 len 32 * _9429] = mem[_9141 + _9285 + 32 len 32 * _9429]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                    if 1 >= _9429:
                                        revert with 0, 50
                                    if mem[_9141 + ceil32(return_data.size) + 64] > -1:
                                        revert with 0, 17
                                    require ext_code.size(brushAddress)
                                    call brushAddress.0x42966c68 with:
                                         gas gas_remaining wei
                                        args mem[_9141 + ceil32(return_data.size) + 64]
                                else:
                                    if ext_call.return_data[0] > !_6376:
                                        revert with 0, 17
                                    mem[_6380 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_6380 + 100] = ext_call.return_data[0] + _6376
                                    mem[_6380 + 132] = 0
                                    mem[_6380 + 164] = 160
                                    mem[_6380 + 260] = mem[_6380]
                                    idx = 0
                                    s = _6380 + 292
                                    t = _6380 + 32
                                    while idx < mem[_6380]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_6380 + 196] = this.address
                                    mem[_6380 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _6380 + (32 * mem[_6380]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9142 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _9286 = mem[_9142]
                                    require mem[_9142] <= test266151307()
                                    require _9142 + mem[_9142] + 31 < _9142 + return_data.size
                                    _9430 = mem[_9142 + mem[_9142]]
                                    if mem[_9142 + mem[_9142]] > test266151307():
                                        revert with 0, 65
                                    if _9142 + ceil32(return_data.size) + ceil32(32 * mem[_9142 + mem[_9142]]) + 1 > test266151307() or ceil32(32 * mem[_9142 + mem[_9142]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _9142 + ceil32(return_data.size) + ceil32(32 * mem[_9142 + mem[_9142]]) + 1
                                    mem[_9142 + ceil32(return_data.size)] = _9430
                                    require return_data.size >= _9286 + (32 * _9430) + 32
                                    mem[_9142 + ceil32(return_data.size) + 32 len 32 * _9430] = mem[_9142 + _9286 + 32 len 32 * _9430]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                    if 1 >= _9430:
                                        revert with 0, 50
                                    if mem[_9142 + ceil32(return_data.size) + 64] > -1:
                                        revert with 0, 17
                                    require ext_code.size(brushAddress)
                                    call brushAddress.0x42966c68 with:
                                         gas gas_remaining wei
                                        args mem[_9142 + ceil32(return_data.size) + 64]
                            else:
                                if brushAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_6376:
                                        revert with 0, 17
                                    mem[_6380 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_6380 + 100] = ext_call.return_data[32] + _6376
                                    mem[_6380 + 132] = 0
                                    mem[_6380 + 164] = 160
                                    mem[_6380 + 260] = mem[_6380]
                                    idx = 0
                                    s = _6380 + 292
                                    t = _6380 + 32
                                    while idx < mem[_6380]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_6380 + 196] = this.address
                                    mem[_6380 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _6380 + (32 * mem[_6380]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9143 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _9287 = mem[_9143]
                                    require mem[_9143] <= test266151307()
                                    require _9143 + mem[_9143] + 31 < _9143 + return_data.size
                                    _9431 = mem[_9143 + mem[_9143]]
                                    if mem[_9143 + mem[_9143]] > test266151307():
                                        revert with 0, 65
                                    if _9143 + ceil32(return_data.size) + ceil32(32 * mem[_9143 + mem[_9143]]) + 1 > test266151307() or ceil32(32 * mem[_9143 + mem[_9143]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _9143 + ceil32(return_data.size) + ceil32(32 * mem[_9143 + mem[_9143]]) + 1
                                    mem[_9143 + ceil32(return_data.size)] = _9431
                                    require return_data.size >= _9287 + (32 * _9431) + 32
                                    mem[_9143 + ceil32(return_data.size) + 32 len 32 * _9431] = mem[_9143 + _9287 + 32 len 32 * _9431]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                    if 1 >= _9431:
                                        revert with 0, 50
                                    if mem[_9143 + ceil32(return_data.size) + 64] > -1:
                                        revert with 0, 17
                                    require ext_code.size(brushAddress)
                                    call brushAddress.0x42966c68 with:
                                         gas gas_remaining wei
                                        args mem[_9143 + ceil32(return_data.size) + 64]
                                else:
                                    if brushAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[0] > !_6376:
                                            revert with 0, 17
                                        mem[_6380 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_6380 + 100] = ext_call.return_data[0] + _6376
                                        mem[_6380 + 132] = 0
                                        mem[_6380 + 164] = 160
                                        mem[_6380 + 260] = mem[_6380]
                                        idx = 0
                                        s = _6380 + 292
                                        t = _6380 + 32
                                        while idx < mem[_6380]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_6380 + 196] = this.address
                                        mem[_6380 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _6380 + (32 * mem[_6380]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9144 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _9288 = mem[_9144]
                                        require mem[_9144] <= test266151307()
                                        require _9144 + mem[_9144] + 31 < _9144 + return_data.size
                                        _9432 = mem[_9144 + mem[_9144]]
                                        if mem[_9144 + mem[_9144]] > test266151307():
                                            revert with 0, 65
                                        if _9144 + ceil32(return_data.size) + ceil32(32 * mem[_9144 + mem[_9144]]) + 1 > test266151307() or ceil32(32 * mem[_9144 + mem[_9144]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _9144 + ceil32(return_data.size) + ceil32(32 * mem[_9144 + mem[_9144]]) + 1
                                        mem[_9144 + ceil32(return_data.size)] = _9432
                                        require return_data.size >= _9288 + (32 * _9432) + 32
                                        mem[_9144 + ceil32(return_data.size) + 32 len 32 * _9432] = mem[_9144 + _9288 + 32 len 32 * _9432]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                        if 1 >= _9432:
                                            revert with 0, 50
                                        if mem[_9144 + ceil32(return_data.size) + 64] > -1:
                                            revert with 0, 17
                                        require ext_code.size(brushAddress)
                                        call brushAddress.0x42966c68 with:
                                             gas gas_remaining wei
                                            args mem[_9144 + ceil32(return_data.size) + 64]
                                    else:
                                        if wftmAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_6376:
                                                revert with 0, 17
                                            mem[_6380 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_6380 + 100] = ext_call.return_data[32] + _6376
                                            mem[_6380 + 132] = 0
                                            mem[_6380 + 164] = 160
                                            mem[_6380 + 260] = mem[_6380]
                                            idx = 0
                                            s = _6380 + 292
                                            t = _6380 + 32
                                            while idx < mem[_6380]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_6380 + 196] = this.address
                                            mem[_6380 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _6380 + (32 * mem[_6380]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9145 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _9289 = mem[_9145]
                                            require mem[_9145] <= test266151307()
                                            require _9145 + mem[_9145] + 31 < _9145 + return_data.size
                                            _9433 = mem[_9145 + mem[_9145]]
                                            if mem[_9145 + mem[_9145]] > test266151307():
                                                revert with 0, 65
                                            if _9145 + ceil32(return_data.size) + ceil32(32 * mem[_9145 + mem[_9145]]) + 1 > test266151307() or ceil32(32 * mem[_9145 + mem[_9145]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _9145 + ceil32(return_data.size) + ceil32(32 * mem[_9145 + mem[_9145]]) + 1
                                            mem[_9145 + ceil32(return_data.size)] = _9433
                                            require return_data.size >= _9289 + (32 * _9433) + 32
                                            mem[_9145 + ceil32(return_data.size) + 32 len 32 * _9433] = mem[_9145 + _9289 + 32 len 32 * _9433]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                            if 1 >= _9433:
                                                revert with 0, 50
                                            if mem[_9145 + ceil32(return_data.size) + 64] > -1:
                                                revert with 0, 17
                                            require ext_code.size(brushAddress)
                                            call brushAddress.0x42966c68 with:
                                                 gas gas_remaining wei
                                                args mem[_9145 + ceil32(return_data.size) + 64]
                                        else:
                                            if ext_call.return_data[0] > !_6376:
                                                revert with 0, 17
                                            mem[_6380 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_6380 + 100] = ext_call.return_data[0] + _6376
                                            mem[_6380 + 132] = 0
                                            mem[_6380 + 164] = 160
                                            mem[_6380 + 260] = mem[_6380]
                                            idx = 0
                                            s = _6380 + 292
                                            t = _6380 + 32
                                            while idx < mem[_6380]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_6380 + 196] = this.address
                                            mem[_6380 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _6380 + (32 * mem[_6380]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9146 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _9290 = mem[_9146]
                                            require mem[_9146] <= test266151307()
                                            require _9146 + mem[_9146] + 31 < _9146 + return_data.size
                                            _9434 = mem[_9146 + mem[_9146]]
                                            if mem[_9146 + mem[_9146]] > test266151307():
                                                revert with 0, 65
                                            if _9146 + ceil32(return_data.size) + ceil32(32 * mem[_9146 + mem[_9146]]) + 1 > test266151307() or ceil32(32 * mem[_9146 + mem[_9146]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _9146 + ceil32(return_data.size) + ceil32(32 * mem[_9146 + mem[_9146]]) + 1
                                            mem[_9146 + ceil32(return_data.size)] = _9434
                                            require return_data.size >= _9290 + (32 * _9434) + 32
                                            mem[_9146 + ceil32(return_data.size) + 32 len 32 * _9434] = mem[_9146 + _9290 + 32 len 32 * _9434]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                            if 1 >= _9434:
                                                revert with 0, 50
                                            if mem[_9146 + ceil32(return_data.size) + 64] > -1:
                                                revert with 0, 17
                                            require ext_code.size(brushAddress)
                                            call brushAddress.0x42966c68 with:
                                                 gas gas_remaining wei
                                                args mem[_9146 + ceil32(return_data.size) + 64]
                        else:
                            if brushAddress != address(ext_call.return_data[0]):
                                if wftmAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_6376:
                                        revert with 0, 17
                                    mem[_6380 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_6380 + 100] = ext_call.return_data[32] + _6376
                                    mem[_6380 + 132] = 0
                                    mem[_6380 + 164] = 160
                                    mem[_6380 + 260] = mem[_6380]
                                    idx = 0
                                    s = _6380 + 292
                                    t = _6380 + 32
                                    while idx < mem[_6380]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_6380 + 196] = this.address
                                    mem[_6380 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _6380 + (32 * mem[_6380]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9147 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _9291 = mem[_9147]
                                    require mem[_9147] <= test266151307()
                                    require _9147 + mem[_9147] + 31 < _9147 + return_data.size
                                    _9435 = mem[_9147 + mem[_9147]]
                                    if mem[_9147 + mem[_9147]] > test266151307():
                                        revert with 0, 65
                                    if _9147 + ceil32(return_data.size) + ceil32(32 * mem[_9147 + mem[_9147]]) + 1 > test266151307() or ceil32(32 * mem[_9147 + mem[_9147]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _9147 + ceil32(return_data.size) + ceil32(32 * mem[_9147 + mem[_9147]]) + 1
                                    mem[_9147 + ceil32(return_data.size)] = _9435
                                    require return_data.size >= _9291 + (32 * _9435) + 32
                                    mem[_9147 + ceil32(return_data.size) + 32 len 32 * _9435] = mem[_9147 + _9291 + 32 len 32 * _9435]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                    if 1 >= _9435:
                                        revert with 0, 50
                                    if mem[_9147 + ceil32(return_data.size) + 64] > -1:
                                        revert with 0, 17
                                    require ext_code.size(brushAddress)
                                    call brushAddress.0x42966c68 with:
                                         gas gas_remaining wei
                                        args mem[_9147 + ceil32(return_data.size) + 64]
                                else:
                                    if ext_call.return_data[0] > !_6376:
                                        revert with 0, 17
                                    mem[_6380 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_6380 + 100] = ext_call.return_data[0] + _6376
                                    mem[_6380 + 132] = 0
                                    mem[_6380 + 164] = 160
                                    mem[_6380 + 260] = mem[_6380]
                                    idx = 0
                                    s = _6380 + 292
                                    t = _6380 + 32
                                    while idx < mem[_6380]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_6380 + 196] = this.address
                                    mem[_6380 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _6380 + (32 * mem[_6380]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9148 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _9292 = mem[_9148]
                                    require mem[_9148] <= test266151307()
                                    require _9148 + mem[_9148] + 31 < _9148 + return_data.size
                                    _9436 = mem[_9148 + mem[_9148]]
                                    if mem[_9148 + mem[_9148]] > test266151307():
                                        revert with 0, 65
                                    if _9148 + ceil32(return_data.size) + ceil32(32 * mem[_9148 + mem[_9148]]) + 1 > test266151307() or ceil32(32 * mem[_9148 + mem[_9148]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _9148 + ceil32(return_data.size) + ceil32(32 * mem[_9148 + mem[_9148]]) + 1
                                    mem[_9148 + ceil32(return_data.size)] = _9436
                                    require return_data.size >= _9292 + (32 * _9436) + 32
                                    mem[_9148 + ceil32(return_data.size) + 32 len 32 * _9436] = mem[_9148 + _9292 + 32 len 32 * _9436]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                    if 1 >= _9436:
                                        revert with 0, 50
                                    if mem[_9148 + ceil32(return_data.size) + 64] > -1:
                                        revert with 0, 17
                                    require ext_code.size(brushAddress)
                                    call brushAddress.0x42966c68 with:
                                         gas gas_remaining wei
                                        args mem[_9148 + ceil32(return_data.size) + 64]
                            else:
                                if brushAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_6376:
                                        revert with 0, 17
                                    mem[_6380 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_6380 + 100] = ext_call.return_data[32] + _6376
                                    mem[_6380 + 132] = 0
                                    mem[_6380 + 164] = 160
                                    mem[_6380 + 260] = mem[_6380]
                                    idx = 0
                                    s = _6380 + 292
                                    t = _6380 + 32
                                    while idx < mem[_6380]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_6380 + 196] = this.address
                                    mem[_6380 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _6380 + (32 * mem[_6380]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9149 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _9293 = mem[_9149]
                                    require mem[_9149] <= test266151307()
                                    require _9149 + mem[_9149] + 31 < _9149 + return_data.size
                                    _9437 = mem[_9149 + mem[_9149]]
                                    if mem[_9149 + mem[_9149]] > test266151307():
                                        revert with 0, 65
                                    if _9149 + ceil32(return_data.size) + ceil32(32 * mem[_9149 + mem[_9149]]) + 1 > test266151307() or ceil32(32 * mem[_9149 + mem[_9149]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _9149 + ceil32(return_data.size) + ceil32(32 * mem[_9149 + mem[_9149]]) + 1
                                    mem[_9149 + ceil32(return_data.size)] = _9437
                                    require return_data.size >= _9293 + (32 * _9437) + 32
                                    mem[_9149 + ceil32(return_data.size) + 32 len 32 * _9437] = mem[_9149 + _9293 + 32 len 32 * _9437]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                    if 1 >= _9437:
                                        revert with 0, 50
                                    if mem[_9149 + ceil32(return_data.size) + 64] > -1:
                                        revert with 0, 17
                                    require ext_code.size(brushAddress)
                                    call brushAddress.0x42966c68 with:
                                         gas gas_remaining wei
                                        args mem[_9149 + ceil32(return_data.size) + 64]
                                else:
                                    if brushAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[0] > !_6376:
                                            revert with 0, 17
                                        mem[_6380 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_6380 + 100] = ext_call.return_data[0] + _6376
                                        mem[_6380 + 132] = 0
                                        mem[_6380 + 164] = 160
                                        mem[_6380 + 260] = mem[_6380]
                                        idx = 0
                                        s = _6380 + 292
                                        t = _6380 + 32
                                        while idx < mem[_6380]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_6380 + 196] = this.address
                                        mem[_6380 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _6380 + (32 * mem[_6380]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9150 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _9294 = mem[_9150]
                                        require mem[_9150] <= test266151307()
                                        require _9150 + mem[_9150] + 31 < _9150 + return_data.size
                                        _9438 = mem[_9150 + mem[_9150]]
                                        if mem[_9150 + mem[_9150]] > test266151307():
                                            revert with 0, 65
                                        if _9150 + ceil32(return_data.size) + ceil32(32 * mem[_9150 + mem[_9150]]) + 1 > test266151307() or ceil32(32 * mem[_9150 + mem[_9150]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _9150 + ceil32(return_data.size) + ceil32(32 * mem[_9150 + mem[_9150]]) + 1
                                        mem[_9150 + ceil32(return_data.size)] = _9438
                                        require return_data.size >= _9294 + (32 * _9438) + 32
                                        mem[_9150 + ceil32(return_data.size) + 32 len 32 * _9438] = mem[_9150 + _9294 + 32 len 32 * _9438]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                        if 1 >= _9438:
                                            revert with 0, 50
                                        if mem[_9150 + ceil32(return_data.size) + 64] > -1:
                                            revert with 0, 17
                                        require ext_code.size(brushAddress)
                                        call brushAddress.0x42966c68 with:
                                             gas gas_remaining wei
                                            args mem[_9150 + ceil32(return_data.size) + 64]
                                    else:
                                        if wftmAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_6376:
                                                revert with 0, 17
                                            mem[_6380 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_6380 + 100] = ext_call.return_data[32] + _6376
                                            mem[_6380 + 132] = 0
                                            mem[_6380 + 164] = 160
                                            mem[_6380 + 260] = mem[_6380]
                                            idx = 0
                                            s = _6380 + 292
                                            t = _6380 + 32
                                            while idx < mem[_6380]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_6380 + 196] = this.address
                                            mem[_6380 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _6380 + (32 * mem[_6380]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9151 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _9295 = mem[_9151]
                                            require mem[_9151] <= test266151307()
                                            require _9151 + mem[_9151] + 31 < _9151 + return_data.size
                                            _9439 = mem[_9151 + mem[_9151]]
                                            if mem[_9151 + mem[_9151]] > test266151307():
                                                revert with 0, 65
                                            if _9151 + ceil32(return_data.size) + ceil32(32 * mem[_9151 + mem[_9151]]) + 1 > test266151307() or ceil32(32 * mem[_9151 + mem[_9151]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _9151 + ceil32(return_data.size) + ceil32(32 * mem[_9151 + mem[_9151]]) + 1
                                            mem[_9151 + ceil32(return_data.size)] = _9439
                                            require return_data.size >= _9295 + (32 * _9439) + 32
                                            mem[_9151 + ceil32(return_data.size) + 32 len 32 * _9439] = mem[_9151 + _9295 + 32 len 32 * _9439]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                            if 1 >= _9439:
                                                revert with 0, 50
                                            if mem[_9151 + ceil32(return_data.size) + 64] > -1:
                                                revert with 0, 17
                                            require ext_code.size(brushAddress)
                                            call brushAddress.0x42966c68 with:
                                                 gas gas_remaining wei
                                                args mem[_9151 + ceil32(return_data.size) + 64]
                                        else:
                                            if ext_call.return_data[0] > !_6376:
                                                revert with 0, 17
                                            mem[_6380 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_6380 + 100] = ext_call.return_data[0] + _6376
                                            mem[_6380 + 132] = 0
                                            mem[_6380 + 164] = 160
                                            mem[_6380 + 260] = mem[_6380]
                                            idx = 0
                                            s = _6380 + 292
                                            t = _6380 + 32
                                            while idx < mem[_6380]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_6380 + 196] = this.address
                                            mem[_6380 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _6380 + (32 * mem[_6380]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9152 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _9296 = mem[_9152]
                                            require mem[_9152] <= test266151307()
                                            require _9152 + mem[_9152] + 31 < _9152 + return_data.size
                                            _9440 = mem[_9152 + mem[_9152]]
                                            if mem[_9152 + mem[_9152]] > test266151307():
                                                revert with 0, 65
                                            if _9152 + ceil32(return_data.size) + ceil32(32 * mem[_9152 + mem[_9152]]) + 1 > test266151307() or ceil32(32 * mem[_9152 + mem[_9152]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _9152 + ceil32(return_data.size) + ceil32(32 * mem[_9152 + mem[_9152]]) + 1
                                            mem[_9152 + ceil32(return_data.size)] = _9440
                                            require return_data.size >= _9296 + (32 * _9440) + 32
                                            mem[_9152 + ceil32(return_data.size) + 32 len 32 * _9440] = mem[_9152 + _9296 + 32 len 32 * _9440]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                            if 1 >= _9440:
                                                revert with 0, 50
                                            if mem[_9152 + ceil32(return_data.size) + 64] > -1:
                                                revert with 0, 17
                                            require ext_code.size(brushAddress)
                                            call brushAddress.0x42966c68 with:
                                                 gas gas_remaining wei
                                                args mem[_9152 + ceil32(return_data.size) + 64]
                    else:
                        if brushAddress == address(ext_call.return_data[0]):
                            if brushAddress != address(ext_call.return_data[0]):
                                if wftmAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_6376:
                                        revert with 0, 17
                                    mem[_6380 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_6380 + 100] = ext_call.return_data[32] + _6376
                                    mem[_6380 + 132] = 0
                                    mem[_6380 + 164] = 160
                                    mem[_6380 + 260] = mem[_6380]
                                    idx = 0
                                    s = _6380 + 292
                                    t = _6380 + 32
                                    while idx < mem[_6380]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_6380 + 196] = this.address
                                    mem[_6380 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _6380 + (32 * mem[_6380]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9153 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _9297 = mem[_9153]
                                    require mem[_9153] <= test266151307()
                                    require _9153 + mem[_9153] + 31 < _9153 + return_data.size
                                    _9441 = mem[_9153 + mem[_9153]]
                                    if mem[_9153 + mem[_9153]] > test266151307():
                                        revert with 0, 65
                                    if _9153 + ceil32(return_data.size) + ceil32(32 * mem[_9153 + mem[_9153]]) + 1 > test266151307() or ceil32(32 * mem[_9153 + mem[_9153]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _9153 + ceil32(return_data.size) + ceil32(32 * mem[_9153 + mem[_9153]]) + 1
                                    mem[_9153 + ceil32(return_data.size)] = _9441
                                    require return_data.size >= _9297 + (32 * _9441) + 32
                                    mem[_9153 + ceil32(return_data.size) + 32 len 32 * _9441] = mem[_9153 + _9297 + 32 len 32 * _9441]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                    if 1 >= _9441:
                                        revert with 0, 50
                                    if mem[_9153 + ceil32(return_data.size) + 64] > -1:
                                        revert with 0, 17
                                    require ext_code.size(brushAddress)
                                    call brushAddress.0x42966c68 with:
                                         gas gas_remaining wei
                                        args mem[_9153 + ceil32(return_data.size) + 64]
                                else:
                                    if ext_call.return_data[0] > !_6376:
                                        revert with 0, 17
                                    mem[_6380 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_6380 + 100] = ext_call.return_data[0] + _6376
                                    mem[_6380 + 132] = 0
                                    mem[_6380 + 164] = 160
                                    mem[_6380 + 260] = mem[_6380]
                                    idx = 0
                                    s = _6380 + 292
                                    t = _6380 + 32
                                    while idx < mem[_6380]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_6380 + 196] = this.address
                                    mem[_6380 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _6380 + (32 * mem[_6380]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9154 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _9298 = mem[_9154]
                                    require mem[_9154] <= test266151307()
                                    require _9154 + mem[_9154] + 31 < _9154 + return_data.size
                                    _9442 = mem[_9154 + mem[_9154]]
                                    if mem[_9154 + mem[_9154]] > test266151307():
                                        revert with 0, 65
                                    if _9154 + ceil32(return_data.size) + ceil32(32 * mem[_9154 + mem[_9154]]) + 1 > test266151307() or ceil32(32 * mem[_9154 + mem[_9154]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _9154 + ceil32(return_data.size) + ceil32(32 * mem[_9154 + mem[_9154]]) + 1
                                    mem[_9154 + ceil32(return_data.size)] = _9442
                                    require return_data.size >= _9298 + (32 * _9442) + 32
                                    mem[_9154 + ceil32(return_data.size) + 32 len 32 * _9442] = mem[_9154 + _9298 + 32 len 32 * _9442]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                    if 1 >= _9442:
                                        revert with 0, 50
                                    if mem[_9154 + ceil32(return_data.size) + 64] > -1:
                                        revert with 0, 17
                                    require ext_code.size(brushAddress)
                                    call brushAddress.0x42966c68 with:
                                         gas gas_remaining wei
                                        args mem[_9154 + ceil32(return_data.size) + 64]
                            else:
                                if brushAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_6376:
                                        revert with 0, 17
                                    mem[_6380 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_6380 + 100] = ext_call.return_data[32] + _6376
                                    mem[_6380 + 132] = 0
                                    mem[_6380 + 164] = 160
                                    mem[_6380 + 260] = mem[_6380]
                                    idx = 0
                                    s = _6380 + 292
                                    t = _6380 + 32
                                    while idx < mem[_6380]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_6380 + 196] = this.address
                                    mem[_6380 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _6380 + (32 * mem[_6380]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9155 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _9299 = mem[_9155]
                                    require mem[_9155] <= test266151307()
                                    require _9155 + mem[_9155] + 31 < _9155 + return_data.size
                                    _9443 = mem[_9155 + mem[_9155]]
                                    if mem[_9155 + mem[_9155]] > test266151307():
                                        revert with 0, 65
                                    if _9155 + ceil32(return_data.size) + ceil32(32 * mem[_9155 + mem[_9155]]) + 1 > test266151307() or ceil32(32 * mem[_9155 + mem[_9155]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _9155 + ceil32(return_data.size) + ceil32(32 * mem[_9155 + mem[_9155]]) + 1
                                    mem[_9155 + ceil32(return_data.size)] = _9443
                                    require return_data.size >= _9299 + (32 * _9443) + 32
                                    mem[_9155 + ceil32(return_data.size) + 32 len 32 * _9443] = mem[_9155 + _9299 + 32 len 32 * _9443]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                    if 1 >= _9443:
                                        revert with 0, 50
                                    if mem[_9155 + ceil32(return_data.size) + 64] > -1:
                                        revert with 0, 17
                                    require ext_code.size(brushAddress)
                                    call brushAddress.0x42966c68 with:
                                         gas gas_remaining wei
                                        args mem[_9155 + ceil32(return_data.size) + 64]
                                else:
                                    if brushAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[0] > !_6376:
                                            revert with 0, 17
                                        mem[_6380 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_6380 + 100] = ext_call.return_data[0] + _6376
                                        mem[_6380 + 132] = 0
                                        mem[_6380 + 164] = 160
                                        mem[_6380 + 260] = mem[_6380]
                                        idx = 0
                                        s = _6380 + 292
                                        t = _6380 + 32
                                        while idx < mem[_6380]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_6380 + 196] = this.address
                                        mem[_6380 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _6380 + (32 * mem[_6380]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9156 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _9300 = mem[_9156]
                                        require mem[_9156] <= test266151307()
                                        require _9156 + mem[_9156] + 31 < _9156 + return_data.size
                                        _9444 = mem[_9156 + mem[_9156]]
                                        if mem[_9156 + mem[_9156]] > test266151307():
                                            revert with 0, 65
                                        if _9156 + ceil32(return_data.size) + ceil32(32 * mem[_9156 + mem[_9156]]) + 1 > test266151307() or ceil32(32 * mem[_9156 + mem[_9156]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _9156 + ceil32(return_data.size) + ceil32(32 * mem[_9156 + mem[_9156]]) + 1
                                        mem[_9156 + ceil32(return_data.size)] = _9444
                                        require return_data.size >= _9300 + (32 * _9444) + 32
                                        mem[_9156 + ceil32(return_data.size) + 32 len 32 * _9444] = mem[_9156 + _9300 + 32 len 32 * _9444]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                        if 1 >= _9444:
                                            revert with 0, 50
                                        if mem[_9156 + ceil32(return_data.size) + 64] > -1:
                                            revert with 0, 17
                                        require ext_code.size(brushAddress)
                                        call brushAddress.0x42966c68 with:
                                             gas gas_remaining wei
                                            args mem[_9156 + ceil32(return_data.size) + 64]
                                    else:
                                        if wftmAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_6376:
                                                revert with 0, 17
                                            mem[_6380 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_6380 + 100] = ext_call.return_data[32] + _6376
                                            mem[_6380 + 132] = 0
                                            mem[_6380 + 164] = 160
                                            mem[_6380 + 260] = mem[_6380]
                                            idx = 0
                                            s = _6380 + 292
                                            t = _6380 + 32
                                            while idx < mem[_6380]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_6380 + 196] = this.address
                                            mem[_6380 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _6380 + (32 * mem[_6380]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9157 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _9301 = mem[_9157]
                                            require mem[_9157] <= test266151307()
                                            require _9157 + mem[_9157] + 31 < _9157 + return_data.size
                                            _9445 = mem[_9157 + mem[_9157]]
                                            if mem[_9157 + mem[_9157]] > test266151307():
                                                revert with 0, 65
                                            if _9157 + ceil32(return_data.size) + ceil32(32 * mem[_9157 + mem[_9157]]) + 1 > test266151307() or ceil32(32 * mem[_9157 + mem[_9157]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _9157 + ceil32(return_data.size) + ceil32(32 * mem[_9157 + mem[_9157]]) + 1
                                            mem[_9157 + ceil32(return_data.size)] = _9445
                                            require return_data.size >= _9301 + (32 * _9445) + 32
                                            mem[_9157 + ceil32(return_data.size) + 32 len 32 * _9445] = mem[_9157 + _9301 + 32 len 32 * _9445]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                            if 1 >= _9445:
                                                revert with 0, 50
                                            if mem[_9157 + ceil32(return_data.size) + 64] > -1:
                                                revert with 0, 17
                                            require ext_code.size(brushAddress)
                                            call brushAddress.0x42966c68 with:
                                                 gas gas_remaining wei
                                                args mem[_9157 + ceil32(return_data.size) + 64]
                                        else:
                                            if ext_call.return_data[0] > !_6376:
                                                revert with 0, 17
                                            mem[_6380 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_6380 + 100] = ext_call.return_data[0] + _6376
                                            mem[_6380 + 132] = 0
                                            mem[_6380 + 164] = 160
                                            mem[_6380 + 260] = mem[_6380]
                                            idx = 0
                                            s = _6380 + 292
                                            t = _6380 + 32
                                            while idx < mem[_6380]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_6380 + 196] = this.address
                                            mem[_6380 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _6380 + (32 * mem[_6380]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9158 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _9302 = mem[_9158]
                                            require mem[_9158] <= test266151307()
                                            require _9158 + mem[_9158] + 31 < _9158 + return_data.size
                                            _9446 = mem[_9158 + mem[_9158]]
                                            if mem[_9158 + mem[_9158]] > test266151307():
                                                revert with 0, 65
                                            if _9158 + ceil32(return_data.size) + ceil32(32 * mem[_9158 + mem[_9158]]) + 1 > test266151307() or ceil32(32 * mem[_9158 + mem[_9158]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _9158 + ceil32(return_data.size) + ceil32(32 * mem[_9158 + mem[_9158]]) + 1
                                            mem[_9158 + ceil32(return_data.size)] = _9446
                                            require return_data.size >= _9302 + (32 * _9446) + 32
                                            mem[_9158 + ceil32(return_data.size) + 32 len 32 * _9446] = mem[_9158 + _9302 + 32 len 32 * _9446]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                            if 1 >= _9446:
                                                revert with 0, 50
                                            if mem[_9158 + ceil32(return_data.size) + 64] > -1:
                                                revert with 0, 17
                                            require ext_code.size(brushAddress)
                                            call brushAddress.0x42966c68 with:
                                                 gas gas_remaining wei
                                                args mem[_9158 + ceil32(return_data.size) + 64]
                        else:
                            if brushAddress == address(ext_call.return_data[0]):
                                if brushAddress != address(ext_call.return_data[0]):
                                    if wftmAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[32] > !_6376:
                                            revert with 0, 17
                                        mem[_6380 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_6380 + 100] = ext_call.return_data[32] + _6376
                                        mem[_6380 + 132] = 0
                                        mem[_6380 + 164] = 160
                                        mem[_6380 + 260] = mem[_6380]
                                        idx = 0
                                        s = _6380 + 292
                                        t = _6380 + 32
                                        while idx < mem[_6380]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_6380 + 196] = this.address
                                        mem[_6380 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _6380 + (32 * mem[_6380]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9159 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _9303 = mem[_9159]
                                        require mem[_9159] <= test266151307()
                                        require _9159 + mem[_9159] + 31 < _9159 + return_data.size
                                        _9447 = mem[_9159 + mem[_9159]]
                                        if mem[_9159 + mem[_9159]] > test266151307():
                                            revert with 0, 65
                                        if _9159 + ceil32(return_data.size) + ceil32(32 * mem[_9159 + mem[_9159]]) + 1 > test266151307() or ceil32(32 * mem[_9159 + mem[_9159]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _9159 + ceil32(return_data.size) + ceil32(32 * mem[_9159 + mem[_9159]]) + 1
                                        mem[_9159 + ceil32(return_data.size)] = _9447
                                        require return_data.size >= _9303 + (32 * _9447) + 32
                                        mem[_9159 + ceil32(return_data.size) + 32 len 32 * _9447] = mem[_9159 + _9303 + 32 len 32 * _9447]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                        if 1 >= _9447:
                                            revert with 0, 50
                                        if mem[_9159 + ceil32(return_data.size) + 64] > -1:
                                            revert with 0, 17
                                        require ext_code.size(brushAddress)
                                        call brushAddress.0x42966c68 with:
                                             gas gas_remaining wei
                                            args mem[_9159 + ceil32(return_data.size) + 64]
                                    else:
                                        if ext_call.return_data[0] > !_6376:
                                            revert with 0, 17
                                        mem[_6380 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_6380 + 100] = ext_call.return_data[0] + _6376
                                        mem[_6380 + 132] = 0
                                        mem[_6380 + 164] = 160
                                        mem[_6380 + 260] = mem[_6380]
                                        idx = 0
                                        s = _6380 + 292
                                        t = _6380 + 32
                                        while idx < mem[_6380]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_6380 + 196] = this.address
                                        mem[_6380 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _6380 + (32 * mem[_6380]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9160 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _9304 = mem[_9160]
                                        require mem[_9160] <= test266151307()
                                        require _9160 + mem[_9160] + 31 < _9160 + return_data.size
                                        _9448 = mem[_9160 + mem[_9160]]
                                        if mem[_9160 + mem[_9160]] > test266151307():
                                            revert with 0, 65
                                        if _9160 + ceil32(return_data.size) + ceil32(32 * mem[_9160 + mem[_9160]]) + 1 > test266151307() or ceil32(32 * mem[_9160 + mem[_9160]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _9160 + ceil32(return_data.size) + ceil32(32 * mem[_9160 + mem[_9160]]) + 1
                                        mem[_9160 + ceil32(return_data.size)] = _9448
                                        require return_data.size >= _9304 + (32 * _9448) + 32
                                        mem[_9160 + ceil32(return_data.size) + 32 len 32 * _9448] = mem[_9160 + _9304 + 32 len 32 * _9448]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                        if 1 >= _9448:
                                            revert with 0, 50
                                        if mem[_9160 + ceil32(return_data.size) + 64] > -1:
                                            revert with 0, 17
                                        require ext_code.size(brushAddress)
                                        call brushAddress.0x42966c68 with:
                                             gas gas_remaining wei
                                            args mem[_9160 + ceil32(return_data.size) + 64]
                                else:
                                    if brushAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[32] > !_6376:
                                            revert with 0, 17
                                        mem[_6380 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_6380 + 100] = ext_call.return_data[32] + _6376
                                        mem[_6380 + 132] = 0
                                        mem[_6380 + 164] = 160
                                        mem[_6380 + 260] = mem[_6380]
                                        idx = 0
                                        s = _6380 + 292
                                        t = _6380 + 32
                                        while idx < mem[_6380]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_6380 + 196] = this.address
                                        mem[_6380 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _6380 + (32 * mem[_6380]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9161 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _9305 = mem[_9161]
                                        require mem[_9161] <= test266151307()
                                        require _9161 + mem[_9161] + 31 < _9161 + return_data.size
                                        _9449 = mem[_9161 + mem[_9161]]
                                        if mem[_9161 + mem[_9161]] > test266151307():
                                            revert with 0, 65
                                        if _9161 + ceil32(return_data.size) + ceil32(32 * mem[_9161 + mem[_9161]]) + 1 > test266151307() or ceil32(32 * mem[_9161 + mem[_9161]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _9161 + ceil32(return_data.size) + ceil32(32 * mem[_9161 + mem[_9161]]) + 1
                                        mem[_9161 + ceil32(return_data.size)] = _9449
                                        require return_data.size >= _9305 + (32 * _9449) + 32
                                        mem[_9161 + ceil32(return_data.size) + 32 len 32 * _9449] = mem[_9161 + _9305 + 32 len 32 * _9449]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                        if 1 >= _9449:
                                            revert with 0, 50
                                        if mem[_9161 + ceil32(return_data.size) + 64] > -1:
                                            revert with 0, 17
                                        require ext_code.size(brushAddress)
                                        call brushAddress.0x42966c68 with:
                                             gas gas_remaining wei
                                            args mem[_9161 + ceil32(return_data.size) + 64]
                                    else:
                                        if brushAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[0] > !_6376:
                                                revert with 0, 17
                                            mem[_6380 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_6380 + 100] = ext_call.return_data[0] + _6376
                                            mem[_6380 + 132] = 0
                                            mem[_6380 + 164] = 160
                                            mem[_6380 + 260] = mem[_6380]
                                            idx = 0
                                            s = _6380 + 292
                                            t = _6380 + 32
                                            while idx < mem[_6380]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_6380 + 196] = this.address
                                            mem[_6380 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _6380 + (32 * mem[_6380]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9162 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _9306 = mem[_9162]
                                            require mem[_9162] <= test266151307()
                                            require _9162 + mem[_9162] + 31 < _9162 + return_data.size
                                            _9450 = mem[_9162 + mem[_9162]]
                                            if mem[_9162 + mem[_9162]] > test266151307():
                                                revert with 0, 65
                                            if _9162 + ceil32(return_data.size) + ceil32(32 * mem[_9162 + mem[_9162]]) + 1 > test266151307() or ceil32(32 * mem[_9162 + mem[_9162]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _9162 + ceil32(return_data.size) + ceil32(32 * mem[_9162 + mem[_9162]]) + 1
                                            mem[_9162 + ceil32(return_data.size)] = _9450
                                            require return_data.size >= _9306 + (32 * _9450) + 32
                                            mem[_9162 + ceil32(return_data.size) + 32 len 32 * _9450] = mem[_9162 + _9306 + 32 len 32 * _9450]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                            if 1 >= _9450:
                                                revert with 0, 50
                                            if mem[_9162 + ceil32(return_data.size) + 64] > -1:
                                                revert with 0, 17
                                            require ext_code.size(brushAddress)
                                            call brushAddress.0x42966c68 with:
                                                 gas gas_remaining wei
                                                args mem[_9162 + ceil32(return_data.size) + 64]
                                        else:
                                            if wftmAddress == address(ext_call.return_data[0]):
                                                if ext_call.return_data[32] > !_6376:
                                                    revert with 0, 17
                                                mem[_6380 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[_6380 + 100] = ext_call.return_data[32] + _6376
                                                mem[_6380 + 132] = 0
                                                mem[_6380 + 164] = 160
                                                mem[_6380 + 260] = mem[_6380]
                                                idx = 0
                                                s = _6380 + 292
                                                t = _6380 + 32
                                                while idx < mem[_6380]:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[_6380 + 196] = this.address
                                                mem[_6380 + 228] = block.timestamp + 10000
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len _6380 + (32 * mem[_6380]) + -mem[64] + 288]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _9163 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _9307 = mem[_9163]
                                                require mem[_9163] <= test266151307()
                                                require _9163 + mem[_9163] + 31 < _9163 + return_data.size
                                                _9451 = mem[_9163 + mem[_9163]]
                                                if mem[_9163 + mem[_9163]] > test266151307():
                                                    revert with 0, 65
                                                if _9163 + ceil32(return_data.size) + ceil32(32 * mem[_9163 + mem[_9163]]) + 1 > test266151307() or ceil32(32 * mem[_9163 + mem[_9163]]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[64] = _9163 + ceil32(return_data.size) + ceil32(32 * mem[_9163 + mem[_9163]]) + 1
                                                mem[_9163 + ceil32(return_data.size)] = _9451
                                                require return_data.size >= _9307 + (32 * _9451) + 32
                                                mem[_9163 + ceil32(return_data.size) + 32 len 32 * _9451] = mem[_9163 + _9307 + 32 len 32 * _9451]
                                                if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                    revert with 0, 17
                                                maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                                if 1 >= _9451:
                                                    revert with 0, 50
                                                if mem[_9163 + ceil32(return_data.size) + 64] > -1:
                                                    revert with 0, 17
                                                require ext_code.size(brushAddress)
                                                call brushAddress.0x42966c68 with:
                                                     gas gas_remaining wei
                                                    args mem[_9163 + ceil32(return_data.size) + 64]
                                            else:
                                                if ext_call.return_data[0] > !_6376:
                                                    revert with 0, 17
                                                mem[_6380 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[_6380 + 100] = ext_call.return_data[0] + _6376
                                                mem[_6380 + 132] = 0
                                                mem[_6380 + 164] = 160
                                                mem[_6380 + 260] = mem[_6380]
                                                idx = 0
                                                s = _6380 + 292
                                                t = _6380 + 32
                                                while idx < mem[_6380]:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[_6380 + 196] = this.address
                                                mem[_6380 + 228] = block.timestamp + 10000
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len _6380 + (32 * mem[_6380]) + -mem[64] + 288]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _9164 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _9308 = mem[_9164]
                                                require mem[_9164] <= test266151307()
                                                require _9164 + mem[_9164] + 31 < _9164 + return_data.size
                                                _9452 = mem[_9164 + mem[_9164]]
                                                if mem[_9164 + mem[_9164]] > test266151307():
                                                    revert with 0, 65
                                                if _9164 + ceil32(return_data.size) + ceil32(32 * mem[_9164 + mem[_9164]]) + 1 > test266151307() or ceil32(32 * mem[_9164 + mem[_9164]]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[64] = _9164 + ceil32(return_data.size) + ceil32(32 * mem[_9164 + mem[_9164]]) + 1
                                                mem[_9164 + ceil32(return_data.size)] = _9452
                                                require return_data.size >= _9308 + (32 * _9452) + 32
                                                mem[_9164 + ceil32(return_data.size) + 32 len 32 * _9452] = mem[_9164 + _9308 + 32 len 32 * _9452]
                                                if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                    revert with 0, 17
                                                maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                                if 1 >= _9452:
                                                    revert with 0, 50
                                                if mem[_9164 + ceil32(return_data.size) + 64] > -1:
                                                    revert with 0, 17
                                                require ext_code.size(brushAddress)
                                                call brushAddress.0x42966c68 with:
                                                     gas gas_remaining wei
                                                    args mem[_9164 + ceil32(return_data.size) + 64]
                            else:
                                if wftmAddress == address(ext_call.return_data[0]):
                                    if brushAddress != address(ext_call.return_data[0]):
                                        if wftmAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_6376:
                                                revert with 0, 17
                                            mem[_6380 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_6380 + 100] = ext_call.return_data[32] + _6376
                                            mem[_6380 + 132] = 0
                                            mem[_6380 + 164] = 160
                                            mem[_6380 + 260] = mem[_6380]
                                            idx = 0
                                            s = _6380 + 292
                                            t = _6380 + 32
                                            while idx < mem[_6380]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_6380 + 196] = this.address
                                            mem[_6380 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _6380 + (32 * mem[_6380]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9165 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _9309 = mem[_9165]
                                            require mem[_9165] <= test266151307()
                                            require _9165 + mem[_9165] + 31 < _9165 + return_data.size
                                            _9453 = mem[_9165 + mem[_9165]]
                                            if mem[_9165 + mem[_9165]] > test266151307():
                                                revert with 0, 65
                                            if _9165 + ceil32(return_data.size) + ceil32(32 * mem[_9165 + mem[_9165]]) + 1 > test266151307() or ceil32(32 * mem[_9165 + mem[_9165]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _9165 + ceil32(return_data.size) + ceil32(32 * mem[_9165 + mem[_9165]]) + 1
                                            mem[_9165 + ceil32(return_data.size)] = _9453
                                            require return_data.size >= _9309 + (32 * _9453) + 32
                                            mem[_9165 + ceil32(return_data.size) + 32 len 32 * _9453] = mem[_9165 + _9309 + 32 len 32 * _9453]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                            if 1 >= _9453:
                                                revert with 0, 50
                                            if mem[_9165 + ceil32(return_data.size) + 64] > -1:
                                                revert with 0, 17
                                            require ext_code.size(brushAddress)
                                            call brushAddress.0x42966c68 with:
                                                 gas gas_remaining wei
                                                args mem[_9165 + ceil32(return_data.size) + 64]
                                        else:
                                            if ext_call.return_data[0] > !_6376:
                                                revert with 0, 17
                                            mem[_6380 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_6380 + 100] = ext_call.return_data[0] + _6376
                                            mem[_6380 + 132] = 0
                                            mem[_6380 + 164] = 160
                                            mem[_6380 + 260] = mem[_6380]
                                            idx = 0
                                            s = _6380 + 292
                                            t = _6380 + 32
                                            while idx < mem[_6380]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_6380 + 196] = this.address
                                            mem[_6380 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _6380 + (32 * mem[_6380]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9166 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _9310 = mem[_9166]
                                            require mem[_9166] <= test266151307()
                                            require _9166 + mem[_9166] + 31 < _9166 + return_data.size
                                            _9454 = mem[_9166 + mem[_9166]]
                                            if mem[_9166 + mem[_9166]] > test266151307():
                                                revert with 0, 65
                                            if _9166 + ceil32(return_data.size) + ceil32(32 * mem[_9166 + mem[_9166]]) + 1 > test266151307() or ceil32(32 * mem[_9166 + mem[_9166]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _9166 + ceil32(return_data.size) + ceil32(32 * mem[_9166 + mem[_9166]]) + 1
                                            mem[_9166 + ceil32(return_data.size)] = _9454
                                            require return_data.size >= _9310 + (32 * _9454) + 32
                                            mem[_9166 + ceil32(return_data.size) + 32 len 32 * _9454] = mem[_9166 + _9310 + 32 len 32 * _9454]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                            if 1 >= _9454:
                                                revert with 0, 50
                                            if mem[_9166 + ceil32(return_data.size) + 64] > -1:
                                                revert with 0, 17
                                            require ext_code.size(brushAddress)
                                            call brushAddress.0x42966c68 with:
                                                 gas gas_remaining wei
                                                args mem[_9166 + ceil32(return_data.size) + 64]
                                    else:
                                        if brushAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_6376:
                                                revert with 0, 17
                                            mem[_6380 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_6380 + 100] = ext_call.return_data[32] + _6376
                                            mem[_6380 + 132] = 0
                                            mem[_6380 + 164] = 160
                                            mem[_6380 + 260] = mem[_6380]
                                            idx = 0
                                            s = _6380 + 292
                                            t = _6380 + 32
                                            while idx < mem[_6380]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_6380 + 196] = this.address
                                            mem[_6380 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _6380 + (32 * mem[_6380]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9167 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _9311 = mem[_9167]
                                            require mem[_9167] <= test266151307()
                                            require _9167 + mem[_9167] + 31 < _9167 + return_data.size
                                            _9455 = mem[_9167 + mem[_9167]]
                                            if mem[_9167 + mem[_9167]] > test266151307():
                                                revert with 0, 65
                                            if _9167 + ceil32(return_data.size) + ceil32(32 * mem[_9167 + mem[_9167]]) + 1 > test266151307() or ceil32(32 * mem[_9167 + mem[_9167]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _9167 + ceil32(return_data.size) + ceil32(32 * mem[_9167 + mem[_9167]]) + 1
                                            mem[_9167 + ceil32(return_data.size)] = _9455
                                            require return_data.size >= _9311 + (32 * _9455) + 32
                                            mem[_9167 + ceil32(return_data.size) + 32 len 32 * _9455] = mem[_9167 + _9311 + 32 len 32 * _9455]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                            if 1 >= _9455:
                                                revert with 0, 50
                                            if mem[_9167 + ceil32(return_data.size) + 64] > -1:
                                                revert with 0, 17
                                            require ext_code.size(brushAddress)
                                            call brushAddress.0x42966c68 with:
                                                 gas gas_remaining wei
                                                args mem[_9167 + ceil32(return_data.size) + 64]
                                        else:
                                            if brushAddress == address(ext_call.return_data[0]):
                                                if ext_call.return_data[0] > !_6376:
                                                    revert with 0, 17
                                                mem[_6380 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[_6380 + 100] = ext_call.return_data[0] + _6376
                                                mem[_6380 + 132] = 0
                                                mem[_6380 + 164] = 160
                                                mem[_6380 + 260] = mem[_6380]
                                                idx = 0
                                                s = _6380 + 292
                                                t = _6380 + 32
                                                while idx < mem[_6380]:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[_6380 + 196] = this.address
                                                mem[_6380 + 228] = block.timestamp + 10000
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len _6380 + (32 * mem[_6380]) + -mem[64] + 288]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _9168 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _9312 = mem[_9168]
                                                require mem[_9168] <= test266151307()
                                                require _9168 + mem[_9168] + 31 < _9168 + return_data.size
                                                _9456 = mem[_9168 + mem[_9168]]
                                                if mem[_9168 + mem[_9168]] > test266151307():
                                                    revert with 0, 65
                                                if _9168 + ceil32(return_data.size) + ceil32(32 * mem[_9168 + mem[_9168]]) + 1 > test266151307() or ceil32(32 * mem[_9168 + mem[_9168]]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[64] = _9168 + ceil32(return_data.size) + ceil32(32 * mem[_9168 + mem[_9168]]) + 1
                                                mem[_9168 + ceil32(return_data.size)] = _9456
                                                require return_data.size >= _9312 + (32 * _9456) + 32
                                                mem[_9168 + ceil32(return_data.size) + 32 len 32 * _9456] = mem[_9168 + _9312 + 32 len 32 * _9456]
                                                if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                    revert with 0, 17
                                                maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                                if 1 >= _9456:
                                                    revert with 0, 50
                                                if mem[_9168 + ceil32(return_data.size) + 64] > -1:
                                                    revert with 0, 17
                                                require ext_code.size(brushAddress)
                                                call brushAddress.0x42966c68 with:
                                                     gas gas_remaining wei
                                                    args mem[_9168 + ceil32(return_data.size) + 64]
                                            else:
                                                if wftmAddress == address(ext_call.return_data[0]):
                                                    if ext_call.return_data[32] > !_6376:
                                                        revert with 0, 17
                                                    mem[_6380 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[_6380 + 100] = ext_call.return_data[32] + _6376
                                                    mem[_6380 + 132] = 0
                                                    mem[_6380 + 164] = 160
                                                    mem[_6380 + 260] = mem[_6380]
                                                    idx = 0
                                                    s = _6380 + 292
                                                    t = _6380 + 32
                                                    while idx < mem[_6380]:
                                                        mem[s] = mem[t + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[_6380 + 196] = this.address
                                                    mem[_6380 + 228] = block.timestamp + 10000
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len _6380 + (32 * mem[_6380]) + -mem[64] + 288]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _9169 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _9313 = mem[_9169]
                                                    require mem[_9169] <= test266151307()
                                                    require _9169 + mem[_9169] + 31 < _9169 + return_data.size
                                                    _9457 = mem[_9169 + mem[_9169]]
                                                    if mem[_9169 + mem[_9169]] > test266151307():
                                                        revert with 0, 65
                                                    if _9169 + ceil32(return_data.size) + ceil32(32 * mem[_9169 + mem[_9169]]) + 1 > test266151307() or ceil32(32 * mem[_9169 + mem[_9169]]) + 1 < 0:
                                                        revert with 0, 65
                                                    mem[64] = _9169 + ceil32(return_data.size) + ceil32(32 * mem[_9169 + mem[_9169]]) + 1
                                                    mem[_9169 + ceil32(return_data.size)] = _9457
                                                    require return_data.size >= _9313 + (32 * _9457) + 32
                                                    mem[_9169 + ceil32(return_data.size) + 32 len 32 * _9457] = mem[_9169 + _9313 + 32 len 32 * _9457]
                                                    if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                        revert with 0, 17
                                                    maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                                    if 1 >= _9457:
                                                        revert with 0, 50
                                                    if mem[_9169 + ceil32(return_data.size) + 64] > -1:
                                                        revert with 0, 17
                                                    require ext_code.size(brushAddress)
                                                    call brushAddress.0x42966c68 with:
                                                         gas gas_remaining wei
                                                        args mem[_9169 + ceil32(return_data.size) + 64]
                                                else:
                                                    if ext_call.return_data[0] > !_6376:
                                                        revert with 0, 17
                                                    mem[_6380 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[_6380 + 100] = ext_call.return_data[0] + _6376
                                                    mem[_6380 + 132] = 0
                                                    mem[_6380 + 164] = 160
                                                    mem[_6380 + 260] = mem[_6380]
                                                    idx = 0
                                                    s = _6380 + 292
                                                    t = _6380 + 32
                                                    while idx < mem[_6380]:
                                                        mem[s] = mem[t + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[_6380 + 196] = this.address
                                                    mem[_6380 + 228] = block.timestamp + 10000
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len _6380 + (32 * mem[_6380]) + -mem[64] + 288]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _9170 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _9314 = mem[_9170]
                                                    require mem[_9170] <= test266151307()
                                                    require _9170 + mem[_9170] + 31 < _9170 + return_data.size
                                                    _9458 = mem[_9170 + mem[_9170]]
                                                    if mem[_9170 + mem[_9170]] > test266151307():
                                                        revert with 0, 65
                                                    if _9170 + ceil32(return_data.size) + ceil32(32 * mem[_9170 + mem[_9170]]) + 1 > test266151307() or ceil32(32 * mem[_9170 + mem[_9170]]) + 1 < 0:
                                                        revert with 0, 65
                                                    mem[64] = _9170 + ceil32(return_data.size) + ceil32(32 * mem[_9170 + mem[_9170]]) + 1
                                                    mem[_9170 + ceil32(return_data.size)] = _9458
                                                    require return_data.size >= _9314 + (32 * _9458) + 32
                                                    mem[_9170 + ceil32(return_data.size) + 32 len 32 * _9458] = mem[_9170 + _9314 + 32 len 32 * _9458]
                                                    if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                        revert with 0, 17
                                                    maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                                    if 1 >= _9458:
                                                        revert with 0, 50
                                                    if mem[_9170 + ceil32(return_data.size) + 64] > -1:
                                                        revert with 0, 17
                                                    require ext_code.size(brushAddress)
                                                    call brushAddress.0x42966c68 with:
                                                         gas gas_remaining wei
                                                        args mem[_9170 + ceil32(return_data.size) + 64]
                                else:
                                    if brushAddress != address(ext_call.return_data[0]):
                                        if wftmAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_6376:
                                                revert with 0, 17
                                            mem[_6380 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_6380 + 100] = ext_call.return_data[32] + _6376
                                            mem[_6380 + 132] = 0
                                            mem[_6380 + 164] = 160
                                            mem[_6380 + 260] = mem[_6380]
                                            idx = 0
                                            s = _6380 + 292
                                            t = _6380 + 32
                                            while idx < mem[_6380]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_6380 + 196] = this.address
                                            mem[_6380 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _6380 + (32 * mem[_6380]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9171 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _9315 = mem[_9171]
                                            require mem[_9171] <= test266151307()
                                            require _9171 + mem[_9171] + 31 < _9171 + return_data.size
                                            _9459 = mem[_9171 + mem[_9171]]
                                            if mem[_9171 + mem[_9171]] > test266151307():
                                                revert with 0, 65
                                            if _9171 + ceil32(return_data.size) + ceil32(32 * mem[_9171 + mem[_9171]]) + 1 > test266151307() or ceil32(32 * mem[_9171 + mem[_9171]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _9171 + ceil32(return_data.size) + ceil32(32 * mem[_9171 + mem[_9171]]) + 1
                                            mem[_9171 + ceil32(return_data.size)] = _9459
                                            require return_data.size >= _9315 + (32 * _9459) + 32
                                            mem[_9171 + ceil32(return_data.size) + 32 len 32 * _9459] = mem[_9171 + _9315 + 32 len 32 * _9459]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                            if 1 >= _9459:
                                                revert with 0, 50
                                            if mem[_9171 + ceil32(return_data.size) + 64] > -1:
                                                revert with 0, 17
                                            require ext_code.size(brushAddress)
                                            call brushAddress.0x42966c68 with:
                                                 gas gas_remaining wei
                                                args mem[_9171 + ceil32(return_data.size) + 64]
                                        else:
                                            if ext_call.return_data[0] > !_6376:
                                                revert with 0, 17
                                            mem[_6380 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_6380 + 100] = ext_call.return_data[0] + _6376
                                            mem[_6380 + 132] = 0
                                            mem[_6380 + 164] = 160
                                            mem[_6380 + 260] = mem[_6380]
                                            idx = 0
                                            s = _6380 + 292
                                            t = _6380 + 32
                                            while idx < mem[_6380]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_6380 + 196] = this.address
                                            mem[_6380 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _6380 + (32 * mem[_6380]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9172 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _9316 = mem[_9172]
                                            require mem[_9172] <= test266151307()
                                            require _9172 + mem[_9172] + 31 < _9172 + return_data.size
                                            _9460 = mem[_9172 + mem[_9172]]
                                            if mem[_9172 + mem[_9172]] > test266151307():
                                                revert with 0, 65
                                            if _9172 + ceil32(return_data.size) + ceil32(32 * mem[_9172 + mem[_9172]]) + 1 > test266151307() or ceil32(32 * mem[_9172 + mem[_9172]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _9172 + ceil32(return_data.size) + ceil32(32 * mem[_9172 + mem[_9172]]) + 1
                                            mem[_9172 + ceil32(return_data.size)] = _9460
                                            require return_data.size >= _9316 + (32 * _9460) + 32
                                            mem[_9172 + ceil32(return_data.size) + 32 len 32 * _9460] = mem[_9172 + _9316 + 32 len 32 * _9460]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                            if 1 >= _9460:
                                                revert with 0, 50
                                            if mem[_9172 + ceil32(return_data.size) + 64] > -1:
                                                revert with 0, 17
                                            require ext_code.size(brushAddress)
                                            call brushAddress.0x42966c68 with:
                                                 gas gas_remaining wei
                                                args mem[_9172 + ceil32(return_data.size) + 64]
                                    else:
                                        if brushAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_6376:
                                                revert with 0, 17
                                            mem[_6380 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_6380 + 100] = ext_call.return_data[32] + _6376
                                            mem[_6380 + 132] = 0
                                            mem[_6380 + 164] = 160
                                            mem[_6380 + 260] = mem[_6380]
                                            idx = 0
                                            s = _6380 + 292
                                            t = _6380 + 32
                                            while idx < mem[_6380]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_6380 + 196] = this.address
                                            mem[_6380 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _6380 + (32 * mem[_6380]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9173 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _9317 = mem[_9173]
                                            require mem[_9173] <= test266151307()
                                            require _9173 + mem[_9173] + 31 < _9173 + return_data.size
                                            _9461 = mem[_9173 + mem[_9173]]
                                            if mem[_9173 + mem[_9173]] > test266151307():
                                                revert with 0, 65
                                            if _9173 + ceil32(return_data.size) + ceil32(32 * mem[_9173 + mem[_9173]]) + 1 > test266151307() or ceil32(32 * mem[_9173 + mem[_9173]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _9173 + ceil32(return_data.size) + ceil32(32 * mem[_9173 + mem[_9173]]) + 1
                                            mem[_9173 + ceil32(return_data.size)] = _9461
                                            require return_data.size >= _9317 + (32 * _9461) + 32
                                            mem[_9173 + ceil32(return_data.size) + 32 len 32 * _9461] = mem[_9173 + _9317 + 32 len 32 * _9461]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                            if 1 >= _9461:
                                                revert with 0, 50
                                            if mem[_9173 + ceil32(return_data.size) + 64] > -1:
                                                revert with 0, 17
                                            require ext_code.size(brushAddress)
                                            call brushAddress.0x42966c68 with:
                                                 gas gas_remaining wei
                                                args mem[_9173 + ceil32(return_data.size) + 64]
                                        else:
                                            if brushAddress == address(ext_call.return_data[0]):
                                                if ext_call.return_data[0] > !_6376:
                                                    revert with 0, 17
                                                mem[_6380 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[_6380 + 100] = ext_call.return_data[0] + _6376
                                                mem[_6380 + 132] = 0
                                                mem[_6380 + 164] = 160
                                                mem[_6380 + 260] = mem[_6380]
                                                idx = 0
                                                s = _6380 + 292
                                                t = _6380 + 32
                                                while idx < mem[_6380]:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[_6380 + 196] = this.address
                                                mem[_6380 + 228] = block.timestamp + 10000
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len _6380 + (32 * mem[_6380]) + -mem[64] + 288]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _9174 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _9318 = mem[_9174]
                                                require mem[_9174] <= test266151307()
                                                require _9174 + mem[_9174] + 31 < _9174 + return_data.size
                                                _9462 = mem[_9174 + mem[_9174]]
                                                if mem[_9174 + mem[_9174]] > test266151307():
                                                    revert with 0, 65
                                                if _9174 + ceil32(return_data.size) + ceil32(32 * mem[_9174 + mem[_9174]]) + 1 > test266151307() or ceil32(32 * mem[_9174 + mem[_9174]]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[64] = _9174 + ceil32(return_data.size) + ceil32(32 * mem[_9174 + mem[_9174]]) + 1
                                                mem[_9174 + ceil32(return_data.size)] = _9462
                                                require return_data.size >= _9318 + (32 * _9462) + 32
                                                mem[_9174 + ceil32(return_data.size) + 32 len 32 * _9462] = mem[_9174 + _9318 + 32 len 32 * _9462]
                                                if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                    revert with 0, 17
                                                maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                                if 1 >= _9462:
                                                    revert with 0, 50
                                                if mem[_9174 + ceil32(return_data.size) + 64] > -1:
                                                    revert with 0, 17
                                                require ext_code.size(brushAddress)
                                                call brushAddress.0x42966c68 with:
                                                     gas gas_remaining wei
                                                    args mem[_9174 + ceil32(return_data.size) + 64]
                                            else:
                                                if wftmAddress == address(ext_call.return_data[0]):
                                                    if ext_call.return_data[32] > !_6376:
                                                        revert with 0, 17
                                                    mem[_6380 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[_6380 + 100] = ext_call.return_data[32] + _6376
                                                    mem[_6380 + 132] = 0
                                                    mem[_6380 + 164] = 160
                                                    mem[_6380 + 260] = mem[_6380]
                                                    idx = 0
                                                    s = _6380 + 292
                                                    t = _6380 + 32
                                                    while idx < mem[_6380]:
                                                        mem[s] = mem[t + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[_6380 + 196] = this.address
                                                    mem[_6380 + 228] = block.timestamp + 10000
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len _6380 + (32 * mem[_6380]) + -mem[64] + 288]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _9175 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _9319 = mem[_9175]
                                                    require mem[_9175] <= test266151307()
                                                    require _9175 + mem[_9175] + 31 < _9175 + return_data.size
                                                    _9463 = mem[_9175 + mem[_9175]]
                                                    if mem[_9175 + mem[_9175]] > test266151307():
                                                        revert with 0, 65
                                                    if _9175 + ceil32(return_data.size) + ceil32(32 * mem[_9175 + mem[_9175]]) + 1 > test266151307() or ceil32(32 * mem[_9175 + mem[_9175]]) + 1 < 0:
                                                        revert with 0, 65
                                                    mem[64] = _9175 + ceil32(return_data.size) + ceil32(32 * mem[_9175 + mem[_9175]]) + 1
                                                    mem[_9175 + ceil32(return_data.size)] = _9463
                                                    require return_data.size >= _9319 + (32 * _9463) + 32
                                                    mem[_9175 + ceil32(return_data.size) + 32 len 32 * _9463] = mem[_9175 + _9319 + 32 len 32 * _9463]
                                                    if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                        revert with 0, 17
                                                    maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                                    if 1 >= _9463:
                                                        revert with 0, 50
                                                    if mem[_9175 + ceil32(return_data.size) + 64] > -1:
                                                        revert with 0, 17
                                                    require ext_code.size(brushAddress)
                                                    call brushAddress.0x42966c68 with:
                                                         gas gas_remaining wei
                                                        args mem[_9175 + ceil32(return_data.size) + 64]
                                                else:
                                                    if ext_call.return_data[0] > !_6376:
                                                        revert with 0, 17
                                                    mem[_6380 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[_6380 + 100] = ext_call.return_data[0] + _6376
                                                    mem[_6380 + 132] = 0
                                                    mem[_6380 + 164] = 160
                                                    mem[_6380 + 260] = mem[_6380]
                                                    idx = 0
                                                    s = _6380 + 292
                                                    t = _6380 + 32
                                                    while idx < mem[_6380]:
                                                        mem[s] = mem[t + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[_6380 + 196] = this.address
                                                    mem[_6380 + 228] = block.timestamp + 10000
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len _6380 + (32 * mem[_6380]) + -mem[64] + 288]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _9176 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _9320 = mem[_9176]
                                                    require mem[_9176] <= test266151307()
                                                    require _9176 + mem[_9176] + 31 < _9176 + return_data.size
                                                    _9464 = mem[_9176 + mem[_9176]]
                                                    if mem[_9176 + mem[_9176]] > test266151307():
                                                        revert with 0, 65
                                                    if _9176 + ceil32(return_data.size) + ceil32(32 * mem[_9176 + mem[_9176]]) + 1 > test266151307() or ceil32(32 * mem[_9176 + mem[_9176]]) + 1 < 0:
                                                        revert with 0, 65
                                                    mem[64] = _9176 + ceil32(return_data.size) + ceil32(32 * mem[_9176 + mem[_9176]]) + 1
                                                    mem[_9176 + ceil32(return_data.size)] = _9464
                                                    require return_data.size >= _9320 + (32 * _9464) + 32
                                                    mem[_9176 + ceil32(return_data.size) + 32 len 32 * _9464] = mem[_9176 + _9320 + 32 len 32 * _9464]
                                                    if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                        revert with 0, 17
                                                    maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                                    if 1 >= _9464:
                                                        revert with 0, 50
                                                    if mem[_9176 + ceil32(return_data.size) + 64] > -1:
                                                        revert with 0, 17
                                                    require ext_code.size(brushAddress)
                                                    call brushAddress.0x42966c68 with:
                                                         gas gas_remaining wei
                                                        args mem[_9176 + ceil32(return_data.size) + 64]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
}

function buyBackAndBurnAll(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    require maxBurnAndBuyBackAmounts[address(arg1)] > 0
    mem[0] = arg1
    mem[32] = 13
    require maxBurnAndBuyBackAmounts[address(arg1)] <= maxBurnAndBuyBackAmounts[address(arg1)]
    require ext_code.size(arg1)
    staticcall arg1.token0() with:
            gas gas_remaining wei
    mem[96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    require ext_code.size(arg1)
    staticcall arg1.token1() with:
            gas gas_remaining wei
    mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    if 60 > !block.timestamp:
        revert with 0, 17
    mem[(2 * ceil32(return_data.size)) + 132] = address(ext_call.return_data[0])
    mem[(2 * ceil32(return_data.size)) + 164] = maxBurnAndBuyBackAmounts[address(arg1)]
    mem[(2 * ceil32(return_data.size)) + 196] = 1
    mem[(2 * ceil32(return_data.size)) + 228] = 1
    mem[(2 * ceil32(return_data.size)) + 260] = this.address
    mem[(2 * ceil32(return_data.size)) + 292] = block.timestamp + 60
    require ext_code.size(routerAddress)
    call routerAddress.removeLiquidity(address rg1, address rg2, uint256 rg3, uint256 rg4, uint256 rg5, address rg6, uint256 rg7) with:
         gas gas_remaining wei
        args address(ext_call.return_data[0]), address(ext_call.return_data[0]), maxBurnAndBuyBackAmounts[address(arg1)], 1, 1, address(this.address), block.timestamp + 60
    mem[(2 * ceil32(return_data.size)) + 96 len 64] = ext_call.return_data[0 len 64]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 64
    if 10000 > !block.timestamp:
        revert with 0, 17
    if brushAddress == address(ext_call.return_data[0]):
        mem[(4 * ceil32(return_data.size)) + 128] = address(ext_call.return_data[0])
        mem[(4 * ceil32(return_data.size)) + 160] = brushAddress
        if brushAddress == address(ext_call.return_data[0]):
            if ext_call.return_data[32] > -1:
                revert with 0, 17
            mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
            mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
            mem[(4 * ceil32(return_data.size)) + 228] = 0
            mem[(4 * ceil32(return_data.size)) + 260] = 160
            mem[(4 * ceil32(return_data.size)) + 356] = 2
            idx = 0
            s = (4 * ceil32(return_data.size)) + 388
            t = (4 * ceil32(return_data.size)) + 128
            while idx < 2:
                mem[s] = mem[t + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[(4 * ceil32(return_data.size)) + 292] = this.address
            mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
            require ext_code.size(routerAddress)
            call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                 gas gas_remaining wei
                args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = (6 * ceil32(return_data.size)) + 192
            require return_data.size >= 32
            _3451 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
            require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
            require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
            _3530 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
            if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                revert with 0, 65
            if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                revert with 0, 65
            mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
            require return_data.size >= _3451 + (32 * _3530) + 32
            mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3530] = mem[(4 * ceil32(return_data.size)) + _3451 + 224 len 32 * _3530]
            if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                revert with 0, 17
            maxBurnAndBuyBackAmounts[address(arg1)] = 0
            if 1 >= _3530:
                revert with 0, 50
        else:
            if wftmAddress == address(ext_call.return_data[0]):
                if ext_call.return_data[32] > -1:
                    revert with 0, 17
                mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                mem[(4 * ceil32(return_data.size)) + 228] = 0
                mem[(4 * ceil32(return_data.size)) + 260] = 160
                mem[(4 * ceil32(return_data.size)) + 356] = 2
                idx = 0
                s = (4 * ceil32(return_data.size)) + 388
                t = (4 * ceil32(return_data.size)) + 128
                while idx < 2:
                    mem[s] = mem[t + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[(4 * ceil32(return_data.size)) + 292] = this.address
                mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                require ext_code.size(routerAddress)
                call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                     gas gas_remaining wei
                    args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = (6 * ceil32(return_data.size)) + 192
                require return_data.size >= 32
                _3449 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                _3528 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                    revert with 0, 65
                if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                    revert with 0, 65
                mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                require return_data.size >= _3449 + (32 * _3528) + 32
                mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3528] = mem[(4 * ceil32(return_data.size)) + _3449 + 224 len 32 * _3528]
                if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                    revert with 0, 17
                maxBurnAndBuyBackAmounts[address(arg1)] = 0
                if 1 >= _3528:
                    revert with 0, 50
            else:
                if ext_call.return_data[0] > -1:
                    revert with 0, 17
                mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                mem[(4 * ceil32(return_data.size)) + 228] = 0
                mem[(4 * ceil32(return_data.size)) + 260] = 160
                mem[(4 * ceil32(return_data.size)) + 356] = 2
                idx = 0
                s = (4 * ceil32(return_data.size)) + 388
                t = (4 * ceil32(return_data.size)) + 128
                while idx < 2:
                    mem[s] = mem[t + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[(4 * ceil32(return_data.size)) + 292] = this.address
                mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                require ext_code.size(routerAddress)
                call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                     gas gas_remaining wei
                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = (6 * ceil32(return_data.size)) + 192
                require return_data.size >= 32
                _3450 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                _3529 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                    revert with 0, 65
                if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                    revert with 0, 65
                mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                require return_data.size >= _3450 + (32 * _3529) + 32
                mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3529] = mem[(4 * ceil32(return_data.size)) + _3450 + 224 len 32 * _3529]
                if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                    revert with 0, 17
                maxBurnAndBuyBackAmounts[address(arg1)] = 0
                if 1 >= _3529:
                    revert with 0, 50
        if mem[(6 * ceil32(return_data.size)) + 256] > !ext_call.return_data[0]:
            revert with 0, 17
        require ext_code.size(brushAddress)
        call brushAddress.0x42966c68 with:
             gas gas_remaining wei
            args (mem[(6 * ceil32(return_data.size)) + 256] + ext_call.return_data[0])
    else:
        if brushAddress == address(ext_call.return_data[0]):
            mem[(4 * ceil32(return_data.size)) + 128] = address(ext_call.return_data[0])
            mem[(4 * ceil32(return_data.size)) + 160] = brushAddress
            if brushAddress == address(ext_call.return_data[0]):
                if brushAddress != address(ext_call.return_data[0]):
                    if wftmAddress == address(ext_call.return_data[0]):
                        if brushAddress != address(ext_call.return_data[0]):
                            if wftmAddress == address(ext_call.return_data[0]):
                                if ext_call.return_data[32] > -1:
                                    revert with 0, 17
                                mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                                mem[(4 * ceil32(return_data.size)) + 228] = 0
                                mem[(4 * ceil32(return_data.size)) + 260] = 160
                                mem[(4 * ceil32(return_data.size)) + 356] = 2
                                idx = 0
                                s = (4 * ceil32(return_data.size)) + 388
                                t = (4 * ceil32(return_data.size)) + 128
                                while idx < 2:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (6 * ceil32(return_data.size)) + 192
                                require return_data.size >= 32
                                _3452 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                                require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                _3531 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                                    revert with 0, 65
                                if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                                    revert with 0, 65
                                mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                require return_data.size >= _3452 + (32 * _3531) + 32
                                mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3531] = mem[(4 * ceil32(return_data.size)) + _3452 + 224 len 32 * _3531]
                                if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                    revert with 0, 17
                                maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                if 1 >= _3531:
                                    revert with 0, 50
                            else:
                                if ext_call.return_data[0] > -1:
                                    revert with 0, 17
                                mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                                mem[(4 * ceil32(return_data.size)) + 228] = 0
                                mem[(4 * ceil32(return_data.size)) + 260] = 160
                                mem[(4 * ceil32(return_data.size)) + 356] = 2
                                idx = 0
                                s = (4 * ceil32(return_data.size)) + 388
                                t = (4 * ceil32(return_data.size)) + 128
                                while idx < 2:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (6 * ceil32(return_data.size)) + 192
                                require return_data.size >= 32
                                _3453 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                                require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                _3532 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                                    revert with 0, 65
                                if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                                    revert with 0, 65
                                mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                require return_data.size >= _3453 + (32 * _3532) + 32
                                mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3532] = mem[(4 * ceil32(return_data.size)) + _3453 + 224 len 32 * _3532]
                                if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                    revert with 0, 17
                                maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                if 1 >= _3532:
                                    revert with 0, 50
                        else:
                            if brushAddress == address(ext_call.return_data[0]):
                                if ext_call.return_data[32] > -1:
                                    revert with 0, 17
                                mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                                mem[(4 * ceil32(return_data.size)) + 228] = 0
                                mem[(4 * ceil32(return_data.size)) + 260] = 160
                                mem[(4 * ceil32(return_data.size)) + 356] = 2
                                idx = 0
                                s = (4 * ceil32(return_data.size)) + 388
                                t = (4 * ceil32(return_data.size)) + 128
                                while idx < 2:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (6 * ceil32(return_data.size)) + 192
                                require return_data.size >= 32
                                _3454 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                                require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                _3533 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                                    revert with 0, 65
                                if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                                    revert with 0, 65
                                mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                require return_data.size >= _3454 + (32 * _3533) + 32
                                mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3533] = mem[(4 * ceil32(return_data.size)) + _3454 + 224 len 32 * _3533]
                                if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                    revert with 0, 17
                                maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                if 1 >= _3533:
                                    revert with 0, 50
                            else:
                                if brushAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[0] > -1:
                                        revert with 0, 17
                                    mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                                    mem[(4 * ceil32(return_data.size)) + 228] = 0
                                    mem[(4 * ceil32(return_data.size)) + 260] = 160
                                    mem[(4 * ceil32(return_data.size)) + 356] = 2
                                    idx = 0
                                    s = (4 * ceil32(return_data.size)) + 388
                                    t = (4 * ceil32(return_data.size)) + 128
                                    while idx < 2:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                    mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = (6 * ceil32(return_data.size)) + 192
                                    require return_data.size >= 32
                                    _3455 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                                    require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                    _3534 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                    if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                                        revert with 0, 65
                                    if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                                        revert with 0, 65
                                    mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                    require return_data.size >= _3455 + (32 * _3534) + 32
                                    mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3534] = mem[(4 * ceil32(return_data.size)) + _3455 + 224 len 32 * _3534]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                    if 1 >= _3534:
                                        revert with 0, 50
                                else:
                                    if wftmAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[32] > -1:
                                            revert with 0, 17
                                        mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                                        mem[(4 * ceil32(return_data.size)) + 228] = 0
                                        mem[(4 * ceil32(return_data.size)) + 260] = 160
                                        mem[(4 * ceil32(return_data.size)) + 356] = 2
                                        idx = 0
                                        s = (4 * ceil32(return_data.size)) + 388
                                        t = (4 * ceil32(return_data.size)) + 128
                                        while idx < 2:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                        mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = (6 * ceil32(return_data.size)) + 192
                                        require return_data.size >= 32
                                        _3456 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                                        require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                                        require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                        _3535 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                        if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                                            revert with 0, 65
                                        if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                                            revert with 0, 65
                                        mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                        require return_data.size >= _3456 + (32 * _3535) + 32
                                        mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3535] = mem[(4 * ceil32(return_data.size)) + _3456 + 224 len 32 * _3535]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                        if 1 >= _3535:
                                            revert with 0, 50
                                    else:
                                        if ext_call.return_data[0] > -1:
                                            revert with 0, 17
                                        mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                                        mem[(4 * ceil32(return_data.size)) + 228] = 0
                                        mem[(4 * ceil32(return_data.size)) + 260] = 160
                                        mem[(4 * ceil32(return_data.size)) + 356] = 2
                                        idx = 0
                                        s = (4 * ceil32(return_data.size)) + 388
                                        t = (4 * ceil32(return_data.size)) + 128
                                        while idx < 2:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                        mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = (6 * ceil32(return_data.size)) + 192
                                        require return_data.size >= 32
                                        _3457 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                                        require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                        require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                        _3536 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                        if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                                            revert with 0, 65
                                        if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                                            revert with 0, 65
                                        mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                        require return_data.size >= _3457 + (32 * _3536) + 32
                                        mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3536] = mem[(4 * ceil32(return_data.size)) + _3457 + 224 len 32 * _3536]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                        if 1 >= _3536:
                                            revert with 0, 50
                    else:
                        if brushAddress != address(ext_call.return_data[0]):
                            if wftmAddress == address(ext_call.return_data[0]):
                                if ext_call.return_data[32] > -1:
                                    revert with 0, 17
                                mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                                mem[(4 * ceil32(return_data.size)) + 228] = 0
                                mem[(4 * ceil32(return_data.size)) + 260] = 160
                                mem[(4 * ceil32(return_data.size)) + 356] = 2
                                idx = 0
                                s = (4 * ceil32(return_data.size)) + 388
                                t = (4 * ceil32(return_data.size)) + 128
                                while idx < 2:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (6 * ceil32(return_data.size)) + 192
                                require return_data.size >= 32
                                _3458 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                                require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                _3537 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                                    revert with 0, 65
                                if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                                    revert with 0, 65
                                mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                require return_data.size >= _3458 + (32 * _3537) + 32
                                mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3537] = mem[(4 * ceil32(return_data.size)) + _3458 + 224 len 32 * _3537]
                                if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                    revert with 0, 17
                                maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                if 1 >= _3537:
                                    revert with 0, 50
                            else:
                                if ext_call.return_data[0] > -1:
                                    revert with 0, 17
                                mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                                mem[(4 * ceil32(return_data.size)) + 228] = 0
                                mem[(4 * ceil32(return_data.size)) + 260] = 160
                                mem[(4 * ceil32(return_data.size)) + 356] = 2
                                idx = 0
                                s = (4 * ceil32(return_data.size)) + 388
                                t = (4 * ceil32(return_data.size)) + 128
                                while idx < 2:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (6 * ceil32(return_data.size)) + 192
                                require return_data.size >= 32
                                _3459 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                                require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                _3538 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                                    revert with 0, 65
                                if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                                    revert with 0, 65
                                mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                require return_data.size >= _3459 + (32 * _3538) + 32
                                mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3538] = mem[(4 * ceil32(return_data.size)) + _3459 + 224 len 32 * _3538]
                                if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                    revert with 0, 17
                                maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                if 1 >= _3538:
                                    revert with 0, 50
                        else:
                            if brushAddress == address(ext_call.return_data[0]):
                                if ext_call.return_data[32] > -1:
                                    revert with 0, 17
                                mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                                mem[(4 * ceil32(return_data.size)) + 228] = 0
                                mem[(4 * ceil32(return_data.size)) + 260] = 160
                                mem[(4 * ceil32(return_data.size)) + 356] = 2
                                idx = 0
                                s = (4 * ceil32(return_data.size)) + 388
                                t = (4 * ceil32(return_data.size)) + 128
                                while idx < 2:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (6 * ceil32(return_data.size)) + 192
                                require return_data.size >= 32
                                _3460 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                                require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                _3539 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                                    revert with 0, 65
                                if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                                    revert with 0, 65
                                mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                require return_data.size >= _3460 + (32 * _3539) + 32
                                mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3539] = mem[(4 * ceil32(return_data.size)) + _3460 + 224 len 32 * _3539]
                                if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                    revert with 0, 17
                                maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                if 1 >= _3539:
                                    revert with 0, 50
                            else:
                                if brushAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[0] > -1:
                                        revert with 0, 17
                                    mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                                    mem[(4 * ceil32(return_data.size)) + 228] = 0
                                    mem[(4 * ceil32(return_data.size)) + 260] = 160
                                    mem[(4 * ceil32(return_data.size)) + 356] = 2
                                    idx = 0
                                    s = (4 * ceil32(return_data.size)) + 388
                                    t = (4 * ceil32(return_data.size)) + 128
                                    while idx < 2:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                    mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = (6 * ceil32(return_data.size)) + 192
                                    require return_data.size >= 32
                                    _3461 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                                    require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                    _3540 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                    if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                                        revert with 0, 65
                                    if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                                        revert with 0, 65
                                    mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                    require return_data.size >= _3461 + (32 * _3540) + 32
                                    mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3540] = mem[(4 * ceil32(return_data.size)) + _3461 + 224 len 32 * _3540]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                    if 1 >= _3540:
                                        revert with 0, 50
                                else:
                                    if wftmAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[32] > -1:
                                            revert with 0, 17
                                        mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                                        mem[(4 * ceil32(return_data.size)) + 228] = 0
                                        mem[(4 * ceil32(return_data.size)) + 260] = 160
                                        mem[(4 * ceil32(return_data.size)) + 356] = 2
                                        idx = 0
                                        s = (4 * ceil32(return_data.size)) + 388
                                        t = (4 * ceil32(return_data.size)) + 128
                                        while idx < 2:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                        mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = (6 * ceil32(return_data.size)) + 192
                                        require return_data.size >= 32
                                        _3462 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                                        require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                                        require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                        _3541 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                        if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                                            revert with 0, 65
                                        if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                                            revert with 0, 65
                                        mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                        require return_data.size >= _3462 + (32 * _3541) + 32
                                        mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3541] = mem[(4 * ceil32(return_data.size)) + _3462 + 224 len 32 * _3541]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                        if 1 >= _3541:
                                            revert with 0, 50
                                    else:
                                        if ext_call.return_data[0] > -1:
                                            revert with 0, 17
                                        mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                                        mem[(4 * ceil32(return_data.size)) + 228] = 0
                                        mem[(4 * ceil32(return_data.size)) + 260] = 160
                                        mem[(4 * ceil32(return_data.size)) + 356] = 2
                                        idx = 0
                                        s = (4 * ceil32(return_data.size)) + 388
                                        t = (4 * ceil32(return_data.size)) + 128
                                        while idx < 2:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                        mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = (6 * ceil32(return_data.size)) + 192
                                        require return_data.size >= 32
                                        _3463 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                                        require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                        require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                        _3542 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                        if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                                            revert with 0, 65
                                        if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                                            revert with 0, 65
                                        mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                        require return_data.size >= _3463 + (32 * _3542) + 32
                                        mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3542] = mem[(4 * ceil32(return_data.size)) + _3463 + 224 len 32 * _3542]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                        if 1 >= _3542:
                                            revert with 0, 50
                else:
                    if brushAddress == address(ext_call.return_data[0]):
                        if brushAddress != address(ext_call.return_data[0]):
                            if wftmAddress == address(ext_call.return_data[0]):
                                if ext_call.return_data[32] > -1:
                                    revert with 0, 17
                                mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                                mem[(4 * ceil32(return_data.size)) + 228] = 0
                                mem[(4 * ceil32(return_data.size)) + 260] = 160
                                mem[(4 * ceil32(return_data.size)) + 356] = 2
                                idx = 0
                                s = (4 * ceil32(return_data.size)) + 388
                                t = (4 * ceil32(return_data.size)) + 128
                                while idx < 2:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (6 * ceil32(return_data.size)) + 192
                                require return_data.size >= 32
                                _3464 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                                require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                _3543 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                                    revert with 0, 65
                                if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                                    revert with 0, 65
                                mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                require return_data.size >= _3464 + (32 * _3543) + 32
                                mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3543] = mem[(4 * ceil32(return_data.size)) + _3464 + 224 len 32 * _3543]
                                if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                    revert with 0, 17
                                maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                if 1 >= _3543:
                                    revert with 0, 50
                            else:
                                if ext_call.return_data[0] > -1:
                                    revert with 0, 17
                                mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                                mem[(4 * ceil32(return_data.size)) + 228] = 0
                                mem[(4 * ceil32(return_data.size)) + 260] = 160
                                mem[(4 * ceil32(return_data.size)) + 356] = 2
                                idx = 0
                                s = (4 * ceil32(return_data.size)) + 388
                                t = (4 * ceil32(return_data.size)) + 128
                                while idx < 2:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (6 * ceil32(return_data.size)) + 192
                                require return_data.size >= 32
                                _3465 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                                require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                _3544 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                                    revert with 0, 65
                                if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                                    revert with 0, 65
                                mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                require return_data.size >= _3465 + (32 * _3544) + 32
                                mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3544] = mem[(4 * ceil32(return_data.size)) + _3465 + 224 len 32 * _3544]
                                if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                    revert with 0, 17
                                maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                if 1 >= _3544:
                                    revert with 0, 50
                        else:
                            if brushAddress == address(ext_call.return_data[0]):
                                if ext_call.return_data[32] > -1:
                                    revert with 0, 17
                                mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                                mem[(4 * ceil32(return_data.size)) + 228] = 0
                                mem[(4 * ceil32(return_data.size)) + 260] = 160
                                mem[(4 * ceil32(return_data.size)) + 356] = 2
                                idx = 0
                                s = (4 * ceil32(return_data.size)) + 388
                                t = (4 * ceil32(return_data.size)) + 128
                                while idx < 2:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (6 * ceil32(return_data.size)) + 192
                                require return_data.size >= 32
                                _3466 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                                require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                _3545 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                                    revert with 0, 65
                                if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                                    revert with 0, 65
                                mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                require return_data.size >= _3466 + (32 * _3545) + 32
                                mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3545] = mem[(4 * ceil32(return_data.size)) + _3466 + 224 len 32 * _3545]
                                if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                    revert with 0, 17
                                maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                if 1 >= _3545:
                                    revert with 0, 50
                            else:
                                if brushAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[0] > -1:
                                        revert with 0, 17
                                    mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                                    mem[(4 * ceil32(return_data.size)) + 228] = 0
                                    mem[(4 * ceil32(return_data.size)) + 260] = 160
                                    mem[(4 * ceil32(return_data.size)) + 356] = 2
                                    idx = 0
                                    s = (4 * ceil32(return_data.size)) + 388
                                    t = (4 * ceil32(return_data.size)) + 128
                                    while idx < 2:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                    mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = (6 * ceil32(return_data.size)) + 192
                                    require return_data.size >= 32
                                    _3467 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                                    require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                    _3546 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                    if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                                        revert with 0, 65
                                    if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                                        revert with 0, 65
                                    mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                    require return_data.size >= _3467 + (32 * _3546) + 32
                                    mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3546] = mem[(4 * ceil32(return_data.size)) + _3467 + 224 len 32 * _3546]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                    if 1 >= _3546:
                                        revert with 0, 50
                                else:
                                    if wftmAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[32] > -1:
                                            revert with 0, 17
                                        mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                                        mem[(4 * ceil32(return_data.size)) + 228] = 0
                                        mem[(4 * ceil32(return_data.size)) + 260] = 160
                                        mem[(4 * ceil32(return_data.size)) + 356] = 2
                                        idx = 0
                                        s = (4 * ceil32(return_data.size)) + 388
                                        t = (4 * ceil32(return_data.size)) + 128
                                        while idx < 2:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                        mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = (6 * ceil32(return_data.size)) + 192
                                        require return_data.size >= 32
                                        _3468 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                                        require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                                        require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                        _3547 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                        if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                                            revert with 0, 65
                                        if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                                            revert with 0, 65
                                        mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                        require return_data.size >= _3468 + (32 * _3547) + 32
                                        mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3547] = mem[(4 * ceil32(return_data.size)) + _3468 + 224 len 32 * _3547]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                        if 1 >= _3547:
                                            revert with 0, 50
                                    else:
                                        if ext_call.return_data[0] > -1:
                                            revert with 0, 17
                                        mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                                        mem[(4 * ceil32(return_data.size)) + 228] = 0
                                        mem[(4 * ceil32(return_data.size)) + 260] = 160
                                        mem[(4 * ceil32(return_data.size)) + 356] = 2
                                        idx = 0
                                        s = (4 * ceil32(return_data.size)) + 388
                                        t = (4 * ceil32(return_data.size)) + 128
                                        while idx < 2:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                        mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = (6 * ceil32(return_data.size)) + 192
                                        require return_data.size >= 32
                                        _3469 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                                        require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                        require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                        _3548 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                        if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                                            revert with 0, 65
                                        if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                                            revert with 0, 65
                                        mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                        require return_data.size >= _3469 + (32 * _3548) + 32
                                        mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3548] = mem[(4 * ceil32(return_data.size)) + _3469 + 224 len 32 * _3548]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                        if 1 >= _3548:
                                            revert with 0, 50
                    else:
                        if brushAddress == address(ext_call.return_data[0]):
                            if brushAddress != address(ext_call.return_data[0]):
                                if wftmAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > -1:
                                        revert with 0, 17
                                    mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                                    mem[(4 * ceil32(return_data.size)) + 228] = 0
                                    mem[(4 * ceil32(return_data.size)) + 260] = 160
                                    mem[(4 * ceil32(return_data.size)) + 356] = 2
                                    idx = 0
                                    s = (4 * ceil32(return_data.size)) + 388
                                    t = (4 * ceil32(return_data.size)) + 128
                                    while idx < 2:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                    mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = (6 * ceil32(return_data.size)) + 192
                                    require return_data.size >= 32
                                    _3470 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                                    require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                                    require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                    _3549 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                    if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                                        revert with 0, 65
                                    if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                                        revert with 0, 65
                                    mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                    require return_data.size >= _3470 + (32 * _3549) + 32
                                    mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3549] = mem[(4 * ceil32(return_data.size)) + _3470 + 224 len 32 * _3549]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                    if 1 >= _3549:
                                        revert with 0, 50
                                else:
                                    if ext_call.return_data[0] > -1:
                                        revert with 0, 17
                                    mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                                    mem[(4 * ceil32(return_data.size)) + 228] = 0
                                    mem[(4 * ceil32(return_data.size)) + 260] = 160
                                    mem[(4 * ceil32(return_data.size)) + 356] = 2
                                    idx = 0
                                    s = (4 * ceil32(return_data.size)) + 388
                                    t = (4 * ceil32(return_data.size)) + 128
                                    while idx < 2:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                    mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = (6 * ceil32(return_data.size)) + 192
                                    require return_data.size >= 32
                                    _3471 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                                    require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                    _3550 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                    if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                                        revert with 0, 65
                                    if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                                        revert with 0, 65
                                    mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                    require return_data.size >= _3471 + (32 * _3550) + 32
                                    mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3550] = mem[(4 * ceil32(return_data.size)) + _3471 + 224 len 32 * _3550]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                    if 1 >= _3550:
                                        revert with 0, 50
                            else:
                                if brushAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > -1:
                                        revert with 0, 17
                                    mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                                    mem[(4 * ceil32(return_data.size)) + 228] = 0
                                    mem[(4 * ceil32(return_data.size)) + 260] = 160
                                    mem[(4 * ceil32(return_data.size)) + 356] = 2
                                    idx = 0
                                    s = (4 * ceil32(return_data.size)) + 388
                                    t = (4 * ceil32(return_data.size)) + 128
                                    while idx < 2:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                    mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = (6 * ceil32(return_data.size)) + 192
                                    require return_data.size >= 32
                                    _3472 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                                    require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                                    require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                    _3551 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                    if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                                        revert with 0, 65
                                    if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                                        revert with 0, 65
                                    mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                    require return_data.size >= _3472 + (32 * _3551) + 32
                                    mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3551] = mem[(4 * ceil32(return_data.size)) + _3472 + 224 len 32 * _3551]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                    if 1 >= _3551:
                                        revert with 0, 50
                                else:
                                    if brushAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[0] > -1:
                                            revert with 0, 17
                                        mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                                        mem[(4 * ceil32(return_data.size)) + 228] = 0
                                        mem[(4 * ceil32(return_data.size)) + 260] = 160
                                        mem[(4 * ceil32(return_data.size)) + 356] = 2
                                        idx = 0
                                        s = (4 * ceil32(return_data.size)) + 388
                                        t = (4 * ceil32(return_data.size)) + 128
                                        while idx < 2:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                        mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = (6 * ceil32(return_data.size)) + 192
                                        require return_data.size >= 32
                                        _3473 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                                        require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                        require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                        _3552 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                        if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                                            revert with 0, 65
                                        if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                                            revert with 0, 65
                                        mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                        require return_data.size >= _3473 + (32 * _3552) + 32
                                        mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3552] = mem[(4 * ceil32(return_data.size)) + _3473 + 224 len 32 * _3552]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                        if 1 >= _3552:
                                            revert with 0, 50
                                    else:
                                        if wftmAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > -1:
                                                revert with 0, 17
                                            mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                                            mem[(4 * ceil32(return_data.size)) + 228] = 0
                                            mem[(4 * ceil32(return_data.size)) + 260] = 160
                                            mem[(4 * ceil32(return_data.size)) + 356] = 2
                                            idx = 0
                                            s = (4 * ceil32(return_data.size)) + 388
                                            t = (4 * ceil32(return_data.size)) + 128
                                            while idx < 2:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                            mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                 gas gas_remaining wei
                                                args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = (6 * ceil32(return_data.size)) + 192
                                            require return_data.size >= 32
                                            _3474 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                                            require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                                            require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                            _3553 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                            if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                                                revert with 0, 65
                                            if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                                                revert with 0, 65
                                            mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                            require return_data.size >= _3474 + (32 * _3553) + 32
                                            mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3553] = mem[(4 * ceil32(return_data.size)) + _3474 + 224 len 32 * _3553]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                            if 1 >= _3553:
                                                revert with 0, 50
                                        else:
                                            if ext_call.return_data[0] > -1:
                                                revert with 0, 17
                                            mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                                            mem[(4 * ceil32(return_data.size)) + 228] = 0
                                            mem[(4 * ceil32(return_data.size)) + 260] = 160
                                            mem[(4 * ceil32(return_data.size)) + 356] = 2
                                            idx = 0
                                            s = (4 * ceil32(return_data.size)) + 388
                                            t = (4 * ceil32(return_data.size)) + 128
                                            while idx < 2:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                            mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                 gas gas_remaining wei
                                                args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = (6 * ceil32(return_data.size)) + 192
                                            require return_data.size >= 32
                                            _3475 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                                            require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                            require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                            _3554 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                            if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                                                revert with 0, 65
                                            if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                                                revert with 0, 65
                                            mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                            require return_data.size >= _3475 + (32 * _3554) + 32
                                            mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3554] = mem[(4 * ceil32(return_data.size)) + _3475 + 224 len 32 * _3554]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                            if 1 >= _3554:
                                                revert with 0, 50
                        else:
                            if wftmAddress == address(ext_call.return_data[0]):
                                if brushAddress != address(ext_call.return_data[0]):
                                    if wftmAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[32] > -1:
                                            revert with 0, 17
                                        mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                                        mem[(4 * ceil32(return_data.size)) + 228] = 0
                                        mem[(4 * ceil32(return_data.size)) + 260] = 160
                                        mem[(4 * ceil32(return_data.size)) + 356] = 2
                                        idx = 0
                                        s = (4 * ceil32(return_data.size)) + 388
                                        t = (4 * ceil32(return_data.size)) + 128
                                        while idx < 2:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                        mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = (6 * ceil32(return_data.size)) + 192
                                        require return_data.size >= 32
                                        _3476 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                                        require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                                        require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                        _3555 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                        if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                                            revert with 0, 65
                                        if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                                            revert with 0, 65
                                        mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                        require return_data.size >= _3476 + (32 * _3555) + 32
                                        mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3555] = mem[(4 * ceil32(return_data.size)) + _3476 + 224 len 32 * _3555]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                        if 1 >= _3555:
                                            revert with 0, 50
                                    else:
                                        if ext_call.return_data[0] > -1:
                                            revert with 0, 17
                                        mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                                        mem[(4 * ceil32(return_data.size)) + 228] = 0
                                        mem[(4 * ceil32(return_data.size)) + 260] = 160
                                        mem[(4 * ceil32(return_data.size)) + 356] = 2
                                        idx = 0
                                        s = (4 * ceil32(return_data.size)) + 388
                                        t = (4 * ceil32(return_data.size)) + 128
                                        while idx < 2:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                        mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = (6 * ceil32(return_data.size)) + 192
                                        require return_data.size >= 32
                                        _3477 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                                        require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                        require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                        _3556 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                        if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                                            revert with 0, 65
                                        if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                                            revert with 0, 65
                                        mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                        require return_data.size >= _3477 + (32 * _3556) + 32
                                        mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3556] = mem[(4 * ceil32(return_data.size)) + _3477 + 224 len 32 * _3556]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                        if 1 >= _3556:
                                            revert with 0, 50
                                else:
                                    if brushAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[32] > -1:
                                            revert with 0, 17
                                        mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                                        mem[(4 * ceil32(return_data.size)) + 228] = 0
                                        mem[(4 * ceil32(return_data.size)) + 260] = 160
                                        mem[(4 * ceil32(return_data.size)) + 356] = 2
                                        idx = 0
                                        s = (4 * ceil32(return_data.size)) + 388
                                        t = (4 * ceil32(return_data.size)) + 128
                                        while idx < 2:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                        mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = (6 * ceil32(return_data.size)) + 192
                                        require return_data.size >= 32
                                        _3478 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                                        require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                                        require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                        _3557 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                        if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                                            revert with 0, 65
                                        if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                                            revert with 0, 65
                                        mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                        require return_data.size >= _3478 + (32 * _3557) + 32
                                        mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3557] = mem[(4 * ceil32(return_data.size)) + _3478 + 224 len 32 * _3557]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                        if 1 >= _3557:
                                            revert with 0, 50
                                    else:
                                        if brushAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[0] > -1:
                                                revert with 0, 17
                                            mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                                            mem[(4 * ceil32(return_data.size)) + 228] = 0
                                            mem[(4 * ceil32(return_data.size)) + 260] = 160
                                            mem[(4 * ceil32(return_data.size)) + 356] = 2
                                            idx = 0
                                            s = (4 * ceil32(return_data.size)) + 388
                                            t = (4 * ceil32(return_data.size)) + 128
                                            while idx < 2:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                            mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                 gas gas_remaining wei
                                                args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = (6 * ceil32(return_data.size)) + 192
                                            require return_data.size >= 32
                                            _3479 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                                            require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                            require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                            _3558 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                            if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                                                revert with 0, 65
                                            if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                                                revert with 0, 65
                                            mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                            require return_data.size >= _3479 + (32 * _3558) + 32
                                            mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3558] = mem[(4 * ceil32(return_data.size)) + _3479 + 224 len 32 * _3558]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                            if 1 >= _3558:
                                                revert with 0, 50
                                        else:
                                            if wftmAddress == address(ext_call.return_data[0]):
                                                if ext_call.return_data[32] > -1:
                                                    revert with 0, 17
                                                mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                                                mem[(4 * ceil32(return_data.size)) + 228] = 0
                                                mem[(4 * ceil32(return_data.size)) + 260] = 160
                                                mem[(4 * ceil32(return_data.size)) + 356] = 2
                                                idx = 0
                                                s = (4 * ceil32(return_data.size)) + 388
                                                t = (4 * ceil32(return_data.size)) + 128
                                                while idx < 2:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                                mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                                require ext_code.size(routerAddress)
                                                call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (6 * ceil32(return_data.size)) + 192
                                                require return_data.size >= 32
                                                _3480 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                                                require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                                                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                                _3559 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                                                    revert with 0, 65
                                                if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                                require return_data.size >= _3480 + (32 * _3559) + 32
                                                mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3559] = mem[(4 * ceil32(return_data.size)) + _3480 + 224 len 32 * _3559]
                                                if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                    revert with 0, 17
                                                maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                                if 1 >= _3559:
                                                    revert with 0, 50
                                            else:
                                                if ext_call.return_data[0] > -1:
                                                    revert with 0, 17
                                                mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                                                mem[(4 * ceil32(return_data.size)) + 228] = 0
                                                mem[(4 * ceil32(return_data.size)) + 260] = 160
                                                mem[(4 * ceil32(return_data.size)) + 356] = 2
                                                idx = 0
                                                s = (4 * ceil32(return_data.size)) + 388
                                                t = (4 * ceil32(return_data.size)) + 128
                                                while idx < 2:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                                mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                                require ext_code.size(routerAddress)
                                                call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (6 * ceil32(return_data.size)) + 192
                                                require return_data.size >= 32
                                                _3481 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                                                require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                                _3560 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                                                    revert with 0, 65
                                                if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                                require return_data.size >= _3481 + (32 * _3560) + 32
                                                mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3560] = mem[(4 * ceil32(return_data.size)) + _3481 + 224 len 32 * _3560]
                                                if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                    revert with 0, 17
                                                maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                                if 1 >= _3560:
                                                    revert with 0, 50
                            else:
                                if brushAddress != address(ext_call.return_data[0]):
                                    if wftmAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[32] > -1:
                                            revert with 0, 17
                                        mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                                        mem[(4 * ceil32(return_data.size)) + 228] = 0
                                        mem[(4 * ceil32(return_data.size)) + 260] = 160
                                        mem[(4 * ceil32(return_data.size)) + 356] = 2
                                        idx = 0
                                        s = (4 * ceil32(return_data.size)) + 388
                                        t = (4 * ceil32(return_data.size)) + 128
                                        while idx < 2:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                        mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = (6 * ceil32(return_data.size)) + 192
                                        require return_data.size >= 32
                                        _3482 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                                        require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                                        require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                        _3561 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                        if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                                            revert with 0, 65
                                        if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                                            revert with 0, 65
                                        mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                        require return_data.size >= _3482 + (32 * _3561) + 32
                                        mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3561] = mem[(4 * ceil32(return_data.size)) + _3482 + 224 len 32 * _3561]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                        if 1 >= _3561:
                                            revert with 0, 50
                                    else:
                                        if ext_call.return_data[0] > -1:
                                            revert with 0, 17
                                        mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                                        mem[(4 * ceil32(return_data.size)) + 228] = 0
                                        mem[(4 * ceil32(return_data.size)) + 260] = 160
                                        mem[(4 * ceil32(return_data.size)) + 356] = 2
                                        idx = 0
                                        s = (4 * ceil32(return_data.size)) + 388
                                        t = (4 * ceil32(return_data.size)) + 128
                                        while idx < 2:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                        mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = (6 * ceil32(return_data.size)) + 192
                                        require return_data.size >= 32
                                        _3483 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                                        require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                        require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                        _3562 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                        if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                                            revert with 0, 65
                                        if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                                            revert with 0, 65
                                        mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                        require return_data.size >= _3483 + (32 * _3562) + 32
                                        mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3562] = mem[(4 * ceil32(return_data.size)) + _3483 + 224 len 32 * _3562]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                        if 1 >= _3562:
                                            revert with 0, 50
                                else:
                                    if brushAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[32] > -1:
                                            revert with 0, 17
                                        mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                                        mem[(4 * ceil32(return_data.size)) + 228] = 0
                                        mem[(4 * ceil32(return_data.size)) + 260] = 160
                                        mem[(4 * ceil32(return_data.size)) + 356] = 2
                                        idx = 0
                                        s = (4 * ceil32(return_data.size)) + 388
                                        t = (4 * ceil32(return_data.size)) + 128
                                        while idx < 2:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                        mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = (6 * ceil32(return_data.size)) + 192
                                        require return_data.size >= 32
                                        _3484 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                                        require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                                        require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                        _3563 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                        if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                                            revert with 0, 65
                                        if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                                            revert with 0, 65
                                        mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                        require return_data.size >= _3484 + (32 * _3563) + 32
                                        mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3563] = mem[(4 * ceil32(return_data.size)) + _3484 + 224 len 32 * _3563]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                        if 1 >= _3563:
                                            revert with 0, 50
                                    else:
                                        if brushAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[0] > -1:
                                                revert with 0, 17
                                            mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                                            mem[(4 * ceil32(return_data.size)) + 228] = 0
                                            mem[(4 * ceil32(return_data.size)) + 260] = 160
                                            mem[(4 * ceil32(return_data.size)) + 356] = 2
                                            idx = 0
                                            s = (4 * ceil32(return_data.size)) + 388
                                            t = (4 * ceil32(return_data.size)) + 128
                                            while idx < 2:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                            mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                 gas gas_remaining wei
                                                args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = (6 * ceil32(return_data.size)) + 192
                                            require return_data.size >= 32
                                            _3485 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                                            require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                            require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                            _3564 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                            if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                                                revert with 0, 65
                                            if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                                                revert with 0, 65
                                            mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                            require return_data.size >= _3485 + (32 * _3564) + 32
                                            mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3564] = mem[(4 * ceil32(return_data.size)) + _3485 + 224 len 32 * _3564]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                            if 1 >= _3564:
                                                revert with 0, 50
                                        else:
                                            if wftmAddress == address(ext_call.return_data[0]):
                                                if ext_call.return_data[32] > -1:
                                                    revert with 0, 17
                                                mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                                                mem[(4 * ceil32(return_data.size)) + 228] = 0
                                                mem[(4 * ceil32(return_data.size)) + 260] = 160
                                                mem[(4 * ceil32(return_data.size)) + 356] = 2
                                                idx = 0
                                                s = (4 * ceil32(return_data.size)) + 388
                                                t = (4 * ceil32(return_data.size)) + 128
                                                while idx < 2:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                                mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                                require ext_code.size(routerAddress)
                                                call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (6 * ceil32(return_data.size)) + 192
                                                require return_data.size >= 32
                                                _3486 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                                                require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                                                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                                _3565 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                                                    revert with 0, 65
                                                if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                                require return_data.size >= _3486 + (32 * _3565) + 32
                                                mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3565] = mem[(4 * ceil32(return_data.size)) + _3486 + 224 len 32 * _3565]
                                                if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                    revert with 0, 17
                                                maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                                if 1 >= _3565:
                                                    revert with 0, 50
                                            else:
                                                if ext_call.return_data[0] > -1:
                                                    revert with 0, 17
                                                mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                                                mem[(4 * ceil32(return_data.size)) + 228] = 0
                                                mem[(4 * ceil32(return_data.size)) + 260] = 160
                                                mem[(4 * ceil32(return_data.size)) + 356] = 2
                                                idx = 0
                                                s = (4 * ceil32(return_data.size)) + 388
                                                t = (4 * ceil32(return_data.size)) + 128
                                                while idx < 2:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                                mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                                require ext_code.size(routerAddress)
                                                call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (6 * ceil32(return_data.size)) + 192
                                                require return_data.size >= 32
                                                _3487 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                                                require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                                _3566 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                                                    revert with 0, 65
                                                if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                                require return_data.size >= _3487 + (32 * _3566) + 32
                                                mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3566] = mem[(4 * ceil32(return_data.size)) + _3487 + 224 len 32 * _3566]
                                                if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                    revert with 0, 17
                                                maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                                if 1 >= _3566:
                                                    revert with 0, 50
                if mem[(6 * ceil32(return_data.size)) + 256] > !ext_call.return_data[0]:
                    revert with 0, 17
                require ext_code.size(brushAddress)
                call brushAddress.0x42966c68 with:
                     gas gas_remaining wei
                    args (mem[(6 * ceil32(return_data.size)) + 256] + ext_call.return_data[0])
            else:
                if brushAddress != address(ext_call.return_data[0]):
                    if wftmAddress == address(ext_call.return_data[0]):
                        if brushAddress != address(ext_call.return_data[0]):
                            if wftmAddress == address(ext_call.return_data[0]):
                                if ext_call.return_data[32] > -1:
                                    revert with 0, 17
                                mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                                mem[(4 * ceil32(return_data.size)) + 228] = 0
                                mem[(4 * ceil32(return_data.size)) + 260] = 160
                                mem[(4 * ceil32(return_data.size)) + 356] = 2
                                idx = 0
                                s = (4 * ceil32(return_data.size)) + 388
                                t = (4 * ceil32(return_data.size)) + 128
                                while idx < 2:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (6 * ceil32(return_data.size)) + 192
                                require return_data.size >= 32
                                _3488 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                                require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                _3567 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                                    revert with 0, 65
                                if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                                    revert with 0, 65
                                mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                require return_data.size >= _3488 + (32 * _3567) + 32
                                mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3567] = mem[(4 * ceil32(return_data.size)) + _3488 + 224 len 32 * _3567]
                                if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                    revert with 0, 17
                                maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                if 1 >= _3567:
                                    revert with 0, 50
                            else:
                                if ext_call.return_data[0] > -1:
                                    revert with 0, 17
                                mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                                mem[(4 * ceil32(return_data.size)) + 228] = 0
                                mem[(4 * ceil32(return_data.size)) + 260] = 160
                                mem[(4 * ceil32(return_data.size)) + 356] = 2
                                idx = 0
                                s = (4 * ceil32(return_data.size)) + 388
                                t = (4 * ceil32(return_data.size)) + 128
                                while idx < 2:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (6 * ceil32(return_data.size)) + 192
                                require return_data.size >= 32
                                _3489 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                                require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                _3568 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                                    revert with 0, 65
                                if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                                    revert with 0, 65
                                mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                require return_data.size >= _3489 + (32 * _3568) + 32
                                mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3568] = mem[(4 * ceil32(return_data.size)) + _3489 + 224 len 32 * _3568]
                                if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                    revert with 0, 17
                                maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                if 1 >= _3568:
                                    revert with 0, 50
                        else:
                            if brushAddress == address(ext_call.return_data[0]):
                                if ext_call.return_data[32] > -1:
                                    revert with 0, 17
                                mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                                mem[(4 * ceil32(return_data.size)) + 228] = 0
                                mem[(4 * ceil32(return_data.size)) + 260] = 160
                                mem[(4 * ceil32(return_data.size)) + 356] = 2
                                idx = 0
                                s = (4 * ceil32(return_data.size)) + 388
                                t = (4 * ceil32(return_data.size)) + 128
                                while idx < 2:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (6 * ceil32(return_data.size)) + 192
                                require return_data.size >= 32
                                _3490 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                                require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                _3569 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                                    revert with 0, 65
                                if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                                    revert with 0, 65
                                mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                require return_data.size >= _3490 + (32 * _3569) + 32
                                mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3569] = mem[(4 * ceil32(return_data.size)) + _3490 + 224 len 32 * _3569]
                                if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                    revert with 0, 17
                                maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                if 1 >= _3569:
                                    revert with 0, 50
                            else:
                                if brushAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[0] > -1:
                                        revert with 0, 17
                                    mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                                    mem[(4 * ceil32(return_data.size)) + 228] = 0
                                    mem[(4 * ceil32(return_data.size)) + 260] = 160
                                    mem[(4 * ceil32(return_data.size)) + 356] = 2
                                    idx = 0
                                    s = (4 * ceil32(return_data.size)) + 388
                                    t = (4 * ceil32(return_data.size)) + 128
                                    while idx < 2:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                    mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = (6 * ceil32(return_data.size)) + 192
                                    require return_data.size >= 32
                                    _3491 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                                    require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                    _3570 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                    if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                                        revert with 0, 65
                                    if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                                        revert with 0, 65
                                    mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                    require return_data.size >= _3491 + (32 * _3570) + 32
                                    mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3570] = mem[(4 * ceil32(return_data.size)) + _3491 + 224 len 32 * _3570]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                    if 1 >= _3570:
                                        revert with 0, 50
                                else:
                                    if wftmAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[32] > -1:
                                            revert with 0, 17
                                        mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                                        mem[(4 * ceil32(return_data.size)) + 228] = 0
                                        mem[(4 * ceil32(return_data.size)) + 260] = 160
                                        mem[(4 * ceil32(return_data.size)) + 356] = 2
                                        idx = 0
                                        s = (4 * ceil32(return_data.size)) + 388
                                        t = (4 * ceil32(return_data.size)) + 128
                                        while idx < 2:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                        mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = (6 * ceil32(return_data.size)) + 192
                                        require return_data.size >= 32
                                        _3492 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                                        require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                                        require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                        _3571 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                        if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                                            revert with 0, 65
                                        if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                                            revert with 0, 65
                                        mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                        require return_data.size >= _3492 + (32 * _3571) + 32
                                        mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3571] = mem[(4 * ceil32(return_data.size)) + _3492 + 224 len 32 * _3571]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                        if 1 >= _3571:
                                            revert with 0, 50
                                    else:
                                        if ext_call.return_data[0] > -1:
                                            revert with 0, 17
                                        mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                                        mem[(4 * ceil32(return_data.size)) + 228] = 0
                                        mem[(4 * ceil32(return_data.size)) + 260] = 160
                                        mem[(4 * ceil32(return_data.size)) + 356] = 2
                                        idx = 0
                                        s = (4 * ceil32(return_data.size)) + 388
                                        t = (4 * ceil32(return_data.size)) + 128
                                        while idx < 2:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                        mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = (6 * ceil32(return_data.size)) + 192
                                        require return_data.size >= 32
                                        _3493 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                                        require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                        require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                        _3572 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                        if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                                            revert with 0, 65
                                        if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                                            revert with 0, 65
                                        mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                        require return_data.size >= _3493 + (32 * _3572) + 32
                                        mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3572] = mem[(4 * ceil32(return_data.size)) + _3493 + 224 len 32 * _3572]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                        if 1 >= _3572:
                                            revert with 0, 50
                    else:
                        if brushAddress != address(ext_call.return_data[0]):
                            if wftmAddress == address(ext_call.return_data[0]):
                                if ext_call.return_data[32] > -1:
                                    revert with 0, 17
                                mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                                mem[(4 * ceil32(return_data.size)) + 228] = 0
                                mem[(4 * ceil32(return_data.size)) + 260] = 160
                                mem[(4 * ceil32(return_data.size)) + 356] = 2
                                idx = 0
                                s = (4 * ceil32(return_data.size)) + 388
                                t = (4 * ceil32(return_data.size)) + 128
                                while idx < 2:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (6 * ceil32(return_data.size)) + 192
                                require return_data.size >= 32
                                _3494 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                                require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                _3573 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                                    revert with 0, 65
                                if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                                    revert with 0, 65
                                mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                require return_data.size >= _3494 + (32 * _3573) + 32
                                mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3573] = mem[(4 * ceil32(return_data.size)) + _3494 + 224 len 32 * _3573]
                                if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                    revert with 0, 17
                                maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                if 1 >= _3573:
                                    revert with 0, 50
                            else:
                                if ext_call.return_data[0] > -1:
                                    revert with 0, 17
                                mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                                mem[(4 * ceil32(return_data.size)) + 228] = 0
                                mem[(4 * ceil32(return_data.size)) + 260] = 160
                                mem[(4 * ceil32(return_data.size)) + 356] = 2
                                idx = 0
                                s = (4 * ceil32(return_data.size)) + 388
                                t = (4 * ceil32(return_data.size)) + 128
                                while idx < 2:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (6 * ceil32(return_data.size)) + 192
                                require return_data.size >= 32
                                _3495 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                                require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                _3574 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                                    revert with 0, 65
                                if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                                    revert with 0, 65
                                mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                require return_data.size >= _3495 + (32 * _3574) + 32
                                mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3574] = mem[(4 * ceil32(return_data.size)) + _3495 + 224 len 32 * _3574]
                                if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                    revert with 0, 17
                                maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                if 1 >= _3574:
                                    revert with 0, 50
                        else:
                            if brushAddress == address(ext_call.return_data[0]):
                                if ext_call.return_data[32] > -1:
                                    revert with 0, 17
                                mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                                mem[(4 * ceil32(return_data.size)) + 228] = 0
                                mem[(4 * ceil32(return_data.size)) + 260] = 160
                                mem[(4 * ceil32(return_data.size)) + 356] = 2
                                idx = 0
                                s = (4 * ceil32(return_data.size)) + 388
                                t = (4 * ceil32(return_data.size)) + 128
                                while idx < 2:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (6 * ceil32(return_data.size)) + 192
                                require return_data.size >= 32
                                _3496 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                                require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                _3575 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                                    revert with 0, 65
                                if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                                    revert with 0, 65
                                mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                require return_data.size >= _3496 + (32 * _3575) + 32
                                mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3575] = mem[(4 * ceil32(return_data.size)) + _3496 + 224 len 32 * _3575]
                                if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                    revert with 0, 17
                                maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                if 1 >= _3575:
                                    revert with 0, 50
                            else:
                                if brushAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[0] > -1:
                                        revert with 0, 17
                                    mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                                    mem[(4 * ceil32(return_data.size)) + 228] = 0
                                    mem[(4 * ceil32(return_data.size)) + 260] = 160
                                    mem[(4 * ceil32(return_data.size)) + 356] = 2
                                    idx = 0
                                    s = (4 * ceil32(return_data.size)) + 388
                                    t = (4 * ceil32(return_data.size)) + 128
                                    while idx < 2:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                    mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = (6 * ceil32(return_data.size)) + 192
                                    require return_data.size >= 32
                                    _3497 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                                    require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                    _3576 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                    if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                                        revert with 0, 65
                                    if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                                        revert with 0, 65
                                    mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                    require return_data.size >= _3497 + (32 * _3576) + 32
                                    mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3576] = mem[(4 * ceil32(return_data.size)) + _3497 + 224 len 32 * _3576]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                    if 1 >= _3576:
                                        revert with 0, 50
                                else:
                                    if wftmAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[32] > -1:
                                            revert with 0, 17
                                        mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                                        mem[(4 * ceil32(return_data.size)) + 228] = 0
                                        mem[(4 * ceil32(return_data.size)) + 260] = 160
                                        mem[(4 * ceil32(return_data.size)) + 356] = 2
                                        idx = 0
                                        s = (4 * ceil32(return_data.size)) + 388
                                        t = (4 * ceil32(return_data.size)) + 128
                                        while idx < 2:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                        mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = (6 * ceil32(return_data.size)) + 192
                                        require return_data.size >= 32
                                        _3498 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                                        require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                                        require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                        _3577 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                        if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                                            revert with 0, 65
                                        if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                                            revert with 0, 65
                                        mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                        require return_data.size >= _3498 + (32 * _3577) + 32
                                        mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3577] = mem[(4 * ceil32(return_data.size)) + _3498 + 224 len 32 * _3577]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                        if 1 >= _3577:
                                            revert with 0, 50
                                    else:
                                        if ext_call.return_data[0] > -1:
                                            revert with 0, 17
                                        mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                                        mem[(4 * ceil32(return_data.size)) + 228] = 0
                                        mem[(4 * ceil32(return_data.size)) + 260] = 160
                                        mem[(4 * ceil32(return_data.size)) + 356] = 2
                                        idx = 0
                                        s = (4 * ceil32(return_data.size)) + 388
                                        t = (4 * ceil32(return_data.size)) + 128
                                        while idx < 2:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                        mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = (6 * ceil32(return_data.size)) + 192
                                        require return_data.size >= 32
                                        _3499 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                                        require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                        require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                        _3578 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                        if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                                            revert with 0, 65
                                        if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                                            revert with 0, 65
                                        mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                        require return_data.size >= _3499 + (32 * _3578) + 32
                                        mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3578] = mem[(4 * ceil32(return_data.size)) + _3499 + 224 len 32 * _3578]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                        if 1 >= _3578:
                                            revert with 0, 50
                else:
                    if brushAddress == address(ext_call.return_data[0]):
                        if brushAddress != address(ext_call.return_data[0]):
                            if wftmAddress == address(ext_call.return_data[0]):
                                if ext_call.return_data[32] > -1:
                                    revert with 0, 17
                                mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                                mem[(4 * ceil32(return_data.size)) + 228] = 0
                                mem[(4 * ceil32(return_data.size)) + 260] = 160
                                mem[(4 * ceil32(return_data.size)) + 356] = 2
                                idx = 0
                                s = (4 * ceil32(return_data.size)) + 388
                                t = (4 * ceil32(return_data.size)) + 128
                                while idx < 2:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (6 * ceil32(return_data.size)) + 192
                                require return_data.size >= 32
                                _3500 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                                require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                _3579 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                                    revert with 0, 65
                                if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                                    revert with 0, 65
                                mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                require return_data.size >= _3500 + (32 * _3579) + 32
                                mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3579] = mem[(4 * ceil32(return_data.size)) + _3500 + 224 len 32 * _3579]
                                if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                    revert with 0, 17
                                maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                if 1 >= _3579:
                                    revert with 0, 50
                            else:
                                if ext_call.return_data[0] > -1:
                                    revert with 0, 17
                                mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                                mem[(4 * ceil32(return_data.size)) + 228] = 0
                                mem[(4 * ceil32(return_data.size)) + 260] = 160
                                mem[(4 * ceil32(return_data.size)) + 356] = 2
                                idx = 0
                                s = (4 * ceil32(return_data.size)) + 388
                                t = (4 * ceil32(return_data.size)) + 128
                                while idx < 2:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (6 * ceil32(return_data.size)) + 192
                                require return_data.size >= 32
                                _3501 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                                require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                _3580 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                                    revert with 0, 65
                                if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                                    revert with 0, 65
                                mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                require return_data.size >= _3501 + (32 * _3580) + 32
                                mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3580] = mem[(4 * ceil32(return_data.size)) + _3501 + 224 len 32 * _3580]
                                if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                    revert with 0, 17
                                maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                if 1 >= _3580:
                                    revert with 0, 50
                        else:
                            if brushAddress == address(ext_call.return_data[0]):
                                if ext_call.return_data[32] > -1:
                                    revert with 0, 17
                                mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                                mem[(4 * ceil32(return_data.size)) + 228] = 0
                                mem[(4 * ceil32(return_data.size)) + 260] = 160
                                mem[(4 * ceil32(return_data.size)) + 356] = 2
                                idx = 0
                                s = (4 * ceil32(return_data.size)) + 388
                                t = (4 * ceil32(return_data.size)) + 128
                                while idx < 2:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (6 * ceil32(return_data.size)) + 192
                                require return_data.size >= 32
                                _3502 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                                require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                _3581 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                                    revert with 0, 65
                                if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                                    revert with 0, 65
                                mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                require return_data.size >= _3502 + (32 * _3581) + 32
                                mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3581] = mem[(4 * ceil32(return_data.size)) + _3502 + 224 len 32 * _3581]
                                if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                    revert with 0, 17
                                maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                if 1 >= _3581:
                                    revert with 0, 50
                            else:
                                if brushAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[0] > -1:
                                        revert with 0, 17
                                    mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                                    mem[(4 * ceil32(return_data.size)) + 228] = 0
                                    mem[(4 * ceil32(return_data.size)) + 260] = 160
                                    mem[(4 * ceil32(return_data.size)) + 356] = 2
                                    idx = 0
                                    s = (4 * ceil32(return_data.size)) + 388
                                    t = (4 * ceil32(return_data.size)) + 128
                                    while idx < 2:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                    mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = (6 * ceil32(return_data.size)) + 192
                                    require return_data.size >= 32
                                    _3503 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                                    require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                    _3582 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                    if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                                        revert with 0, 65
                                    if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                                        revert with 0, 65
                                    mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                    require return_data.size >= _3503 + (32 * _3582) + 32
                                    mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3582] = mem[(4 * ceil32(return_data.size)) + _3503 + 224 len 32 * _3582]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                    if 1 >= _3582:
                                        revert with 0, 50
                                else:
                                    if wftmAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[32] > -1:
                                            revert with 0, 17
                                        mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                                        mem[(4 * ceil32(return_data.size)) + 228] = 0
                                        mem[(4 * ceil32(return_data.size)) + 260] = 160
                                        mem[(4 * ceil32(return_data.size)) + 356] = 2
                                        idx = 0
                                        s = (4 * ceil32(return_data.size)) + 388
                                        t = (4 * ceil32(return_data.size)) + 128
                                        while idx < 2:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                        mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = (6 * ceil32(return_data.size)) + 192
                                        require return_data.size >= 32
                                        _3504 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                                        require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                                        require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                        _3583 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                        if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                                            revert with 0, 65
                                        if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                                            revert with 0, 65
                                        mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                        require return_data.size >= _3504 + (32 * _3583) + 32
                                        mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3583] = mem[(4 * ceil32(return_data.size)) + _3504 + 224 len 32 * _3583]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                        if 1 >= _3583:
                                            revert with 0, 50
                                    else:
                                        if ext_call.return_data[0] > -1:
                                            revert with 0, 17
                                        mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                                        mem[(4 * ceil32(return_data.size)) + 228] = 0
                                        mem[(4 * ceil32(return_data.size)) + 260] = 160
                                        mem[(4 * ceil32(return_data.size)) + 356] = 2
                                        idx = 0
                                        s = (4 * ceil32(return_data.size)) + 388
                                        t = (4 * ceil32(return_data.size)) + 128
                                        while idx < 2:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                        mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = (6 * ceil32(return_data.size)) + 192
                                        require return_data.size >= 32
                                        _3505 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                                        require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                        require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                        _3584 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                        if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                                            revert with 0, 65
                                        if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                                            revert with 0, 65
                                        mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                        require return_data.size >= _3505 + (32 * _3584) + 32
                                        mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3584] = mem[(4 * ceil32(return_data.size)) + _3505 + 224 len 32 * _3584]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                        if 1 >= _3584:
                                            revert with 0, 50
                    else:
                        if brushAddress == address(ext_call.return_data[0]):
                            if brushAddress != address(ext_call.return_data[0]):
                                if wftmAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > -1:
                                        revert with 0, 17
                                    mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                                    mem[(4 * ceil32(return_data.size)) + 228] = 0
                                    mem[(4 * ceil32(return_data.size)) + 260] = 160
                                    mem[(4 * ceil32(return_data.size)) + 356] = 2
                                    idx = 0
                                    s = (4 * ceil32(return_data.size)) + 388
                                    t = (4 * ceil32(return_data.size)) + 128
                                    while idx < 2:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                    mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = (6 * ceil32(return_data.size)) + 192
                                    require return_data.size >= 32
                                    _3506 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                                    require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                                    require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                    _3585 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                    if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                                        revert with 0, 65
                                    if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                                        revert with 0, 65
                                    mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                    require return_data.size >= _3506 + (32 * _3585) + 32
                                    mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3585] = mem[(4 * ceil32(return_data.size)) + _3506 + 224 len 32 * _3585]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                    if 1 >= _3585:
                                        revert with 0, 50
                                else:
                                    if ext_call.return_data[0] > -1:
                                        revert with 0, 17
                                    mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                                    mem[(4 * ceil32(return_data.size)) + 228] = 0
                                    mem[(4 * ceil32(return_data.size)) + 260] = 160
                                    mem[(4 * ceil32(return_data.size)) + 356] = 2
                                    idx = 0
                                    s = (4 * ceil32(return_data.size)) + 388
                                    t = (4 * ceil32(return_data.size)) + 128
                                    while idx < 2:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                    mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = (6 * ceil32(return_data.size)) + 192
                                    require return_data.size >= 32
                                    _3507 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                                    require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                    _3586 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                    if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                                        revert with 0, 65
                                    if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                                        revert with 0, 65
                                    mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                    require return_data.size >= _3507 + (32 * _3586) + 32
                                    mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3586] = mem[(4 * ceil32(return_data.size)) + _3507 + 224 len 32 * _3586]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                    if 1 >= _3586:
                                        revert with 0, 50
                            else:
                                if brushAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > -1:
                                        revert with 0, 17
                                    mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                                    mem[(4 * ceil32(return_data.size)) + 228] = 0
                                    mem[(4 * ceil32(return_data.size)) + 260] = 160
                                    mem[(4 * ceil32(return_data.size)) + 356] = 2
                                    idx = 0
                                    s = (4 * ceil32(return_data.size)) + 388
                                    t = (4 * ceil32(return_data.size)) + 128
                                    while idx < 2:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                    mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = (6 * ceil32(return_data.size)) + 192
                                    require return_data.size >= 32
                                    _3508 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                                    require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                                    require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                    _3587 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                    if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                                        revert with 0, 65
                                    if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                                        revert with 0, 65
                                    mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                    require return_data.size >= _3508 + (32 * _3587) + 32
                                    mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3587] = mem[(4 * ceil32(return_data.size)) + _3508 + 224 len 32 * _3587]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                    if 1 >= _3587:
                                        revert with 0, 50
                                else:
                                    if brushAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[0] > -1:
                                            revert with 0, 17
                                        mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                                        mem[(4 * ceil32(return_data.size)) + 228] = 0
                                        mem[(4 * ceil32(return_data.size)) + 260] = 160
                                        mem[(4 * ceil32(return_data.size)) + 356] = 2
                                        idx = 0
                                        s = (4 * ceil32(return_data.size)) + 388
                                        t = (4 * ceil32(return_data.size)) + 128
                                        while idx < 2:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                        mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = (6 * ceil32(return_data.size)) + 192
                                        require return_data.size >= 32
                                        _3509 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                                        require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                        require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                        _3588 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                        if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                                            revert with 0, 65
                                        if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                                            revert with 0, 65
                                        mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                        require return_data.size >= _3509 + (32 * _3588) + 32
                                        mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3588] = mem[(4 * ceil32(return_data.size)) + _3509 + 224 len 32 * _3588]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                        if 1 >= _3588:
                                            revert with 0, 50
                                    else:
                                        if wftmAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > -1:
                                                revert with 0, 17
                                            mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                                            mem[(4 * ceil32(return_data.size)) + 228] = 0
                                            mem[(4 * ceil32(return_data.size)) + 260] = 160
                                            mem[(4 * ceil32(return_data.size)) + 356] = 2
                                            idx = 0
                                            s = (4 * ceil32(return_data.size)) + 388
                                            t = (4 * ceil32(return_data.size)) + 128
                                            while idx < 2:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                            mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                 gas gas_remaining wei
                                                args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = (6 * ceil32(return_data.size)) + 192
                                            require return_data.size >= 32
                                            _3510 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                                            require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                                            require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                            _3589 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                            if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                                                revert with 0, 65
                                            if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                                                revert with 0, 65
                                            mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                            require return_data.size >= _3510 + (32 * _3589) + 32
                                            mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3589] = mem[(4 * ceil32(return_data.size)) + _3510 + 224 len 32 * _3589]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                            if 1 >= _3589:
                                                revert with 0, 50
                                        else:
                                            if ext_call.return_data[0] > -1:
                                                revert with 0, 17
                                            mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                                            mem[(4 * ceil32(return_data.size)) + 228] = 0
                                            mem[(4 * ceil32(return_data.size)) + 260] = 160
                                            mem[(4 * ceil32(return_data.size)) + 356] = 2
                                            idx = 0
                                            s = (4 * ceil32(return_data.size)) + 388
                                            t = (4 * ceil32(return_data.size)) + 128
                                            while idx < 2:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                            mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                 gas gas_remaining wei
                                                args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = (6 * ceil32(return_data.size)) + 192
                                            require return_data.size >= 32
                                            _3511 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                                            require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                            require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                            _3590 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                            if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                                                revert with 0, 65
                                            if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                                                revert with 0, 65
                                            mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                            require return_data.size >= _3511 + (32 * _3590) + 32
                                            mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3590] = mem[(4 * ceil32(return_data.size)) + _3511 + 224 len 32 * _3590]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                            if 1 >= _3590:
                                                revert with 0, 50
                        else:
                            if wftmAddress == address(ext_call.return_data[0]):
                                if brushAddress != address(ext_call.return_data[0]):
                                    if wftmAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[32] > -1:
                                            revert with 0, 17
                                        mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                                        mem[(4 * ceil32(return_data.size)) + 228] = 0
                                        mem[(4 * ceil32(return_data.size)) + 260] = 160
                                        mem[(4 * ceil32(return_data.size)) + 356] = 2
                                        idx = 0
                                        s = (4 * ceil32(return_data.size)) + 388
                                        t = (4 * ceil32(return_data.size)) + 128
                                        while idx < 2:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                        mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = (6 * ceil32(return_data.size)) + 192
                                        require return_data.size >= 32
                                        _3512 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                                        require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                                        require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                        _3591 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                        if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                                            revert with 0, 65
                                        if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                                            revert with 0, 65
                                        mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                        require return_data.size >= _3512 + (32 * _3591) + 32
                                        mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3591] = mem[(4 * ceil32(return_data.size)) + _3512 + 224 len 32 * _3591]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                        if 1 >= _3591:
                                            revert with 0, 50
                                    else:
                                        if ext_call.return_data[0] > -1:
                                            revert with 0, 17
                                        mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                                        mem[(4 * ceil32(return_data.size)) + 228] = 0
                                        mem[(4 * ceil32(return_data.size)) + 260] = 160
                                        mem[(4 * ceil32(return_data.size)) + 356] = 2
                                        idx = 0
                                        s = (4 * ceil32(return_data.size)) + 388
                                        t = (4 * ceil32(return_data.size)) + 128
                                        while idx < 2:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                        mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = (6 * ceil32(return_data.size)) + 192
                                        require return_data.size >= 32
                                        _3513 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                                        require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                        require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                        _3592 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                        if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                                            revert with 0, 65
                                        if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                                            revert with 0, 65
                                        mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                        require return_data.size >= _3513 + (32 * _3592) + 32
                                        mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3592] = mem[(4 * ceil32(return_data.size)) + _3513 + 224 len 32 * _3592]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                        if 1 >= _3592:
                                            revert with 0, 50
                                else:
                                    if brushAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[32] > -1:
                                            revert with 0, 17
                                        mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                                        mem[(4 * ceil32(return_data.size)) + 228] = 0
                                        mem[(4 * ceil32(return_data.size)) + 260] = 160
                                        mem[(4 * ceil32(return_data.size)) + 356] = 2
                                        idx = 0
                                        s = (4 * ceil32(return_data.size)) + 388
                                        t = (4 * ceil32(return_data.size)) + 128
                                        while idx < 2:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                        mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = (6 * ceil32(return_data.size)) + 192
                                        require return_data.size >= 32
                                        _3514 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                                        require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                                        require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                        _3593 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                        if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                                            revert with 0, 65
                                        if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                                            revert with 0, 65
                                        mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                        require return_data.size >= _3514 + (32 * _3593) + 32
                                        mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3593] = mem[(4 * ceil32(return_data.size)) + _3514 + 224 len 32 * _3593]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                        if 1 >= _3593:
                                            revert with 0, 50
                                    else:
                                        if brushAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[0] > -1:
                                                revert with 0, 17
                                            mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                                            mem[(4 * ceil32(return_data.size)) + 228] = 0
                                            mem[(4 * ceil32(return_data.size)) + 260] = 160
                                            mem[(4 * ceil32(return_data.size)) + 356] = 2
                                            idx = 0
                                            s = (4 * ceil32(return_data.size)) + 388
                                            t = (4 * ceil32(return_data.size)) + 128
                                            while idx < 2:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                            mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                 gas gas_remaining wei
                                                args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = (6 * ceil32(return_data.size)) + 192
                                            require return_data.size >= 32
                                            _3515 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                                            require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                            require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                            _3594 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                            if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                                                revert with 0, 65
                                            if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                                                revert with 0, 65
                                            mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                            require return_data.size >= _3515 + (32 * _3594) + 32
                                            mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3594] = mem[(4 * ceil32(return_data.size)) + _3515 + 224 len 32 * _3594]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                            if 1 >= _3594:
                                                revert with 0, 50
                                        else:
                                            if wftmAddress == address(ext_call.return_data[0]):
                                                if ext_call.return_data[32] > -1:
                                                    revert with 0, 17
                                                mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                                                mem[(4 * ceil32(return_data.size)) + 228] = 0
                                                mem[(4 * ceil32(return_data.size)) + 260] = 160
                                                mem[(4 * ceil32(return_data.size)) + 356] = 2
                                                idx = 0
                                                s = (4 * ceil32(return_data.size)) + 388
                                                t = (4 * ceil32(return_data.size)) + 128
                                                while idx < 2:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                                mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                                require ext_code.size(routerAddress)
                                                call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (6 * ceil32(return_data.size)) + 192
                                                require return_data.size >= 32
                                                _3516 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                                                require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                                                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                                _3595 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                                                    revert with 0, 65
                                                if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                                require return_data.size >= _3516 + (32 * _3595) + 32
                                                mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3595] = mem[(4 * ceil32(return_data.size)) + _3516 + 224 len 32 * _3595]
                                                if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                    revert with 0, 17
                                                maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                                if 1 >= _3595:
                                                    revert with 0, 50
                                            else:
                                                if ext_call.return_data[0] > -1:
                                                    revert with 0, 17
                                                mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                                                mem[(4 * ceil32(return_data.size)) + 228] = 0
                                                mem[(4 * ceil32(return_data.size)) + 260] = 160
                                                mem[(4 * ceil32(return_data.size)) + 356] = 2
                                                idx = 0
                                                s = (4 * ceil32(return_data.size)) + 388
                                                t = (4 * ceil32(return_data.size)) + 128
                                                while idx < 2:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                                mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                                require ext_code.size(routerAddress)
                                                call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (6 * ceil32(return_data.size)) + 192
                                                require return_data.size >= 32
                                                _3517 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                                                require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                                _3596 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                                                    revert with 0, 65
                                                if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                                require return_data.size >= _3517 + (32 * _3596) + 32
                                                mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3596] = mem[(4 * ceil32(return_data.size)) + _3517 + 224 len 32 * _3596]
                                                if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                    revert with 0, 17
                                                maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                                if 1 >= _3596:
                                                    revert with 0, 50
                            else:
                                if brushAddress != address(ext_call.return_data[0]):
                                    if wftmAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[32] > -1:
                                            revert with 0, 17
                                        mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                                        mem[(4 * ceil32(return_data.size)) + 228] = 0
                                        mem[(4 * ceil32(return_data.size)) + 260] = 160
                                        mem[(4 * ceil32(return_data.size)) + 356] = 2
                                        idx = 0
                                        s = (4 * ceil32(return_data.size)) + 388
                                        t = (4 * ceil32(return_data.size)) + 128
                                        while idx < 2:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                        mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = (6 * ceil32(return_data.size)) + 192
                                        require return_data.size >= 32
                                        _3518 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                                        require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                                        require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                        _3597 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                        if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                                            revert with 0, 65
                                        if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                                            revert with 0, 65
                                        mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                        require return_data.size >= _3518 + (32 * _3597) + 32
                                        mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3597] = mem[(4 * ceil32(return_data.size)) + _3518 + 224 len 32 * _3597]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                        if 1 >= _3597:
                                            revert with 0, 50
                                    else:
                                        if ext_call.return_data[0] > -1:
                                            revert with 0, 17
                                        mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                                        mem[(4 * ceil32(return_data.size)) + 228] = 0
                                        mem[(4 * ceil32(return_data.size)) + 260] = 160
                                        mem[(4 * ceil32(return_data.size)) + 356] = 2
                                        idx = 0
                                        s = (4 * ceil32(return_data.size)) + 388
                                        t = (4 * ceil32(return_data.size)) + 128
                                        while idx < 2:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                        mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = (6 * ceil32(return_data.size)) + 192
                                        require return_data.size >= 32
                                        _3519 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                                        require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                        require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                        _3598 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                        if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                                            revert with 0, 65
                                        if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                                            revert with 0, 65
                                        mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                        require return_data.size >= _3519 + (32 * _3598) + 32
                                        mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3598] = mem[(4 * ceil32(return_data.size)) + _3519 + 224 len 32 * _3598]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                        if 1 >= _3598:
                                            revert with 0, 50
                                else:
                                    if brushAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[32] > -1:
                                            revert with 0, 17
                                        mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                                        mem[(4 * ceil32(return_data.size)) + 228] = 0
                                        mem[(4 * ceil32(return_data.size)) + 260] = 160
                                        mem[(4 * ceil32(return_data.size)) + 356] = 2
                                        idx = 0
                                        s = (4 * ceil32(return_data.size)) + 388
                                        t = (4 * ceil32(return_data.size)) + 128
                                        while idx < 2:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                        mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = (6 * ceil32(return_data.size)) + 192
                                        require return_data.size >= 32
                                        _3520 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                                        require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                                        require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                        _3599 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                        if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                                            revert with 0, 65
                                        if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                                            revert with 0, 65
                                        mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                        require return_data.size >= _3520 + (32 * _3599) + 32
                                        mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3599] = mem[(4 * ceil32(return_data.size)) + _3520 + 224 len 32 * _3599]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                        if 1 >= _3599:
                                            revert with 0, 50
                                    else:
                                        if brushAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[0] > -1:
                                                revert with 0, 17
                                            mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                                            mem[(4 * ceil32(return_data.size)) + 228] = 0
                                            mem[(4 * ceil32(return_data.size)) + 260] = 160
                                            mem[(4 * ceil32(return_data.size)) + 356] = 2
                                            idx = 0
                                            s = (4 * ceil32(return_data.size)) + 388
                                            t = (4 * ceil32(return_data.size)) + 128
                                            while idx < 2:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                            mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                 gas gas_remaining wei
                                                args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = (6 * ceil32(return_data.size)) + 192
                                            require return_data.size >= 32
                                            _3521 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                                            require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                            require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                            _3600 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                            if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                                                revert with 0, 65
                                            if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                                                revert with 0, 65
                                            mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                            require return_data.size >= _3521 + (32 * _3600) + 32
                                            mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3600] = mem[(4 * ceil32(return_data.size)) + _3521 + 224 len 32 * _3600]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                            if 1 >= _3600:
                                                revert with 0, 50
                                        else:
                                            if wftmAddress == address(ext_call.return_data[0]):
                                                if ext_call.return_data[32] > -1:
                                                    revert with 0, 17
                                                mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                                                mem[(4 * ceil32(return_data.size)) + 228] = 0
                                                mem[(4 * ceil32(return_data.size)) + 260] = 160
                                                mem[(4 * ceil32(return_data.size)) + 356] = 2
                                                idx = 0
                                                s = (4 * ceil32(return_data.size)) + 388
                                                t = (4 * ceil32(return_data.size)) + 128
                                                while idx < 2:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                                mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                                require ext_code.size(routerAddress)
                                                call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (6 * ceil32(return_data.size)) + 192
                                                require return_data.size >= 32
                                                _3522 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                                                require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                                                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                                _3601 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                                                    revert with 0, 65
                                                if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                                require return_data.size >= _3522 + (32 * _3601) + 32
                                                mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3601] = mem[(4 * ceil32(return_data.size)) + _3522 + 224 len 32 * _3601]
                                                if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                    revert with 0, 17
                                                maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                                if 1 >= _3601:
                                                    revert with 0, 50
                                            else:
                                                if ext_call.return_data[0] > -1:
                                                    revert with 0, 17
                                                mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                                                mem[(4 * ceil32(return_data.size)) + 228] = 0
                                                mem[(4 * ceil32(return_data.size)) + 260] = 160
                                                mem[(4 * ceil32(return_data.size)) + 356] = 2
                                                idx = 0
                                                s = (4 * ceil32(return_data.size)) + 388
                                                t = (4 * ceil32(return_data.size)) + 128
                                                while idx < 2:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                                mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                                require ext_code.size(routerAddress)
                                                call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (6 * ceil32(return_data.size)) + 192
                                                require return_data.size >= 32
                                                _3523 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                                                require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                                _3602 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                                                    revert with 0, 65
                                                if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                                require return_data.size >= _3523 + (32 * _3602) + 32
                                                mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3602] = mem[(4 * ceil32(return_data.size)) + _3523 + 224 len 32 * _3602]
                                                if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                    revert with 0, 17
                                                maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                                if 1 >= _3602:
                                                    revert with 0, 50
                if mem[(6 * ceil32(return_data.size)) + 256] > !ext_call.return_data[32]:
                    revert with 0, 17
                require ext_code.size(brushAddress)
                call brushAddress.0x42966c68 with:
                     gas gas_remaining wei
                    args (mem[(6 * ceil32(return_data.size)) + 256] + ext_call.return_data[32])
        else:
            mem[(4 * ceil32(return_data.size)) + 96] = 2
            mem[(4 * ceil32(return_data.size)) + 128] = address(ext_call.return_data[0])
            mem[(4 * ceil32(return_data.size)) + 160] = wftmAddress
            mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
            if wftmAddress == address(ext_call.return_data[0]):
                if wftmAddress == address(ext_call.return_data[0]):
                    mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                    mem[(4 * ceil32(return_data.size)) + 228] = 0
                    mem[(4 * ceil32(return_data.size)) + 260] = 160
                    mem[(4 * ceil32(return_data.size)) + 356] = 2
                    idx = 0
                    s = (4 * ceil32(return_data.size)) + 388
                    t = (4 * ceil32(return_data.size)) + 128
                    while idx < 2:
                        mem[s] = mem[t + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[(4 * ceil32(return_data.size)) + 292] = this.address
                    mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                    require ext_code.size(routerAddress)
                    call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                         gas gas_remaining wei
                        args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = (6 * ceil32(return_data.size)) + 192
                    require return_data.size >= 32
                    _3524 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                    require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                    require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                    _3603 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                    if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                        revert with 0, 65
                    if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                        revert with 0, 65
                    mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193
                    mem[(6 * ceil32(return_data.size)) + 192] = _3603
                    require return_data.size >= _3524 + (32 * _3603) + 32
                    mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3603] = mem[(4 * ceil32(return_data.size)) + _3524 + 224 len 32 * _3603]
                    if 1 >= _3603:
                        revert with 0, 50
                    _6374 = mem[(6 * ceil32(return_data.size)) + 256]
                    _6378 = mem[64]
                    mem[mem[64]] = 2
                    mem[64] = mem[64] + 96
                    if 0 >= mem[_6378]:
                        revert with 0, 50
                    mem[_6378 + 32] = address(ext_call.return_data[0])
                    if 1 >= mem[_6378]:
                        revert with 0, 50
                    mem[_6378 + 64] = brushAddress
                    if brushAddress != address(ext_call.return_data[0]):
                        if wftmAddress == address(ext_call.return_data[0]):
                            if brushAddress != address(ext_call.return_data[0]):
                                if wftmAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_6374:
                                        revert with 0, 17
                                    mem[_6378 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_6378 + 100] = ext_call.return_data[32] + _6374
                                    mem[_6378 + 132] = 0
                                    mem[_6378 + 164] = 160
                                    mem[_6378 + 260] = mem[_6378]
                                    idx = 0
                                    s = _6378 + 292
                                    t = _6378 + 32
                                    while idx < mem[_6378]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_6378 + 196] = this.address
                                    mem[_6378 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _6378 + (32 * mem[_6378]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9034 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _9178 = mem[_9034]
                                    require mem[_9034] <= test266151307()
                                    require _9034 + mem[_9034] + 31 < _9034 + return_data.size
                                    _9322 = mem[_9034 + mem[_9034]]
                                    if mem[_9034 + mem[_9034]] > test266151307():
                                        revert with 0, 65
                                    if _9034 + ceil32(return_data.size) + ceil32(32 * mem[_9034 + mem[_9034]]) + 1 > test266151307() or ceil32(32 * mem[_9034 + mem[_9034]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _9034 + ceil32(return_data.size) + ceil32(32 * mem[_9034 + mem[_9034]]) + 1
                                    mem[_9034 + ceil32(return_data.size)] = _9322
                                    require return_data.size >= _9178 + (32 * _9322) + 32
                                    mem[_9034 + ceil32(return_data.size) + 32 len 32 * _9322] = mem[_9034 + _9178 + 32 len 32 * _9322]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                    if 1 >= _9322:
                                        revert with 0, 50
                                    if mem[_9034 + ceil32(return_data.size) + 64] > -1:
                                        revert with 0, 17
                                    require ext_code.size(brushAddress)
                                    call brushAddress.0x42966c68 with:
                                         gas gas_remaining wei
                                        args mem[_9034 + ceil32(return_data.size) + 64]
                                else:
                                    if ext_call.return_data[0] > !_6374:
                                        revert with 0, 17
                                    mem[_6378 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_6378 + 100] = ext_call.return_data[0] + _6374
                                    mem[_6378 + 132] = 0
                                    mem[_6378 + 164] = 160
                                    mem[_6378 + 260] = mem[_6378]
                                    idx = 0
                                    s = _6378 + 292
                                    t = _6378 + 32
                                    while idx < mem[_6378]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_6378 + 196] = this.address
                                    mem[_6378 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _6378 + (32 * mem[_6378]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9035 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _9179 = mem[_9035]
                                    require mem[_9035] <= test266151307()
                                    require _9035 + mem[_9035] + 31 < _9035 + return_data.size
                                    _9323 = mem[_9035 + mem[_9035]]
                                    if mem[_9035 + mem[_9035]] > test266151307():
                                        revert with 0, 65
                                    if _9035 + ceil32(return_data.size) + ceil32(32 * mem[_9035 + mem[_9035]]) + 1 > test266151307() or ceil32(32 * mem[_9035 + mem[_9035]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _9035 + ceil32(return_data.size) + ceil32(32 * mem[_9035 + mem[_9035]]) + 1
                                    mem[_9035 + ceil32(return_data.size)] = _9323
                                    require return_data.size >= _9179 + (32 * _9323) + 32
                                    mem[_9035 + ceil32(return_data.size) + 32 len 32 * _9323] = mem[_9035 + _9179 + 32 len 32 * _9323]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                    if 1 >= _9323:
                                        revert with 0, 50
                                    if mem[_9035 + ceil32(return_data.size) + 64] > -1:
                                        revert with 0, 17
                                    require ext_code.size(brushAddress)
                                    call brushAddress.0x42966c68 with:
                                         gas gas_remaining wei
                                        args mem[_9035 + ceil32(return_data.size) + 64]
                            else:
                                if brushAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_6374:
                                        revert with 0, 17
                                    mem[_6378 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_6378 + 100] = ext_call.return_data[32] + _6374
                                    mem[_6378 + 132] = 0
                                    mem[_6378 + 164] = 160
                                    mem[_6378 + 260] = mem[_6378]
                                    idx = 0
                                    s = _6378 + 292
                                    t = _6378 + 32
                                    while idx < mem[_6378]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_6378 + 196] = this.address
                                    mem[_6378 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _6378 + (32 * mem[_6378]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9036 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _9180 = mem[_9036]
                                    require mem[_9036] <= test266151307()
                                    require _9036 + mem[_9036] + 31 < _9036 + return_data.size
                                    _9324 = mem[_9036 + mem[_9036]]
                                    if mem[_9036 + mem[_9036]] > test266151307():
                                        revert with 0, 65
                                    if _9036 + ceil32(return_data.size) + ceil32(32 * mem[_9036 + mem[_9036]]) + 1 > test266151307() or ceil32(32 * mem[_9036 + mem[_9036]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _9036 + ceil32(return_data.size) + ceil32(32 * mem[_9036 + mem[_9036]]) + 1
                                    mem[_9036 + ceil32(return_data.size)] = _9324
                                    require return_data.size >= _9180 + (32 * _9324) + 32
                                    mem[_9036 + ceil32(return_data.size) + 32 len 32 * _9324] = mem[_9036 + _9180 + 32 len 32 * _9324]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                    if 1 >= _9324:
                                        revert with 0, 50
                                    if mem[_9036 + ceil32(return_data.size) + 64] > -1:
                                        revert with 0, 17
                                    require ext_code.size(brushAddress)
                                    call brushAddress.0x42966c68 with:
                                         gas gas_remaining wei
                                        args mem[_9036 + ceil32(return_data.size) + 64]
                                else:
                                    if brushAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[0] > !_6374:
                                            revert with 0, 17
                                        mem[_6378 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_6378 + 100] = ext_call.return_data[0] + _6374
                                        mem[_6378 + 132] = 0
                                        mem[_6378 + 164] = 160
                                        mem[_6378 + 260] = mem[_6378]
                                        idx = 0
                                        s = _6378 + 292
                                        t = _6378 + 32
                                        while idx < mem[_6378]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_6378 + 196] = this.address
                                        mem[_6378 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _6378 + (32 * mem[_6378]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9037 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _9181 = mem[_9037]
                                        require mem[_9037] <= test266151307()
                                        require _9037 + mem[_9037] + 31 < _9037 + return_data.size
                                        _9325 = mem[_9037 + mem[_9037]]
                                        if mem[_9037 + mem[_9037]] > test266151307():
                                            revert with 0, 65
                                        if _9037 + ceil32(return_data.size) + ceil32(32 * mem[_9037 + mem[_9037]]) + 1 > test266151307() or ceil32(32 * mem[_9037 + mem[_9037]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _9037 + ceil32(return_data.size) + ceil32(32 * mem[_9037 + mem[_9037]]) + 1
                                        mem[_9037 + ceil32(return_data.size)] = _9325
                                        require return_data.size >= _9181 + (32 * _9325) + 32
                                        mem[_9037 + ceil32(return_data.size) + 32 len 32 * _9325] = mem[_9037 + _9181 + 32 len 32 * _9325]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                        if 1 >= _9325:
                                            revert with 0, 50
                                        if mem[_9037 + ceil32(return_data.size) + 64] > -1:
                                            revert with 0, 17
                                        require ext_code.size(brushAddress)
                                        call brushAddress.0x42966c68 with:
                                             gas gas_remaining wei
                                            args mem[_9037 + ceil32(return_data.size) + 64]
                                    else:
                                        if wftmAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_6374:
                                                revert with 0, 17
                                            mem[_6378 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_6378 + 100] = ext_call.return_data[32] + _6374
                                            mem[_6378 + 132] = 0
                                            mem[_6378 + 164] = 160
                                            mem[_6378 + 260] = mem[_6378]
                                            idx = 0
                                            s = _6378 + 292
                                            t = _6378 + 32
                                            while idx < mem[_6378]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_6378 + 196] = this.address
                                            mem[_6378 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _6378 + (32 * mem[_6378]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9038 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _9182 = mem[_9038]
                                            require mem[_9038] <= test266151307()
                                            require _9038 + mem[_9038] + 31 < _9038 + return_data.size
                                            _9326 = mem[_9038 + mem[_9038]]
                                            if mem[_9038 + mem[_9038]] > test266151307():
                                                revert with 0, 65
                                            if _9038 + ceil32(return_data.size) + ceil32(32 * mem[_9038 + mem[_9038]]) + 1 > test266151307() or ceil32(32 * mem[_9038 + mem[_9038]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _9038 + ceil32(return_data.size) + ceil32(32 * mem[_9038 + mem[_9038]]) + 1
                                            mem[_9038 + ceil32(return_data.size)] = _9326
                                            require return_data.size >= _9182 + (32 * _9326) + 32
                                            mem[_9038 + ceil32(return_data.size) + 32 len 32 * _9326] = mem[_9038 + _9182 + 32 len 32 * _9326]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                            if 1 >= _9326:
                                                revert with 0, 50
                                            if mem[_9038 + ceil32(return_data.size) + 64] > -1:
                                                revert with 0, 17
                                            require ext_code.size(brushAddress)
                                            call brushAddress.0x42966c68 with:
                                                 gas gas_remaining wei
                                                args mem[_9038 + ceil32(return_data.size) + 64]
                                        else:
                                            if ext_call.return_data[0] > !_6374:
                                                revert with 0, 17
                                            mem[_6378 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_6378 + 100] = ext_call.return_data[0] + _6374
                                            mem[_6378 + 132] = 0
                                            mem[_6378 + 164] = 160
                                            mem[_6378 + 260] = mem[_6378]
                                            idx = 0
                                            s = _6378 + 292
                                            t = _6378 + 32
                                            while idx < mem[_6378]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_6378 + 196] = this.address
                                            mem[_6378 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _6378 + (32 * mem[_6378]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9039 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _9183 = mem[_9039]
                                            require mem[_9039] <= test266151307()
                                            require _9039 + mem[_9039] + 31 < _9039 + return_data.size
                                            _9327 = mem[_9039 + mem[_9039]]
                                            if mem[_9039 + mem[_9039]] > test266151307():
                                                revert with 0, 65
                                            if _9039 + ceil32(return_data.size) + ceil32(32 * mem[_9039 + mem[_9039]]) + 1 > test266151307() or ceil32(32 * mem[_9039 + mem[_9039]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _9039 + ceil32(return_data.size) + ceil32(32 * mem[_9039 + mem[_9039]]) + 1
                                            mem[_9039 + ceil32(return_data.size)] = _9327
                                            require return_data.size >= _9183 + (32 * _9327) + 32
                                            mem[_9039 + ceil32(return_data.size) + 32 len 32 * _9327] = mem[_9039 + _9183 + 32 len 32 * _9327]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                            if 1 >= _9327:
                                                revert with 0, 50
                                            if mem[_9039 + ceil32(return_data.size) + 64] > -1:
                                                revert with 0, 17
                                            require ext_code.size(brushAddress)
                                            call brushAddress.0x42966c68 with:
                                                 gas gas_remaining wei
                                                args mem[_9039 + ceil32(return_data.size) + 64]
                        else:
                            if brushAddress != address(ext_call.return_data[0]):
                                if wftmAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_6374:
                                        revert with 0, 17
                                    mem[_6378 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_6378 + 100] = ext_call.return_data[32] + _6374
                                    mem[_6378 + 132] = 0
                                    mem[_6378 + 164] = 160
                                    mem[_6378 + 260] = mem[_6378]
                                    idx = 0
                                    s = _6378 + 292
                                    t = _6378 + 32
                                    while idx < mem[_6378]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_6378 + 196] = this.address
                                    mem[_6378 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _6378 + (32 * mem[_6378]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9040 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _9184 = mem[_9040]
                                    require mem[_9040] <= test266151307()
                                    require _9040 + mem[_9040] + 31 < _9040 + return_data.size
                                    _9328 = mem[_9040 + mem[_9040]]
                                    if mem[_9040 + mem[_9040]] > test266151307():
                                        revert with 0, 65
                                    if _9040 + ceil32(return_data.size) + ceil32(32 * mem[_9040 + mem[_9040]]) + 1 > test266151307() or ceil32(32 * mem[_9040 + mem[_9040]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _9040 + ceil32(return_data.size) + ceil32(32 * mem[_9040 + mem[_9040]]) + 1
                                    mem[_9040 + ceil32(return_data.size)] = _9328
                                    require return_data.size >= _9184 + (32 * _9328) + 32
                                    mem[_9040 + ceil32(return_data.size) + 32 len 32 * _9328] = mem[_9040 + _9184 + 32 len 32 * _9328]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                    if 1 >= _9328:
                                        revert with 0, 50
                                    if mem[_9040 + ceil32(return_data.size) + 64] > -1:
                                        revert with 0, 17
                                    require ext_code.size(brushAddress)
                                    call brushAddress.0x42966c68 with:
                                         gas gas_remaining wei
                                        args mem[_9040 + ceil32(return_data.size) + 64]
                                else:
                                    if ext_call.return_data[0] > !_6374:
                                        revert with 0, 17
                                    mem[_6378 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_6378 + 100] = ext_call.return_data[0] + _6374
                                    mem[_6378 + 132] = 0
                                    mem[_6378 + 164] = 160
                                    mem[_6378 + 260] = mem[_6378]
                                    idx = 0
                                    s = _6378 + 292
                                    t = _6378 + 32
                                    while idx < mem[_6378]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_6378 + 196] = this.address
                                    mem[_6378 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _6378 + (32 * mem[_6378]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9041 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _9185 = mem[_9041]
                                    require mem[_9041] <= test266151307()
                                    require _9041 + mem[_9041] + 31 < _9041 + return_data.size
                                    _9329 = mem[_9041 + mem[_9041]]
                                    if mem[_9041 + mem[_9041]] > test266151307():
                                        revert with 0, 65
                                    if _9041 + ceil32(return_data.size) + ceil32(32 * mem[_9041 + mem[_9041]]) + 1 > test266151307() or ceil32(32 * mem[_9041 + mem[_9041]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _9041 + ceil32(return_data.size) + ceil32(32 * mem[_9041 + mem[_9041]]) + 1
                                    mem[_9041 + ceil32(return_data.size)] = _9329
                                    require return_data.size >= _9185 + (32 * _9329) + 32
                                    mem[_9041 + ceil32(return_data.size) + 32 len 32 * _9329] = mem[_9041 + _9185 + 32 len 32 * _9329]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                    if 1 >= _9329:
                                        revert with 0, 50
                                    if mem[_9041 + ceil32(return_data.size) + 64] > -1:
                                        revert with 0, 17
                                    require ext_code.size(brushAddress)
                                    call brushAddress.0x42966c68 with:
                                         gas gas_remaining wei
                                        args mem[_9041 + ceil32(return_data.size) + 64]
                            else:
                                if brushAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_6374:
                                        revert with 0, 17
                                    mem[_6378 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_6378 + 100] = ext_call.return_data[32] + _6374
                                    mem[_6378 + 132] = 0
                                    mem[_6378 + 164] = 160
                                    mem[_6378 + 260] = mem[_6378]
                                    idx = 0
                                    s = _6378 + 292
                                    t = _6378 + 32
                                    while idx < mem[_6378]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_6378 + 196] = this.address
                                    mem[_6378 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _6378 + (32 * mem[_6378]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9042 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _9186 = mem[_9042]
                                    require mem[_9042] <= test266151307()
                                    require _9042 + mem[_9042] + 31 < _9042 + return_data.size
                                    _9330 = mem[_9042 + mem[_9042]]
                                    if mem[_9042 + mem[_9042]] > test266151307():
                                        revert with 0, 65
                                    if _9042 + ceil32(return_data.size) + ceil32(32 * mem[_9042 + mem[_9042]]) + 1 > test266151307() or ceil32(32 * mem[_9042 + mem[_9042]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _9042 + ceil32(return_data.size) + ceil32(32 * mem[_9042 + mem[_9042]]) + 1
                                    mem[_9042 + ceil32(return_data.size)] = _9330
                                    require return_data.size >= _9186 + (32 * _9330) + 32
                                    mem[_9042 + ceil32(return_data.size) + 32 len 32 * _9330] = mem[_9042 + _9186 + 32 len 32 * _9330]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                    if 1 >= _9330:
                                        revert with 0, 50
                                    if mem[_9042 + ceil32(return_data.size) + 64] > -1:
                                        revert with 0, 17
                                    require ext_code.size(brushAddress)
                                    call brushAddress.0x42966c68 with:
                                         gas gas_remaining wei
                                        args mem[_9042 + ceil32(return_data.size) + 64]
                                else:
                                    if brushAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[0] > !_6374:
                                            revert with 0, 17
                                        mem[_6378 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_6378 + 100] = ext_call.return_data[0] + _6374
                                        mem[_6378 + 132] = 0
                                        mem[_6378 + 164] = 160
                                        mem[_6378 + 260] = mem[_6378]
                                        idx = 0
                                        s = _6378 + 292
                                        t = _6378 + 32
                                        while idx < mem[_6378]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_6378 + 196] = this.address
                                        mem[_6378 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _6378 + (32 * mem[_6378]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9043 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _9187 = mem[_9043]
                                        require mem[_9043] <= test266151307()
                                        require _9043 + mem[_9043] + 31 < _9043 + return_data.size
                                        _9331 = mem[_9043 + mem[_9043]]
                                        if mem[_9043 + mem[_9043]] > test266151307():
                                            revert with 0, 65
                                        if _9043 + ceil32(return_data.size) + ceil32(32 * mem[_9043 + mem[_9043]]) + 1 > test266151307() or ceil32(32 * mem[_9043 + mem[_9043]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _9043 + ceil32(return_data.size) + ceil32(32 * mem[_9043 + mem[_9043]]) + 1
                                        mem[_9043 + ceil32(return_data.size)] = _9331
                                        require return_data.size >= _9187 + (32 * _9331) + 32
                                        mem[_9043 + ceil32(return_data.size) + 32 len 32 * _9331] = mem[_9043 + _9187 + 32 len 32 * _9331]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                        if 1 >= _9331:
                                            revert with 0, 50
                                        if mem[_9043 + ceil32(return_data.size) + 64] > -1:
                                            revert with 0, 17
                                        require ext_code.size(brushAddress)
                                        call brushAddress.0x42966c68 with:
                                             gas gas_remaining wei
                                            args mem[_9043 + ceil32(return_data.size) + 64]
                                    else:
                                        if wftmAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_6374:
                                                revert with 0, 17
                                            mem[_6378 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_6378 + 100] = ext_call.return_data[32] + _6374
                                            mem[_6378 + 132] = 0
                                            mem[_6378 + 164] = 160
                                            mem[_6378 + 260] = mem[_6378]
                                            idx = 0
                                            s = _6378 + 292
                                            t = _6378 + 32
                                            while idx < mem[_6378]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_6378 + 196] = this.address
                                            mem[_6378 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _6378 + (32 * mem[_6378]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9044 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _9188 = mem[_9044]
                                            require mem[_9044] <= test266151307()
                                            require _9044 + mem[_9044] + 31 < _9044 + return_data.size
                                            _9332 = mem[_9044 + mem[_9044]]
                                            if mem[_9044 + mem[_9044]] > test266151307():
                                                revert with 0, 65
                                            if _9044 + ceil32(return_data.size) + ceil32(32 * mem[_9044 + mem[_9044]]) + 1 > test266151307() or ceil32(32 * mem[_9044 + mem[_9044]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _9044 + ceil32(return_data.size) + ceil32(32 * mem[_9044 + mem[_9044]]) + 1
                                            mem[_9044 + ceil32(return_data.size)] = _9332
                                            require return_data.size >= _9188 + (32 * _9332) + 32
                                            mem[_9044 + ceil32(return_data.size) + 32 len 32 * _9332] = mem[_9044 + _9188 + 32 len 32 * _9332]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                            if 1 >= _9332:
                                                revert with 0, 50
                                            if mem[_9044 + ceil32(return_data.size) + 64] > -1:
                                                revert with 0, 17
                                            require ext_code.size(brushAddress)
                                            call brushAddress.0x42966c68 with:
                                                 gas gas_remaining wei
                                                args mem[_9044 + ceil32(return_data.size) + 64]
                                        else:
                                            if ext_call.return_data[0] > !_6374:
                                                revert with 0, 17
                                            mem[_6378 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_6378 + 100] = ext_call.return_data[0] + _6374
                                            mem[_6378 + 132] = 0
                                            mem[_6378 + 164] = 160
                                            mem[_6378 + 260] = mem[_6378]
                                            idx = 0
                                            s = _6378 + 292
                                            t = _6378 + 32
                                            while idx < mem[_6378]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_6378 + 196] = this.address
                                            mem[_6378 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _6378 + (32 * mem[_6378]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9045 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _9189 = mem[_9045]
                                            require mem[_9045] <= test266151307()
                                            require _9045 + mem[_9045] + 31 < _9045 + return_data.size
                                            _9333 = mem[_9045 + mem[_9045]]
                                            if mem[_9045 + mem[_9045]] > test266151307():
                                                revert with 0, 65
                                            if _9045 + ceil32(return_data.size) + ceil32(32 * mem[_9045 + mem[_9045]]) + 1 > test266151307() or ceil32(32 * mem[_9045 + mem[_9045]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _9045 + ceil32(return_data.size) + ceil32(32 * mem[_9045 + mem[_9045]]) + 1
                                            mem[_9045 + ceil32(return_data.size)] = _9333
                                            require return_data.size >= _9189 + (32 * _9333) + 32
                                            mem[_9045 + ceil32(return_data.size) + 32 len 32 * _9333] = mem[_9045 + _9189 + 32 len 32 * _9333]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                            if 1 >= _9333:
                                                revert with 0, 50
                                            if mem[_9045 + ceil32(return_data.size) + 64] > -1:
                                                revert with 0, 17
                                            require ext_code.size(brushAddress)
                                            call brushAddress.0x42966c68 with:
                                                 gas gas_remaining wei
                                                args mem[_9045 + ceil32(return_data.size) + 64]
                    else:
                        if brushAddress == address(ext_call.return_data[0]):
                            if brushAddress != address(ext_call.return_data[0]):
                                if wftmAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_6374:
                                        revert with 0, 17
                                    mem[_6378 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_6378 + 100] = ext_call.return_data[32] + _6374
                                    mem[_6378 + 132] = 0
                                    mem[_6378 + 164] = 160
                                    mem[_6378 + 260] = mem[_6378]
                                    idx = 0
                                    s = _6378 + 292
                                    t = _6378 + 32
                                    while idx < mem[_6378]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_6378 + 196] = this.address
                                    mem[_6378 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _6378 + (32 * mem[_6378]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9046 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _9190 = mem[_9046]
                                    require mem[_9046] <= test266151307()
                                    require _9046 + mem[_9046] + 31 < _9046 + return_data.size
                                    _9334 = mem[_9046 + mem[_9046]]
                                    if mem[_9046 + mem[_9046]] > test266151307():
                                        revert with 0, 65
                                    if _9046 + ceil32(return_data.size) + ceil32(32 * mem[_9046 + mem[_9046]]) + 1 > test266151307() or ceil32(32 * mem[_9046 + mem[_9046]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _9046 + ceil32(return_data.size) + ceil32(32 * mem[_9046 + mem[_9046]]) + 1
                                    mem[_9046 + ceil32(return_data.size)] = _9334
                                    require return_data.size >= _9190 + (32 * _9334) + 32
                                    mem[_9046 + ceil32(return_data.size) + 32 len 32 * _9334] = mem[_9046 + _9190 + 32 len 32 * _9334]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                    if 1 >= _9334:
                                        revert with 0, 50
                                    if mem[_9046 + ceil32(return_data.size) + 64] > -1:
                                        revert with 0, 17
                                    require ext_code.size(brushAddress)
                                    call brushAddress.0x42966c68 with:
                                         gas gas_remaining wei
                                        args mem[_9046 + ceil32(return_data.size) + 64]
                                else:
                                    if ext_call.return_data[0] > !_6374:
                                        revert with 0, 17
                                    mem[_6378 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_6378 + 100] = ext_call.return_data[0] + _6374
                                    mem[_6378 + 132] = 0
                                    mem[_6378 + 164] = 160
                                    mem[_6378 + 260] = mem[_6378]
                                    idx = 0
                                    s = _6378 + 292
                                    t = _6378 + 32
                                    while idx < mem[_6378]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_6378 + 196] = this.address
                                    mem[_6378 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _6378 + (32 * mem[_6378]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9047 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _9191 = mem[_9047]
                                    require mem[_9047] <= test266151307()
                                    require _9047 + mem[_9047] + 31 < _9047 + return_data.size
                                    _9335 = mem[_9047 + mem[_9047]]
                                    if mem[_9047 + mem[_9047]] > test266151307():
                                        revert with 0, 65
                                    if _9047 + ceil32(return_data.size) + ceil32(32 * mem[_9047 + mem[_9047]]) + 1 > test266151307() or ceil32(32 * mem[_9047 + mem[_9047]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _9047 + ceil32(return_data.size) + ceil32(32 * mem[_9047 + mem[_9047]]) + 1
                                    mem[_9047 + ceil32(return_data.size)] = _9335
                                    require return_data.size >= _9191 + (32 * _9335) + 32
                                    mem[_9047 + ceil32(return_data.size) + 32 len 32 * _9335] = mem[_9047 + _9191 + 32 len 32 * _9335]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                    if 1 >= _9335:
                                        revert with 0, 50
                                    if mem[_9047 + ceil32(return_data.size) + 64] > -1:
                                        revert with 0, 17
                                    require ext_code.size(brushAddress)
                                    call brushAddress.0x42966c68 with:
                                         gas gas_remaining wei
                                        args mem[_9047 + ceil32(return_data.size) + 64]
                            else:
                                if brushAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_6374:
                                        revert with 0, 17
                                    mem[_6378 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_6378 + 100] = ext_call.return_data[32] + _6374
                                    mem[_6378 + 132] = 0
                                    mem[_6378 + 164] = 160
                                    mem[_6378 + 260] = mem[_6378]
                                    idx = 0
                                    s = _6378 + 292
                                    t = _6378 + 32
                                    while idx < mem[_6378]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_6378 + 196] = this.address
                                    mem[_6378 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _6378 + (32 * mem[_6378]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9048 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _9192 = mem[_9048]
                                    require mem[_9048] <= test266151307()
                                    require _9048 + mem[_9048] + 31 < _9048 + return_data.size
                                    _9336 = mem[_9048 + mem[_9048]]
                                    if mem[_9048 + mem[_9048]] > test266151307():
                                        revert with 0, 65
                                    if _9048 + ceil32(return_data.size) + ceil32(32 * mem[_9048 + mem[_9048]]) + 1 > test266151307() or ceil32(32 * mem[_9048 + mem[_9048]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _9048 + ceil32(return_data.size) + ceil32(32 * mem[_9048 + mem[_9048]]) + 1
                                    mem[_9048 + ceil32(return_data.size)] = _9336
                                    require return_data.size >= _9192 + (32 * _9336) + 32
                                    mem[_9048 + ceil32(return_data.size) + 32 len 32 * _9336] = mem[_9048 + _9192 + 32 len 32 * _9336]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                    if 1 >= _9336:
                                        revert with 0, 50
                                    if mem[_9048 + ceil32(return_data.size) + 64] > -1:
                                        revert with 0, 17
                                    require ext_code.size(brushAddress)
                                    call brushAddress.0x42966c68 with:
                                         gas gas_remaining wei
                                        args mem[_9048 + ceil32(return_data.size) + 64]
                                else:
                                    if brushAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[0] > !_6374:
                                            revert with 0, 17
                                        mem[_6378 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_6378 + 100] = ext_call.return_data[0] + _6374
                                        mem[_6378 + 132] = 0
                                        mem[_6378 + 164] = 160
                                        mem[_6378 + 260] = mem[_6378]
                                        idx = 0
                                        s = _6378 + 292
                                        t = _6378 + 32
                                        while idx < mem[_6378]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_6378 + 196] = this.address
                                        mem[_6378 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _6378 + (32 * mem[_6378]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9049 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _9193 = mem[_9049]
                                        require mem[_9049] <= test266151307()
                                        require _9049 + mem[_9049] + 31 < _9049 + return_data.size
                                        _9337 = mem[_9049 + mem[_9049]]
                                        if mem[_9049 + mem[_9049]] > test266151307():
                                            revert with 0, 65
                                        if _9049 + ceil32(return_data.size) + ceil32(32 * mem[_9049 + mem[_9049]]) + 1 > test266151307() or ceil32(32 * mem[_9049 + mem[_9049]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _9049 + ceil32(return_data.size) + ceil32(32 * mem[_9049 + mem[_9049]]) + 1
                                        mem[_9049 + ceil32(return_data.size)] = _9337
                                        require return_data.size >= _9193 + (32 * _9337) + 32
                                        mem[_9049 + ceil32(return_data.size) + 32 len 32 * _9337] = mem[_9049 + _9193 + 32 len 32 * _9337]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                        if 1 >= _9337:
                                            revert with 0, 50
                                        if mem[_9049 + ceil32(return_data.size) + 64] > -1:
                                            revert with 0, 17
                                        require ext_code.size(brushAddress)
                                        call brushAddress.0x42966c68 with:
                                             gas gas_remaining wei
                                            args mem[_9049 + ceil32(return_data.size) + 64]
                                    else:
                                        if wftmAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_6374:
                                                revert with 0, 17
                                            mem[_6378 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_6378 + 100] = ext_call.return_data[32] + _6374
                                            mem[_6378 + 132] = 0
                                            mem[_6378 + 164] = 160
                                            mem[_6378 + 260] = mem[_6378]
                                            idx = 0
                                            s = _6378 + 292
                                            t = _6378 + 32
                                            while idx < mem[_6378]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_6378 + 196] = this.address
                                            mem[_6378 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _6378 + (32 * mem[_6378]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9050 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _9194 = mem[_9050]
                                            require mem[_9050] <= test266151307()
                                            require _9050 + mem[_9050] + 31 < _9050 + return_data.size
                                            _9338 = mem[_9050 + mem[_9050]]
                                            if mem[_9050 + mem[_9050]] > test266151307():
                                                revert with 0, 65
                                            if _9050 + ceil32(return_data.size) + ceil32(32 * mem[_9050 + mem[_9050]]) + 1 > test266151307() or ceil32(32 * mem[_9050 + mem[_9050]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _9050 + ceil32(return_data.size) + ceil32(32 * mem[_9050 + mem[_9050]]) + 1
                                            mem[_9050 + ceil32(return_data.size)] = _9338
                                            require return_data.size >= _9194 + (32 * _9338) + 32
                                            mem[_9050 + ceil32(return_data.size) + 32 len 32 * _9338] = mem[_9050 + _9194 + 32 len 32 * _9338]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                            if 1 >= _9338:
                                                revert with 0, 50
                                            if mem[_9050 + ceil32(return_data.size) + 64] > -1:
                                                revert with 0, 17
                                            require ext_code.size(brushAddress)
                                            call brushAddress.0x42966c68 with:
                                                 gas gas_remaining wei
                                                args mem[_9050 + ceil32(return_data.size) + 64]
                                        else:
                                            if ext_call.return_data[0] > !_6374:
                                                revert with 0, 17
                                            mem[_6378 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_6378 + 100] = ext_call.return_data[0] + _6374
                                            mem[_6378 + 132] = 0
                                            mem[_6378 + 164] = 160
                                            mem[_6378 + 260] = mem[_6378]
                                            idx = 0
                                            s = _6378 + 292
                                            t = _6378 + 32
                                            while idx < mem[_6378]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_6378 + 196] = this.address
                                            mem[_6378 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _6378 + (32 * mem[_6378]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9051 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _9195 = mem[_9051]
                                            require mem[_9051] <= test266151307()
                                            require _9051 + mem[_9051] + 31 < _9051 + return_data.size
                                            _9339 = mem[_9051 + mem[_9051]]
                                            if mem[_9051 + mem[_9051]] > test266151307():
                                                revert with 0, 65
                                            if _9051 + ceil32(return_data.size) + ceil32(32 * mem[_9051 + mem[_9051]]) + 1 > test266151307() or ceil32(32 * mem[_9051 + mem[_9051]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _9051 + ceil32(return_data.size) + ceil32(32 * mem[_9051 + mem[_9051]]) + 1
                                            mem[_9051 + ceil32(return_data.size)] = _9339
                                            require return_data.size >= _9195 + (32 * _9339) + 32
                                            mem[_9051 + ceil32(return_data.size) + 32 len 32 * _9339] = mem[_9051 + _9195 + 32 len 32 * _9339]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                            if 1 >= _9339:
                                                revert with 0, 50
                                            if mem[_9051 + ceil32(return_data.size) + 64] > -1:
                                                revert with 0, 17
                                            require ext_code.size(brushAddress)
                                            call brushAddress.0x42966c68 with:
                                                 gas gas_remaining wei
                                                args mem[_9051 + ceil32(return_data.size) + 64]
                        else:
                            if brushAddress == address(ext_call.return_data[0]):
                                if brushAddress != address(ext_call.return_data[0]):
                                    if wftmAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[32] > !_6374:
                                            revert with 0, 17
                                        mem[_6378 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_6378 + 100] = ext_call.return_data[32] + _6374
                                        mem[_6378 + 132] = 0
                                        mem[_6378 + 164] = 160
                                        mem[_6378 + 260] = mem[_6378]
                                        idx = 0
                                        s = _6378 + 292
                                        t = _6378 + 32
                                        while idx < mem[_6378]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_6378 + 196] = this.address
                                        mem[_6378 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _6378 + (32 * mem[_6378]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9052 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _9196 = mem[_9052]
                                        require mem[_9052] <= test266151307()
                                        require _9052 + mem[_9052] + 31 < _9052 + return_data.size
                                        _9340 = mem[_9052 + mem[_9052]]
                                        if mem[_9052 + mem[_9052]] > test266151307():
                                            revert with 0, 65
                                        if _9052 + ceil32(return_data.size) + ceil32(32 * mem[_9052 + mem[_9052]]) + 1 > test266151307() or ceil32(32 * mem[_9052 + mem[_9052]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _9052 + ceil32(return_data.size) + ceil32(32 * mem[_9052 + mem[_9052]]) + 1
                                        mem[_9052 + ceil32(return_data.size)] = _9340
                                        require return_data.size >= _9196 + (32 * _9340) + 32
                                        mem[_9052 + ceil32(return_data.size) + 32 len 32 * _9340] = mem[_9052 + _9196 + 32 len 32 * _9340]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                        if 1 >= _9340:
                                            revert with 0, 50
                                        if mem[_9052 + ceil32(return_data.size) + 64] > -1:
                                            revert with 0, 17
                                        require ext_code.size(brushAddress)
                                        call brushAddress.0x42966c68 with:
                                             gas gas_remaining wei
                                            args mem[_9052 + ceil32(return_data.size) + 64]
                                    else:
                                        if ext_call.return_data[0] > !_6374:
                                            revert with 0, 17
                                        mem[_6378 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_6378 + 100] = ext_call.return_data[0] + _6374
                                        mem[_6378 + 132] = 0
                                        mem[_6378 + 164] = 160
                                        mem[_6378 + 260] = mem[_6378]
                                        idx = 0
                                        s = _6378 + 292
                                        t = _6378 + 32
                                        while idx < mem[_6378]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_6378 + 196] = this.address
                                        mem[_6378 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _6378 + (32 * mem[_6378]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9053 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _9197 = mem[_9053]
                                        require mem[_9053] <= test266151307()
                                        require _9053 + mem[_9053] + 31 < _9053 + return_data.size
                                        _9341 = mem[_9053 + mem[_9053]]
                                        if mem[_9053 + mem[_9053]] > test266151307():
                                            revert with 0, 65
                                        if _9053 + ceil32(return_data.size) + ceil32(32 * mem[_9053 + mem[_9053]]) + 1 > test266151307() or ceil32(32 * mem[_9053 + mem[_9053]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _9053 + ceil32(return_data.size) + ceil32(32 * mem[_9053 + mem[_9053]]) + 1
                                        mem[_9053 + ceil32(return_data.size)] = _9341
                                        require return_data.size >= _9197 + (32 * _9341) + 32
                                        mem[_9053 + ceil32(return_data.size) + 32 len 32 * _9341] = mem[_9053 + _9197 + 32 len 32 * _9341]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                        if 1 >= _9341:
                                            revert with 0, 50
                                        if mem[_9053 + ceil32(return_data.size) + 64] > -1:
                                            revert with 0, 17
                                        require ext_code.size(brushAddress)
                                        call brushAddress.0x42966c68 with:
                                             gas gas_remaining wei
                                            args mem[_9053 + ceil32(return_data.size) + 64]
                                else:
                                    if brushAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[32] > !_6374:
                                            revert with 0, 17
                                        mem[_6378 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_6378 + 100] = ext_call.return_data[32] + _6374
                                        mem[_6378 + 132] = 0
                                        mem[_6378 + 164] = 160
                                        mem[_6378 + 260] = mem[_6378]
                                        idx = 0
                                        s = _6378 + 292
                                        t = _6378 + 32
                                        while idx < mem[_6378]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_6378 + 196] = this.address
                                        mem[_6378 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _6378 + (32 * mem[_6378]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9054 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _9198 = mem[_9054]
                                        require mem[_9054] <= test266151307()
                                        require _9054 + mem[_9054] + 31 < _9054 + return_data.size
                                        _9342 = mem[_9054 + mem[_9054]]
                                        if mem[_9054 + mem[_9054]] > test266151307():
                                            revert with 0, 65
                                        if _9054 + ceil32(return_data.size) + ceil32(32 * mem[_9054 + mem[_9054]]) + 1 > test266151307() or ceil32(32 * mem[_9054 + mem[_9054]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _9054 + ceil32(return_data.size) + ceil32(32 * mem[_9054 + mem[_9054]]) + 1
                                        mem[_9054 + ceil32(return_data.size)] = _9342
                                        require return_data.size >= _9198 + (32 * _9342) + 32
                                        mem[_9054 + ceil32(return_data.size) + 32 len 32 * _9342] = mem[_9054 + _9198 + 32 len 32 * _9342]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                        if 1 >= _9342:
                                            revert with 0, 50
                                        if mem[_9054 + ceil32(return_data.size) + 64] > -1:
                                            revert with 0, 17
                                        require ext_code.size(brushAddress)
                                        call brushAddress.0x42966c68 with:
                                             gas gas_remaining wei
                                            args mem[_9054 + ceil32(return_data.size) + 64]
                                    else:
                                        if brushAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[0] > !_6374:
                                                revert with 0, 17
                                            mem[_6378 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_6378 + 100] = ext_call.return_data[0] + _6374
                                            mem[_6378 + 132] = 0
                                            mem[_6378 + 164] = 160
                                            mem[_6378 + 260] = mem[_6378]
                                            idx = 0
                                            s = _6378 + 292
                                            t = _6378 + 32
                                            while idx < mem[_6378]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_6378 + 196] = this.address
                                            mem[_6378 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _6378 + (32 * mem[_6378]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9055 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _9199 = mem[_9055]
                                            require mem[_9055] <= test266151307()
                                            require _9055 + mem[_9055] + 31 < _9055 + return_data.size
                                            _9343 = mem[_9055 + mem[_9055]]
                                            if mem[_9055 + mem[_9055]] > test266151307():
                                                revert with 0, 65
                                            if _9055 + ceil32(return_data.size) + ceil32(32 * mem[_9055 + mem[_9055]]) + 1 > test266151307() or ceil32(32 * mem[_9055 + mem[_9055]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _9055 + ceil32(return_data.size) + ceil32(32 * mem[_9055 + mem[_9055]]) + 1
                                            mem[_9055 + ceil32(return_data.size)] = _9343
                                            require return_data.size >= _9199 + (32 * _9343) + 32
                                            mem[_9055 + ceil32(return_data.size) + 32 len 32 * _9343] = mem[_9055 + _9199 + 32 len 32 * _9343]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                            if 1 >= _9343:
                                                revert with 0, 50
                                            if mem[_9055 + ceil32(return_data.size) + 64] > -1:
                                                revert with 0, 17
                                            require ext_code.size(brushAddress)
                                            call brushAddress.0x42966c68 with:
                                                 gas gas_remaining wei
                                                args mem[_9055 + ceil32(return_data.size) + 64]
                                        else:
                                            if wftmAddress == address(ext_call.return_data[0]):
                                                if ext_call.return_data[32] > !_6374:
                                                    revert with 0, 17
                                                mem[_6378 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[_6378 + 100] = ext_call.return_data[32] + _6374
                                                mem[_6378 + 132] = 0
                                                mem[_6378 + 164] = 160
                                                mem[_6378 + 260] = mem[_6378]
                                                idx = 0
                                                s = _6378 + 292
                                                t = _6378 + 32
                                                while idx < mem[_6378]:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[_6378 + 196] = this.address
                                                mem[_6378 + 228] = block.timestamp + 10000
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len _6378 + (32 * mem[_6378]) + -mem[64] + 288]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _9056 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _9200 = mem[_9056]
                                                require mem[_9056] <= test266151307()
                                                require _9056 + mem[_9056] + 31 < _9056 + return_data.size
                                                _9344 = mem[_9056 + mem[_9056]]
                                                if mem[_9056 + mem[_9056]] > test266151307():
                                                    revert with 0, 65
                                                if _9056 + ceil32(return_data.size) + ceil32(32 * mem[_9056 + mem[_9056]]) + 1 > test266151307() or ceil32(32 * mem[_9056 + mem[_9056]]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[64] = _9056 + ceil32(return_data.size) + ceil32(32 * mem[_9056 + mem[_9056]]) + 1
                                                mem[_9056 + ceil32(return_data.size)] = _9344
                                                require return_data.size >= _9200 + (32 * _9344) + 32
                                                mem[_9056 + ceil32(return_data.size) + 32 len 32 * _9344] = mem[_9056 + _9200 + 32 len 32 * _9344]
                                                if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                    revert with 0, 17
                                                maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                                if 1 >= _9344:
                                                    revert with 0, 50
                                                if mem[_9056 + ceil32(return_data.size) + 64] > -1:
                                                    revert with 0, 17
                                                require ext_code.size(brushAddress)
                                                call brushAddress.0x42966c68 with:
                                                     gas gas_remaining wei
                                                    args mem[_9056 + ceil32(return_data.size) + 64]
                                            else:
                                                if ext_call.return_data[0] > !_6374:
                                                    revert with 0, 17
                                                mem[_6378 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[_6378 + 100] = ext_call.return_data[0] + _6374
                                                mem[_6378 + 132] = 0
                                                mem[_6378 + 164] = 160
                                                mem[_6378 + 260] = mem[_6378]
                                                idx = 0
                                                s = _6378 + 292
                                                t = _6378 + 32
                                                while idx < mem[_6378]:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[_6378 + 196] = this.address
                                                mem[_6378 + 228] = block.timestamp + 10000
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len _6378 + (32 * mem[_6378]) + -mem[64] + 288]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _9057 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _9201 = mem[_9057]
                                                require mem[_9057] <= test266151307()
                                                require _9057 + mem[_9057] + 31 < _9057 + return_data.size
                                                _9345 = mem[_9057 + mem[_9057]]
                                                if mem[_9057 + mem[_9057]] > test266151307():
                                                    revert with 0, 65
                                                if _9057 + ceil32(return_data.size) + ceil32(32 * mem[_9057 + mem[_9057]]) + 1 > test266151307() or ceil32(32 * mem[_9057 + mem[_9057]]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[64] = _9057 + ceil32(return_data.size) + ceil32(32 * mem[_9057 + mem[_9057]]) + 1
                                                mem[_9057 + ceil32(return_data.size)] = _9345
                                                require return_data.size >= _9201 + (32 * _9345) + 32
                                                mem[_9057 + ceil32(return_data.size) + 32 len 32 * _9345] = mem[_9057 + _9201 + 32 len 32 * _9345]
                                                if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                    revert with 0, 17
                                                maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                                if 1 >= _9345:
                                                    revert with 0, 50
                                                if mem[_9057 + ceil32(return_data.size) + 64] > -1:
                                                    revert with 0, 17
                                                require ext_code.size(brushAddress)
                                                call brushAddress.0x42966c68 with:
                                                     gas gas_remaining wei
                                                    args mem[_9057 + ceil32(return_data.size) + 64]
                            else:
                                if wftmAddress == address(ext_call.return_data[0]):
                                    if brushAddress != address(ext_call.return_data[0]):
                                        if wftmAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_6374:
                                                revert with 0, 17
                                            mem[_6378 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_6378 + 100] = ext_call.return_data[32] + _6374
                                            mem[_6378 + 132] = 0
                                            mem[_6378 + 164] = 160
                                            mem[_6378 + 260] = mem[_6378]
                                            idx = 0
                                            s = _6378 + 292
                                            t = _6378 + 32
                                            while idx < mem[_6378]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_6378 + 196] = this.address
                                            mem[_6378 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _6378 + (32 * mem[_6378]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9058 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _9202 = mem[_9058]
                                            require mem[_9058] <= test266151307()
                                            require _9058 + mem[_9058] + 31 < _9058 + return_data.size
                                            _9346 = mem[_9058 + mem[_9058]]
                                            if mem[_9058 + mem[_9058]] > test266151307():
                                                revert with 0, 65
                                            if _9058 + ceil32(return_data.size) + ceil32(32 * mem[_9058 + mem[_9058]]) + 1 > test266151307() or ceil32(32 * mem[_9058 + mem[_9058]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _9058 + ceil32(return_data.size) + ceil32(32 * mem[_9058 + mem[_9058]]) + 1
                                            mem[_9058 + ceil32(return_data.size)] = _9346
                                            require return_data.size >= _9202 + (32 * _9346) + 32
                                            mem[_9058 + ceil32(return_data.size) + 32 len 32 * _9346] = mem[_9058 + _9202 + 32 len 32 * _9346]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                            if 1 >= _9346:
                                                revert with 0, 50
                                            if mem[_9058 + ceil32(return_data.size) + 64] > -1:
                                                revert with 0, 17
                                            require ext_code.size(brushAddress)
                                            call brushAddress.0x42966c68 with:
                                                 gas gas_remaining wei
                                                args mem[_9058 + ceil32(return_data.size) + 64]
                                        else:
                                            if ext_call.return_data[0] > !_6374:
                                                revert with 0, 17
                                            mem[_6378 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_6378 + 100] = ext_call.return_data[0] + _6374
                                            mem[_6378 + 132] = 0
                                            mem[_6378 + 164] = 160
                                            mem[_6378 + 260] = mem[_6378]
                                            idx = 0
                                            s = _6378 + 292
                                            t = _6378 + 32
                                            while idx < mem[_6378]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_6378 + 196] = this.address
                                            mem[_6378 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _6378 + (32 * mem[_6378]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9059 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _9203 = mem[_9059]
                                            require mem[_9059] <= test266151307()
                                            require _9059 + mem[_9059] + 31 < _9059 + return_data.size
                                            _9347 = mem[_9059 + mem[_9059]]
                                            if mem[_9059 + mem[_9059]] > test266151307():
                                                revert with 0, 65
                                            if _9059 + ceil32(return_data.size) + ceil32(32 * mem[_9059 + mem[_9059]]) + 1 > test266151307() or ceil32(32 * mem[_9059 + mem[_9059]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _9059 + ceil32(return_data.size) + ceil32(32 * mem[_9059 + mem[_9059]]) + 1
                                            mem[_9059 + ceil32(return_data.size)] = _9347
                                            require return_data.size >= _9203 + (32 * _9347) + 32
                                            mem[_9059 + ceil32(return_data.size) + 32 len 32 * _9347] = mem[_9059 + _9203 + 32 len 32 * _9347]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                            if 1 >= _9347:
                                                revert with 0, 50
                                            if mem[_9059 + ceil32(return_data.size) + 64] > -1:
                                                revert with 0, 17
                                            require ext_code.size(brushAddress)
                                            call brushAddress.0x42966c68 with:
                                                 gas gas_remaining wei
                                                args mem[_9059 + ceil32(return_data.size) + 64]
                                    else:
                                        if brushAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_6374:
                                                revert with 0, 17
                                            mem[_6378 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_6378 + 100] = ext_call.return_data[32] + _6374
                                            mem[_6378 + 132] = 0
                                            mem[_6378 + 164] = 160
                                            mem[_6378 + 260] = mem[_6378]
                                            idx = 0
                                            s = _6378 + 292
                                            t = _6378 + 32
                                            while idx < mem[_6378]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_6378 + 196] = this.address
                                            mem[_6378 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _6378 + (32 * mem[_6378]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9060 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _9204 = mem[_9060]
                                            require mem[_9060] <= test266151307()
                                            require _9060 + mem[_9060] + 31 < _9060 + return_data.size
                                            _9348 = mem[_9060 + mem[_9060]]
                                            if mem[_9060 + mem[_9060]] > test266151307():
                                                revert with 0, 65
                                            if _9060 + ceil32(return_data.size) + ceil32(32 * mem[_9060 + mem[_9060]]) + 1 > test266151307() or ceil32(32 * mem[_9060 + mem[_9060]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _9060 + ceil32(return_data.size) + ceil32(32 * mem[_9060 + mem[_9060]]) + 1
                                            mem[_9060 + ceil32(return_data.size)] = _9348
                                            require return_data.size >= _9204 + (32 * _9348) + 32
                                            mem[_9060 + ceil32(return_data.size) + 32 len 32 * _9348] = mem[_9060 + _9204 + 32 len 32 * _9348]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                            if 1 >= _9348:
                                                revert with 0, 50
                                            if mem[_9060 + ceil32(return_data.size) + 64] > -1:
                                                revert with 0, 17
                                            require ext_code.size(brushAddress)
                                            call brushAddress.0x42966c68 with:
                                                 gas gas_remaining wei
                                                args mem[_9060 + ceil32(return_data.size) + 64]
                                        else:
                                            if brushAddress == address(ext_call.return_data[0]):
                                                if ext_call.return_data[0] > !_6374:
                                                    revert with 0, 17
                                                mem[_6378 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[_6378 + 100] = ext_call.return_data[0] + _6374
                                                mem[_6378 + 132] = 0
                                                mem[_6378 + 164] = 160
                                                mem[_6378 + 260] = mem[_6378]
                                                idx = 0
                                                s = _6378 + 292
                                                t = _6378 + 32
                                                while idx < mem[_6378]:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[_6378 + 196] = this.address
                                                mem[_6378 + 228] = block.timestamp + 10000
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len _6378 + (32 * mem[_6378]) + -mem[64] + 288]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _9061 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _9205 = mem[_9061]
                                                require mem[_9061] <= test266151307()
                                                require _9061 + mem[_9061] + 31 < _9061 + return_data.size
                                                _9349 = mem[_9061 + mem[_9061]]
                                                if mem[_9061 + mem[_9061]] > test266151307():
                                                    revert with 0, 65
                                                if _9061 + ceil32(return_data.size) + ceil32(32 * mem[_9061 + mem[_9061]]) + 1 > test266151307() or ceil32(32 * mem[_9061 + mem[_9061]]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[64] = _9061 + ceil32(return_data.size) + ceil32(32 * mem[_9061 + mem[_9061]]) + 1
                                                mem[_9061 + ceil32(return_data.size)] = _9349
                                                require return_data.size >= _9205 + (32 * _9349) + 32
                                                mem[_9061 + ceil32(return_data.size) + 32 len 32 * _9349] = mem[_9061 + _9205 + 32 len 32 * _9349]
                                                if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                    revert with 0, 17
                                                maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                                if 1 >= _9349:
                                                    revert with 0, 50
                                                if mem[_9061 + ceil32(return_data.size) + 64] > -1:
                                                    revert with 0, 17
                                                require ext_code.size(brushAddress)
                                                call brushAddress.0x42966c68 with:
                                                     gas gas_remaining wei
                                                    args mem[_9061 + ceil32(return_data.size) + 64]
                                            else:
                                                if wftmAddress == address(ext_call.return_data[0]):
                                                    if ext_call.return_data[32] > !_6374:
                                                        revert with 0, 17
                                                    mem[_6378 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[_6378 + 100] = ext_call.return_data[32] + _6374
                                                    mem[_6378 + 132] = 0
                                                    mem[_6378 + 164] = 160
                                                    mem[_6378 + 260] = mem[_6378]
                                                    idx = 0
                                                    s = _6378 + 292
                                                    t = _6378 + 32
                                                    while idx < mem[_6378]:
                                                        mem[s] = mem[t + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[_6378 + 196] = this.address
                                                    mem[_6378 + 228] = block.timestamp + 10000
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len _6378 + (32 * mem[_6378]) + -mem[64] + 288]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _9062 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _9206 = mem[_9062]
                                                    require mem[_9062] <= test266151307()
                                                    require _9062 + mem[_9062] + 31 < _9062 + return_data.size
                                                    _9350 = mem[_9062 + mem[_9062]]
                                                    if mem[_9062 + mem[_9062]] > test266151307():
                                                        revert with 0, 65
                                                    if _9062 + ceil32(return_data.size) + ceil32(32 * mem[_9062 + mem[_9062]]) + 1 > test266151307() or ceil32(32 * mem[_9062 + mem[_9062]]) + 1 < 0:
                                                        revert with 0, 65
                                                    mem[64] = _9062 + ceil32(return_data.size) + ceil32(32 * mem[_9062 + mem[_9062]]) + 1
                                                    mem[_9062 + ceil32(return_data.size)] = _9350
                                                    require return_data.size >= _9206 + (32 * _9350) + 32
                                                    mem[_9062 + ceil32(return_data.size) + 32 len 32 * _9350] = mem[_9062 + _9206 + 32 len 32 * _9350]
                                                    if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                        revert with 0, 17
                                                    maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                                    if 1 >= _9350:
                                                        revert with 0, 50
                                                    if mem[_9062 + ceil32(return_data.size) + 64] > -1:
                                                        revert with 0, 17
                                                    require ext_code.size(brushAddress)
                                                    call brushAddress.0x42966c68 with:
                                                         gas gas_remaining wei
                                                        args mem[_9062 + ceil32(return_data.size) + 64]
                                                else:
                                                    if ext_call.return_data[0] > !_6374:
                                                        revert with 0, 17
                                                    mem[_6378 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[_6378 + 100] = ext_call.return_data[0] + _6374
                                                    mem[_6378 + 132] = 0
                                                    mem[_6378 + 164] = 160
                                                    mem[_6378 + 260] = mem[_6378]
                                                    idx = 0
                                                    s = _6378 + 292
                                                    t = _6378 + 32
                                                    while idx < mem[_6378]:
                                                        mem[s] = mem[t + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[_6378 + 196] = this.address
                                                    mem[_6378 + 228] = block.timestamp + 10000
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len _6378 + (32 * mem[_6378]) + -mem[64] + 288]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _9063 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _9207 = mem[_9063]
                                                    require mem[_9063] <= test266151307()
                                                    require _9063 + mem[_9063] + 31 < _9063 + return_data.size
                                                    _9351 = mem[_9063 + mem[_9063]]
                                                    if mem[_9063 + mem[_9063]] > test266151307():
                                                        revert with 0, 65
                                                    if _9063 + ceil32(return_data.size) + ceil32(32 * mem[_9063 + mem[_9063]]) + 1 > test266151307() or ceil32(32 * mem[_9063 + mem[_9063]]) + 1 < 0:
                                                        revert with 0, 65
                                                    mem[64] = _9063 + ceil32(return_data.size) + ceil32(32 * mem[_9063 + mem[_9063]]) + 1
                                                    mem[_9063 + ceil32(return_data.size)] = _9351
                                                    require return_data.size >= _9207 + (32 * _9351) + 32
                                                    mem[_9063 + ceil32(return_data.size) + 32 len 32 * _9351] = mem[_9063 + _9207 + 32 len 32 * _9351]
                                                    if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                        revert with 0, 17
                                                    maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                                    if 1 >= _9351:
                                                        revert with 0, 50
                                                    if mem[_9063 + ceil32(return_data.size) + 64] > -1:
                                                        revert with 0, 17
                                                    require ext_code.size(brushAddress)
                                                    call brushAddress.0x42966c68 with:
                                                         gas gas_remaining wei
                                                        args mem[_9063 + ceil32(return_data.size) + 64]
                                else:
                                    if brushAddress != address(ext_call.return_data[0]):
                                        if wftmAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_6374:
                                                revert with 0, 17
                                            mem[_6378 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_6378 + 100] = ext_call.return_data[32] + _6374
                                            mem[_6378 + 132] = 0
                                            mem[_6378 + 164] = 160
                                            mem[_6378 + 260] = mem[_6378]
                                            idx = 0
                                            s = _6378 + 292
                                            t = _6378 + 32
                                            while idx < mem[_6378]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_6378 + 196] = this.address
                                            mem[_6378 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _6378 + (32 * mem[_6378]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9064 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _9208 = mem[_9064]
                                            require mem[_9064] <= test266151307()
                                            require _9064 + mem[_9064] + 31 < _9064 + return_data.size
                                            _9352 = mem[_9064 + mem[_9064]]
                                            if mem[_9064 + mem[_9064]] > test266151307():
                                                revert with 0, 65
                                            if _9064 + ceil32(return_data.size) + ceil32(32 * mem[_9064 + mem[_9064]]) + 1 > test266151307() or ceil32(32 * mem[_9064 + mem[_9064]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _9064 + ceil32(return_data.size) + ceil32(32 * mem[_9064 + mem[_9064]]) + 1
                                            mem[_9064 + ceil32(return_data.size)] = _9352
                                            require return_data.size >= _9208 + (32 * _9352) + 32
                                            mem[_9064 + ceil32(return_data.size) + 32 len 32 * _9352] = mem[_9064 + _9208 + 32 len 32 * _9352]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                            if 1 >= _9352:
                                                revert with 0, 50
                                            if mem[_9064 + ceil32(return_data.size) + 64] > -1:
                                                revert with 0, 17
                                            require ext_code.size(brushAddress)
                                            call brushAddress.0x42966c68 with:
                                                 gas gas_remaining wei
                                                args mem[_9064 + ceil32(return_data.size) + 64]
                                        else:
                                            if ext_call.return_data[0] > !_6374:
                                                revert with 0, 17
                                            mem[_6378 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_6378 + 100] = ext_call.return_data[0] + _6374
                                            mem[_6378 + 132] = 0
                                            mem[_6378 + 164] = 160
                                            mem[_6378 + 260] = mem[_6378]
                                            idx = 0
                                            s = _6378 + 292
                                            t = _6378 + 32
                                            while idx < mem[_6378]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_6378 + 196] = this.address
                                            mem[_6378 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _6378 + (32 * mem[_6378]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9065 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _9209 = mem[_9065]
                                            require mem[_9065] <= test266151307()
                                            require _9065 + mem[_9065] + 31 < _9065 + return_data.size
                                            _9353 = mem[_9065 + mem[_9065]]
                                            if mem[_9065 + mem[_9065]] > test266151307():
                                                revert with 0, 65
                                            if _9065 + ceil32(return_data.size) + ceil32(32 * mem[_9065 + mem[_9065]]) + 1 > test266151307() or ceil32(32 * mem[_9065 + mem[_9065]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _9065 + ceil32(return_data.size) + ceil32(32 * mem[_9065 + mem[_9065]]) + 1
                                            mem[_9065 + ceil32(return_data.size)] = _9353
                                            require return_data.size >= _9209 + (32 * _9353) + 32
                                            mem[_9065 + ceil32(return_data.size) + 32 len 32 * _9353] = mem[_9065 + _9209 + 32 len 32 * _9353]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                            if 1 >= _9353:
                                                revert with 0, 50
                                            if mem[_9065 + ceil32(return_data.size) + 64] > -1:
                                                revert with 0, 17
                                            require ext_code.size(brushAddress)
                                            call brushAddress.0x42966c68 with:
                                                 gas gas_remaining wei
                                                args mem[_9065 + ceil32(return_data.size) + 64]
                                    else:
                                        if brushAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_6374:
                                                revert with 0, 17
                                            mem[_6378 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_6378 + 100] = ext_call.return_data[32] + _6374
                                            mem[_6378 + 132] = 0
                                            mem[_6378 + 164] = 160
                                            mem[_6378 + 260] = mem[_6378]
                                            idx = 0
                                            s = _6378 + 292
                                            t = _6378 + 32
                                            while idx < mem[_6378]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_6378 + 196] = this.address
                                            mem[_6378 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _6378 + (32 * mem[_6378]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9066 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _9210 = mem[_9066]
                                            require mem[_9066] <= test266151307()
                                            require _9066 + mem[_9066] + 31 < _9066 + return_data.size
                                            _9354 = mem[_9066 + mem[_9066]]
                                            if mem[_9066 + mem[_9066]] > test266151307():
                                                revert with 0, 65
                                            if _9066 + ceil32(return_data.size) + ceil32(32 * mem[_9066 + mem[_9066]]) + 1 > test266151307() or ceil32(32 * mem[_9066 + mem[_9066]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _9066 + ceil32(return_data.size) + ceil32(32 * mem[_9066 + mem[_9066]]) + 1
                                            mem[_9066 + ceil32(return_data.size)] = _9354
                                            require return_data.size >= _9210 + (32 * _9354) + 32
                                            mem[_9066 + ceil32(return_data.size) + 32 len 32 * _9354] = mem[_9066 + _9210 + 32 len 32 * _9354]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                            if 1 >= _9354:
                                                revert with 0, 50
                                            if mem[_9066 + ceil32(return_data.size) + 64] > -1:
                                                revert with 0, 17
                                            require ext_code.size(brushAddress)
                                            call brushAddress.0x42966c68 with:
                                                 gas gas_remaining wei
                                                args mem[_9066 + ceil32(return_data.size) + 64]
                                        else:
                                            if brushAddress == address(ext_call.return_data[0]):
                                                if ext_call.return_data[0] > !_6374:
                                                    revert with 0, 17
                                                mem[_6378 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[_6378 + 100] = ext_call.return_data[0] + _6374
                                                mem[_6378 + 132] = 0
                                                mem[_6378 + 164] = 160
                                                mem[_6378 + 260] = mem[_6378]
                                                idx = 0
                                                s = _6378 + 292
                                                t = _6378 + 32
                                                while idx < mem[_6378]:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[_6378 + 196] = this.address
                                                mem[_6378 + 228] = block.timestamp + 10000
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len _6378 + (32 * mem[_6378]) + -mem[64] + 288]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _9067 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _9211 = mem[_9067]
                                                require mem[_9067] <= test266151307()
                                                require _9067 + mem[_9067] + 31 < _9067 + return_data.size
                                                _9355 = mem[_9067 + mem[_9067]]
                                                if mem[_9067 + mem[_9067]] > test266151307():
                                                    revert with 0, 65
                                                if _9067 + ceil32(return_data.size) + ceil32(32 * mem[_9067 + mem[_9067]]) + 1 > test266151307() or ceil32(32 * mem[_9067 + mem[_9067]]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[64] = _9067 + ceil32(return_data.size) + ceil32(32 * mem[_9067 + mem[_9067]]) + 1
                                                mem[_9067 + ceil32(return_data.size)] = _9355
                                                require return_data.size >= _9211 + (32 * _9355) + 32
                                                mem[_9067 + ceil32(return_data.size) + 32 len 32 * _9355] = mem[_9067 + _9211 + 32 len 32 * _9355]
                                                if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                    revert with 0, 17
                                                maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                                if 1 >= _9355:
                                                    revert with 0, 50
                                                if mem[_9067 + ceil32(return_data.size) + 64] > -1:
                                                    revert with 0, 17
                                                require ext_code.size(brushAddress)
                                                call brushAddress.0x42966c68 with:
                                                     gas gas_remaining wei
                                                    args mem[_9067 + ceil32(return_data.size) + 64]
                                            else:
                                                if wftmAddress == address(ext_call.return_data[0]):
                                                    if ext_call.return_data[32] > !_6374:
                                                        revert with 0, 17
                                                    mem[_6378 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[_6378 + 100] = ext_call.return_data[32] + _6374
                                                    mem[_6378 + 132] = 0
                                                    mem[_6378 + 164] = 160
                                                    mem[_6378 + 260] = mem[_6378]
                                                    idx = 0
                                                    s = _6378 + 292
                                                    t = _6378 + 32
                                                    while idx < mem[_6378]:
                                                        mem[s] = mem[t + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[_6378 + 196] = this.address
                                                    mem[_6378 + 228] = block.timestamp + 10000
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len _6378 + (32 * mem[_6378]) + -mem[64] + 288]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _9068 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _9212 = mem[_9068]
                                                    require mem[_9068] <= test266151307()
                                                    require _9068 + mem[_9068] + 31 < _9068 + return_data.size
                                                    _9356 = mem[_9068 + mem[_9068]]
                                                    if mem[_9068 + mem[_9068]] > test266151307():
                                                        revert with 0, 65
                                                    if _9068 + ceil32(return_data.size) + ceil32(32 * mem[_9068 + mem[_9068]]) + 1 > test266151307() or ceil32(32 * mem[_9068 + mem[_9068]]) + 1 < 0:
                                                        revert with 0, 65
                                                    mem[64] = _9068 + ceil32(return_data.size) + ceil32(32 * mem[_9068 + mem[_9068]]) + 1
                                                    mem[_9068 + ceil32(return_data.size)] = _9356
                                                    require return_data.size >= _9212 + (32 * _9356) + 32
                                                    mem[_9068 + ceil32(return_data.size) + 32 len 32 * _9356] = mem[_9068 + _9212 + 32 len 32 * _9356]
                                                    if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                        revert with 0, 17
                                                    maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                                    if 1 >= _9356:
                                                        revert with 0, 50
                                                    if mem[_9068 + ceil32(return_data.size) + 64] > -1:
                                                        revert with 0, 17
                                                    require ext_code.size(brushAddress)
                                                    call brushAddress.0x42966c68 with:
                                                         gas gas_remaining wei
                                                        args mem[_9068 + ceil32(return_data.size) + 64]
                                                else:
                                                    if ext_call.return_data[0] > !_6374:
                                                        revert with 0, 17
                                                    mem[_6378 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[_6378 + 100] = ext_call.return_data[0] + _6374
                                                    mem[_6378 + 132] = 0
                                                    mem[_6378 + 164] = 160
                                                    mem[_6378 + 260] = mem[_6378]
                                                    idx = 0
                                                    s = _6378 + 292
                                                    t = _6378 + 32
                                                    while idx < mem[_6378]:
                                                        mem[s] = mem[t + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[_6378 + 196] = this.address
                                                    mem[_6378 + 228] = block.timestamp + 10000
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len _6378 + (32 * mem[_6378]) + -mem[64] + 288]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _9069 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _9213 = mem[_9069]
                                                    require mem[_9069] <= test266151307()
                                                    require _9069 + mem[_9069] + 31 < _9069 + return_data.size
                                                    _9357 = mem[_9069 + mem[_9069]]
                                                    if mem[_9069 + mem[_9069]] > test266151307():
                                                        revert with 0, 65
                                                    if _9069 + ceil32(return_data.size) + ceil32(32 * mem[_9069 + mem[_9069]]) + 1 > test266151307() or ceil32(32 * mem[_9069 + mem[_9069]]) + 1 < 0:
                                                        revert with 0, 65
                                                    mem[64] = _9069 + ceil32(return_data.size) + ceil32(32 * mem[_9069 + mem[_9069]]) + 1
                                                    mem[_9069 + ceil32(return_data.size)] = _9357
                                                    require return_data.size >= _9213 + (32 * _9357) + 32
                                                    mem[_9069 + ceil32(return_data.size) + 32 len 32 * _9357] = mem[_9069 + _9213 + 32 len 32 * _9357]
                                                    if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                        revert with 0, 17
                                                    maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                                    if 1 >= _9357:
                                                        revert with 0, 50
                                                    if mem[_9069 + ceil32(return_data.size) + 64] > -1:
                                                        revert with 0, 17
                                                    require ext_code.size(brushAddress)
                                                    call brushAddress.0x42966c68 with:
                                                         gas gas_remaining wei
                                                        args mem[_9069 + ceil32(return_data.size) + 64]
                else:
                    mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                    mem[(4 * ceil32(return_data.size)) + 228] = 0
                    mem[(4 * ceil32(return_data.size)) + 260] = 160
                    mem[(4 * ceil32(return_data.size)) + 356] = 2
                    idx = 0
                    s = (4 * ceil32(return_data.size)) + 388
                    t = (4 * ceil32(return_data.size)) + 128
                    while idx < 2:
                        mem[s] = mem[t + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[(4 * ceil32(return_data.size)) + 292] = this.address
                    mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                    require ext_code.size(routerAddress)
                    call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                         gas gas_remaining wei
                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = (6 * ceil32(return_data.size)) + 192
                    require return_data.size >= 32
                    _3525 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                    require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                    require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                    _3604 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                    if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                        revert with 0, 65
                    if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                        revert with 0, 65
                    mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193
                    mem[(6 * ceil32(return_data.size)) + 192] = _3604
                    require return_data.size >= _3525 + (32 * _3604) + 32
                    mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3604] = mem[(4 * ceil32(return_data.size)) + _3525 + 224 len 32 * _3604]
                    if 1 >= _3604:
                        revert with 0, 50
                    _6375 = mem[(6 * ceil32(return_data.size)) + 256]
                    _6379 = mem[64]
                    mem[mem[64]] = 2
                    mem[64] = mem[64] + 96
                    if 0 >= mem[_6379]:
                        revert with 0, 50
                    mem[_6379 + 32] = address(ext_call.return_data[0])
                    if 1 >= mem[_6379]:
                        revert with 0, 50
                    mem[_6379 + 64] = brushAddress
                    if brushAddress != address(ext_call.return_data[0]):
                        if wftmAddress == address(ext_call.return_data[0]):
                            if brushAddress != address(ext_call.return_data[0]):
                                if wftmAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_6375:
                                        revert with 0, 17
                                    mem[_6379 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_6379 + 100] = ext_call.return_data[32] + _6375
                                    mem[_6379 + 132] = 0
                                    mem[_6379 + 164] = 160
                                    mem[_6379 + 260] = mem[_6379]
                                    idx = 0
                                    s = _6379 + 292
                                    t = _6379 + 32
                                    while idx < mem[_6379]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_6379 + 196] = this.address
                                    mem[_6379 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _6379 + (32 * mem[_6379]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9070 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _9214 = mem[_9070]
                                    require mem[_9070] <= test266151307()
                                    require _9070 + mem[_9070] + 31 < _9070 + return_data.size
                                    _9358 = mem[_9070 + mem[_9070]]
                                    if mem[_9070 + mem[_9070]] > test266151307():
                                        revert with 0, 65
                                    if _9070 + ceil32(return_data.size) + ceil32(32 * mem[_9070 + mem[_9070]]) + 1 > test266151307() or ceil32(32 * mem[_9070 + mem[_9070]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _9070 + ceil32(return_data.size) + ceil32(32 * mem[_9070 + mem[_9070]]) + 1
                                    mem[_9070 + ceil32(return_data.size)] = _9358
                                    require return_data.size >= _9214 + (32 * _9358) + 32
                                    mem[_9070 + ceil32(return_data.size) + 32 len 32 * _9358] = mem[_9070 + _9214 + 32 len 32 * _9358]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                    if 1 >= _9358:
                                        revert with 0, 50
                                    if mem[_9070 + ceil32(return_data.size) + 64] > -1:
                                        revert with 0, 17
                                    require ext_code.size(brushAddress)
                                    call brushAddress.0x42966c68 with:
                                         gas gas_remaining wei
                                        args mem[_9070 + ceil32(return_data.size) + 64]
                                else:
                                    if ext_call.return_data[0] > !_6375:
                                        revert with 0, 17
                                    mem[_6379 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_6379 + 100] = ext_call.return_data[0] + _6375
                                    mem[_6379 + 132] = 0
                                    mem[_6379 + 164] = 160
                                    mem[_6379 + 260] = mem[_6379]
                                    idx = 0
                                    s = _6379 + 292
                                    t = _6379 + 32
                                    while idx < mem[_6379]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_6379 + 196] = this.address
                                    mem[_6379 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _6379 + (32 * mem[_6379]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9071 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _9215 = mem[_9071]
                                    require mem[_9071] <= test266151307()
                                    require _9071 + mem[_9071] + 31 < _9071 + return_data.size
                                    _9359 = mem[_9071 + mem[_9071]]
                                    if mem[_9071 + mem[_9071]] > test266151307():
                                        revert with 0, 65
                                    if _9071 + ceil32(return_data.size) + ceil32(32 * mem[_9071 + mem[_9071]]) + 1 > test266151307() or ceil32(32 * mem[_9071 + mem[_9071]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _9071 + ceil32(return_data.size) + ceil32(32 * mem[_9071 + mem[_9071]]) + 1
                                    mem[_9071 + ceil32(return_data.size)] = _9359
                                    require return_data.size >= _9215 + (32 * _9359) + 32
                                    mem[_9071 + ceil32(return_data.size) + 32 len 32 * _9359] = mem[_9071 + _9215 + 32 len 32 * _9359]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                    if 1 >= _9359:
                                        revert with 0, 50
                                    if mem[_9071 + ceil32(return_data.size) + 64] > -1:
                                        revert with 0, 17
                                    require ext_code.size(brushAddress)
                                    call brushAddress.0x42966c68 with:
                                         gas gas_remaining wei
                                        args mem[_9071 + ceil32(return_data.size) + 64]
                            else:
                                if brushAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_6375:
                                        revert with 0, 17
                                    mem[_6379 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_6379 + 100] = ext_call.return_data[32] + _6375
                                    mem[_6379 + 132] = 0
                                    mem[_6379 + 164] = 160
                                    mem[_6379 + 260] = mem[_6379]
                                    idx = 0
                                    s = _6379 + 292
                                    t = _6379 + 32
                                    while idx < mem[_6379]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_6379 + 196] = this.address
                                    mem[_6379 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _6379 + (32 * mem[_6379]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9072 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _9216 = mem[_9072]
                                    require mem[_9072] <= test266151307()
                                    require _9072 + mem[_9072] + 31 < _9072 + return_data.size
                                    _9360 = mem[_9072 + mem[_9072]]
                                    if mem[_9072 + mem[_9072]] > test266151307():
                                        revert with 0, 65
                                    if _9072 + ceil32(return_data.size) + ceil32(32 * mem[_9072 + mem[_9072]]) + 1 > test266151307() or ceil32(32 * mem[_9072 + mem[_9072]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _9072 + ceil32(return_data.size) + ceil32(32 * mem[_9072 + mem[_9072]]) + 1
                                    mem[_9072 + ceil32(return_data.size)] = _9360
                                    require return_data.size >= _9216 + (32 * _9360) + 32
                                    mem[_9072 + ceil32(return_data.size) + 32 len 32 * _9360] = mem[_9072 + _9216 + 32 len 32 * _9360]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                    if 1 >= _9360:
                                        revert with 0, 50
                                    if mem[_9072 + ceil32(return_data.size) + 64] > -1:
                                        revert with 0, 17
                                    require ext_code.size(brushAddress)
                                    call brushAddress.0x42966c68 with:
                                         gas gas_remaining wei
                                        args mem[_9072 + ceil32(return_data.size) + 64]
                                else:
                                    if brushAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[0] > !_6375:
                                            revert with 0, 17
                                        mem[_6379 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_6379 + 100] = ext_call.return_data[0] + _6375
                                        mem[_6379 + 132] = 0
                                        mem[_6379 + 164] = 160
                                        mem[_6379 + 260] = mem[_6379]
                                        idx = 0
                                        s = _6379 + 292
                                        t = _6379 + 32
                                        while idx < mem[_6379]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_6379 + 196] = this.address
                                        mem[_6379 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _6379 + (32 * mem[_6379]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9073 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _9217 = mem[_9073]
                                        require mem[_9073] <= test266151307()
                                        require _9073 + mem[_9073] + 31 < _9073 + return_data.size
                                        _9361 = mem[_9073 + mem[_9073]]
                                        if mem[_9073 + mem[_9073]] > test266151307():
                                            revert with 0, 65
                                        if _9073 + ceil32(return_data.size) + ceil32(32 * mem[_9073 + mem[_9073]]) + 1 > test266151307() or ceil32(32 * mem[_9073 + mem[_9073]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _9073 + ceil32(return_data.size) + ceil32(32 * mem[_9073 + mem[_9073]]) + 1
                                        mem[_9073 + ceil32(return_data.size)] = _9361
                                        require return_data.size >= _9217 + (32 * _9361) + 32
                                        mem[_9073 + ceil32(return_data.size) + 32 len 32 * _9361] = mem[_9073 + _9217 + 32 len 32 * _9361]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                        if 1 >= _9361:
                                            revert with 0, 50
                                        if mem[_9073 + ceil32(return_data.size) + 64] > -1:
                                            revert with 0, 17
                                        require ext_code.size(brushAddress)
                                        call brushAddress.0x42966c68 with:
                                             gas gas_remaining wei
                                            args mem[_9073 + ceil32(return_data.size) + 64]
                                    else:
                                        if wftmAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_6375:
                                                revert with 0, 17
                                            mem[_6379 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_6379 + 100] = ext_call.return_data[32] + _6375
                                            mem[_6379 + 132] = 0
                                            mem[_6379 + 164] = 160
                                            mem[_6379 + 260] = mem[_6379]
                                            idx = 0
                                            s = _6379 + 292
                                            t = _6379 + 32
                                            while idx < mem[_6379]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_6379 + 196] = this.address
                                            mem[_6379 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _6379 + (32 * mem[_6379]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9074 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _9218 = mem[_9074]
                                            require mem[_9074] <= test266151307()
                                            require _9074 + mem[_9074] + 31 < _9074 + return_data.size
                                            _9362 = mem[_9074 + mem[_9074]]
                                            if mem[_9074 + mem[_9074]] > test266151307():
                                                revert with 0, 65
                                            if _9074 + ceil32(return_data.size) + ceil32(32 * mem[_9074 + mem[_9074]]) + 1 > test266151307() or ceil32(32 * mem[_9074 + mem[_9074]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _9074 + ceil32(return_data.size) + ceil32(32 * mem[_9074 + mem[_9074]]) + 1
                                            mem[_9074 + ceil32(return_data.size)] = _9362
                                            require return_data.size >= _9218 + (32 * _9362) + 32
                                            mem[_9074 + ceil32(return_data.size) + 32 len 32 * _9362] = mem[_9074 + _9218 + 32 len 32 * _9362]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                            if 1 >= _9362:
                                                revert with 0, 50
                                            if mem[_9074 + ceil32(return_data.size) + 64] > -1:
                                                revert with 0, 17
                                            require ext_code.size(brushAddress)
                                            call brushAddress.0x42966c68 with:
                                                 gas gas_remaining wei
                                                args mem[_9074 + ceil32(return_data.size) + 64]
                                        else:
                                            if ext_call.return_data[0] > !_6375:
                                                revert with 0, 17
                                            mem[_6379 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_6379 + 100] = ext_call.return_data[0] + _6375
                                            mem[_6379 + 132] = 0
                                            mem[_6379 + 164] = 160
                                            mem[_6379 + 260] = mem[_6379]
                                            idx = 0
                                            s = _6379 + 292
                                            t = _6379 + 32
                                            while idx < mem[_6379]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_6379 + 196] = this.address
                                            mem[_6379 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _6379 + (32 * mem[_6379]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9075 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _9219 = mem[_9075]
                                            require mem[_9075] <= test266151307()
                                            require _9075 + mem[_9075] + 31 < _9075 + return_data.size
                                            _9363 = mem[_9075 + mem[_9075]]
                                            if mem[_9075 + mem[_9075]] > test266151307():
                                                revert with 0, 65
                                            if _9075 + ceil32(return_data.size) + ceil32(32 * mem[_9075 + mem[_9075]]) + 1 > test266151307() or ceil32(32 * mem[_9075 + mem[_9075]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _9075 + ceil32(return_data.size) + ceil32(32 * mem[_9075 + mem[_9075]]) + 1
                                            mem[_9075 + ceil32(return_data.size)] = _9363
                                            require return_data.size >= _9219 + (32 * _9363) + 32
                                            mem[_9075 + ceil32(return_data.size) + 32 len 32 * _9363] = mem[_9075 + _9219 + 32 len 32 * _9363]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                            if 1 >= _9363:
                                                revert with 0, 50
                                            if mem[_9075 + ceil32(return_data.size) + 64] > -1:
                                                revert with 0, 17
                                            require ext_code.size(brushAddress)
                                            call brushAddress.0x42966c68 with:
                                                 gas gas_remaining wei
                                                args mem[_9075 + ceil32(return_data.size) + 64]
                        else:
                            if brushAddress != address(ext_call.return_data[0]):
                                if wftmAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_6375:
                                        revert with 0, 17
                                    mem[_6379 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_6379 + 100] = ext_call.return_data[32] + _6375
                                    mem[_6379 + 132] = 0
                                    mem[_6379 + 164] = 160
                                    mem[_6379 + 260] = mem[_6379]
                                    idx = 0
                                    s = _6379 + 292
                                    t = _6379 + 32
                                    while idx < mem[_6379]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_6379 + 196] = this.address
                                    mem[_6379 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _6379 + (32 * mem[_6379]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9076 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _9220 = mem[_9076]
                                    require mem[_9076] <= test266151307()
                                    require _9076 + mem[_9076] + 31 < _9076 + return_data.size
                                    _9364 = mem[_9076 + mem[_9076]]
                                    if mem[_9076 + mem[_9076]] > test266151307():
                                        revert with 0, 65
                                    if _9076 + ceil32(return_data.size) + ceil32(32 * mem[_9076 + mem[_9076]]) + 1 > test266151307() or ceil32(32 * mem[_9076 + mem[_9076]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _9076 + ceil32(return_data.size) + ceil32(32 * mem[_9076 + mem[_9076]]) + 1
                                    mem[_9076 + ceil32(return_data.size)] = _9364
                                    require return_data.size >= _9220 + (32 * _9364) + 32
                                    mem[_9076 + ceil32(return_data.size) + 32 len 32 * _9364] = mem[_9076 + _9220 + 32 len 32 * _9364]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                    if 1 >= _9364:
                                        revert with 0, 50
                                    if mem[_9076 + ceil32(return_data.size) + 64] > -1:
                                        revert with 0, 17
                                    require ext_code.size(brushAddress)
                                    call brushAddress.0x42966c68 with:
                                         gas gas_remaining wei
                                        args mem[_9076 + ceil32(return_data.size) + 64]
                                else:
                                    if ext_call.return_data[0] > !_6375:
                                        revert with 0, 17
                                    mem[_6379 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_6379 + 100] = ext_call.return_data[0] + _6375
                                    mem[_6379 + 132] = 0
                                    mem[_6379 + 164] = 160
                                    mem[_6379 + 260] = mem[_6379]
                                    idx = 0
                                    s = _6379 + 292
                                    t = _6379 + 32
                                    while idx < mem[_6379]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_6379 + 196] = this.address
                                    mem[_6379 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _6379 + (32 * mem[_6379]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9077 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _9221 = mem[_9077]
                                    require mem[_9077] <= test266151307()
                                    require _9077 + mem[_9077] + 31 < _9077 + return_data.size
                                    _9365 = mem[_9077 + mem[_9077]]
                                    if mem[_9077 + mem[_9077]] > test266151307():
                                        revert with 0, 65
                                    if _9077 + ceil32(return_data.size) + ceil32(32 * mem[_9077 + mem[_9077]]) + 1 > test266151307() or ceil32(32 * mem[_9077 + mem[_9077]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _9077 + ceil32(return_data.size) + ceil32(32 * mem[_9077 + mem[_9077]]) + 1
                                    mem[_9077 + ceil32(return_data.size)] = _9365
                                    require return_data.size >= _9221 + (32 * _9365) + 32
                                    mem[_9077 + ceil32(return_data.size) + 32 len 32 * _9365] = mem[_9077 + _9221 + 32 len 32 * _9365]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                    if 1 >= _9365:
                                        revert with 0, 50
                                    if mem[_9077 + ceil32(return_data.size) + 64] > -1:
                                        revert with 0, 17
                                    require ext_code.size(brushAddress)
                                    call brushAddress.0x42966c68 with:
                                         gas gas_remaining wei
                                        args mem[_9077 + ceil32(return_data.size) + 64]
                            else:
                                if brushAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_6375:
                                        revert with 0, 17
                                    mem[_6379 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_6379 + 100] = ext_call.return_data[32] + _6375
                                    mem[_6379 + 132] = 0
                                    mem[_6379 + 164] = 160
                                    mem[_6379 + 260] = mem[_6379]
                                    idx = 0
                                    s = _6379 + 292
                                    t = _6379 + 32
                                    while idx < mem[_6379]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_6379 + 196] = this.address
                                    mem[_6379 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _6379 + (32 * mem[_6379]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9078 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _9222 = mem[_9078]
                                    require mem[_9078] <= test266151307()
                                    require _9078 + mem[_9078] + 31 < _9078 + return_data.size
                                    _9366 = mem[_9078 + mem[_9078]]
                                    if mem[_9078 + mem[_9078]] > test266151307():
                                        revert with 0, 65
                                    if _9078 + ceil32(return_data.size) + ceil32(32 * mem[_9078 + mem[_9078]]) + 1 > test266151307() or ceil32(32 * mem[_9078 + mem[_9078]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _9078 + ceil32(return_data.size) + ceil32(32 * mem[_9078 + mem[_9078]]) + 1
                                    mem[_9078 + ceil32(return_data.size)] = _9366
                                    require return_data.size >= _9222 + (32 * _9366) + 32
                                    mem[_9078 + ceil32(return_data.size) + 32 len 32 * _9366] = mem[_9078 + _9222 + 32 len 32 * _9366]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                    if 1 >= _9366:
                                        revert with 0, 50
                                    if mem[_9078 + ceil32(return_data.size) + 64] > -1:
                                        revert with 0, 17
                                    require ext_code.size(brushAddress)
                                    call brushAddress.0x42966c68 with:
                                         gas gas_remaining wei
                                        args mem[_9078 + ceil32(return_data.size) + 64]
                                else:
                                    if brushAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[0] > !_6375:
                                            revert with 0, 17
                                        mem[_6379 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_6379 + 100] = ext_call.return_data[0] + _6375
                                        mem[_6379 + 132] = 0
                                        mem[_6379 + 164] = 160
                                        mem[_6379 + 260] = mem[_6379]
                                        idx = 0
                                        s = _6379 + 292
                                        t = _6379 + 32
                                        while idx < mem[_6379]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_6379 + 196] = this.address
                                        mem[_6379 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _6379 + (32 * mem[_6379]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9079 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _9223 = mem[_9079]
                                        require mem[_9079] <= test266151307()
                                        require _9079 + mem[_9079] + 31 < _9079 + return_data.size
                                        _9367 = mem[_9079 + mem[_9079]]
                                        if mem[_9079 + mem[_9079]] > test266151307():
                                            revert with 0, 65
                                        if _9079 + ceil32(return_data.size) + ceil32(32 * mem[_9079 + mem[_9079]]) + 1 > test266151307() or ceil32(32 * mem[_9079 + mem[_9079]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _9079 + ceil32(return_data.size) + ceil32(32 * mem[_9079 + mem[_9079]]) + 1
                                        mem[_9079 + ceil32(return_data.size)] = _9367
                                        require return_data.size >= _9223 + (32 * _9367) + 32
                                        mem[_9079 + ceil32(return_data.size) + 32 len 32 * _9367] = mem[_9079 + _9223 + 32 len 32 * _9367]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                        if 1 >= _9367:
                                            revert with 0, 50
                                        if mem[_9079 + ceil32(return_data.size) + 64] > -1:
                                            revert with 0, 17
                                        require ext_code.size(brushAddress)
                                        call brushAddress.0x42966c68 with:
                                             gas gas_remaining wei
                                            args mem[_9079 + ceil32(return_data.size) + 64]
                                    else:
                                        if wftmAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_6375:
                                                revert with 0, 17
                                            mem[_6379 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_6379 + 100] = ext_call.return_data[32] + _6375
                                            mem[_6379 + 132] = 0
                                            mem[_6379 + 164] = 160
                                            mem[_6379 + 260] = mem[_6379]
                                            idx = 0
                                            s = _6379 + 292
                                            t = _6379 + 32
                                            while idx < mem[_6379]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_6379 + 196] = this.address
                                            mem[_6379 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _6379 + (32 * mem[_6379]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9080 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _9224 = mem[_9080]
                                            require mem[_9080] <= test266151307()
                                            require _9080 + mem[_9080] + 31 < _9080 + return_data.size
                                            _9368 = mem[_9080 + mem[_9080]]
                                            if mem[_9080 + mem[_9080]] > test266151307():
                                                revert with 0, 65
                                            if _9080 + ceil32(return_data.size) + ceil32(32 * mem[_9080 + mem[_9080]]) + 1 > test266151307() or ceil32(32 * mem[_9080 + mem[_9080]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _9080 + ceil32(return_data.size) + ceil32(32 * mem[_9080 + mem[_9080]]) + 1
                                            mem[_9080 + ceil32(return_data.size)] = _9368
                                            require return_data.size >= _9224 + (32 * _9368) + 32
                                            mem[_9080 + ceil32(return_data.size) + 32 len 32 * _9368] = mem[_9080 + _9224 + 32 len 32 * _9368]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                            if 1 >= _9368:
                                                revert with 0, 50
                                            if mem[_9080 + ceil32(return_data.size) + 64] > -1:
                                                revert with 0, 17
                                            require ext_code.size(brushAddress)
                                            call brushAddress.0x42966c68 with:
                                                 gas gas_remaining wei
                                                args mem[_9080 + ceil32(return_data.size) + 64]
                                        else:
                                            if ext_call.return_data[0] > !_6375:
                                                revert with 0, 17
                                            mem[_6379 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_6379 + 100] = ext_call.return_data[0] + _6375
                                            mem[_6379 + 132] = 0
                                            mem[_6379 + 164] = 160
                                            mem[_6379 + 260] = mem[_6379]
                                            idx = 0
                                            s = _6379 + 292
                                            t = _6379 + 32
                                            while idx < mem[_6379]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_6379 + 196] = this.address
                                            mem[_6379 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _6379 + (32 * mem[_6379]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9081 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _9225 = mem[_9081]
                                            require mem[_9081] <= test266151307()
                                            require _9081 + mem[_9081] + 31 < _9081 + return_data.size
                                            _9369 = mem[_9081 + mem[_9081]]
                                            if mem[_9081 + mem[_9081]] > test266151307():
                                                revert with 0, 65
                                            if _9081 + ceil32(return_data.size) + ceil32(32 * mem[_9081 + mem[_9081]]) + 1 > test266151307() or ceil32(32 * mem[_9081 + mem[_9081]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _9081 + ceil32(return_data.size) + ceil32(32 * mem[_9081 + mem[_9081]]) + 1
                                            mem[_9081 + ceil32(return_data.size)] = _9369
                                            require return_data.size >= _9225 + (32 * _9369) + 32
                                            mem[_9081 + ceil32(return_data.size) + 32 len 32 * _9369] = mem[_9081 + _9225 + 32 len 32 * _9369]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                            if 1 >= _9369:
                                                revert with 0, 50
                                            if mem[_9081 + ceil32(return_data.size) + 64] > -1:
                                                revert with 0, 17
                                            require ext_code.size(brushAddress)
                                            call brushAddress.0x42966c68 with:
                                                 gas gas_remaining wei
                                                args mem[_9081 + ceil32(return_data.size) + 64]
                    else:
                        if brushAddress == address(ext_call.return_data[0]):
                            if brushAddress != address(ext_call.return_data[0]):
                                if wftmAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_6375:
                                        revert with 0, 17
                                    mem[_6379 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_6379 + 100] = ext_call.return_data[32] + _6375
                                    mem[_6379 + 132] = 0
                                    mem[_6379 + 164] = 160
                                    mem[_6379 + 260] = mem[_6379]
                                    idx = 0
                                    s = _6379 + 292
                                    t = _6379 + 32
                                    while idx < mem[_6379]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_6379 + 196] = this.address
                                    mem[_6379 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _6379 + (32 * mem[_6379]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9082 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _9226 = mem[_9082]
                                    require mem[_9082] <= test266151307()
                                    require _9082 + mem[_9082] + 31 < _9082 + return_data.size
                                    _9370 = mem[_9082 + mem[_9082]]
                                    if mem[_9082 + mem[_9082]] > test266151307():
                                        revert with 0, 65
                                    if _9082 + ceil32(return_data.size) + ceil32(32 * mem[_9082 + mem[_9082]]) + 1 > test266151307() or ceil32(32 * mem[_9082 + mem[_9082]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _9082 + ceil32(return_data.size) + ceil32(32 * mem[_9082 + mem[_9082]]) + 1
                                    mem[_9082 + ceil32(return_data.size)] = _9370
                                    require return_data.size >= _9226 + (32 * _9370) + 32
                                    mem[_9082 + ceil32(return_data.size) + 32 len 32 * _9370] = mem[_9082 + _9226 + 32 len 32 * _9370]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                    if 1 >= _9370:
                                        revert with 0, 50
                                    if mem[_9082 + ceil32(return_data.size) + 64] > -1:
                                        revert with 0, 17
                                    require ext_code.size(brushAddress)
                                    call brushAddress.0x42966c68 with:
                                         gas gas_remaining wei
                                        args mem[_9082 + ceil32(return_data.size) + 64]
                                else:
                                    if ext_call.return_data[0] > !_6375:
                                        revert with 0, 17
                                    mem[_6379 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_6379 + 100] = ext_call.return_data[0] + _6375
                                    mem[_6379 + 132] = 0
                                    mem[_6379 + 164] = 160
                                    mem[_6379 + 260] = mem[_6379]
                                    idx = 0
                                    s = _6379 + 292
                                    t = _6379 + 32
                                    while idx < mem[_6379]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_6379 + 196] = this.address
                                    mem[_6379 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _6379 + (32 * mem[_6379]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9083 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _9227 = mem[_9083]
                                    require mem[_9083] <= test266151307()
                                    require _9083 + mem[_9083] + 31 < _9083 + return_data.size
                                    _9371 = mem[_9083 + mem[_9083]]
                                    if mem[_9083 + mem[_9083]] > test266151307():
                                        revert with 0, 65
                                    if _9083 + ceil32(return_data.size) + ceil32(32 * mem[_9083 + mem[_9083]]) + 1 > test266151307() or ceil32(32 * mem[_9083 + mem[_9083]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _9083 + ceil32(return_data.size) + ceil32(32 * mem[_9083 + mem[_9083]]) + 1
                                    mem[_9083 + ceil32(return_data.size)] = _9371
                                    require return_data.size >= _9227 + (32 * _9371) + 32
                                    mem[_9083 + ceil32(return_data.size) + 32 len 32 * _9371] = mem[_9083 + _9227 + 32 len 32 * _9371]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                    if 1 >= _9371:
                                        revert with 0, 50
                                    if mem[_9083 + ceil32(return_data.size) + 64] > -1:
                                        revert with 0, 17
                                    require ext_code.size(brushAddress)
                                    call brushAddress.0x42966c68 with:
                                         gas gas_remaining wei
                                        args mem[_9083 + ceil32(return_data.size) + 64]
                            else:
                                if brushAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_6375:
                                        revert with 0, 17
                                    mem[_6379 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_6379 + 100] = ext_call.return_data[32] + _6375
                                    mem[_6379 + 132] = 0
                                    mem[_6379 + 164] = 160
                                    mem[_6379 + 260] = mem[_6379]
                                    idx = 0
                                    s = _6379 + 292
                                    t = _6379 + 32
                                    while idx < mem[_6379]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_6379 + 196] = this.address
                                    mem[_6379 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _6379 + (32 * mem[_6379]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9084 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _9228 = mem[_9084]
                                    require mem[_9084] <= test266151307()
                                    require _9084 + mem[_9084] + 31 < _9084 + return_data.size
                                    _9372 = mem[_9084 + mem[_9084]]
                                    if mem[_9084 + mem[_9084]] > test266151307():
                                        revert with 0, 65
                                    if _9084 + ceil32(return_data.size) + ceil32(32 * mem[_9084 + mem[_9084]]) + 1 > test266151307() or ceil32(32 * mem[_9084 + mem[_9084]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _9084 + ceil32(return_data.size) + ceil32(32 * mem[_9084 + mem[_9084]]) + 1
                                    mem[_9084 + ceil32(return_data.size)] = _9372
                                    require return_data.size >= _9228 + (32 * _9372) + 32
                                    mem[_9084 + ceil32(return_data.size) + 32 len 32 * _9372] = mem[_9084 + _9228 + 32 len 32 * _9372]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                    if 1 >= _9372:
                                        revert with 0, 50
                                    if mem[_9084 + ceil32(return_data.size) + 64] > -1:
                                        revert with 0, 17
                                    require ext_code.size(brushAddress)
                                    call brushAddress.0x42966c68 with:
                                         gas gas_remaining wei
                                        args mem[_9084 + ceil32(return_data.size) + 64]
                                else:
                                    if brushAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[0] > !_6375:
                                            revert with 0, 17
                                        mem[_6379 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_6379 + 100] = ext_call.return_data[0] + _6375
                                        mem[_6379 + 132] = 0
                                        mem[_6379 + 164] = 160
                                        mem[_6379 + 260] = mem[_6379]
                                        idx = 0
                                        s = _6379 + 292
                                        t = _6379 + 32
                                        while idx < mem[_6379]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_6379 + 196] = this.address
                                        mem[_6379 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _6379 + (32 * mem[_6379]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9085 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _9229 = mem[_9085]
                                        require mem[_9085] <= test266151307()
                                        require _9085 + mem[_9085] + 31 < _9085 + return_data.size
                                        _9373 = mem[_9085 + mem[_9085]]
                                        if mem[_9085 + mem[_9085]] > test266151307():
                                            revert with 0, 65
                                        if _9085 + ceil32(return_data.size) + ceil32(32 * mem[_9085 + mem[_9085]]) + 1 > test266151307() or ceil32(32 * mem[_9085 + mem[_9085]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _9085 + ceil32(return_data.size) + ceil32(32 * mem[_9085 + mem[_9085]]) + 1
                                        mem[_9085 + ceil32(return_data.size)] = _9373
                                        require return_data.size >= _9229 + (32 * _9373) + 32
                                        mem[_9085 + ceil32(return_data.size) + 32 len 32 * _9373] = mem[_9085 + _9229 + 32 len 32 * _9373]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                        if 1 >= _9373:
                                            revert with 0, 50
                                        if mem[_9085 + ceil32(return_data.size) + 64] > -1:
                                            revert with 0, 17
                                        require ext_code.size(brushAddress)
                                        call brushAddress.0x42966c68 with:
                                             gas gas_remaining wei
                                            args mem[_9085 + ceil32(return_data.size) + 64]
                                    else:
                                        if wftmAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_6375:
                                                revert with 0, 17
                                            mem[_6379 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_6379 + 100] = ext_call.return_data[32] + _6375
                                            mem[_6379 + 132] = 0
                                            mem[_6379 + 164] = 160
                                            mem[_6379 + 260] = mem[_6379]
                                            idx = 0
                                            s = _6379 + 292
                                            t = _6379 + 32
                                            while idx < mem[_6379]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_6379 + 196] = this.address
                                            mem[_6379 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _6379 + (32 * mem[_6379]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9086 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _9230 = mem[_9086]
                                            require mem[_9086] <= test266151307()
                                            require _9086 + mem[_9086] + 31 < _9086 + return_data.size
                                            _9374 = mem[_9086 + mem[_9086]]
                                            if mem[_9086 + mem[_9086]] > test266151307():
                                                revert with 0, 65
                                            if _9086 + ceil32(return_data.size) + ceil32(32 * mem[_9086 + mem[_9086]]) + 1 > test266151307() or ceil32(32 * mem[_9086 + mem[_9086]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _9086 + ceil32(return_data.size) + ceil32(32 * mem[_9086 + mem[_9086]]) + 1
                                            mem[_9086 + ceil32(return_data.size)] = _9374
                                            require return_data.size >= _9230 + (32 * _9374) + 32
                                            mem[_9086 + ceil32(return_data.size) + 32 len 32 * _9374] = mem[_9086 + _9230 + 32 len 32 * _9374]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                            if 1 >= _9374:
                                                revert with 0, 50
                                            if mem[_9086 + ceil32(return_data.size) + 64] > -1:
                                                revert with 0, 17
                                            require ext_code.size(brushAddress)
                                            call brushAddress.0x42966c68 with:
                                                 gas gas_remaining wei
                                                args mem[_9086 + ceil32(return_data.size) + 64]
                                        else:
                                            if ext_call.return_data[0] > !_6375:
                                                revert with 0, 17
                                            mem[_6379 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_6379 + 100] = ext_call.return_data[0] + _6375
                                            mem[_6379 + 132] = 0
                                            mem[_6379 + 164] = 160
                                            mem[_6379 + 260] = mem[_6379]
                                            idx = 0
                                            s = _6379 + 292
                                            t = _6379 + 32
                                            while idx < mem[_6379]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_6379 + 196] = this.address
                                            mem[_6379 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _6379 + (32 * mem[_6379]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9087 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _9231 = mem[_9087]
                                            require mem[_9087] <= test266151307()
                                            require _9087 + mem[_9087] + 31 < _9087 + return_data.size
                                            _9375 = mem[_9087 + mem[_9087]]
                                            if mem[_9087 + mem[_9087]] > test266151307():
                                                revert with 0, 65
                                            if _9087 + ceil32(return_data.size) + ceil32(32 * mem[_9087 + mem[_9087]]) + 1 > test266151307() or ceil32(32 * mem[_9087 + mem[_9087]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _9087 + ceil32(return_data.size) + ceil32(32 * mem[_9087 + mem[_9087]]) + 1
                                            mem[_9087 + ceil32(return_data.size)] = _9375
                                            require return_data.size >= _9231 + (32 * _9375) + 32
                                            mem[_9087 + ceil32(return_data.size) + 32 len 32 * _9375] = mem[_9087 + _9231 + 32 len 32 * _9375]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                            if 1 >= _9375:
                                                revert with 0, 50
                                            if mem[_9087 + ceil32(return_data.size) + 64] > -1:
                                                revert with 0, 17
                                            require ext_code.size(brushAddress)
                                            call brushAddress.0x42966c68 with:
                                                 gas gas_remaining wei
                                                args mem[_9087 + ceil32(return_data.size) + 64]
                        else:
                            if brushAddress == address(ext_call.return_data[0]):
                                if brushAddress != address(ext_call.return_data[0]):
                                    if wftmAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[32] > !_6375:
                                            revert with 0, 17
                                        mem[_6379 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_6379 + 100] = ext_call.return_data[32] + _6375
                                        mem[_6379 + 132] = 0
                                        mem[_6379 + 164] = 160
                                        mem[_6379 + 260] = mem[_6379]
                                        idx = 0
                                        s = _6379 + 292
                                        t = _6379 + 32
                                        while idx < mem[_6379]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_6379 + 196] = this.address
                                        mem[_6379 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _6379 + (32 * mem[_6379]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9088 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _9232 = mem[_9088]
                                        require mem[_9088] <= test266151307()
                                        require _9088 + mem[_9088] + 31 < _9088 + return_data.size
                                        _9376 = mem[_9088 + mem[_9088]]
                                        if mem[_9088 + mem[_9088]] > test266151307():
                                            revert with 0, 65
                                        if _9088 + ceil32(return_data.size) + ceil32(32 * mem[_9088 + mem[_9088]]) + 1 > test266151307() or ceil32(32 * mem[_9088 + mem[_9088]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _9088 + ceil32(return_data.size) + ceil32(32 * mem[_9088 + mem[_9088]]) + 1
                                        mem[_9088 + ceil32(return_data.size)] = _9376
                                        require return_data.size >= _9232 + (32 * _9376) + 32
                                        mem[_9088 + ceil32(return_data.size) + 32 len 32 * _9376] = mem[_9088 + _9232 + 32 len 32 * _9376]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                        if 1 >= _9376:
                                            revert with 0, 50
                                        if mem[_9088 + ceil32(return_data.size) + 64] > -1:
                                            revert with 0, 17
                                        require ext_code.size(brushAddress)
                                        call brushAddress.0x42966c68 with:
                                             gas gas_remaining wei
                                            args mem[_9088 + ceil32(return_data.size) + 64]
                                    else:
                                        if ext_call.return_data[0] > !_6375:
                                            revert with 0, 17
                                        mem[_6379 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_6379 + 100] = ext_call.return_data[0] + _6375
                                        mem[_6379 + 132] = 0
                                        mem[_6379 + 164] = 160
                                        mem[_6379 + 260] = mem[_6379]
                                        idx = 0
                                        s = _6379 + 292
                                        t = _6379 + 32
                                        while idx < mem[_6379]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_6379 + 196] = this.address
                                        mem[_6379 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _6379 + (32 * mem[_6379]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9089 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _9233 = mem[_9089]
                                        require mem[_9089] <= test266151307()
                                        require _9089 + mem[_9089] + 31 < _9089 + return_data.size
                                        _9377 = mem[_9089 + mem[_9089]]
                                        if mem[_9089 + mem[_9089]] > test266151307():
                                            revert with 0, 65
                                        if _9089 + ceil32(return_data.size) + ceil32(32 * mem[_9089 + mem[_9089]]) + 1 > test266151307() or ceil32(32 * mem[_9089 + mem[_9089]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _9089 + ceil32(return_data.size) + ceil32(32 * mem[_9089 + mem[_9089]]) + 1
                                        mem[_9089 + ceil32(return_data.size)] = _9377
                                        require return_data.size >= _9233 + (32 * _9377) + 32
                                        mem[_9089 + ceil32(return_data.size) + 32 len 32 * _9377] = mem[_9089 + _9233 + 32 len 32 * _9377]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                        if 1 >= _9377:
                                            revert with 0, 50
                                        if mem[_9089 + ceil32(return_data.size) + 64] > -1:
                                            revert with 0, 17
                                        require ext_code.size(brushAddress)
                                        call brushAddress.0x42966c68 with:
                                             gas gas_remaining wei
                                            args mem[_9089 + ceil32(return_data.size) + 64]
                                else:
                                    if brushAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[32] > !_6375:
                                            revert with 0, 17
                                        mem[_6379 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_6379 + 100] = ext_call.return_data[32] + _6375
                                        mem[_6379 + 132] = 0
                                        mem[_6379 + 164] = 160
                                        mem[_6379 + 260] = mem[_6379]
                                        idx = 0
                                        s = _6379 + 292
                                        t = _6379 + 32
                                        while idx < mem[_6379]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_6379 + 196] = this.address
                                        mem[_6379 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _6379 + (32 * mem[_6379]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9090 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _9234 = mem[_9090]
                                        require mem[_9090] <= test266151307()
                                        require _9090 + mem[_9090] + 31 < _9090 + return_data.size
                                        _9378 = mem[_9090 + mem[_9090]]
                                        if mem[_9090 + mem[_9090]] > test266151307():
                                            revert with 0, 65
                                        if _9090 + ceil32(return_data.size) + ceil32(32 * mem[_9090 + mem[_9090]]) + 1 > test266151307() or ceil32(32 * mem[_9090 + mem[_9090]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _9090 + ceil32(return_data.size) + ceil32(32 * mem[_9090 + mem[_9090]]) + 1
                                        mem[_9090 + ceil32(return_data.size)] = _9378
                                        require return_data.size >= _9234 + (32 * _9378) + 32
                                        mem[_9090 + ceil32(return_data.size) + 32 len 32 * _9378] = mem[_9090 + _9234 + 32 len 32 * _9378]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                        if 1 >= _9378:
                                            revert with 0, 50
                                        if mem[_9090 + ceil32(return_data.size) + 64] > -1:
                                            revert with 0, 17
                                        require ext_code.size(brushAddress)
                                        call brushAddress.0x42966c68 with:
                                             gas gas_remaining wei
                                            args mem[_9090 + ceil32(return_data.size) + 64]
                                    else:
                                        if brushAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[0] > !_6375:
                                                revert with 0, 17
                                            mem[_6379 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_6379 + 100] = ext_call.return_data[0] + _6375
                                            mem[_6379 + 132] = 0
                                            mem[_6379 + 164] = 160
                                            mem[_6379 + 260] = mem[_6379]
                                            idx = 0
                                            s = _6379 + 292
                                            t = _6379 + 32
                                            while idx < mem[_6379]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_6379 + 196] = this.address
                                            mem[_6379 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _6379 + (32 * mem[_6379]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9091 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _9235 = mem[_9091]
                                            require mem[_9091] <= test266151307()
                                            require _9091 + mem[_9091] + 31 < _9091 + return_data.size
                                            _9379 = mem[_9091 + mem[_9091]]
                                            if mem[_9091 + mem[_9091]] > test266151307():
                                                revert with 0, 65
                                            if _9091 + ceil32(return_data.size) + ceil32(32 * mem[_9091 + mem[_9091]]) + 1 > test266151307() or ceil32(32 * mem[_9091 + mem[_9091]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _9091 + ceil32(return_data.size) + ceil32(32 * mem[_9091 + mem[_9091]]) + 1
                                            mem[_9091 + ceil32(return_data.size)] = _9379
                                            require return_data.size >= _9235 + (32 * _9379) + 32
                                            mem[_9091 + ceil32(return_data.size) + 32 len 32 * _9379] = mem[_9091 + _9235 + 32 len 32 * _9379]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                            if 1 >= _9379:
                                                revert with 0, 50
                                            if mem[_9091 + ceil32(return_data.size) + 64] > -1:
                                                revert with 0, 17
                                            require ext_code.size(brushAddress)
                                            call brushAddress.0x42966c68 with:
                                                 gas gas_remaining wei
                                                args mem[_9091 + ceil32(return_data.size) + 64]
                                        else:
                                            if wftmAddress == address(ext_call.return_data[0]):
                                                if ext_call.return_data[32] > !_6375:
                                                    revert with 0, 17
                                                mem[_6379 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[_6379 + 100] = ext_call.return_data[32] + _6375
                                                mem[_6379 + 132] = 0
                                                mem[_6379 + 164] = 160
                                                mem[_6379 + 260] = mem[_6379]
                                                idx = 0
                                                s = _6379 + 292
                                                t = _6379 + 32
                                                while idx < mem[_6379]:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[_6379 + 196] = this.address
                                                mem[_6379 + 228] = block.timestamp + 10000
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len _6379 + (32 * mem[_6379]) + -mem[64] + 288]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _9092 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _9236 = mem[_9092]
                                                require mem[_9092] <= test266151307()
                                                require _9092 + mem[_9092] + 31 < _9092 + return_data.size
                                                _9380 = mem[_9092 + mem[_9092]]
                                                if mem[_9092 + mem[_9092]] > test266151307():
                                                    revert with 0, 65
                                                if _9092 + ceil32(return_data.size) + ceil32(32 * mem[_9092 + mem[_9092]]) + 1 > test266151307() or ceil32(32 * mem[_9092 + mem[_9092]]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[64] = _9092 + ceil32(return_data.size) + ceil32(32 * mem[_9092 + mem[_9092]]) + 1
                                                mem[_9092 + ceil32(return_data.size)] = _9380
                                                require return_data.size >= _9236 + (32 * _9380) + 32
                                                mem[_9092 + ceil32(return_data.size) + 32 len 32 * _9380] = mem[_9092 + _9236 + 32 len 32 * _9380]
                                                if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                    revert with 0, 17
                                                maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                                if 1 >= _9380:
                                                    revert with 0, 50
                                                if mem[_9092 + ceil32(return_data.size) + 64] > -1:
                                                    revert with 0, 17
                                                require ext_code.size(brushAddress)
                                                call brushAddress.0x42966c68 with:
                                                     gas gas_remaining wei
                                                    args mem[_9092 + ceil32(return_data.size) + 64]
                                            else:
                                                if ext_call.return_data[0] > !_6375:
                                                    revert with 0, 17
                                                mem[_6379 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[_6379 + 100] = ext_call.return_data[0] + _6375
                                                mem[_6379 + 132] = 0
                                                mem[_6379 + 164] = 160
                                                mem[_6379 + 260] = mem[_6379]
                                                idx = 0
                                                s = _6379 + 292
                                                t = _6379 + 32
                                                while idx < mem[_6379]:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[_6379 + 196] = this.address
                                                mem[_6379 + 228] = block.timestamp + 10000
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len _6379 + (32 * mem[_6379]) + -mem[64] + 288]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _9093 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _9237 = mem[_9093]
                                                require mem[_9093] <= test266151307()
                                                require _9093 + mem[_9093] + 31 < _9093 + return_data.size
                                                _9381 = mem[_9093 + mem[_9093]]
                                                if mem[_9093 + mem[_9093]] > test266151307():
                                                    revert with 0, 65
                                                if _9093 + ceil32(return_data.size) + ceil32(32 * mem[_9093 + mem[_9093]]) + 1 > test266151307() or ceil32(32 * mem[_9093 + mem[_9093]]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[64] = _9093 + ceil32(return_data.size) + ceil32(32 * mem[_9093 + mem[_9093]]) + 1
                                                mem[_9093 + ceil32(return_data.size)] = _9381
                                                require return_data.size >= _9237 + (32 * _9381) + 32
                                                mem[_9093 + ceil32(return_data.size) + 32 len 32 * _9381] = mem[_9093 + _9237 + 32 len 32 * _9381]
                                                if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                    revert with 0, 17
                                                maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                                if 1 >= _9381:
                                                    revert with 0, 50
                                                if mem[_9093 + ceil32(return_data.size) + 64] > -1:
                                                    revert with 0, 17
                                                require ext_code.size(brushAddress)
                                                call brushAddress.0x42966c68 with:
                                                     gas gas_remaining wei
                                                    args mem[_9093 + ceil32(return_data.size) + 64]
                            else:
                                if wftmAddress == address(ext_call.return_data[0]):
                                    if brushAddress != address(ext_call.return_data[0]):
                                        if wftmAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_6375:
                                                revert with 0, 17
                                            mem[_6379 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_6379 + 100] = ext_call.return_data[32] + _6375
                                            mem[_6379 + 132] = 0
                                            mem[_6379 + 164] = 160
                                            mem[_6379 + 260] = mem[_6379]
                                            idx = 0
                                            s = _6379 + 292
                                            t = _6379 + 32
                                            while idx < mem[_6379]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_6379 + 196] = this.address
                                            mem[_6379 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _6379 + (32 * mem[_6379]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9094 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _9238 = mem[_9094]
                                            require mem[_9094] <= test266151307()
                                            require _9094 + mem[_9094] + 31 < _9094 + return_data.size
                                            _9382 = mem[_9094 + mem[_9094]]
                                            if mem[_9094 + mem[_9094]] > test266151307():
                                                revert with 0, 65
                                            if _9094 + ceil32(return_data.size) + ceil32(32 * mem[_9094 + mem[_9094]]) + 1 > test266151307() or ceil32(32 * mem[_9094 + mem[_9094]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _9094 + ceil32(return_data.size) + ceil32(32 * mem[_9094 + mem[_9094]]) + 1
                                            mem[_9094 + ceil32(return_data.size)] = _9382
                                            require return_data.size >= _9238 + (32 * _9382) + 32
                                            mem[_9094 + ceil32(return_data.size) + 32 len 32 * _9382] = mem[_9094 + _9238 + 32 len 32 * _9382]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                            if 1 >= _9382:
                                                revert with 0, 50
                                            if mem[_9094 + ceil32(return_data.size) + 64] > -1:
                                                revert with 0, 17
                                            require ext_code.size(brushAddress)
                                            call brushAddress.0x42966c68 with:
                                                 gas gas_remaining wei
                                                args mem[_9094 + ceil32(return_data.size) + 64]
                                        else:
                                            if ext_call.return_data[0] > !_6375:
                                                revert with 0, 17
                                            mem[_6379 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_6379 + 100] = ext_call.return_data[0] + _6375
                                            mem[_6379 + 132] = 0
                                            mem[_6379 + 164] = 160
                                            mem[_6379 + 260] = mem[_6379]
                                            idx = 0
                                            s = _6379 + 292
                                            t = _6379 + 32
                                            while idx < mem[_6379]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_6379 + 196] = this.address
                                            mem[_6379 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _6379 + (32 * mem[_6379]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9095 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _9239 = mem[_9095]
                                            require mem[_9095] <= test266151307()
                                            require _9095 + mem[_9095] + 31 < _9095 + return_data.size
                                            _9383 = mem[_9095 + mem[_9095]]
                                            if mem[_9095 + mem[_9095]] > test266151307():
                                                revert with 0, 65
                                            if _9095 + ceil32(return_data.size) + ceil32(32 * mem[_9095 + mem[_9095]]) + 1 > test266151307() or ceil32(32 * mem[_9095 + mem[_9095]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _9095 + ceil32(return_data.size) + ceil32(32 * mem[_9095 + mem[_9095]]) + 1
                                            mem[_9095 + ceil32(return_data.size)] = _9383
                                            require return_data.size >= _9239 + (32 * _9383) + 32
                                            mem[_9095 + ceil32(return_data.size) + 32 len 32 * _9383] = mem[_9095 + _9239 + 32 len 32 * _9383]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                            if 1 >= _9383:
                                                revert with 0, 50
                                            if mem[_9095 + ceil32(return_data.size) + 64] > -1:
                                                revert with 0, 17
                                            require ext_code.size(brushAddress)
                                            call brushAddress.0x42966c68 with:
                                                 gas gas_remaining wei
                                                args mem[_9095 + ceil32(return_data.size) + 64]
                                    else:
                                        if brushAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_6375:
                                                revert with 0, 17
                                            mem[_6379 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_6379 + 100] = ext_call.return_data[32] + _6375
                                            mem[_6379 + 132] = 0
                                            mem[_6379 + 164] = 160
                                            mem[_6379 + 260] = mem[_6379]
                                            idx = 0
                                            s = _6379 + 292
                                            t = _6379 + 32
                                            while idx < mem[_6379]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_6379 + 196] = this.address
                                            mem[_6379 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _6379 + (32 * mem[_6379]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9096 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _9240 = mem[_9096]
                                            require mem[_9096] <= test266151307()
                                            require _9096 + mem[_9096] + 31 < _9096 + return_data.size
                                            _9384 = mem[_9096 + mem[_9096]]
                                            if mem[_9096 + mem[_9096]] > test266151307():
                                                revert with 0, 65
                                            if _9096 + ceil32(return_data.size) + ceil32(32 * mem[_9096 + mem[_9096]]) + 1 > test266151307() or ceil32(32 * mem[_9096 + mem[_9096]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _9096 + ceil32(return_data.size) + ceil32(32 * mem[_9096 + mem[_9096]]) + 1
                                            mem[_9096 + ceil32(return_data.size)] = _9384
                                            require return_data.size >= _9240 + (32 * _9384) + 32
                                            mem[_9096 + ceil32(return_data.size) + 32 len 32 * _9384] = mem[_9096 + _9240 + 32 len 32 * _9384]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                            if 1 >= _9384:
                                                revert with 0, 50
                                            if mem[_9096 + ceil32(return_data.size) + 64] > -1:
                                                revert with 0, 17
                                            require ext_code.size(brushAddress)
                                            call brushAddress.0x42966c68 with:
                                                 gas gas_remaining wei
                                                args mem[_9096 + ceil32(return_data.size) + 64]
                                        else:
                                            if brushAddress == address(ext_call.return_data[0]):
                                                if ext_call.return_data[0] > !_6375:
                                                    revert with 0, 17
                                                mem[_6379 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[_6379 + 100] = ext_call.return_data[0] + _6375
                                                mem[_6379 + 132] = 0
                                                mem[_6379 + 164] = 160
                                                mem[_6379 + 260] = mem[_6379]
                                                idx = 0
                                                s = _6379 + 292
                                                t = _6379 + 32
                                                while idx < mem[_6379]:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[_6379 + 196] = this.address
                                                mem[_6379 + 228] = block.timestamp + 10000
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len _6379 + (32 * mem[_6379]) + -mem[64] + 288]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _9097 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _9241 = mem[_9097]
                                                require mem[_9097] <= test266151307()
                                                require _9097 + mem[_9097] + 31 < _9097 + return_data.size
                                                _9385 = mem[_9097 + mem[_9097]]
                                                if mem[_9097 + mem[_9097]] > test266151307():
                                                    revert with 0, 65
                                                if _9097 + ceil32(return_data.size) + ceil32(32 * mem[_9097 + mem[_9097]]) + 1 > test266151307() or ceil32(32 * mem[_9097 + mem[_9097]]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[64] = _9097 + ceil32(return_data.size) + ceil32(32 * mem[_9097 + mem[_9097]]) + 1
                                                mem[_9097 + ceil32(return_data.size)] = _9385
                                                require return_data.size >= _9241 + (32 * _9385) + 32
                                                mem[_9097 + ceil32(return_data.size) + 32 len 32 * _9385] = mem[_9097 + _9241 + 32 len 32 * _9385]
                                                if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                    revert with 0, 17
                                                maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                                if 1 >= _9385:
                                                    revert with 0, 50
                                                if mem[_9097 + ceil32(return_data.size) + 64] > -1:
                                                    revert with 0, 17
                                                require ext_code.size(brushAddress)
                                                call brushAddress.0x42966c68 with:
                                                     gas gas_remaining wei
                                                    args mem[_9097 + ceil32(return_data.size) + 64]
                                            else:
                                                if wftmAddress == address(ext_call.return_data[0]):
                                                    if ext_call.return_data[32] > !_6375:
                                                        revert with 0, 17
                                                    mem[_6379 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[_6379 + 100] = ext_call.return_data[32] + _6375
                                                    mem[_6379 + 132] = 0
                                                    mem[_6379 + 164] = 160
                                                    mem[_6379 + 260] = mem[_6379]
                                                    idx = 0
                                                    s = _6379 + 292
                                                    t = _6379 + 32
                                                    while idx < mem[_6379]:
                                                        mem[s] = mem[t + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[_6379 + 196] = this.address
                                                    mem[_6379 + 228] = block.timestamp + 10000
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len _6379 + (32 * mem[_6379]) + -mem[64] + 288]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _9098 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _9242 = mem[_9098]
                                                    require mem[_9098] <= test266151307()
                                                    require _9098 + mem[_9098] + 31 < _9098 + return_data.size
                                                    _9386 = mem[_9098 + mem[_9098]]
                                                    if mem[_9098 + mem[_9098]] > test266151307():
                                                        revert with 0, 65
                                                    if _9098 + ceil32(return_data.size) + ceil32(32 * mem[_9098 + mem[_9098]]) + 1 > test266151307() or ceil32(32 * mem[_9098 + mem[_9098]]) + 1 < 0:
                                                        revert with 0, 65
                                                    mem[64] = _9098 + ceil32(return_data.size) + ceil32(32 * mem[_9098 + mem[_9098]]) + 1
                                                    mem[_9098 + ceil32(return_data.size)] = _9386
                                                    require return_data.size >= _9242 + (32 * _9386) + 32
                                                    mem[_9098 + ceil32(return_data.size) + 32 len 32 * _9386] = mem[_9098 + _9242 + 32 len 32 * _9386]
                                                    if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                        revert with 0, 17
                                                    maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                                    if 1 >= _9386:
                                                        revert with 0, 50
                                                    if mem[_9098 + ceil32(return_data.size) + 64] > -1:
                                                        revert with 0, 17
                                                    require ext_code.size(brushAddress)
                                                    call brushAddress.0x42966c68 with:
                                                         gas gas_remaining wei
                                                        args mem[_9098 + ceil32(return_data.size) + 64]
                                                else:
                                                    if ext_call.return_data[0] > !_6375:
                                                        revert with 0, 17
                                                    mem[_6379 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[_6379 + 100] = ext_call.return_data[0] + _6375
                                                    mem[_6379 + 132] = 0
                                                    mem[_6379 + 164] = 160
                                                    mem[_6379 + 260] = mem[_6379]
                                                    idx = 0
                                                    s = _6379 + 292
                                                    t = _6379 + 32
                                                    while idx < mem[_6379]:
                                                        mem[s] = mem[t + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[_6379 + 196] = this.address
                                                    mem[_6379 + 228] = block.timestamp + 10000
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len _6379 + (32 * mem[_6379]) + -mem[64] + 288]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _9099 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _9243 = mem[_9099]
                                                    require mem[_9099] <= test266151307()
                                                    require _9099 + mem[_9099] + 31 < _9099 + return_data.size
                                                    _9387 = mem[_9099 + mem[_9099]]
                                                    if mem[_9099 + mem[_9099]] > test266151307():
                                                        revert with 0, 65
                                                    if _9099 + ceil32(return_data.size) + ceil32(32 * mem[_9099 + mem[_9099]]) + 1 > test266151307() or ceil32(32 * mem[_9099 + mem[_9099]]) + 1 < 0:
                                                        revert with 0, 65
                                                    mem[64] = _9099 + ceil32(return_data.size) + ceil32(32 * mem[_9099 + mem[_9099]]) + 1
                                                    mem[_9099 + ceil32(return_data.size)] = _9387
                                                    require return_data.size >= _9243 + (32 * _9387) + 32
                                                    mem[_9099 + ceil32(return_data.size) + 32 len 32 * _9387] = mem[_9099 + _9243 + 32 len 32 * _9387]
                                                    if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                        revert with 0, 17
                                                    maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                                    if 1 >= _9387:
                                                        revert with 0, 50
                                                    if mem[_9099 + ceil32(return_data.size) + 64] > -1:
                                                        revert with 0, 17
                                                    require ext_code.size(brushAddress)
                                                    call brushAddress.0x42966c68 with:
                                                         gas gas_remaining wei
                                                        args mem[_9099 + ceil32(return_data.size) + 64]
                                else:
                                    if brushAddress != address(ext_call.return_data[0]):
                                        if wftmAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_6375:
                                                revert with 0, 17
                                            mem[_6379 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_6379 + 100] = ext_call.return_data[32] + _6375
                                            mem[_6379 + 132] = 0
                                            mem[_6379 + 164] = 160
                                            mem[_6379 + 260] = mem[_6379]
                                            idx = 0
                                            s = _6379 + 292
                                            t = _6379 + 32
                                            while idx < mem[_6379]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_6379 + 196] = this.address
                                            mem[_6379 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _6379 + (32 * mem[_6379]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9100 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _9244 = mem[_9100]
                                            require mem[_9100] <= test266151307()
                                            require _9100 + mem[_9100] + 31 < _9100 + return_data.size
                                            _9388 = mem[_9100 + mem[_9100]]
                                            if mem[_9100 + mem[_9100]] > test266151307():
                                                revert with 0, 65
                                            if _9100 + ceil32(return_data.size) + ceil32(32 * mem[_9100 + mem[_9100]]) + 1 > test266151307() or ceil32(32 * mem[_9100 + mem[_9100]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _9100 + ceil32(return_data.size) + ceil32(32 * mem[_9100 + mem[_9100]]) + 1
                                            mem[_9100 + ceil32(return_data.size)] = _9388
                                            require return_data.size >= _9244 + (32 * _9388) + 32
                                            mem[_9100 + ceil32(return_data.size) + 32 len 32 * _9388] = mem[_9100 + _9244 + 32 len 32 * _9388]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                            if 1 >= _9388:
                                                revert with 0, 50
                                            if mem[_9100 + ceil32(return_data.size) + 64] > -1:
                                                revert with 0, 17
                                            require ext_code.size(brushAddress)
                                            call brushAddress.0x42966c68 with:
                                                 gas gas_remaining wei
                                                args mem[_9100 + ceil32(return_data.size) + 64]
                                        else:
                                            if ext_call.return_data[0] > !_6375:
                                                revert with 0, 17
                                            mem[_6379 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_6379 + 100] = ext_call.return_data[0] + _6375
                                            mem[_6379 + 132] = 0
                                            mem[_6379 + 164] = 160
                                            mem[_6379 + 260] = mem[_6379]
                                            idx = 0
                                            s = _6379 + 292
                                            t = _6379 + 32
                                            while idx < mem[_6379]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_6379 + 196] = this.address
                                            mem[_6379 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _6379 + (32 * mem[_6379]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9101 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _9245 = mem[_9101]
                                            require mem[_9101] <= test266151307()
                                            require _9101 + mem[_9101] + 31 < _9101 + return_data.size
                                            _9389 = mem[_9101 + mem[_9101]]
                                            if mem[_9101 + mem[_9101]] > test266151307():
                                                revert with 0, 65
                                            if _9101 + ceil32(return_data.size) + ceil32(32 * mem[_9101 + mem[_9101]]) + 1 > test266151307() or ceil32(32 * mem[_9101 + mem[_9101]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _9101 + ceil32(return_data.size) + ceil32(32 * mem[_9101 + mem[_9101]]) + 1
                                            mem[_9101 + ceil32(return_data.size)] = _9389
                                            require return_data.size >= _9245 + (32 * _9389) + 32
                                            mem[_9101 + ceil32(return_data.size) + 32 len 32 * _9389] = mem[_9101 + _9245 + 32 len 32 * _9389]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                            if 1 >= _9389:
                                                revert with 0, 50
                                            if mem[_9101 + ceil32(return_data.size) + 64] > -1:
                                                revert with 0, 17
                                            require ext_code.size(brushAddress)
                                            call brushAddress.0x42966c68 with:
                                                 gas gas_remaining wei
                                                args mem[_9101 + ceil32(return_data.size) + 64]
                                    else:
                                        if brushAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_6375:
                                                revert with 0, 17
                                            mem[_6379 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_6379 + 100] = ext_call.return_data[32] + _6375
                                            mem[_6379 + 132] = 0
                                            mem[_6379 + 164] = 160
                                            mem[_6379 + 260] = mem[_6379]
                                            idx = 0
                                            s = _6379 + 292
                                            t = _6379 + 32
                                            while idx < mem[_6379]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_6379 + 196] = this.address
                                            mem[_6379 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _6379 + (32 * mem[_6379]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9102 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _9246 = mem[_9102]
                                            require mem[_9102] <= test266151307()
                                            require _9102 + mem[_9102] + 31 < _9102 + return_data.size
                                            _9390 = mem[_9102 + mem[_9102]]
                                            if mem[_9102 + mem[_9102]] > test266151307():
                                                revert with 0, 65
                                            if _9102 + ceil32(return_data.size) + ceil32(32 * mem[_9102 + mem[_9102]]) + 1 > test266151307() or ceil32(32 * mem[_9102 + mem[_9102]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _9102 + ceil32(return_data.size) + ceil32(32 * mem[_9102 + mem[_9102]]) + 1
                                            mem[_9102 + ceil32(return_data.size)] = _9390
                                            require return_data.size >= _9246 + (32 * _9390) + 32
                                            mem[_9102 + ceil32(return_data.size) + 32 len 32 * _9390] = mem[_9102 + _9246 + 32 len 32 * _9390]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                            if 1 >= _9390:
                                                revert with 0, 50
                                            if mem[_9102 + ceil32(return_data.size) + 64] > -1:
                                                revert with 0, 17
                                            require ext_code.size(brushAddress)
                                            call brushAddress.0x42966c68 with:
                                                 gas gas_remaining wei
                                                args mem[_9102 + ceil32(return_data.size) + 64]
                                        else:
                                            if brushAddress == address(ext_call.return_data[0]):
                                                if ext_call.return_data[0] > !_6375:
                                                    revert with 0, 17
                                                mem[_6379 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[_6379 + 100] = ext_call.return_data[0] + _6375
                                                mem[_6379 + 132] = 0
                                                mem[_6379 + 164] = 160
                                                mem[_6379 + 260] = mem[_6379]
                                                idx = 0
                                                s = _6379 + 292
                                                t = _6379 + 32
                                                while idx < mem[_6379]:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[_6379 + 196] = this.address
                                                mem[_6379 + 228] = block.timestamp + 10000
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len _6379 + (32 * mem[_6379]) + -mem[64] + 288]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _9103 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _9247 = mem[_9103]
                                                require mem[_9103] <= test266151307()
                                                require _9103 + mem[_9103] + 31 < _9103 + return_data.size
                                                _9391 = mem[_9103 + mem[_9103]]
                                                if mem[_9103 + mem[_9103]] > test266151307():
                                                    revert with 0, 65
                                                if _9103 + ceil32(return_data.size) + ceil32(32 * mem[_9103 + mem[_9103]]) + 1 > test266151307() or ceil32(32 * mem[_9103 + mem[_9103]]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[64] = _9103 + ceil32(return_data.size) + ceil32(32 * mem[_9103 + mem[_9103]]) + 1
                                                mem[_9103 + ceil32(return_data.size)] = _9391
                                                require return_data.size >= _9247 + (32 * _9391) + 32
                                                mem[_9103 + ceil32(return_data.size) + 32 len 32 * _9391] = mem[_9103 + _9247 + 32 len 32 * _9391]
                                                if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                    revert with 0, 17
                                                maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                                if 1 >= _9391:
                                                    revert with 0, 50
                                                if mem[_9103 + ceil32(return_data.size) + 64] > -1:
                                                    revert with 0, 17
                                                require ext_code.size(brushAddress)
                                                call brushAddress.0x42966c68 with:
                                                     gas gas_remaining wei
                                                    args mem[_9103 + ceil32(return_data.size) + 64]
                                            else:
                                                if wftmAddress == address(ext_call.return_data[0]):
                                                    if ext_call.return_data[32] > !_6375:
                                                        revert with 0, 17
                                                    mem[_6379 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[_6379 + 100] = ext_call.return_data[32] + _6375
                                                    mem[_6379 + 132] = 0
                                                    mem[_6379 + 164] = 160
                                                    mem[_6379 + 260] = mem[_6379]
                                                    idx = 0
                                                    s = _6379 + 292
                                                    t = _6379 + 32
                                                    while idx < mem[_6379]:
                                                        mem[s] = mem[t + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[_6379 + 196] = this.address
                                                    mem[_6379 + 228] = block.timestamp + 10000
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len _6379 + (32 * mem[_6379]) + -mem[64] + 288]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _9104 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _9248 = mem[_9104]
                                                    require mem[_9104] <= test266151307()
                                                    require _9104 + mem[_9104] + 31 < _9104 + return_data.size
                                                    _9392 = mem[_9104 + mem[_9104]]
                                                    if mem[_9104 + mem[_9104]] > test266151307():
                                                        revert with 0, 65
                                                    if _9104 + ceil32(return_data.size) + ceil32(32 * mem[_9104 + mem[_9104]]) + 1 > test266151307() or ceil32(32 * mem[_9104 + mem[_9104]]) + 1 < 0:
                                                        revert with 0, 65
                                                    mem[64] = _9104 + ceil32(return_data.size) + ceil32(32 * mem[_9104 + mem[_9104]]) + 1
                                                    mem[_9104 + ceil32(return_data.size)] = _9392
                                                    require return_data.size >= _9248 + (32 * _9392) + 32
                                                    mem[_9104 + ceil32(return_data.size) + 32 len 32 * _9392] = mem[_9104 + _9248 + 32 len 32 * _9392]
                                                    if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                        revert with 0, 17
                                                    maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                                    if 1 >= _9392:
                                                        revert with 0, 50
                                                    if mem[_9104 + ceil32(return_data.size) + 64] > -1:
                                                        revert with 0, 17
                                                    require ext_code.size(brushAddress)
                                                    call brushAddress.0x42966c68 with:
                                                         gas gas_remaining wei
                                                        args mem[_9104 + ceil32(return_data.size) + 64]
                                                else:
                                                    if ext_call.return_data[0] > !_6375:
                                                        revert with 0, 17
                                                    mem[_6379 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[_6379 + 100] = ext_call.return_data[0] + _6375
                                                    mem[_6379 + 132] = 0
                                                    mem[_6379 + 164] = 160
                                                    mem[_6379 + 260] = mem[_6379]
                                                    idx = 0
                                                    s = _6379 + 292
                                                    t = _6379 + 32
                                                    while idx < mem[_6379]:
                                                        mem[s] = mem[t + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[_6379 + 196] = this.address
                                                    mem[_6379 + 228] = block.timestamp + 10000
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len _6379 + (32 * mem[_6379]) + -mem[64] + 288]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _9105 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _9249 = mem[_9105]
                                                    require mem[_9105] <= test266151307()
                                                    require _9105 + mem[_9105] + 31 < _9105 + return_data.size
                                                    _9393 = mem[_9105 + mem[_9105]]
                                                    if mem[_9105 + mem[_9105]] > test266151307():
                                                        revert with 0, 65
                                                    if _9105 + ceil32(return_data.size) + ceil32(32 * mem[_9105 + mem[_9105]]) + 1 > test266151307() or ceil32(32 * mem[_9105 + mem[_9105]]) + 1 < 0:
                                                        revert with 0, 65
                                                    mem[64] = _9105 + ceil32(return_data.size) + ceil32(32 * mem[_9105 + mem[_9105]]) + 1
                                                    mem[_9105 + ceil32(return_data.size)] = _9393
                                                    require return_data.size >= _9249 + (32 * _9393) + 32
                                                    mem[_9105 + ceil32(return_data.size) + 32 len 32 * _9393] = mem[_9105 + _9249 + 32 len 32 * _9393]
                                                    if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                        revert with 0, 17
                                                    maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                                    if 1 >= _9393:
                                                        revert with 0, 50
                                                    if mem[_9105 + ceil32(return_data.size) + 64] > -1:
                                                        revert with 0, 17
                                                    require ext_code.size(brushAddress)
                                                    call brushAddress.0x42966c68 with:
                                                         gas gas_remaining wei
                                                        args mem[_9105 + ceil32(return_data.size) + 64]
            else:
                if wftmAddress == address(ext_call.return_data[0]):
                    mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                    mem[(4 * ceil32(return_data.size)) + 228] = 0
                    mem[(4 * ceil32(return_data.size)) + 260] = 160
                    mem[(4 * ceil32(return_data.size)) + 356] = 2
                    idx = 0
                    s = (4 * ceil32(return_data.size)) + 388
                    t = (4 * ceil32(return_data.size)) + 128
                    while idx < 2:
                        mem[s] = mem[t + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[(4 * ceil32(return_data.size)) + 292] = this.address
                    mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                    require ext_code.size(routerAddress)
                    call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                         gas gas_remaining wei
                        args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = (6 * ceil32(return_data.size)) + 192
                    require return_data.size >= 32
                    _3526 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                    require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                    require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                    _3605 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                    if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                        revert with 0, 65
                    if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                        revert with 0, 65
                    mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193
                    mem[(6 * ceil32(return_data.size)) + 192] = _3605
                    require return_data.size >= _3526 + (32 * _3605) + 32
                    mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3605] = mem[(4 * ceil32(return_data.size)) + _3526 + 224 len 32 * _3605]
                    if 1 >= _3605:
                        revert with 0, 50
                    _6376 = mem[(6 * ceil32(return_data.size)) + 256]
                    _6380 = mem[64]
                    mem[mem[64]] = 2
                    mem[64] = mem[64] + 96
                    if 0 >= mem[_6380]:
                        revert with 0, 50
                    mem[_6380 + 32] = address(ext_call.return_data[0])
                    if 1 >= mem[_6380]:
                        revert with 0, 50
                    mem[_6380 + 64] = brushAddress
                    if brushAddress != address(ext_call.return_data[0]):
                        if wftmAddress == address(ext_call.return_data[0]):
                            if brushAddress != address(ext_call.return_data[0]):
                                if wftmAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_6376:
                                        revert with 0, 17
                                    mem[_6380 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_6380 + 100] = ext_call.return_data[32] + _6376
                                    mem[_6380 + 132] = 0
                                    mem[_6380 + 164] = 160
                                    mem[_6380 + 260] = mem[_6380]
                                    idx = 0
                                    s = _6380 + 292
                                    t = _6380 + 32
                                    while idx < mem[_6380]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_6380 + 196] = this.address
                                    mem[_6380 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _6380 + (32 * mem[_6380]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9106 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _9250 = mem[_9106]
                                    require mem[_9106] <= test266151307()
                                    require _9106 + mem[_9106] + 31 < _9106 + return_data.size
                                    _9394 = mem[_9106 + mem[_9106]]
                                    if mem[_9106 + mem[_9106]] > test266151307():
                                        revert with 0, 65
                                    if _9106 + ceil32(return_data.size) + ceil32(32 * mem[_9106 + mem[_9106]]) + 1 > test266151307() or ceil32(32 * mem[_9106 + mem[_9106]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _9106 + ceil32(return_data.size) + ceil32(32 * mem[_9106 + mem[_9106]]) + 1
                                    mem[_9106 + ceil32(return_data.size)] = _9394
                                    require return_data.size >= _9250 + (32 * _9394) + 32
                                    mem[_9106 + ceil32(return_data.size) + 32 len 32 * _9394] = mem[_9106 + _9250 + 32 len 32 * _9394]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                    if 1 >= _9394:
                                        revert with 0, 50
                                    if mem[_9106 + ceil32(return_data.size) + 64] > -1:
                                        revert with 0, 17
                                    require ext_code.size(brushAddress)
                                    call brushAddress.0x42966c68 with:
                                         gas gas_remaining wei
                                        args mem[_9106 + ceil32(return_data.size) + 64]
                                else:
                                    if ext_call.return_data[0] > !_6376:
                                        revert with 0, 17
                                    mem[_6380 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_6380 + 100] = ext_call.return_data[0] + _6376
                                    mem[_6380 + 132] = 0
                                    mem[_6380 + 164] = 160
                                    mem[_6380 + 260] = mem[_6380]
                                    idx = 0
                                    s = _6380 + 292
                                    t = _6380 + 32
                                    while idx < mem[_6380]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_6380 + 196] = this.address
                                    mem[_6380 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _6380 + (32 * mem[_6380]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9107 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _9251 = mem[_9107]
                                    require mem[_9107] <= test266151307()
                                    require _9107 + mem[_9107] + 31 < _9107 + return_data.size
                                    _9395 = mem[_9107 + mem[_9107]]
                                    if mem[_9107 + mem[_9107]] > test266151307():
                                        revert with 0, 65
                                    if _9107 + ceil32(return_data.size) + ceil32(32 * mem[_9107 + mem[_9107]]) + 1 > test266151307() or ceil32(32 * mem[_9107 + mem[_9107]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _9107 + ceil32(return_data.size) + ceil32(32 * mem[_9107 + mem[_9107]]) + 1
                                    mem[_9107 + ceil32(return_data.size)] = _9395
                                    require return_data.size >= _9251 + (32 * _9395) + 32
                                    mem[_9107 + ceil32(return_data.size) + 32 len 32 * _9395] = mem[_9107 + _9251 + 32 len 32 * _9395]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                    if 1 >= _9395:
                                        revert with 0, 50
                                    if mem[_9107 + ceil32(return_data.size) + 64] > -1:
                                        revert with 0, 17
                                    require ext_code.size(brushAddress)
                                    call brushAddress.0x42966c68 with:
                                         gas gas_remaining wei
                                        args mem[_9107 + ceil32(return_data.size) + 64]
                            else:
                                if brushAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_6376:
                                        revert with 0, 17
                                    mem[_6380 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_6380 + 100] = ext_call.return_data[32] + _6376
                                    mem[_6380 + 132] = 0
                                    mem[_6380 + 164] = 160
                                    mem[_6380 + 260] = mem[_6380]
                                    idx = 0
                                    s = _6380 + 292
                                    t = _6380 + 32
                                    while idx < mem[_6380]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_6380 + 196] = this.address
                                    mem[_6380 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _6380 + (32 * mem[_6380]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9108 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _9252 = mem[_9108]
                                    require mem[_9108] <= test266151307()
                                    require _9108 + mem[_9108] + 31 < _9108 + return_data.size
                                    _9396 = mem[_9108 + mem[_9108]]
                                    if mem[_9108 + mem[_9108]] > test266151307():
                                        revert with 0, 65
                                    if _9108 + ceil32(return_data.size) + ceil32(32 * mem[_9108 + mem[_9108]]) + 1 > test266151307() or ceil32(32 * mem[_9108 + mem[_9108]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _9108 + ceil32(return_data.size) + ceil32(32 * mem[_9108 + mem[_9108]]) + 1
                                    mem[_9108 + ceil32(return_data.size)] = _9396
                                    require return_data.size >= _9252 + (32 * _9396) + 32
                                    mem[_9108 + ceil32(return_data.size) + 32 len 32 * _9396] = mem[_9108 + _9252 + 32 len 32 * _9396]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                    if 1 >= _9396:
                                        revert with 0, 50
                                    if mem[_9108 + ceil32(return_data.size) + 64] > -1:
                                        revert with 0, 17
                                    require ext_code.size(brushAddress)
                                    call brushAddress.0x42966c68 with:
                                         gas gas_remaining wei
                                        args mem[_9108 + ceil32(return_data.size) + 64]
                                else:
                                    if brushAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[0] > !_6376:
                                            revert with 0, 17
                                        mem[_6380 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_6380 + 100] = ext_call.return_data[0] + _6376
                                        mem[_6380 + 132] = 0
                                        mem[_6380 + 164] = 160
                                        mem[_6380 + 260] = mem[_6380]
                                        idx = 0
                                        s = _6380 + 292
                                        t = _6380 + 32
                                        while idx < mem[_6380]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_6380 + 196] = this.address
                                        mem[_6380 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _6380 + (32 * mem[_6380]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9109 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _9253 = mem[_9109]
                                        require mem[_9109] <= test266151307()
                                        require _9109 + mem[_9109] + 31 < _9109 + return_data.size
                                        _9397 = mem[_9109 + mem[_9109]]
                                        if mem[_9109 + mem[_9109]] > test266151307():
                                            revert with 0, 65
                                        if _9109 + ceil32(return_data.size) + ceil32(32 * mem[_9109 + mem[_9109]]) + 1 > test266151307() or ceil32(32 * mem[_9109 + mem[_9109]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _9109 + ceil32(return_data.size) + ceil32(32 * mem[_9109 + mem[_9109]]) + 1
                                        mem[_9109 + ceil32(return_data.size)] = _9397
                                        require return_data.size >= _9253 + (32 * _9397) + 32
                                        mem[_9109 + ceil32(return_data.size) + 32 len 32 * _9397] = mem[_9109 + _9253 + 32 len 32 * _9397]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                        if 1 >= _9397:
                                            revert with 0, 50
                                        if mem[_9109 + ceil32(return_data.size) + 64] > -1:
                                            revert with 0, 17
                                        require ext_code.size(brushAddress)
                                        call brushAddress.0x42966c68 with:
                                             gas gas_remaining wei
                                            args mem[_9109 + ceil32(return_data.size) + 64]
                                    else:
                                        if wftmAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_6376:
                                                revert with 0, 17
                                            mem[_6380 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_6380 + 100] = ext_call.return_data[32] + _6376
                                            mem[_6380 + 132] = 0
                                            mem[_6380 + 164] = 160
                                            mem[_6380 + 260] = mem[_6380]
                                            idx = 0
                                            s = _6380 + 292
                                            t = _6380 + 32
                                            while idx < mem[_6380]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_6380 + 196] = this.address
                                            mem[_6380 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _6380 + (32 * mem[_6380]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9110 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _9254 = mem[_9110]
                                            require mem[_9110] <= test266151307()
                                            require _9110 + mem[_9110] + 31 < _9110 + return_data.size
                                            _9398 = mem[_9110 + mem[_9110]]
                                            if mem[_9110 + mem[_9110]] > test266151307():
                                                revert with 0, 65
                                            if _9110 + ceil32(return_data.size) + ceil32(32 * mem[_9110 + mem[_9110]]) + 1 > test266151307() or ceil32(32 * mem[_9110 + mem[_9110]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _9110 + ceil32(return_data.size) + ceil32(32 * mem[_9110 + mem[_9110]]) + 1
                                            mem[_9110 + ceil32(return_data.size)] = _9398
                                            require return_data.size >= _9254 + (32 * _9398) + 32
                                            mem[_9110 + ceil32(return_data.size) + 32 len 32 * _9398] = mem[_9110 + _9254 + 32 len 32 * _9398]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                            if 1 >= _9398:
                                                revert with 0, 50
                                            if mem[_9110 + ceil32(return_data.size) + 64] > -1:
                                                revert with 0, 17
                                            require ext_code.size(brushAddress)
                                            call brushAddress.0x42966c68 with:
                                                 gas gas_remaining wei
                                                args mem[_9110 + ceil32(return_data.size) + 64]
                                        else:
                                            if ext_call.return_data[0] > !_6376:
                                                revert with 0, 17
                                            mem[_6380 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_6380 + 100] = ext_call.return_data[0] + _6376
                                            mem[_6380 + 132] = 0
                                            mem[_6380 + 164] = 160
                                            mem[_6380 + 260] = mem[_6380]
                                            idx = 0
                                            s = _6380 + 292
                                            t = _6380 + 32
                                            while idx < mem[_6380]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_6380 + 196] = this.address
                                            mem[_6380 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _6380 + (32 * mem[_6380]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9111 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _9255 = mem[_9111]
                                            require mem[_9111] <= test266151307()
                                            require _9111 + mem[_9111] + 31 < _9111 + return_data.size
                                            _9399 = mem[_9111 + mem[_9111]]
                                            if mem[_9111 + mem[_9111]] > test266151307():
                                                revert with 0, 65
                                            if _9111 + ceil32(return_data.size) + ceil32(32 * mem[_9111 + mem[_9111]]) + 1 > test266151307() or ceil32(32 * mem[_9111 + mem[_9111]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _9111 + ceil32(return_data.size) + ceil32(32 * mem[_9111 + mem[_9111]]) + 1
                                            mem[_9111 + ceil32(return_data.size)] = _9399
                                            require return_data.size >= _9255 + (32 * _9399) + 32
                                            mem[_9111 + ceil32(return_data.size) + 32 len 32 * _9399] = mem[_9111 + _9255 + 32 len 32 * _9399]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                            if 1 >= _9399:
                                                revert with 0, 50
                                            if mem[_9111 + ceil32(return_data.size) + 64] > -1:
                                                revert with 0, 17
                                            require ext_code.size(brushAddress)
                                            call brushAddress.0x42966c68 with:
                                                 gas gas_remaining wei
                                                args mem[_9111 + ceil32(return_data.size) + 64]
                        else:
                            if brushAddress != address(ext_call.return_data[0]):
                                if wftmAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_6376:
                                        revert with 0, 17
                                    mem[_6380 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_6380 + 100] = ext_call.return_data[32] + _6376
                                    mem[_6380 + 132] = 0
                                    mem[_6380 + 164] = 160
                                    mem[_6380 + 260] = mem[_6380]
                                    idx = 0
                                    s = _6380 + 292
                                    t = _6380 + 32
                                    while idx < mem[_6380]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_6380 + 196] = this.address
                                    mem[_6380 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _6380 + (32 * mem[_6380]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9112 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _9256 = mem[_9112]
                                    require mem[_9112] <= test266151307()
                                    require _9112 + mem[_9112] + 31 < _9112 + return_data.size
                                    _9400 = mem[_9112 + mem[_9112]]
                                    if mem[_9112 + mem[_9112]] > test266151307():
                                        revert with 0, 65
                                    if _9112 + ceil32(return_data.size) + ceil32(32 * mem[_9112 + mem[_9112]]) + 1 > test266151307() or ceil32(32 * mem[_9112 + mem[_9112]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _9112 + ceil32(return_data.size) + ceil32(32 * mem[_9112 + mem[_9112]]) + 1
                                    mem[_9112 + ceil32(return_data.size)] = _9400
                                    require return_data.size >= _9256 + (32 * _9400) + 32
                                    mem[_9112 + ceil32(return_data.size) + 32 len 32 * _9400] = mem[_9112 + _9256 + 32 len 32 * _9400]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                    if 1 >= _9400:
                                        revert with 0, 50
                                    if mem[_9112 + ceil32(return_data.size) + 64] > -1:
                                        revert with 0, 17
                                    require ext_code.size(brushAddress)
                                    call brushAddress.0x42966c68 with:
                                         gas gas_remaining wei
                                        args mem[_9112 + ceil32(return_data.size) + 64]
                                else:
                                    if ext_call.return_data[0] > !_6376:
                                        revert with 0, 17
                                    mem[_6380 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_6380 + 100] = ext_call.return_data[0] + _6376
                                    mem[_6380 + 132] = 0
                                    mem[_6380 + 164] = 160
                                    mem[_6380 + 260] = mem[_6380]
                                    idx = 0
                                    s = _6380 + 292
                                    t = _6380 + 32
                                    while idx < mem[_6380]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_6380 + 196] = this.address
                                    mem[_6380 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _6380 + (32 * mem[_6380]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9113 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _9257 = mem[_9113]
                                    require mem[_9113] <= test266151307()
                                    require _9113 + mem[_9113] + 31 < _9113 + return_data.size
                                    _9401 = mem[_9113 + mem[_9113]]
                                    if mem[_9113 + mem[_9113]] > test266151307():
                                        revert with 0, 65
                                    if _9113 + ceil32(return_data.size) + ceil32(32 * mem[_9113 + mem[_9113]]) + 1 > test266151307() or ceil32(32 * mem[_9113 + mem[_9113]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _9113 + ceil32(return_data.size) + ceil32(32 * mem[_9113 + mem[_9113]]) + 1
                                    mem[_9113 + ceil32(return_data.size)] = _9401
                                    require return_data.size >= _9257 + (32 * _9401) + 32
                                    mem[_9113 + ceil32(return_data.size) + 32 len 32 * _9401] = mem[_9113 + _9257 + 32 len 32 * _9401]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                    if 1 >= _9401:
                                        revert with 0, 50
                                    if mem[_9113 + ceil32(return_data.size) + 64] > -1:
                                        revert with 0, 17
                                    require ext_code.size(brushAddress)
                                    call brushAddress.0x42966c68 with:
                                         gas gas_remaining wei
                                        args mem[_9113 + ceil32(return_data.size) + 64]
                            else:
                                if brushAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_6376:
                                        revert with 0, 17
                                    mem[_6380 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_6380 + 100] = ext_call.return_data[32] + _6376
                                    mem[_6380 + 132] = 0
                                    mem[_6380 + 164] = 160
                                    mem[_6380 + 260] = mem[_6380]
                                    idx = 0
                                    s = _6380 + 292
                                    t = _6380 + 32
                                    while idx < mem[_6380]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_6380 + 196] = this.address
                                    mem[_6380 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _6380 + (32 * mem[_6380]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9114 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _9258 = mem[_9114]
                                    require mem[_9114] <= test266151307()
                                    require _9114 + mem[_9114] + 31 < _9114 + return_data.size
                                    _9402 = mem[_9114 + mem[_9114]]
                                    if mem[_9114 + mem[_9114]] > test266151307():
                                        revert with 0, 65
                                    if _9114 + ceil32(return_data.size) + ceil32(32 * mem[_9114 + mem[_9114]]) + 1 > test266151307() or ceil32(32 * mem[_9114 + mem[_9114]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _9114 + ceil32(return_data.size) + ceil32(32 * mem[_9114 + mem[_9114]]) + 1
                                    mem[_9114 + ceil32(return_data.size)] = _9402
                                    require return_data.size >= _9258 + (32 * _9402) + 32
                                    mem[_9114 + ceil32(return_data.size) + 32 len 32 * _9402] = mem[_9114 + _9258 + 32 len 32 * _9402]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                    if 1 >= _9402:
                                        revert with 0, 50
                                    if mem[_9114 + ceil32(return_data.size) + 64] > -1:
                                        revert with 0, 17
                                    require ext_code.size(brushAddress)
                                    call brushAddress.0x42966c68 with:
                                         gas gas_remaining wei
                                        args mem[_9114 + ceil32(return_data.size) + 64]
                                else:
                                    if brushAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[0] > !_6376:
                                            revert with 0, 17
                                        mem[_6380 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_6380 + 100] = ext_call.return_data[0] + _6376
                                        mem[_6380 + 132] = 0
                                        mem[_6380 + 164] = 160
                                        mem[_6380 + 260] = mem[_6380]
                                        idx = 0
                                        s = _6380 + 292
                                        t = _6380 + 32
                                        while idx < mem[_6380]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_6380 + 196] = this.address
                                        mem[_6380 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _6380 + (32 * mem[_6380]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9115 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _9259 = mem[_9115]
                                        require mem[_9115] <= test266151307()
                                        require _9115 + mem[_9115] + 31 < _9115 + return_data.size
                                        _9403 = mem[_9115 + mem[_9115]]
                                        if mem[_9115 + mem[_9115]] > test266151307():
                                            revert with 0, 65
                                        if _9115 + ceil32(return_data.size) + ceil32(32 * mem[_9115 + mem[_9115]]) + 1 > test266151307() or ceil32(32 * mem[_9115 + mem[_9115]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _9115 + ceil32(return_data.size) + ceil32(32 * mem[_9115 + mem[_9115]]) + 1
                                        mem[_9115 + ceil32(return_data.size)] = _9403
                                        require return_data.size >= _9259 + (32 * _9403) + 32
                                        mem[_9115 + ceil32(return_data.size) + 32 len 32 * _9403] = mem[_9115 + _9259 + 32 len 32 * _9403]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                        if 1 >= _9403:
                                            revert with 0, 50
                                        if mem[_9115 + ceil32(return_data.size) + 64] > -1:
                                            revert with 0, 17
                                        require ext_code.size(brushAddress)
                                        call brushAddress.0x42966c68 with:
                                             gas gas_remaining wei
                                            args mem[_9115 + ceil32(return_data.size) + 64]
                                    else:
                                        if wftmAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_6376:
                                                revert with 0, 17
                                            mem[_6380 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_6380 + 100] = ext_call.return_data[32] + _6376
                                            mem[_6380 + 132] = 0
                                            mem[_6380 + 164] = 160
                                            mem[_6380 + 260] = mem[_6380]
                                            idx = 0
                                            s = _6380 + 292
                                            t = _6380 + 32
                                            while idx < mem[_6380]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_6380 + 196] = this.address
                                            mem[_6380 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _6380 + (32 * mem[_6380]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9116 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _9260 = mem[_9116]
                                            require mem[_9116] <= test266151307()
                                            require _9116 + mem[_9116] + 31 < _9116 + return_data.size
                                            _9404 = mem[_9116 + mem[_9116]]
                                            if mem[_9116 + mem[_9116]] > test266151307():
                                                revert with 0, 65
                                            if _9116 + ceil32(return_data.size) + ceil32(32 * mem[_9116 + mem[_9116]]) + 1 > test266151307() or ceil32(32 * mem[_9116 + mem[_9116]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _9116 + ceil32(return_data.size) + ceil32(32 * mem[_9116 + mem[_9116]]) + 1
                                            mem[_9116 + ceil32(return_data.size)] = _9404
                                            require return_data.size >= _9260 + (32 * _9404) + 32
                                            mem[_9116 + ceil32(return_data.size) + 32 len 32 * _9404] = mem[_9116 + _9260 + 32 len 32 * _9404]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                            if 1 >= _9404:
                                                revert with 0, 50
                                            if mem[_9116 + ceil32(return_data.size) + 64] > -1:
                                                revert with 0, 17
                                            require ext_code.size(brushAddress)
                                            call brushAddress.0x42966c68 with:
                                                 gas gas_remaining wei
                                                args mem[_9116 + ceil32(return_data.size) + 64]
                                        else:
                                            if ext_call.return_data[0] > !_6376:
                                                revert with 0, 17
                                            mem[_6380 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_6380 + 100] = ext_call.return_data[0] + _6376
                                            mem[_6380 + 132] = 0
                                            mem[_6380 + 164] = 160
                                            mem[_6380 + 260] = mem[_6380]
                                            idx = 0
                                            s = _6380 + 292
                                            t = _6380 + 32
                                            while idx < mem[_6380]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_6380 + 196] = this.address
                                            mem[_6380 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _6380 + (32 * mem[_6380]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9117 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _9261 = mem[_9117]
                                            require mem[_9117] <= test266151307()
                                            require _9117 + mem[_9117] + 31 < _9117 + return_data.size
                                            _9405 = mem[_9117 + mem[_9117]]
                                            if mem[_9117 + mem[_9117]] > test266151307():
                                                revert with 0, 65
                                            if _9117 + ceil32(return_data.size) + ceil32(32 * mem[_9117 + mem[_9117]]) + 1 > test266151307() or ceil32(32 * mem[_9117 + mem[_9117]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _9117 + ceil32(return_data.size) + ceil32(32 * mem[_9117 + mem[_9117]]) + 1
                                            mem[_9117 + ceil32(return_data.size)] = _9405
                                            require return_data.size >= _9261 + (32 * _9405) + 32
                                            mem[_9117 + ceil32(return_data.size) + 32 len 32 * _9405] = mem[_9117 + _9261 + 32 len 32 * _9405]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                            if 1 >= _9405:
                                                revert with 0, 50
                                            if mem[_9117 + ceil32(return_data.size) + 64] > -1:
                                                revert with 0, 17
                                            require ext_code.size(brushAddress)
                                            call brushAddress.0x42966c68 with:
                                                 gas gas_remaining wei
                                                args mem[_9117 + ceil32(return_data.size) + 64]
                    else:
                        if brushAddress == address(ext_call.return_data[0]):
                            if brushAddress != address(ext_call.return_data[0]):
                                if wftmAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_6376:
                                        revert with 0, 17
                                    mem[_6380 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_6380 + 100] = ext_call.return_data[32] + _6376
                                    mem[_6380 + 132] = 0
                                    mem[_6380 + 164] = 160
                                    mem[_6380 + 260] = mem[_6380]
                                    idx = 0
                                    s = _6380 + 292
                                    t = _6380 + 32
                                    while idx < mem[_6380]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_6380 + 196] = this.address
                                    mem[_6380 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _6380 + (32 * mem[_6380]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9118 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _9262 = mem[_9118]
                                    require mem[_9118] <= test266151307()
                                    require _9118 + mem[_9118] + 31 < _9118 + return_data.size
                                    _9406 = mem[_9118 + mem[_9118]]
                                    if mem[_9118 + mem[_9118]] > test266151307():
                                        revert with 0, 65
                                    if _9118 + ceil32(return_data.size) + ceil32(32 * mem[_9118 + mem[_9118]]) + 1 > test266151307() or ceil32(32 * mem[_9118 + mem[_9118]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _9118 + ceil32(return_data.size) + ceil32(32 * mem[_9118 + mem[_9118]]) + 1
                                    mem[_9118 + ceil32(return_data.size)] = _9406
                                    require return_data.size >= _9262 + (32 * _9406) + 32
                                    mem[_9118 + ceil32(return_data.size) + 32 len 32 * _9406] = mem[_9118 + _9262 + 32 len 32 * _9406]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                    if 1 >= _9406:
                                        revert with 0, 50
                                    if mem[_9118 + ceil32(return_data.size) + 64] > -1:
                                        revert with 0, 17
                                    require ext_code.size(brushAddress)
                                    call brushAddress.0x42966c68 with:
                                         gas gas_remaining wei
                                        args mem[_9118 + ceil32(return_data.size) + 64]
                                else:
                                    if ext_call.return_data[0] > !_6376:
                                        revert with 0, 17
                                    mem[_6380 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_6380 + 100] = ext_call.return_data[0] + _6376
                                    mem[_6380 + 132] = 0
                                    mem[_6380 + 164] = 160
                                    mem[_6380 + 260] = mem[_6380]
                                    idx = 0
                                    s = _6380 + 292
                                    t = _6380 + 32
                                    while idx < mem[_6380]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_6380 + 196] = this.address
                                    mem[_6380 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _6380 + (32 * mem[_6380]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9119 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _9263 = mem[_9119]
                                    require mem[_9119] <= test266151307()
                                    require _9119 + mem[_9119] + 31 < _9119 + return_data.size
                                    _9407 = mem[_9119 + mem[_9119]]
                                    if mem[_9119 + mem[_9119]] > test266151307():
                                        revert with 0, 65
                                    if _9119 + ceil32(return_data.size) + ceil32(32 * mem[_9119 + mem[_9119]]) + 1 > test266151307() or ceil32(32 * mem[_9119 + mem[_9119]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _9119 + ceil32(return_data.size) + ceil32(32 * mem[_9119 + mem[_9119]]) + 1
                                    mem[_9119 + ceil32(return_data.size)] = _9407
                                    require return_data.size >= _9263 + (32 * _9407) + 32
                                    mem[_9119 + ceil32(return_data.size) + 32 len 32 * _9407] = mem[_9119 + _9263 + 32 len 32 * _9407]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                    if 1 >= _9407:
                                        revert with 0, 50
                                    if mem[_9119 + ceil32(return_data.size) + 64] > -1:
                                        revert with 0, 17
                                    require ext_code.size(brushAddress)
                                    call brushAddress.0x42966c68 with:
                                         gas gas_remaining wei
                                        args mem[_9119 + ceil32(return_data.size) + 64]
                            else:
                                if brushAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_6376:
                                        revert with 0, 17
                                    mem[_6380 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_6380 + 100] = ext_call.return_data[32] + _6376
                                    mem[_6380 + 132] = 0
                                    mem[_6380 + 164] = 160
                                    mem[_6380 + 260] = mem[_6380]
                                    idx = 0
                                    s = _6380 + 292
                                    t = _6380 + 32
                                    while idx < mem[_6380]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_6380 + 196] = this.address
                                    mem[_6380 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _6380 + (32 * mem[_6380]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9120 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _9264 = mem[_9120]
                                    require mem[_9120] <= test266151307()
                                    require _9120 + mem[_9120] + 31 < _9120 + return_data.size
                                    _9408 = mem[_9120 + mem[_9120]]
                                    if mem[_9120 + mem[_9120]] > test266151307():
                                        revert with 0, 65
                                    if _9120 + ceil32(return_data.size) + ceil32(32 * mem[_9120 + mem[_9120]]) + 1 > test266151307() or ceil32(32 * mem[_9120 + mem[_9120]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _9120 + ceil32(return_data.size) + ceil32(32 * mem[_9120 + mem[_9120]]) + 1
                                    mem[_9120 + ceil32(return_data.size)] = _9408
                                    require return_data.size >= _9264 + (32 * _9408) + 32
                                    mem[_9120 + ceil32(return_data.size) + 32 len 32 * _9408] = mem[_9120 + _9264 + 32 len 32 * _9408]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                    if 1 >= _9408:
                                        revert with 0, 50
                                    if mem[_9120 + ceil32(return_data.size) + 64] > -1:
                                        revert with 0, 17
                                    require ext_code.size(brushAddress)
                                    call brushAddress.0x42966c68 with:
                                         gas gas_remaining wei
                                        args mem[_9120 + ceil32(return_data.size) + 64]
                                else:
                                    if brushAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[0] > !_6376:
                                            revert with 0, 17
                                        mem[_6380 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_6380 + 100] = ext_call.return_data[0] + _6376
                                        mem[_6380 + 132] = 0
                                        mem[_6380 + 164] = 160
                                        mem[_6380 + 260] = mem[_6380]
                                        idx = 0
                                        s = _6380 + 292
                                        t = _6380 + 32
                                        while idx < mem[_6380]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_6380 + 196] = this.address
                                        mem[_6380 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _6380 + (32 * mem[_6380]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9121 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _9265 = mem[_9121]
                                        require mem[_9121] <= test266151307()
                                        require _9121 + mem[_9121] + 31 < _9121 + return_data.size
                                        _9409 = mem[_9121 + mem[_9121]]
                                        if mem[_9121 + mem[_9121]] > test266151307():
                                            revert with 0, 65
                                        if _9121 + ceil32(return_data.size) + ceil32(32 * mem[_9121 + mem[_9121]]) + 1 > test266151307() or ceil32(32 * mem[_9121 + mem[_9121]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _9121 + ceil32(return_data.size) + ceil32(32 * mem[_9121 + mem[_9121]]) + 1
                                        mem[_9121 + ceil32(return_data.size)] = _9409
                                        require return_data.size >= _9265 + (32 * _9409) + 32
                                        mem[_9121 + ceil32(return_data.size) + 32 len 32 * _9409] = mem[_9121 + _9265 + 32 len 32 * _9409]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                        if 1 >= _9409:
                                            revert with 0, 50
                                        if mem[_9121 + ceil32(return_data.size) + 64] > -1:
                                            revert with 0, 17
                                        require ext_code.size(brushAddress)
                                        call brushAddress.0x42966c68 with:
                                             gas gas_remaining wei
                                            args mem[_9121 + ceil32(return_data.size) + 64]
                                    else:
                                        if wftmAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_6376:
                                                revert with 0, 17
                                            mem[_6380 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_6380 + 100] = ext_call.return_data[32] + _6376
                                            mem[_6380 + 132] = 0
                                            mem[_6380 + 164] = 160
                                            mem[_6380 + 260] = mem[_6380]
                                            idx = 0
                                            s = _6380 + 292
                                            t = _6380 + 32
                                            while idx < mem[_6380]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_6380 + 196] = this.address
                                            mem[_6380 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _6380 + (32 * mem[_6380]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9122 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _9266 = mem[_9122]
                                            require mem[_9122] <= test266151307()
                                            require _9122 + mem[_9122] + 31 < _9122 + return_data.size
                                            _9410 = mem[_9122 + mem[_9122]]
                                            if mem[_9122 + mem[_9122]] > test266151307():
                                                revert with 0, 65
                                            if _9122 + ceil32(return_data.size) + ceil32(32 * mem[_9122 + mem[_9122]]) + 1 > test266151307() or ceil32(32 * mem[_9122 + mem[_9122]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _9122 + ceil32(return_data.size) + ceil32(32 * mem[_9122 + mem[_9122]]) + 1
                                            mem[_9122 + ceil32(return_data.size)] = _9410
                                            require return_data.size >= _9266 + (32 * _9410) + 32
                                            mem[_9122 + ceil32(return_data.size) + 32 len 32 * _9410] = mem[_9122 + _9266 + 32 len 32 * _9410]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                            if 1 >= _9410:
                                                revert with 0, 50
                                            if mem[_9122 + ceil32(return_data.size) + 64] > -1:
                                                revert with 0, 17
                                            require ext_code.size(brushAddress)
                                            call brushAddress.0x42966c68 with:
                                                 gas gas_remaining wei
                                                args mem[_9122 + ceil32(return_data.size) + 64]
                                        else:
                                            if ext_call.return_data[0] > !_6376:
                                                revert with 0, 17
                                            mem[_6380 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_6380 + 100] = ext_call.return_data[0] + _6376
                                            mem[_6380 + 132] = 0
                                            mem[_6380 + 164] = 160
                                            mem[_6380 + 260] = mem[_6380]
                                            idx = 0
                                            s = _6380 + 292
                                            t = _6380 + 32
                                            while idx < mem[_6380]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_6380 + 196] = this.address
                                            mem[_6380 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _6380 + (32 * mem[_6380]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9123 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _9267 = mem[_9123]
                                            require mem[_9123] <= test266151307()
                                            require _9123 + mem[_9123] + 31 < _9123 + return_data.size
                                            _9411 = mem[_9123 + mem[_9123]]
                                            if mem[_9123 + mem[_9123]] > test266151307():
                                                revert with 0, 65
                                            if _9123 + ceil32(return_data.size) + ceil32(32 * mem[_9123 + mem[_9123]]) + 1 > test266151307() or ceil32(32 * mem[_9123 + mem[_9123]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _9123 + ceil32(return_data.size) + ceil32(32 * mem[_9123 + mem[_9123]]) + 1
                                            mem[_9123 + ceil32(return_data.size)] = _9411
                                            require return_data.size >= _9267 + (32 * _9411) + 32
                                            mem[_9123 + ceil32(return_data.size) + 32 len 32 * _9411] = mem[_9123 + _9267 + 32 len 32 * _9411]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                            if 1 >= _9411:
                                                revert with 0, 50
                                            if mem[_9123 + ceil32(return_data.size) + 64] > -1:
                                                revert with 0, 17
                                            require ext_code.size(brushAddress)
                                            call brushAddress.0x42966c68 with:
                                                 gas gas_remaining wei
                                                args mem[_9123 + ceil32(return_data.size) + 64]
                        else:
                            if brushAddress == address(ext_call.return_data[0]):
                                if brushAddress != address(ext_call.return_data[0]):
                                    if wftmAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[32] > !_6376:
                                            revert with 0, 17
                                        mem[_6380 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_6380 + 100] = ext_call.return_data[32] + _6376
                                        mem[_6380 + 132] = 0
                                        mem[_6380 + 164] = 160
                                        mem[_6380 + 260] = mem[_6380]
                                        idx = 0
                                        s = _6380 + 292
                                        t = _6380 + 32
                                        while idx < mem[_6380]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_6380 + 196] = this.address
                                        mem[_6380 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _6380 + (32 * mem[_6380]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9124 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _9268 = mem[_9124]
                                        require mem[_9124] <= test266151307()
                                        require _9124 + mem[_9124] + 31 < _9124 + return_data.size
                                        _9412 = mem[_9124 + mem[_9124]]
                                        if mem[_9124 + mem[_9124]] > test266151307():
                                            revert with 0, 65
                                        if _9124 + ceil32(return_data.size) + ceil32(32 * mem[_9124 + mem[_9124]]) + 1 > test266151307() or ceil32(32 * mem[_9124 + mem[_9124]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _9124 + ceil32(return_data.size) + ceil32(32 * mem[_9124 + mem[_9124]]) + 1
                                        mem[_9124 + ceil32(return_data.size)] = _9412
                                        require return_data.size >= _9268 + (32 * _9412) + 32
                                        mem[_9124 + ceil32(return_data.size) + 32 len 32 * _9412] = mem[_9124 + _9268 + 32 len 32 * _9412]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                        if 1 >= _9412:
                                            revert with 0, 50
                                        if mem[_9124 + ceil32(return_data.size) + 64] > -1:
                                            revert with 0, 17
                                        require ext_code.size(brushAddress)
                                        call brushAddress.0x42966c68 with:
                                             gas gas_remaining wei
                                            args mem[_9124 + ceil32(return_data.size) + 64]
                                    else:
                                        if ext_call.return_data[0] > !_6376:
                                            revert with 0, 17
                                        mem[_6380 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_6380 + 100] = ext_call.return_data[0] + _6376
                                        mem[_6380 + 132] = 0
                                        mem[_6380 + 164] = 160
                                        mem[_6380 + 260] = mem[_6380]
                                        idx = 0
                                        s = _6380 + 292
                                        t = _6380 + 32
                                        while idx < mem[_6380]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_6380 + 196] = this.address
                                        mem[_6380 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _6380 + (32 * mem[_6380]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9125 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _9269 = mem[_9125]
                                        require mem[_9125] <= test266151307()
                                        require _9125 + mem[_9125] + 31 < _9125 + return_data.size
                                        _9413 = mem[_9125 + mem[_9125]]
                                        if mem[_9125 + mem[_9125]] > test266151307():
                                            revert with 0, 65
                                        if _9125 + ceil32(return_data.size) + ceil32(32 * mem[_9125 + mem[_9125]]) + 1 > test266151307() or ceil32(32 * mem[_9125 + mem[_9125]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _9125 + ceil32(return_data.size) + ceil32(32 * mem[_9125 + mem[_9125]]) + 1
                                        mem[_9125 + ceil32(return_data.size)] = _9413
                                        require return_data.size >= _9269 + (32 * _9413) + 32
                                        mem[_9125 + ceil32(return_data.size) + 32 len 32 * _9413] = mem[_9125 + _9269 + 32 len 32 * _9413]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                        if 1 >= _9413:
                                            revert with 0, 50
                                        if mem[_9125 + ceil32(return_data.size) + 64] > -1:
                                            revert with 0, 17
                                        require ext_code.size(brushAddress)
                                        call brushAddress.0x42966c68 with:
                                             gas gas_remaining wei
                                            args mem[_9125 + ceil32(return_data.size) + 64]
                                else:
                                    if brushAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[32] > !_6376:
                                            revert with 0, 17
                                        mem[_6380 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_6380 + 100] = ext_call.return_data[32] + _6376
                                        mem[_6380 + 132] = 0
                                        mem[_6380 + 164] = 160
                                        mem[_6380 + 260] = mem[_6380]
                                        idx = 0
                                        s = _6380 + 292
                                        t = _6380 + 32
                                        while idx < mem[_6380]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_6380 + 196] = this.address
                                        mem[_6380 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _6380 + (32 * mem[_6380]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9126 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _9270 = mem[_9126]
                                        require mem[_9126] <= test266151307()
                                        require _9126 + mem[_9126] + 31 < _9126 + return_data.size
                                        _9414 = mem[_9126 + mem[_9126]]
                                        if mem[_9126 + mem[_9126]] > test266151307():
                                            revert with 0, 65
                                        if _9126 + ceil32(return_data.size) + ceil32(32 * mem[_9126 + mem[_9126]]) + 1 > test266151307() or ceil32(32 * mem[_9126 + mem[_9126]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _9126 + ceil32(return_data.size) + ceil32(32 * mem[_9126 + mem[_9126]]) + 1
                                        mem[_9126 + ceil32(return_data.size)] = _9414
                                        require return_data.size >= _9270 + (32 * _9414) + 32
                                        mem[_9126 + ceil32(return_data.size) + 32 len 32 * _9414] = mem[_9126 + _9270 + 32 len 32 * _9414]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                        if 1 >= _9414:
                                            revert with 0, 50
                                        if mem[_9126 + ceil32(return_data.size) + 64] > -1:
                                            revert with 0, 17
                                        require ext_code.size(brushAddress)
                                        call brushAddress.0x42966c68 with:
                                             gas gas_remaining wei
                                            args mem[_9126 + ceil32(return_data.size) + 64]
                                    else:
                                        if brushAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[0] > !_6376:
                                                revert with 0, 17
                                            mem[_6380 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_6380 + 100] = ext_call.return_data[0] + _6376
                                            mem[_6380 + 132] = 0
                                            mem[_6380 + 164] = 160
                                            mem[_6380 + 260] = mem[_6380]
                                            idx = 0
                                            s = _6380 + 292
                                            t = _6380 + 32
                                            while idx < mem[_6380]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_6380 + 196] = this.address
                                            mem[_6380 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _6380 + (32 * mem[_6380]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9127 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _9271 = mem[_9127]
                                            require mem[_9127] <= test266151307()
                                            require _9127 + mem[_9127] + 31 < _9127 + return_data.size
                                            _9415 = mem[_9127 + mem[_9127]]
                                            if mem[_9127 + mem[_9127]] > test266151307():
                                                revert with 0, 65
                                            if _9127 + ceil32(return_data.size) + ceil32(32 * mem[_9127 + mem[_9127]]) + 1 > test266151307() or ceil32(32 * mem[_9127 + mem[_9127]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _9127 + ceil32(return_data.size) + ceil32(32 * mem[_9127 + mem[_9127]]) + 1
                                            mem[_9127 + ceil32(return_data.size)] = _9415
                                            require return_data.size >= _9271 + (32 * _9415) + 32
                                            mem[_9127 + ceil32(return_data.size) + 32 len 32 * _9415] = mem[_9127 + _9271 + 32 len 32 * _9415]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                            if 1 >= _9415:
                                                revert with 0, 50
                                            if mem[_9127 + ceil32(return_data.size) + 64] > -1:
                                                revert with 0, 17
                                            require ext_code.size(brushAddress)
                                            call brushAddress.0x42966c68 with:
                                                 gas gas_remaining wei
                                                args mem[_9127 + ceil32(return_data.size) + 64]
                                        else:
                                            if wftmAddress == address(ext_call.return_data[0]):
                                                if ext_call.return_data[32] > !_6376:
                                                    revert with 0, 17
                                                mem[_6380 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[_6380 + 100] = ext_call.return_data[32] + _6376
                                                mem[_6380 + 132] = 0
                                                mem[_6380 + 164] = 160
                                                mem[_6380 + 260] = mem[_6380]
                                                idx = 0
                                                s = _6380 + 292
                                                t = _6380 + 32
                                                while idx < mem[_6380]:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[_6380 + 196] = this.address
                                                mem[_6380 + 228] = block.timestamp + 10000
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len _6380 + (32 * mem[_6380]) + -mem[64] + 288]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _9128 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _9272 = mem[_9128]
                                                require mem[_9128] <= test266151307()
                                                require _9128 + mem[_9128] + 31 < _9128 + return_data.size
                                                _9416 = mem[_9128 + mem[_9128]]
                                                if mem[_9128 + mem[_9128]] > test266151307():
                                                    revert with 0, 65
                                                if _9128 + ceil32(return_data.size) + ceil32(32 * mem[_9128 + mem[_9128]]) + 1 > test266151307() or ceil32(32 * mem[_9128 + mem[_9128]]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[64] = _9128 + ceil32(return_data.size) + ceil32(32 * mem[_9128 + mem[_9128]]) + 1
                                                mem[_9128 + ceil32(return_data.size)] = _9416
                                                require return_data.size >= _9272 + (32 * _9416) + 32
                                                mem[_9128 + ceil32(return_data.size) + 32 len 32 * _9416] = mem[_9128 + _9272 + 32 len 32 * _9416]
                                                if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                    revert with 0, 17
                                                maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                                if 1 >= _9416:
                                                    revert with 0, 50
                                                if mem[_9128 + ceil32(return_data.size) + 64] > -1:
                                                    revert with 0, 17
                                                require ext_code.size(brushAddress)
                                                call brushAddress.0x42966c68 with:
                                                     gas gas_remaining wei
                                                    args mem[_9128 + ceil32(return_data.size) + 64]
                                            else:
                                                if ext_call.return_data[0] > !_6376:
                                                    revert with 0, 17
                                                mem[_6380 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[_6380 + 100] = ext_call.return_data[0] + _6376
                                                mem[_6380 + 132] = 0
                                                mem[_6380 + 164] = 160
                                                mem[_6380 + 260] = mem[_6380]
                                                idx = 0
                                                s = _6380 + 292
                                                t = _6380 + 32
                                                while idx < mem[_6380]:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[_6380 + 196] = this.address
                                                mem[_6380 + 228] = block.timestamp + 10000
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len _6380 + (32 * mem[_6380]) + -mem[64] + 288]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _9129 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _9273 = mem[_9129]
                                                require mem[_9129] <= test266151307()
                                                require _9129 + mem[_9129] + 31 < _9129 + return_data.size
                                                _9417 = mem[_9129 + mem[_9129]]
                                                if mem[_9129 + mem[_9129]] > test266151307():
                                                    revert with 0, 65
                                                if _9129 + ceil32(return_data.size) + ceil32(32 * mem[_9129 + mem[_9129]]) + 1 > test266151307() or ceil32(32 * mem[_9129 + mem[_9129]]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[64] = _9129 + ceil32(return_data.size) + ceil32(32 * mem[_9129 + mem[_9129]]) + 1
                                                mem[_9129 + ceil32(return_data.size)] = _9417
                                                require return_data.size >= _9273 + (32 * _9417) + 32
                                                mem[_9129 + ceil32(return_data.size) + 32 len 32 * _9417] = mem[_9129 + _9273 + 32 len 32 * _9417]
                                                if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                    revert with 0, 17
                                                maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                                if 1 >= _9417:
                                                    revert with 0, 50
                                                if mem[_9129 + ceil32(return_data.size) + 64] > -1:
                                                    revert with 0, 17
                                                require ext_code.size(brushAddress)
                                                call brushAddress.0x42966c68 with:
                                                     gas gas_remaining wei
                                                    args mem[_9129 + ceil32(return_data.size) + 64]
                            else:
                                if wftmAddress == address(ext_call.return_data[0]):
                                    if brushAddress != address(ext_call.return_data[0]):
                                        if wftmAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_6376:
                                                revert with 0, 17
                                            mem[_6380 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_6380 + 100] = ext_call.return_data[32] + _6376
                                            mem[_6380 + 132] = 0
                                            mem[_6380 + 164] = 160
                                            mem[_6380 + 260] = mem[_6380]
                                            idx = 0
                                            s = _6380 + 292
                                            t = _6380 + 32
                                            while idx < mem[_6380]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_6380 + 196] = this.address
                                            mem[_6380 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _6380 + (32 * mem[_6380]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9130 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _9274 = mem[_9130]
                                            require mem[_9130] <= test266151307()
                                            require _9130 + mem[_9130] + 31 < _9130 + return_data.size
                                            _9418 = mem[_9130 + mem[_9130]]
                                            if mem[_9130 + mem[_9130]] > test266151307():
                                                revert with 0, 65
                                            if _9130 + ceil32(return_data.size) + ceil32(32 * mem[_9130 + mem[_9130]]) + 1 > test266151307() or ceil32(32 * mem[_9130 + mem[_9130]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _9130 + ceil32(return_data.size) + ceil32(32 * mem[_9130 + mem[_9130]]) + 1
                                            mem[_9130 + ceil32(return_data.size)] = _9418
                                            require return_data.size >= _9274 + (32 * _9418) + 32
                                            mem[_9130 + ceil32(return_data.size) + 32 len 32 * _9418] = mem[_9130 + _9274 + 32 len 32 * _9418]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                            if 1 >= _9418:
                                                revert with 0, 50
                                            if mem[_9130 + ceil32(return_data.size) + 64] > -1:
                                                revert with 0, 17
                                            require ext_code.size(brushAddress)
                                            call brushAddress.0x42966c68 with:
                                                 gas gas_remaining wei
                                                args mem[_9130 + ceil32(return_data.size) + 64]
                                        else:
                                            if ext_call.return_data[0] > !_6376:
                                                revert with 0, 17
                                            mem[_6380 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_6380 + 100] = ext_call.return_data[0] + _6376
                                            mem[_6380 + 132] = 0
                                            mem[_6380 + 164] = 160
                                            mem[_6380 + 260] = mem[_6380]
                                            idx = 0
                                            s = _6380 + 292
                                            t = _6380 + 32
                                            while idx < mem[_6380]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_6380 + 196] = this.address
                                            mem[_6380 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _6380 + (32 * mem[_6380]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9131 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _9275 = mem[_9131]
                                            require mem[_9131] <= test266151307()
                                            require _9131 + mem[_9131] + 31 < _9131 + return_data.size
                                            _9419 = mem[_9131 + mem[_9131]]
                                            if mem[_9131 + mem[_9131]] > test266151307():
                                                revert with 0, 65
                                            if _9131 + ceil32(return_data.size) + ceil32(32 * mem[_9131 + mem[_9131]]) + 1 > test266151307() or ceil32(32 * mem[_9131 + mem[_9131]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _9131 + ceil32(return_data.size) + ceil32(32 * mem[_9131 + mem[_9131]]) + 1
                                            mem[_9131 + ceil32(return_data.size)] = _9419
                                            require return_data.size >= _9275 + (32 * _9419) + 32
                                            mem[_9131 + ceil32(return_data.size) + 32 len 32 * _9419] = mem[_9131 + _9275 + 32 len 32 * _9419]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                            if 1 >= _9419:
                                                revert with 0, 50
                                            if mem[_9131 + ceil32(return_data.size) + 64] > -1:
                                                revert with 0, 17
                                            require ext_code.size(brushAddress)
                                            call brushAddress.0x42966c68 with:
                                                 gas gas_remaining wei
                                                args mem[_9131 + ceil32(return_data.size) + 64]
                                    else:
                                        if brushAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_6376:
                                                revert with 0, 17
                                            mem[_6380 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_6380 + 100] = ext_call.return_data[32] + _6376
                                            mem[_6380 + 132] = 0
                                            mem[_6380 + 164] = 160
                                            mem[_6380 + 260] = mem[_6380]
                                            idx = 0
                                            s = _6380 + 292
                                            t = _6380 + 32
                                            while idx < mem[_6380]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_6380 + 196] = this.address
                                            mem[_6380 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _6380 + (32 * mem[_6380]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9132 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _9276 = mem[_9132]
                                            require mem[_9132] <= test266151307()
                                            require _9132 + mem[_9132] + 31 < _9132 + return_data.size
                                            _9420 = mem[_9132 + mem[_9132]]
                                            if mem[_9132 + mem[_9132]] > test266151307():
                                                revert with 0, 65
                                            if _9132 + ceil32(return_data.size) + ceil32(32 * mem[_9132 + mem[_9132]]) + 1 > test266151307() or ceil32(32 * mem[_9132 + mem[_9132]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _9132 + ceil32(return_data.size) + ceil32(32 * mem[_9132 + mem[_9132]]) + 1
                                            mem[_9132 + ceil32(return_data.size)] = _9420
                                            require return_data.size >= _9276 + (32 * _9420) + 32
                                            mem[_9132 + ceil32(return_data.size) + 32 len 32 * _9420] = mem[_9132 + _9276 + 32 len 32 * _9420]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                            if 1 >= _9420:
                                                revert with 0, 50
                                            if mem[_9132 + ceil32(return_data.size) + 64] > -1:
                                                revert with 0, 17
                                            require ext_code.size(brushAddress)
                                            call brushAddress.0x42966c68 with:
                                                 gas gas_remaining wei
                                                args mem[_9132 + ceil32(return_data.size) + 64]
                                        else:
                                            if brushAddress == address(ext_call.return_data[0]):
                                                if ext_call.return_data[0] > !_6376:
                                                    revert with 0, 17
                                                mem[_6380 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[_6380 + 100] = ext_call.return_data[0] + _6376
                                                mem[_6380 + 132] = 0
                                                mem[_6380 + 164] = 160
                                                mem[_6380 + 260] = mem[_6380]
                                                idx = 0
                                                s = _6380 + 292
                                                t = _6380 + 32
                                                while idx < mem[_6380]:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[_6380 + 196] = this.address
                                                mem[_6380 + 228] = block.timestamp + 10000
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len _6380 + (32 * mem[_6380]) + -mem[64] + 288]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _9133 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _9277 = mem[_9133]
                                                require mem[_9133] <= test266151307()
                                                require _9133 + mem[_9133] + 31 < _9133 + return_data.size
                                                _9421 = mem[_9133 + mem[_9133]]
                                                if mem[_9133 + mem[_9133]] > test266151307():
                                                    revert with 0, 65
                                                if _9133 + ceil32(return_data.size) + ceil32(32 * mem[_9133 + mem[_9133]]) + 1 > test266151307() or ceil32(32 * mem[_9133 + mem[_9133]]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[64] = _9133 + ceil32(return_data.size) + ceil32(32 * mem[_9133 + mem[_9133]]) + 1
                                                mem[_9133 + ceil32(return_data.size)] = _9421
                                                require return_data.size >= _9277 + (32 * _9421) + 32
                                                mem[_9133 + ceil32(return_data.size) + 32 len 32 * _9421] = mem[_9133 + _9277 + 32 len 32 * _9421]
                                                if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                    revert with 0, 17
                                                maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                                if 1 >= _9421:
                                                    revert with 0, 50
                                                if mem[_9133 + ceil32(return_data.size) + 64] > -1:
                                                    revert with 0, 17
                                                require ext_code.size(brushAddress)
                                                call brushAddress.0x42966c68 with:
                                                     gas gas_remaining wei
                                                    args mem[_9133 + ceil32(return_data.size) + 64]
                                            else:
                                                if wftmAddress == address(ext_call.return_data[0]):
                                                    if ext_call.return_data[32] > !_6376:
                                                        revert with 0, 17
                                                    mem[_6380 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[_6380 + 100] = ext_call.return_data[32] + _6376
                                                    mem[_6380 + 132] = 0
                                                    mem[_6380 + 164] = 160
                                                    mem[_6380 + 260] = mem[_6380]
                                                    idx = 0
                                                    s = _6380 + 292
                                                    t = _6380 + 32
                                                    while idx < mem[_6380]:
                                                        mem[s] = mem[t + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[_6380 + 196] = this.address
                                                    mem[_6380 + 228] = block.timestamp + 10000
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len _6380 + (32 * mem[_6380]) + -mem[64] + 288]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _9134 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _9278 = mem[_9134]
                                                    require mem[_9134] <= test266151307()
                                                    require _9134 + mem[_9134] + 31 < _9134 + return_data.size
                                                    _9422 = mem[_9134 + mem[_9134]]
                                                    if mem[_9134 + mem[_9134]] > test266151307():
                                                        revert with 0, 65
                                                    if _9134 + ceil32(return_data.size) + ceil32(32 * mem[_9134 + mem[_9134]]) + 1 > test266151307() or ceil32(32 * mem[_9134 + mem[_9134]]) + 1 < 0:
                                                        revert with 0, 65
                                                    mem[64] = _9134 + ceil32(return_data.size) + ceil32(32 * mem[_9134 + mem[_9134]]) + 1
                                                    mem[_9134 + ceil32(return_data.size)] = _9422
                                                    require return_data.size >= _9278 + (32 * _9422) + 32
                                                    mem[_9134 + ceil32(return_data.size) + 32 len 32 * _9422] = mem[_9134 + _9278 + 32 len 32 * _9422]
                                                    if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                        revert with 0, 17
                                                    maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                                    if 1 >= _9422:
                                                        revert with 0, 50
                                                    if mem[_9134 + ceil32(return_data.size) + 64] > -1:
                                                        revert with 0, 17
                                                    require ext_code.size(brushAddress)
                                                    call brushAddress.0x42966c68 with:
                                                         gas gas_remaining wei
                                                        args mem[_9134 + ceil32(return_data.size) + 64]
                                                else:
                                                    if ext_call.return_data[0] > !_6376:
                                                        revert with 0, 17
                                                    mem[_6380 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[_6380 + 100] = ext_call.return_data[0] + _6376
                                                    mem[_6380 + 132] = 0
                                                    mem[_6380 + 164] = 160
                                                    mem[_6380 + 260] = mem[_6380]
                                                    idx = 0
                                                    s = _6380 + 292
                                                    t = _6380 + 32
                                                    while idx < mem[_6380]:
                                                        mem[s] = mem[t + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[_6380 + 196] = this.address
                                                    mem[_6380 + 228] = block.timestamp + 10000
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len _6380 + (32 * mem[_6380]) + -mem[64] + 288]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _9135 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _9279 = mem[_9135]
                                                    require mem[_9135] <= test266151307()
                                                    require _9135 + mem[_9135] + 31 < _9135 + return_data.size
                                                    _9423 = mem[_9135 + mem[_9135]]
                                                    if mem[_9135 + mem[_9135]] > test266151307():
                                                        revert with 0, 65
                                                    if _9135 + ceil32(return_data.size) + ceil32(32 * mem[_9135 + mem[_9135]]) + 1 > test266151307() or ceil32(32 * mem[_9135 + mem[_9135]]) + 1 < 0:
                                                        revert with 0, 65
                                                    mem[64] = _9135 + ceil32(return_data.size) + ceil32(32 * mem[_9135 + mem[_9135]]) + 1
                                                    mem[_9135 + ceil32(return_data.size)] = _9423
                                                    require return_data.size >= _9279 + (32 * _9423) + 32
                                                    mem[_9135 + ceil32(return_data.size) + 32 len 32 * _9423] = mem[_9135 + _9279 + 32 len 32 * _9423]
                                                    if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                        revert with 0, 17
                                                    maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                                    if 1 >= _9423:
                                                        revert with 0, 50
                                                    if mem[_9135 + ceil32(return_data.size) + 64] > -1:
                                                        revert with 0, 17
                                                    require ext_code.size(brushAddress)
                                                    call brushAddress.0x42966c68 with:
                                                         gas gas_remaining wei
                                                        args mem[_9135 + ceil32(return_data.size) + 64]
                                else:
                                    if brushAddress != address(ext_call.return_data[0]):
                                        if wftmAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_6376:
                                                revert with 0, 17
                                            mem[_6380 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_6380 + 100] = ext_call.return_data[32] + _6376
                                            mem[_6380 + 132] = 0
                                            mem[_6380 + 164] = 160
                                            mem[_6380 + 260] = mem[_6380]
                                            idx = 0
                                            s = _6380 + 292
                                            t = _6380 + 32
                                            while idx < mem[_6380]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_6380 + 196] = this.address
                                            mem[_6380 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _6380 + (32 * mem[_6380]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9136 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _9280 = mem[_9136]
                                            require mem[_9136] <= test266151307()
                                            require _9136 + mem[_9136] + 31 < _9136 + return_data.size
                                            _9424 = mem[_9136 + mem[_9136]]
                                            if mem[_9136 + mem[_9136]] > test266151307():
                                                revert with 0, 65
                                            if _9136 + ceil32(return_data.size) + ceil32(32 * mem[_9136 + mem[_9136]]) + 1 > test266151307() or ceil32(32 * mem[_9136 + mem[_9136]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _9136 + ceil32(return_data.size) + ceil32(32 * mem[_9136 + mem[_9136]]) + 1
                                            mem[_9136 + ceil32(return_data.size)] = _9424
                                            require return_data.size >= _9280 + (32 * _9424) + 32
                                            mem[_9136 + ceil32(return_data.size) + 32 len 32 * _9424] = mem[_9136 + _9280 + 32 len 32 * _9424]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                            if 1 >= _9424:
                                                revert with 0, 50
                                            if mem[_9136 + ceil32(return_data.size) + 64] > -1:
                                                revert with 0, 17
                                            require ext_code.size(brushAddress)
                                            call brushAddress.0x42966c68 with:
                                                 gas gas_remaining wei
                                                args mem[_9136 + ceil32(return_data.size) + 64]
                                        else:
                                            if ext_call.return_data[0] > !_6376:
                                                revert with 0, 17
                                            mem[_6380 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_6380 + 100] = ext_call.return_data[0] + _6376
                                            mem[_6380 + 132] = 0
                                            mem[_6380 + 164] = 160
                                            mem[_6380 + 260] = mem[_6380]
                                            idx = 0
                                            s = _6380 + 292
                                            t = _6380 + 32
                                            while idx < mem[_6380]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_6380 + 196] = this.address
                                            mem[_6380 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _6380 + (32 * mem[_6380]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9137 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _9281 = mem[_9137]
                                            require mem[_9137] <= test266151307()
                                            require _9137 + mem[_9137] + 31 < _9137 + return_data.size
                                            _9425 = mem[_9137 + mem[_9137]]
                                            if mem[_9137 + mem[_9137]] > test266151307():
                                                revert with 0, 65
                                            if _9137 + ceil32(return_data.size) + ceil32(32 * mem[_9137 + mem[_9137]]) + 1 > test266151307() or ceil32(32 * mem[_9137 + mem[_9137]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _9137 + ceil32(return_data.size) + ceil32(32 * mem[_9137 + mem[_9137]]) + 1
                                            mem[_9137 + ceil32(return_data.size)] = _9425
                                            require return_data.size >= _9281 + (32 * _9425) + 32
                                            mem[_9137 + ceil32(return_data.size) + 32 len 32 * _9425] = mem[_9137 + _9281 + 32 len 32 * _9425]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                            if 1 >= _9425:
                                                revert with 0, 50
                                            if mem[_9137 + ceil32(return_data.size) + 64] > -1:
                                                revert with 0, 17
                                            require ext_code.size(brushAddress)
                                            call brushAddress.0x42966c68 with:
                                                 gas gas_remaining wei
                                                args mem[_9137 + ceil32(return_data.size) + 64]
                                    else:
                                        if brushAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_6376:
                                                revert with 0, 17
                                            mem[_6380 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_6380 + 100] = ext_call.return_data[32] + _6376
                                            mem[_6380 + 132] = 0
                                            mem[_6380 + 164] = 160
                                            mem[_6380 + 260] = mem[_6380]
                                            idx = 0
                                            s = _6380 + 292
                                            t = _6380 + 32
                                            while idx < mem[_6380]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_6380 + 196] = this.address
                                            mem[_6380 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _6380 + (32 * mem[_6380]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9138 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _9282 = mem[_9138]
                                            require mem[_9138] <= test266151307()
                                            require _9138 + mem[_9138] + 31 < _9138 + return_data.size
                                            _9426 = mem[_9138 + mem[_9138]]
                                            if mem[_9138 + mem[_9138]] > test266151307():
                                                revert with 0, 65
                                            if _9138 + ceil32(return_data.size) + ceil32(32 * mem[_9138 + mem[_9138]]) + 1 > test266151307() or ceil32(32 * mem[_9138 + mem[_9138]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _9138 + ceil32(return_data.size) + ceil32(32 * mem[_9138 + mem[_9138]]) + 1
                                            mem[_9138 + ceil32(return_data.size)] = _9426
                                            require return_data.size >= _9282 + (32 * _9426) + 32
                                            mem[_9138 + ceil32(return_data.size) + 32 len 32 * _9426] = mem[_9138 + _9282 + 32 len 32 * _9426]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                            if 1 >= _9426:
                                                revert with 0, 50
                                            if mem[_9138 + ceil32(return_data.size) + 64] > -1:
                                                revert with 0, 17
                                            require ext_code.size(brushAddress)
                                            call brushAddress.0x42966c68 with:
                                                 gas gas_remaining wei
                                                args mem[_9138 + ceil32(return_data.size) + 64]
                                        else:
                                            if brushAddress == address(ext_call.return_data[0]):
                                                if ext_call.return_data[0] > !_6376:
                                                    revert with 0, 17
                                                mem[_6380 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[_6380 + 100] = ext_call.return_data[0] + _6376
                                                mem[_6380 + 132] = 0
                                                mem[_6380 + 164] = 160
                                                mem[_6380 + 260] = mem[_6380]
                                                idx = 0
                                                s = _6380 + 292
                                                t = _6380 + 32
                                                while idx < mem[_6380]:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[_6380 + 196] = this.address
                                                mem[_6380 + 228] = block.timestamp + 10000
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len _6380 + (32 * mem[_6380]) + -mem[64] + 288]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _9139 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _9283 = mem[_9139]
                                                require mem[_9139] <= test266151307()
                                                require _9139 + mem[_9139] + 31 < _9139 + return_data.size
                                                _9427 = mem[_9139 + mem[_9139]]
                                                if mem[_9139 + mem[_9139]] > test266151307():
                                                    revert with 0, 65
                                                if _9139 + ceil32(return_data.size) + ceil32(32 * mem[_9139 + mem[_9139]]) + 1 > test266151307() or ceil32(32 * mem[_9139 + mem[_9139]]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[64] = _9139 + ceil32(return_data.size) + ceil32(32 * mem[_9139 + mem[_9139]]) + 1
                                                mem[_9139 + ceil32(return_data.size)] = _9427
                                                require return_data.size >= _9283 + (32 * _9427) + 32
                                                mem[_9139 + ceil32(return_data.size) + 32 len 32 * _9427] = mem[_9139 + _9283 + 32 len 32 * _9427]
                                                if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                    revert with 0, 17
                                                maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                                if 1 >= _9427:
                                                    revert with 0, 50
                                                if mem[_9139 + ceil32(return_data.size) + 64] > -1:
                                                    revert with 0, 17
                                                require ext_code.size(brushAddress)
                                                call brushAddress.0x42966c68 with:
                                                     gas gas_remaining wei
                                                    args mem[_9139 + ceil32(return_data.size) + 64]
                                            else:
                                                if wftmAddress == address(ext_call.return_data[0]):
                                                    if ext_call.return_data[32] > !_6376:
                                                        revert with 0, 17
                                                    mem[_6380 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[_6380 + 100] = ext_call.return_data[32] + _6376
                                                    mem[_6380 + 132] = 0
                                                    mem[_6380 + 164] = 160
                                                    mem[_6380 + 260] = mem[_6380]
                                                    idx = 0
                                                    s = _6380 + 292
                                                    t = _6380 + 32
                                                    while idx < mem[_6380]:
                                                        mem[s] = mem[t + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[_6380 + 196] = this.address
                                                    mem[_6380 + 228] = block.timestamp + 10000
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len _6380 + (32 * mem[_6380]) + -mem[64] + 288]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _9140 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _9284 = mem[_9140]
                                                    require mem[_9140] <= test266151307()
                                                    require _9140 + mem[_9140] + 31 < _9140 + return_data.size
                                                    _9428 = mem[_9140 + mem[_9140]]
                                                    if mem[_9140 + mem[_9140]] > test266151307():
                                                        revert with 0, 65
                                                    if _9140 + ceil32(return_data.size) + ceil32(32 * mem[_9140 + mem[_9140]]) + 1 > test266151307() or ceil32(32 * mem[_9140 + mem[_9140]]) + 1 < 0:
                                                        revert with 0, 65
                                                    mem[64] = _9140 + ceil32(return_data.size) + ceil32(32 * mem[_9140 + mem[_9140]]) + 1
                                                    mem[_9140 + ceil32(return_data.size)] = _9428
                                                    require return_data.size >= _9284 + (32 * _9428) + 32
                                                    mem[_9140 + ceil32(return_data.size) + 32 len 32 * _9428] = mem[_9140 + _9284 + 32 len 32 * _9428]
                                                    if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                        revert with 0, 17
                                                    maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                                    if 1 >= _9428:
                                                        revert with 0, 50
                                                    if mem[_9140 + ceil32(return_data.size) + 64] > -1:
                                                        revert with 0, 17
                                                    require ext_code.size(brushAddress)
                                                    call brushAddress.0x42966c68 with:
                                                         gas gas_remaining wei
                                                        args mem[_9140 + ceil32(return_data.size) + 64]
                                                else:
                                                    if ext_call.return_data[0] > !_6376:
                                                        revert with 0, 17
                                                    mem[_6380 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[_6380 + 100] = ext_call.return_data[0] + _6376
                                                    mem[_6380 + 132] = 0
                                                    mem[_6380 + 164] = 160
                                                    mem[_6380 + 260] = mem[_6380]
                                                    idx = 0
                                                    s = _6380 + 292
                                                    t = _6380 + 32
                                                    while idx < mem[_6380]:
                                                        mem[s] = mem[t + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[_6380 + 196] = this.address
                                                    mem[_6380 + 228] = block.timestamp + 10000
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len _6380 + (32 * mem[_6380]) + -mem[64] + 288]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _9141 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _9285 = mem[_9141]
                                                    require mem[_9141] <= test266151307()
                                                    require _9141 + mem[_9141] + 31 < _9141 + return_data.size
                                                    _9429 = mem[_9141 + mem[_9141]]
                                                    if mem[_9141 + mem[_9141]] > test266151307():
                                                        revert with 0, 65
                                                    if _9141 + ceil32(return_data.size) + ceil32(32 * mem[_9141 + mem[_9141]]) + 1 > test266151307() or ceil32(32 * mem[_9141 + mem[_9141]]) + 1 < 0:
                                                        revert with 0, 65
                                                    mem[64] = _9141 + ceil32(return_data.size) + ceil32(32 * mem[_9141 + mem[_9141]]) + 1
                                                    mem[_9141 + ceil32(return_data.size)] = _9429
                                                    require return_data.size >= _9285 + (32 * _9429) + 32
                                                    mem[_9141 + ceil32(return_data.size) + 32 len 32 * _9429] = mem[_9141 + _9285 + 32 len 32 * _9429]
                                                    if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                        revert with 0, 17
                                                    maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                                    if 1 >= _9429:
                                                        revert with 0, 50
                                                    if mem[_9141 + ceil32(return_data.size) + 64] > -1:
                                                        revert with 0, 17
                                                    require ext_code.size(brushAddress)
                                                    call brushAddress.0x42966c68 with:
                                                         gas gas_remaining wei
                                                        args mem[_9141 + ceil32(return_data.size) + 64]
                else:
                    mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                    mem[(4 * ceil32(return_data.size)) + 228] = 0
                    mem[(4 * ceil32(return_data.size)) + 260] = 160
                    mem[(4 * ceil32(return_data.size)) + 356] = 2
                    idx = 0
                    s = (4 * ceil32(return_data.size)) + 388
                    t = (4 * ceil32(return_data.size)) + 128
                    while idx < 2:
                        mem[s] = mem[t + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[(4 * ceil32(return_data.size)) + 292] = this.address
                    mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                    require ext_code.size(routerAddress)
                    call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                         gas gas_remaining wei
                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = (6 * ceil32(return_data.size)) + 192
                    require return_data.size >= 32
                    _3527 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                    require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                    require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                    _3606 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                    if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                        revert with 0, 65
                    if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                        revert with 0, 65
                    mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193
                    mem[(6 * ceil32(return_data.size)) + 192] = _3606
                    require return_data.size >= _3527 + (32 * _3606) + 32
                    mem[(6 * ceil32(return_data.size)) + 224 len 32 * _3606] = mem[(4 * ceil32(return_data.size)) + _3527 + 224 len 32 * _3606]
                    if 1 >= _3606:
                        revert with 0, 50
                    _6377 = mem[(6 * ceil32(return_data.size)) + 256]
                    _6381 = mem[64]
                    mem[mem[64]] = 2
                    mem[64] = mem[64] + 96
                    if 0 >= mem[_6381]:
                        revert with 0, 50
                    mem[_6381 + 32] = address(ext_call.return_data[0])
                    if 1 >= mem[_6381]:
                        revert with 0, 50
                    mem[_6381 + 64] = brushAddress
                    if brushAddress != address(ext_call.return_data[0]):
                        if wftmAddress == address(ext_call.return_data[0]):
                            if brushAddress != address(ext_call.return_data[0]):
                                if wftmAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_6377:
                                        revert with 0, 17
                                    mem[_6381 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_6381 + 100] = ext_call.return_data[32] + _6377
                                    mem[_6381 + 132] = 0
                                    mem[_6381 + 164] = 160
                                    mem[_6381 + 260] = mem[_6381]
                                    idx = 0
                                    s = _6381 + 292
                                    t = _6381 + 32
                                    while idx < mem[_6381]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_6381 + 196] = this.address
                                    mem[_6381 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _6381 + (32 * mem[_6381]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9142 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _9286 = mem[_9142]
                                    require mem[_9142] <= test266151307()
                                    require _9142 + mem[_9142] + 31 < _9142 + return_data.size
                                    _9430 = mem[_9142 + mem[_9142]]
                                    if mem[_9142 + mem[_9142]] > test266151307():
                                        revert with 0, 65
                                    if _9142 + ceil32(return_data.size) + ceil32(32 * mem[_9142 + mem[_9142]]) + 1 > test266151307() or ceil32(32 * mem[_9142 + mem[_9142]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _9142 + ceil32(return_data.size) + ceil32(32 * mem[_9142 + mem[_9142]]) + 1
                                    mem[_9142 + ceil32(return_data.size)] = _9430
                                    require return_data.size >= _9286 + (32 * _9430) + 32
                                    mem[_9142 + ceil32(return_data.size) + 32 len 32 * _9430] = mem[_9142 + _9286 + 32 len 32 * _9430]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                    if 1 >= _9430:
                                        revert with 0, 50
                                    if mem[_9142 + ceil32(return_data.size) + 64] > -1:
                                        revert with 0, 17
                                    require ext_code.size(brushAddress)
                                    call brushAddress.0x42966c68 with:
                                         gas gas_remaining wei
                                        args mem[_9142 + ceil32(return_data.size) + 64]
                                else:
                                    if ext_call.return_data[0] > !_6377:
                                        revert with 0, 17
                                    mem[_6381 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_6381 + 100] = ext_call.return_data[0] + _6377
                                    mem[_6381 + 132] = 0
                                    mem[_6381 + 164] = 160
                                    mem[_6381 + 260] = mem[_6381]
                                    idx = 0
                                    s = _6381 + 292
                                    t = _6381 + 32
                                    while idx < mem[_6381]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_6381 + 196] = this.address
                                    mem[_6381 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _6381 + (32 * mem[_6381]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9143 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _9287 = mem[_9143]
                                    require mem[_9143] <= test266151307()
                                    require _9143 + mem[_9143] + 31 < _9143 + return_data.size
                                    _9431 = mem[_9143 + mem[_9143]]
                                    if mem[_9143 + mem[_9143]] > test266151307():
                                        revert with 0, 65
                                    if _9143 + ceil32(return_data.size) + ceil32(32 * mem[_9143 + mem[_9143]]) + 1 > test266151307() or ceil32(32 * mem[_9143 + mem[_9143]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _9143 + ceil32(return_data.size) + ceil32(32 * mem[_9143 + mem[_9143]]) + 1
                                    mem[_9143 + ceil32(return_data.size)] = _9431
                                    require return_data.size >= _9287 + (32 * _9431) + 32
                                    mem[_9143 + ceil32(return_data.size) + 32 len 32 * _9431] = mem[_9143 + _9287 + 32 len 32 * _9431]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                    if 1 >= _9431:
                                        revert with 0, 50
                                    if mem[_9143 + ceil32(return_data.size) + 64] > -1:
                                        revert with 0, 17
                                    require ext_code.size(brushAddress)
                                    call brushAddress.0x42966c68 with:
                                         gas gas_remaining wei
                                        args mem[_9143 + ceil32(return_data.size) + 64]
                            else:
                                if brushAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_6377:
                                        revert with 0, 17
                                    mem[_6381 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_6381 + 100] = ext_call.return_data[32] + _6377
                                    mem[_6381 + 132] = 0
                                    mem[_6381 + 164] = 160
                                    mem[_6381 + 260] = mem[_6381]
                                    idx = 0
                                    s = _6381 + 292
                                    t = _6381 + 32
                                    while idx < mem[_6381]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_6381 + 196] = this.address
                                    mem[_6381 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _6381 + (32 * mem[_6381]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9144 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _9288 = mem[_9144]
                                    require mem[_9144] <= test266151307()
                                    require _9144 + mem[_9144] + 31 < _9144 + return_data.size
                                    _9432 = mem[_9144 + mem[_9144]]
                                    if mem[_9144 + mem[_9144]] > test266151307():
                                        revert with 0, 65
                                    if _9144 + ceil32(return_data.size) + ceil32(32 * mem[_9144 + mem[_9144]]) + 1 > test266151307() or ceil32(32 * mem[_9144 + mem[_9144]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _9144 + ceil32(return_data.size) + ceil32(32 * mem[_9144 + mem[_9144]]) + 1
                                    mem[_9144 + ceil32(return_data.size)] = _9432
                                    require return_data.size >= _9288 + (32 * _9432) + 32
                                    mem[_9144 + ceil32(return_data.size) + 32 len 32 * _9432] = mem[_9144 + _9288 + 32 len 32 * _9432]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                    if 1 >= _9432:
                                        revert with 0, 50
                                    if mem[_9144 + ceil32(return_data.size) + 64] > -1:
                                        revert with 0, 17
                                    require ext_code.size(brushAddress)
                                    call brushAddress.0x42966c68 with:
                                         gas gas_remaining wei
                                        args mem[_9144 + ceil32(return_data.size) + 64]
                                else:
                                    if brushAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[0] > !_6377:
                                            revert with 0, 17
                                        mem[_6381 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_6381 + 100] = ext_call.return_data[0] + _6377
                                        mem[_6381 + 132] = 0
                                        mem[_6381 + 164] = 160
                                        mem[_6381 + 260] = mem[_6381]
                                        idx = 0
                                        s = _6381 + 292
                                        t = _6381 + 32
                                        while idx < mem[_6381]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_6381 + 196] = this.address
                                        mem[_6381 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _6381 + (32 * mem[_6381]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9145 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _9289 = mem[_9145]
                                        require mem[_9145] <= test266151307()
                                        require _9145 + mem[_9145] + 31 < _9145 + return_data.size
                                        _9433 = mem[_9145 + mem[_9145]]
                                        if mem[_9145 + mem[_9145]] > test266151307():
                                            revert with 0, 65
                                        if _9145 + ceil32(return_data.size) + ceil32(32 * mem[_9145 + mem[_9145]]) + 1 > test266151307() or ceil32(32 * mem[_9145 + mem[_9145]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _9145 + ceil32(return_data.size) + ceil32(32 * mem[_9145 + mem[_9145]]) + 1
                                        mem[_9145 + ceil32(return_data.size)] = _9433
                                        require return_data.size >= _9289 + (32 * _9433) + 32
                                        mem[_9145 + ceil32(return_data.size) + 32 len 32 * _9433] = mem[_9145 + _9289 + 32 len 32 * _9433]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                        if 1 >= _9433:
                                            revert with 0, 50
                                        if mem[_9145 + ceil32(return_data.size) + 64] > -1:
                                            revert with 0, 17
                                        require ext_code.size(brushAddress)
                                        call brushAddress.0x42966c68 with:
                                             gas gas_remaining wei
                                            args mem[_9145 + ceil32(return_data.size) + 64]
                                    else:
                                        if wftmAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_6377:
                                                revert with 0, 17
                                            mem[_6381 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_6381 + 100] = ext_call.return_data[32] + _6377
                                            mem[_6381 + 132] = 0
                                            mem[_6381 + 164] = 160
                                            mem[_6381 + 260] = mem[_6381]
                                            idx = 0
                                            s = _6381 + 292
                                            t = _6381 + 32
                                            while idx < mem[_6381]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_6381 + 196] = this.address
                                            mem[_6381 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _6381 + (32 * mem[_6381]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9146 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _9290 = mem[_9146]
                                            require mem[_9146] <= test266151307()
                                            require _9146 + mem[_9146] + 31 < _9146 + return_data.size
                                            _9434 = mem[_9146 + mem[_9146]]
                                            if mem[_9146 + mem[_9146]] > test266151307():
                                                revert with 0, 65
                                            if _9146 + ceil32(return_data.size) + ceil32(32 * mem[_9146 + mem[_9146]]) + 1 > test266151307() or ceil32(32 * mem[_9146 + mem[_9146]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _9146 + ceil32(return_data.size) + ceil32(32 * mem[_9146 + mem[_9146]]) + 1
                                            mem[_9146 + ceil32(return_data.size)] = _9434
                                            require return_data.size >= _9290 + (32 * _9434) + 32
                                            mem[_9146 + ceil32(return_data.size) + 32 len 32 * _9434] = mem[_9146 + _9290 + 32 len 32 * _9434]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                            if 1 >= _9434:
                                                revert with 0, 50
                                            if mem[_9146 + ceil32(return_data.size) + 64] > -1:
                                                revert with 0, 17
                                            require ext_code.size(brushAddress)
                                            call brushAddress.0x42966c68 with:
                                                 gas gas_remaining wei
                                                args mem[_9146 + ceil32(return_data.size) + 64]
                                        else:
                                            if ext_call.return_data[0] > !_6377:
                                                revert with 0, 17
                                            mem[_6381 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_6381 + 100] = ext_call.return_data[0] + _6377
                                            mem[_6381 + 132] = 0
                                            mem[_6381 + 164] = 160
                                            mem[_6381 + 260] = mem[_6381]
                                            idx = 0
                                            s = _6381 + 292
                                            t = _6381 + 32
                                            while idx < mem[_6381]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_6381 + 196] = this.address
                                            mem[_6381 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _6381 + (32 * mem[_6381]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9147 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _9291 = mem[_9147]
                                            require mem[_9147] <= test266151307()
                                            require _9147 + mem[_9147] + 31 < _9147 + return_data.size
                                            _9435 = mem[_9147 + mem[_9147]]
                                            if mem[_9147 + mem[_9147]] > test266151307():
                                                revert with 0, 65
                                            if _9147 + ceil32(return_data.size) + ceil32(32 * mem[_9147 + mem[_9147]]) + 1 > test266151307() or ceil32(32 * mem[_9147 + mem[_9147]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _9147 + ceil32(return_data.size) + ceil32(32 * mem[_9147 + mem[_9147]]) + 1
                                            mem[_9147 + ceil32(return_data.size)] = _9435
                                            require return_data.size >= _9291 + (32 * _9435) + 32
                                            mem[_9147 + ceil32(return_data.size) + 32 len 32 * _9435] = mem[_9147 + _9291 + 32 len 32 * _9435]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                            if 1 >= _9435:
                                                revert with 0, 50
                                            if mem[_9147 + ceil32(return_data.size) + 64] > -1:
                                                revert with 0, 17
                                            require ext_code.size(brushAddress)
                                            call brushAddress.0x42966c68 with:
                                                 gas gas_remaining wei
                                                args mem[_9147 + ceil32(return_data.size) + 64]
                        else:
                            if brushAddress != address(ext_call.return_data[0]):
                                if wftmAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_6377:
                                        revert with 0, 17
                                    mem[_6381 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_6381 + 100] = ext_call.return_data[32] + _6377
                                    mem[_6381 + 132] = 0
                                    mem[_6381 + 164] = 160
                                    mem[_6381 + 260] = mem[_6381]
                                    idx = 0
                                    s = _6381 + 292
                                    t = _6381 + 32
                                    while idx < mem[_6381]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_6381 + 196] = this.address
                                    mem[_6381 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _6381 + (32 * mem[_6381]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9148 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _9292 = mem[_9148]
                                    require mem[_9148] <= test266151307()
                                    require _9148 + mem[_9148] + 31 < _9148 + return_data.size
                                    _9436 = mem[_9148 + mem[_9148]]
                                    if mem[_9148 + mem[_9148]] > test266151307():
                                        revert with 0, 65
                                    if _9148 + ceil32(return_data.size) + ceil32(32 * mem[_9148 + mem[_9148]]) + 1 > test266151307() or ceil32(32 * mem[_9148 + mem[_9148]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _9148 + ceil32(return_data.size) + ceil32(32 * mem[_9148 + mem[_9148]]) + 1
                                    mem[_9148 + ceil32(return_data.size)] = _9436
                                    require return_data.size >= _9292 + (32 * _9436) + 32
                                    mem[_9148 + ceil32(return_data.size) + 32 len 32 * _9436] = mem[_9148 + _9292 + 32 len 32 * _9436]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                    if 1 >= _9436:
                                        revert with 0, 50
                                    if mem[_9148 + ceil32(return_data.size) + 64] > -1:
                                        revert with 0, 17
                                    require ext_code.size(brushAddress)
                                    call brushAddress.0x42966c68 with:
                                         gas gas_remaining wei
                                        args mem[_9148 + ceil32(return_data.size) + 64]
                                else:
                                    if ext_call.return_data[0] > !_6377:
                                        revert with 0, 17
                                    mem[_6381 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_6381 + 100] = ext_call.return_data[0] + _6377
                                    mem[_6381 + 132] = 0
                                    mem[_6381 + 164] = 160
                                    mem[_6381 + 260] = mem[_6381]
                                    idx = 0
                                    s = _6381 + 292
                                    t = _6381 + 32
                                    while idx < mem[_6381]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_6381 + 196] = this.address
                                    mem[_6381 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _6381 + (32 * mem[_6381]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9149 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _9293 = mem[_9149]
                                    require mem[_9149] <= test266151307()
                                    require _9149 + mem[_9149] + 31 < _9149 + return_data.size
                                    _9437 = mem[_9149 + mem[_9149]]
                                    if mem[_9149 + mem[_9149]] > test266151307():
                                        revert with 0, 65
                                    if _9149 + ceil32(return_data.size) + ceil32(32 * mem[_9149 + mem[_9149]]) + 1 > test266151307() or ceil32(32 * mem[_9149 + mem[_9149]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _9149 + ceil32(return_data.size) + ceil32(32 * mem[_9149 + mem[_9149]]) + 1
                                    mem[_9149 + ceil32(return_data.size)] = _9437
                                    require return_data.size >= _9293 + (32 * _9437) + 32
                                    mem[_9149 + ceil32(return_data.size) + 32 len 32 * _9437] = mem[_9149 + _9293 + 32 len 32 * _9437]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                    if 1 >= _9437:
                                        revert with 0, 50
                                    if mem[_9149 + ceil32(return_data.size) + 64] > -1:
                                        revert with 0, 17
                                    require ext_code.size(brushAddress)
                                    call brushAddress.0x42966c68 with:
                                         gas gas_remaining wei
                                        args mem[_9149 + ceil32(return_data.size) + 64]
                            else:
                                if brushAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_6377:
                                        revert with 0, 17
                                    mem[_6381 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_6381 + 100] = ext_call.return_data[32] + _6377
                                    mem[_6381 + 132] = 0
                                    mem[_6381 + 164] = 160
                                    mem[_6381 + 260] = mem[_6381]
                                    idx = 0
                                    s = _6381 + 292
                                    t = _6381 + 32
                                    while idx < mem[_6381]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_6381 + 196] = this.address
                                    mem[_6381 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _6381 + (32 * mem[_6381]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9150 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _9294 = mem[_9150]
                                    require mem[_9150] <= test266151307()
                                    require _9150 + mem[_9150] + 31 < _9150 + return_data.size
                                    _9438 = mem[_9150 + mem[_9150]]
                                    if mem[_9150 + mem[_9150]] > test266151307():
                                        revert with 0, 65
                                    if _9150 + ceil32(return_data.size) + ceil32(32 * mem[_9150 + mem[_9150]]) + 1 > test266151307() or ceil32(32 * mem[_9150 + mem[_9150]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _9150 + ceil32(return_data.size) + ceil32(32 * mem[_9150 + mem[_9150]]) + 1
                                    mem[_9150 + ceil32(return_data.size)] = _9438
                                    require return_data.size >= _9294 + (32 * _9438) + 32
                                    mem[_9150 + ceil32(return_data.size) + 32 len 32 * _9438] = mem[_9150 + _9294 + 32 len 32 * _9438]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                    if 1 >= _9438:
                                        revert with 0, 50
                                    if mem[_9150 + ceil32(return_data.size) + 64] > -1:
                                        revert with 0, 17
                                    require ext_code.size(brushAddress)
                                    call brushAddress.0x42966c68 with:
                                         gas gas_remaining wei
                                        args mem[_9150 + ceil32(return_data.size) + 64]
                                else:
                                    if brushAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[0] > !_6377:
                                            revert with 0, 17
                                        mem[_6381 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_6381 + 100] = ext_call.return_data[0] + _6377
                                        mem[_6381 + 132] = 0
                                        mem[_6381 + 164] = 160
                                        mem[_6381 + 260] = mem[_6381]
                                        idx = 0
                                        s = _6381 + 292
                                        t = _6381 + 32
                                        while idx < mem[_6381]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_6381 + 196] = this.address
                                        mem[_6381 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _6381 + (32 * mem[_6381]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9151 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _9295 = mem[_9151]
                                        require mem[_9151] <= test266151307()
                                        require _9151 + mem[_9151] + 31 < _9151 + return_data.size
                                        _9439 = mem[_9151 + mem[_9151]]
                                        if mem[_9151 + mem[_9151]] > test266151307():
                                            revert with 0, 65
                                        if _9151 + ceil32(return_data.size) + ceil32(32 * mem[_9151 + mem[_9151]]) + 1 > test266151307() or ceil32(32 * mem[_9151 + mem[_9151]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _9151 + ceil32(return_data.size) + ceil32(32 * mem[_9151 + mem[_9151]]) + 1
                                        mem[_9151 + ceil32(return_data.size)] = _9439
                                        require return_data.size >= _9295 + (32 * _9439) + 32
                                        mem[_9151 + ceil32(return_data.size) + 32 len 32 * _9439] = mem[_9151 + _9295 + 32 len 32 * _9439]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                        if 1 >= _9439:
                                            revert with 0, 50
                                        if mem[_9151 + ceil32(return_data.size) + 64] > -1:
                                            revert with 0, 17
                                        require ext_code.size(brushAddress)
                                        call brushAddress.0x42966c68 with:
                                             gas gas_remaining wei
                                            args mem[_9151 + ceil32(return_data.size) + 64]
                                    else:
                                        if wftmAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_6377:
                                                revert with 0, 17
                                            mem[_6381 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_6381 + 100] = ext_call.return_data[32] + _6377
                                            mem[_6381 + 132] = 0
                                            mem[_6381 + 164] = 160
                                            mem[_6381 + 260] = mem[_6381]
                                            idx = 0
                                            s = _6381 + 292
                                            t = _6381 + 32
                                            while idx < mem[_6381]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_6381 + 196] = this.address
                                            mem[_6381 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _6381 + (32 * mem[_6381]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9152 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _9296 = mem[_9152]
                                            require mem[_9152] <= test266151307()
                                            require _9152 + mem[_9152] + 31 < _9152 + return_data.size
                                            _9440 = mem[_9152 + mem[_9152]]
                                            if mem[_9152 + mem[_9152]] > test266151307():
                                                revert with 0, 65
                                            if _9152 + ceil32(return_data.size) + ceil32(32 * mem[_9152 + mem[_9152]]) + 1 > test266151307() or ceil32(32 * mem[_9152 + mem[_9152]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _9152 + ceil32(return_data.size) + ceil32(32 * mem[_9152 + mem[_9152]]) + 1
                                            mem[_9152 + ceil32(return_data.size)] = _9440
                                            require return_data.size >= _9296 + (32 * _9440) + 32
                                            mem[_9152 + ceil32(return_data.size) + 32 len 32 * _9440] = mem[_9152 + _9296 + 32 len 32 * _9440]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                            if 1 >= _9440:
                                                revert with 0, 50
                                            if mem[_9152 + ceil32(return_data.size) + 64] > -1:
                                                revert with 0, 17
                                            require ext_code.size(brushAddress)
                                            call brushAddress.0x42966c68 with:
                                                 gas gas_remaining wei
                                                args mem[_9152 + ceil32(return_data.size) + 64]
                                        else:
                                            if ext_call.return_data[0] > !_6377:
                                                revert with 0, 17
                                            mem[_6381 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_6381 + 100] = ext_call.return_data[0] + _6377
                                            mem[_6381 + 132] = 0
                                            mem[_6381 + 164] = 160
                                            mem[_6381 + 260] = mem[_6381]
                                            idx = 0
                                            s = _6381 + 292
                                            t = _6381 + 32
                                            while idx < mem[_6381]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_6381 + 196] = this.address
                                            mem[_6381 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _6381 + (32 * mem[_6381]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9153 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _9297 = mem[_9153]
                                            require mem[_9153] <= test266151307()
                                            require _9153 + mem[_9153] + 31 < _9153 + return_data.size
                                            _9441 = mem[_9153 + mem[_9153]]
                                            if mem[_9153 + mem[_9153]] > test266151307():
                                                revert with 0, 65
                                            if _9153 + ceil32(return_data.size) + ceil32(32 * mem[_9153 + mem[_9153]]) + 1 > test266151307() or ceil32(32 * mem[_9153 + mem[_9153]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _9153 + ceil32(return_data.size) + ceil32(32 * mem[_9153 + mem[_9153]]) + 1
                                            mem[_9153 + ceil32(return_data.size)] = _9441
                                            require return_data.size >= _9297 + (32 * _9441) + 32
                                            mem[_9153 + ceil32(return_data.size) + 32 len 32 * _9441] = mem[_9153 + _9297 + 32 len 32 * _9441]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                            if 1 >= _9441:
                                                revert with 0, 50
                                            if mem[_9153 + ceil32(return_data.size) + 64] > -1:
                                                revert with 0, 17
                                            require ext_code.size(brushAddress)
                                            call brushAddress.0x42966c68 with:
                                                 gas gas_remaining wei
                                                args mem[_9153 + ceil32(return_data.size) + 64]
                    else:
                        if brushAddress == address(ext_call.return_data[0]):
                            if brushAddress != address(ext_call.return_data[0]):
                                if wftmAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_6377:
                                        revert with 0, 17
                                    mem[_6381 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_6381 + 100] = ext_call.return_data[32] + _6377
                                    mem[_6381 + 132] = 0
                                    mem[_6381 + 164] = 160
                                    mem[_6381 + 260] = mem[_6381]
                                    idx = 0
                                    s = _6381 + 292
                                    t = _6381 + 32
                                    while idx < mem[_6381]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_6381 + 196] = this.address
                                    mem[_6381 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _6381 + (32 * mem[_6381]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9154 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _9298 = mem[_9154]
                                    require mem[_9154] <= test266151307()
                                    require _9154 + mem[_9154] + 31 < _9154 + return_data.size
                                    _9442 = mem[_9154 + mem[_9154]]
                                    if mem[_9154 + mem[_9154]] > test266151307():
                                        revert with 0, 65
                                    if _9154 + ceil32(return_data.size) + ceil32(32 * mem[_9154 + mem[_9154]]) + 1 > test266151307() or ceil32(32 * mem[_9154 + mem[_9154]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _9154 + ceil32(return_data.size) + ceil32(32 * mem[_9154 + mem[_9154]]) + 1
                                    mem[_9154 + ceil32(return_data.size)] = _9442
                                    require return_data.size >= _9298 + (32 * _9442) + 32
                                    mem[_9154 + ceil32(return_data.size) + 32 len 32 * _9442] = mem[_9154 + _9298 + 32 len 32 * _9442]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                    if 1 >= _9442:
                                        revert with 0, 50
                                    if mem[_9154 + ceil32(return_data.size) + 64] > -1:
                                        revert with 0, 17
                                    require ext_code.size(brushAddress)
                                    call brushAddress.0x42966c68 with:
                                         gas gas_remaining wei
                                        args mem[_9154 + ceil32(return_data.size) + 64]
                                else:
                                    if ext_call.return_data[0] > !_6377:
                                        revert with 0, 17
                                    mem[_6381 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_6381 + 100] = ext_call.return_data[0] + _6377
                                    mem[_6381 + 132] = 0
                                    mem[_6381 + 164] = 160
                                    mem[_6381 + 260] = mem[_6381]
                                    idx = 0
                                    s = _6381 + 292
                                    t = _6381 + 32
                                    while idx < mem[_6381]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_6381 + 196] = this.address
                                    mem[_6381 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _6381 + (32 * mem[_6381]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9155 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _9299 = mem[_9155]
                                    require mem[_9155] <= test266151307()
                                    require _9155 + mem[_9155] + 31 < _9155 + return_data.size
                                    _9443 = mem[_9155 + mem[_9155]]
                                    if mem[_9155 + mem[_9155]] > test266151307():
                                        revert with 0, 65
                                    if _9155 + ceil32(return_data.size) + ceil32(32 * mem[_9155 + mem[_9155]]) + 1 > test266151307() or ceil32(32 * mem[_9155 + mem[_9155]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _9155 + ceil32(return_data.size) + ceil32(32 * mem[_9155 + mem[_9155]]) + 1
                                    mem[_9155 + ceil32(return_data.size)] = _9443
                                    require return_data.size >= _9299 + (32 * _9443) + 32
                                    mem[_9155 + ceil32(return_data.size) + 32 len 32 * _9443] = mem[_9155 + _9299 + 32 len 32 * _9443]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                    if 1 >= _9443:
                                        revert with 0, 50
                                    if mem[_9155 + ceil32(return_data.size) + 64] > -1:
                                        revert with 0, 17
                                    require ext_code.size(brushAddress)
                                    call brushAddress.0x42966c68 with:
                                         gas gas_remaining wei
                                        args mem[_9155 + ceil32(return_data.size) + 64]
                            else:
                                if brushAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_6377:
                                        revert with 0, 17
                                    mem[_6381 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_6381 + 100] = ext_call.return_data[32] + _6377
                                    mem[_6381 + 132] = 0
                                    mem[_6381 + 164] = 160
                                    mem[_6381 + 260] = mem[_6381]
                                    idx = 0
                                    s = _6381 + 292
                                    t = _6381 + 32
                                    while idx < mem[_6381]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_6381 + 196] = this.address
                                    mem[_6381 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _6381 + (32 * mem[_6381]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9156 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _9300 = mem[_9156]
                                    require mem[_9156] <= test266151307()
                                    require _9156 + mem[_9156] + 31 < _9156 + return_data.size
                                    _9444 = mem[_9156 + mem[_9156]]
                                    if mem[_9156 + mem[_9156]] > test266151307():
                                        revert with 0, 65
                                    if _9156 + ceil32(return_data.size) + ceil32(32 * mem[_9156 + mem[_9156]]) + 1 > test266151307() or ceil32(32 * mem[_9156 + mem[_9156]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _9156 + ceil32(return_data.size) + ceil32(32 * mem[_9156 + mem[_9156]]) + 1
                                    mem[_9156 + ceil32(return_data.size)] = _9444
                                    require return_data.size >= _9300 + (32 * _9444) + 32
                                    mem[_9156 + ceil32(return_data.size) + 32 len 32 * _9444] = mem[_9156 + _9300 + 32 len 32 * _9444]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                    if 1 >= _9444:
                                        revert with 0, 50
                                    if mem[_9156 + ceil32(return_data.size) + 64] > -1:
                                        revert with 0, 17
                                    require ext_code.size(brushAddress)
                                    call brushAddress.0x42966c68 with:
                                         gas gas_remaining wei
                                        args mem[_9156 + ceil32(return_data.size) + 64]
                                else:
                                    if brushAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[0] > !_6377:
                                            revert with 0, 17
                                        mem[_6381 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_6381 + 100] = ext_call.return_data[0] + _6377
                                        mem[_6381 + 132] = 0
                                        mem[_6381 + 164] = 160
                                        mem[_6381 + 260] = mem[_6381]
                                        idx = 0
                                        s = _6381 + 292
                                        t = _6381 + 32
                                        while idx < mem[_6381]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_6381 + 196] = this.address
                                        mem[_6381 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _6381 + (32 * mem[_6381]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9157 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _9301 = mem[_9157]
                                        require mem[_9157] <= test266151307()
                                        require _9157 + mem[_9157] + 31 < _9157 + return_data.size
                                        _9445 = mem[_9157 + mem[_9157]]
                                        if mem[_9157 + mem[_9157]] > test266151307():
                                            revert with 0, 65
                                        if _9157 + ceil32(return_data.size) + ceil32(32 * mem[_9157 + mem[_9157]]) + 1 > test266151307() or ceil32(32 * mem[_9157 + mem[_9157]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _9157 + ceil32(return_data.size) + ceil32(32 * mem[_9157 + mem[_9157]]) + 1
                                        mem[_9157 + ceil32(return_data.size)] = _9445
                                        require return_data.size >= _9301 + (32 * _9445) + 32
                                        mem[_9157 + ceil32(return_data.size) + 32 len 32 * _9445] = mem[_9157 + _9301 + 32 len 32 * _9445]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                        if 1 >= _9445:
                                            revert with 0, 50
                                        if mem[_9157 + ceil32(return_data.size) + 64] > -1:
                                            revert with 0, 17
                                        require ext_code.size(brushAddress)
                                        call brushAddress.0x42966c68 with:
                                             gas gas_remaining wei
                                            args mem[_9157 + ceil32(return_data.size) + 64]
                                    else:
                                        if wftmAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_6377:
                                                revert with 0, 17
                                            mem[_6381 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_6381 + 100] = ext_call.return_data[32] + _6377
                                            mem[_6381 + 132] = 0
                                            mem[_6381 + 164] = 160
                                            mem[_6381 + 260] = mem[_6381]
                                            idx = 0
                                            s = _6381 + 292
                                            t = _6381 + 32
                                            while idx < mem[_6381]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_6381 + 196] = this.address
                                            mem[_6381 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _6381 + (32 * mem[_6381]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9158 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _9302 = mem[_9158]
                                            require mem[_9158] <= test266151307()
                                            require _9158 + mem[_9158] + 31 < _9158 + return_data.size
                                            _9446 = mem[_9158 + mem[_9158]]
                                            if mem[_9158 + mem[_9158]] > test266151307():
                                                revert with 0, 65
                                            if _9158 + ceil32(return_data.size) + ceil32(32 * mem[_9158 + mem[_9158]]) + 1 > test266151307() or ceil32(32 * mem[_9158 + mem[_9158]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _9158 + ceil32(return_data.size) + ceil32(32 * mem[_9158 + mem[_9158]]) + 1
                                            mem[_9158 + ceil32(return_data.size)] = _9446
                                            require return_data.size >= _9302 + (32 * _9446) + 32
                                            mem[_9158 + ceil32(return_data.size) + 32 len 32 * _9446] = mem[_9158 + _9302 + 32 len 32 * _9446]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                            if 1 >= _9446:
                                                revert with 0, 50
                                            if mem[_9158 + ceil32(return_data.size) + 64] > -1:
                                                revert with 0, 17
                                            require ext_code.size(brushAddress)
                                            call brushAddress.0x42966c68 with:
                                                 gas gas_remaining wei
                                                args mem[_9158 + ceil32(return_data.size) + 64]
                                        else:
                                            if ext_call.return_data[0] > !_6377:
                                                revert with 0, 17
                                            mem[_6381 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_6381 + 100] = ext_call.return_data[0] + _6377
                                            mem[_6381 + 132] = 0
                                            mem[_6381 + 164] = 160
                                            mem[_6381 + 260] = mem[_6381]
                                            idx = 0
                                            s = _6381 + 292
                                            t = _6381 + 32
                                            while idx < mem[_6381]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_6381 + 196] = this.address
                                            mem[_6381 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _6381 + (32 * mem[_6381]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9159 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _9303 = mem[_9159]
                                            require mem[_9159] <= test266151307()
                                            require _9159 + mem[_9159] + 31 < _9159 + return_data.size
                                            _9447 = mem[_9159 + mem[_9159]]
                                            if mem[_9159 + mem[_9159]] > test266151307():
                                                revert with 0, 65
                                            if _9159 + ceil32(return_data.size) + ceil32(32 * mem[_9159 + mem[_9159]]) + 1 > test266151307() or ceil32(32 * mem[_9159 + mem[_9159]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _9159 + ceil32(return_data.size) + ceil32(32 * mem[_9159 + mem[_9159]]) + 1
                                            mem[_9159 + ceil32(return_data.size)] = _9447
                                            require return_data.size >= _9303 + (32 * _9447) + 32
                                            mem[_9159 + ceil32(return_data.size) + 32 len 32 * _9447] = mem[_9159 + _9303 + 32 len 32 * _9447]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                            if 1 >= _9447:
                                                revert with 0, 50
                                            if mem[_9159 + ceil32(return_data.size) + 64] > -1:
                                                revert with 0, 17
                                            require ext_code.size(brushAddress)
                                            call brushAddress.0x42966c68 with:
                                                 gas gas_remaining wei
                                                args mem[_9159 + ceil32(return_data.size) + 64]
                        else:
                            if brushAddress == address(ext_call.return_data[0]):
                                if brushAddress != address(ext_call.return_data[0]):
                                    if wftmAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[32] > !_6377:
                                            revert with 0, 17
                                        mem[_6381 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_6381 + 100] = ext_call.return_data[32] + _6377
                                        mem[_6381 + 132] = 0
                                        mem[_6381 + 164] = 160
                                        mem[_6381 + 260] = mem[_6381]
                                        idx = 0
                                        s = _6381 + 292
                                        t = _6381 + 32
                                        while idx < mem[_6381]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_6381 + 196] = this.address
                                        mem[_6381 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _6381 + (32 * mem[_6381]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9160 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _9304 = mem[_9160]
                                        require mem[_9160] <= test266151307()
                                        require _9160 + mem[_9160] + 31 < _9160 + return_data.size
                                        _9448 = mem[_9160 + mem[_9160]]
                                        if mem[_9160 + mem[_9160]] > test266151307():
                                            revert with 0, 65
                                        if _9160 + ceil32(return_data.size) + ceil32(32 * mem[_9160 + mem[_9160]]) + 1 > test266151307() or ceil32(32 * mem[_9160 + mem[_9160]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _9160 + ceil32(return_data.size) + ceil32(32 * mem[_9160 + mem[_9160]]) + 1
                                        mem[_9160 + ceil32(return_data.size)] = _9448
                                        require return_data.size >= _9304 + (32 * _9448) + 32
                                        mem[_9160 + ceil32(return_data.size) + 32 len 32 * _9448] = mem[_9160 + _9304 + 32 len 32 * _9448]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                        if 1 >= _9448:
                                            revert with 0, 50
                                        if mem[_9160 + ceil32(return_data.size) + 64] > -1:
                                            revert with 0, 17
                                        require ext_code.size(brushAddress)
                                        call brushAddress.0x42966c68 with:
                                             gas gas_remaining wei
                                            args mem[_9160 + ceil32(return_data.size) + 64]
                                    else:
                                        if ext_call.return_data[0] > !_6377:
                                            revert with 0, 17
                                        mem[_6381 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_6381 + 100] = ext_call.return_data[0] + _6377
                                        mem[_6381 + 132] = 0
                                        mem[_6381 + 164] = 160
                                        mem[_6381 + 260] = mem[_6381]
                                        idx = 0
                                        s = _6381 + 292
                                        t = _6381 + 32
                                        while idx < mem[_6381]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_6381 + 196] = this.address
                                        mem[_6381 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _6381 + (32 * mem[_6381]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9161 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _9305 = mem[_9161]
                                        require mem[_9161] <= test266151307()
                                        require _9161 + mem[_9161] + 31 < _9161 + return_data.size
                                        _9449 = mem[_9161 + mem[_9161]]
                                        if mem[_9161 + mem[_9161]] > test266151307():
                                            revert with 0, 65
                                        if _9161 + ceil32(return_data.size) + ceil32(32 * mem[_9161 + mem[_9161]]) + 1 > test266151307() or ceil32(32 * mem[_9161 + mem[_9161]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _9161 + ceil32(return_data.size) + ceil32(32 * mem[_9161 + mem[_9161]]) + 1
                                        mem[_9161 + ceil32(return_data.size)] = _9449
                                        require return_data.size >= _9305 + (32 * _9449) + 32
                                        mem[_9161 + ceil32(return_data.size) + 32 len 32 * _9449] = mem[_9161 + _9305 + 32 len 32 * _9449]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                        if 1 >= _9449:
                                            revert with 0, 50
                                        if mem[_9161 + ceil32(return_data.size) + 64] > -1:
                                            revert with 0, 17
                                        require ext_code.size(brushAddress)
                                        call brushAddress.0x42966c68 with:
                                             gas gas_remaining wei
                                            args mem[_9161 + ceil32(return_data.size) + 64]
                                else:
                                    if brushAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[32] > !_6377:
                                            revert with 0, 17
                                        mem[_6381 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_6381 + 100] = ext_call.return_data[32] + _6377
                                        mem[_6381 + 132] = 0
                                        mem[_6381 + 164] = 160
                                        mem[_6381 + 260] = mem[_6381]
                                        idx = 0
                                        s = _6381 + 292
                                        t = _6381 + 32
                                        while idx < mem[_6381]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_6381 + 196] = this.address
                                        mem[_6381 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _6381 + (32 * mem[_6381]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9162 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _9306 = mem[_9162]
                                        require mem[_9162] <= test266151307()
                                        require _9162 + mem[_9162] + 31 < _9162 + return_data.size
                                        _9450 = mem[_9162 + mem[_9162]]
                                        if mem[_9162 + mem[_9162]] > test266151307():
                                            revert with 0, 65
                                        if _9162 + ceil32(return_data.size) + ceil32(32 * mem[_9162 + mem[_9162]]) + 1 > test266151307() or ceil32(32 * mem[_9162 + mem[_9162]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _9162 + ceil32(return_data.size) + ceil32(32 * mem[_9162 + mem[_9162]]) + 1
                                        mem[_9162 + ceil32(return_data.size)] = _9450
                                        require return_data.size >= _9306 + (32 * _9450) + 32
                                        mem[_9162 + ceil32(return_data.size) + 32 len 32 * _9450] = mem[_9162 + _9306 + 32 len 32 * _9450]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                        if 1 >= _9450:
                                            revert with 0, 50
                                        if mem[_9162 + ceil32(return_data.size) + 64] > -1:
                                            revert with 0, 17
                                        require ext_code.size(brushAddress)
                                        call brushAddress.0x42966c68 with:
                                             gas gas_remaining wei
                                            args mem[_9162 + ceil32(return_data.size) + 64]
                                    else:
                                        if brushAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[0] > !_6377:
                                                revert with 0, 17
                                            mem[_6381 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_6381 + 100] = ext_call.return_data[0] + _6377
                                            mem[_6381 + 132] = 0
                                            mem[_6381 + 164] = 160
                                            mem[_6381 + 260] = mem[_6381]
                                            idx = 0
                                            s = _6381 + 292
                                            t = _6381 + 32
                                            while idx < mem[_6381]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_6381 + 196] = this.address
                                            mem[_6381 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _6381 + (32 * mem[_6381]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9163 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _9307 = mem[_9163]
                                            require mem[_9163] <= test266151307()
                                            require _9163 + mem[_9163] + 31 < _9163 + return_data.size
                                            _9451 = mem[_9163 + mem[_9163]]
                                            if mem[_9163 + mem[_9163]] > test266151307():
                                                revert with 0, 65
                                            if _9163 + ceil32(return_data.size) + ceil32(32 * mem[_9163 + mem[_9163]]) + 1 > test266151307() or ceil32(32 * mem[_9163 + mem[_9163]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _9163 + ceil32(return_data.size) + ceil32(32 * mem[_9163 + mem[_9163]]) + 1
                                            mem[_9163 + ceil32(return_data.size)] = _9451
                                            require return_data.size >= _9307 + (32 * _9451) + 32
                                            mem[_9163 + ceil32(return_data.size) + 32 len 32 * _9451] = mem[_9163 + _9307 + 32 len 32 * _9451]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                            if 1 >= _9451:
                                                revert with 0, 50
                                            if mem[_9163 + ceil32(return_data.size) + 64] > -1:
                                                revert with 0, 17
                                            require ext_code.size(brushAddress)
                                            call brushAddress.0x42966c68 with:
                                                 gas gas_remaining wei
                                                args mem[_9163 + ceil32(return_data.size) + 64]
                                        else:
                                            if wftmAddress == address(ext_call.return_data[0]):
                                                if ext_call.return_data[32] > !_6377:
                                                    revert with 0, 17
                                                mem[_6381 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[_6381 + 100] = ext_call.return_data[32] + _6377
                                                mem[_6381 + 132] = 0
                                                mem[_6381 + 164] = 160
                                                mem[_6381 + 260] = mem[_6381]
                                                idx = 0
                                                s = _6381 + 292
                                                t = _6381 + 32
                                                while idx < mem[_6381]:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[_6381 + 196] = this.address
                                                mem[_6381 + 228] = block.timestamp + 10000
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len _6381 + (32 * mem[_6381]) + -mem[64] + 288]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _9164 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _9308 = mem[_9164]
                                                require mem[_9164] <= test266151307()
                                                require _9164 + mem[_9164] + 31 < _9164 + return_data.size
                                                _9452 = mem[_9164 + mem[_9164]]
                                                if mem[_9164 + mem[_9164]] > test266151307():
                                                    revert with 0, 65
                                                if _9164 + ceil32(return_data.size) + ceil32(32 * mem[_9164 + mem[_9164]]) + 1 > test266151307() or ceil32(32 * mem[_9164 + mem[_9164]]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[64] = _9164 + ceil32(return_data.size) + ceil32(32 * mem[_9164 + mem[_9164]]) + 1
                                                mem[_9164 + ceil32(return_data.size)] = _9452
                                                require return_data.size >= _9308 + (32 * _9452) + 32
                                                mem[_9164 + ceil32(return_data.size) + 32 len 32 * _9452] = mem[_9164 + _9308 + 32 len 32 * _9452]
                                                if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                    revert with 0, 17
                                                maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                                if 1 >= _9452:
                                                    revert with 0, 50
                                                if mem[_9164 + ceil32(return_data.size) + 64] > -1:
                                                    revert with 0, 17
                                                require ext_code.size(brushAddress)
                                                call brushAddress.0x42966c68 with:
                                                     gas gas_remaining wei
                                                    args mem[_9164 + ceil32(return_data.size) + 64]
                                            else:
                                                if ext_call.return_data[0] > !_6377:
                                                    revert with 0, 17
                                                mem[_6381 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[_6381 + 100] = ext_call.return_data[0] + _6377
                                                mem[_6381 + 132] = 0
                                                mem[_6381 + 164] = 160
                                                mem[_6381 + 260] = mem[_6381]
                                                idx = 0
                                                s = _6381 + 292
                                                t = _6381 + 32
                                                while idx < mem[_6381]:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[_6381 + 196] = this.address
                                                mem[_6381 + 228] = block.timestamp + 10000
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len _6381 + (32 * mem[_6381]) + -mem[64] + 288]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _9165 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _9309 = mem[_9165]
                                                require mem[_9165] <= test266151307()
                                                require _9165 + mem[_9165] + 31 < _9165 + return_data.size
                                                _9453 = mem[_9165 + mem[_9165]]
                                                if mem[_9165 + mem[_9165]] > test266151307():
                                                    revert with 0, 65
                                                if _9165 + ceil32(return_data.size) + ceil32(32 * mem[_9165 + mem[_9165]]) + 1 > test266151307() or ceil32(32 * mem[_9165 + mem[_9165]]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[64] = _9165 + ceil32(return_data.size) + ceil32(32 * mem[_9165 + mem[_9165]]) + 1
                                                mem[_9165 + ceil32(return_data.size)] = _9453
                                                require return_data.size >= _9309 + (32 * _9453) + 32
                                                mem[_9165 + ceil32(return_data.size) + 32 len 32 * _9453] = mem[_9165 + _9309 + 32 len 32 * _9453]
                                                if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                    revert with 0, 17
                                                maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                                if 1 >= _9453:
                                                    revert with 0, 50
                                                if mem[_9165 + ceil32(return_data.size) + 64] > -1:
                                                    revert with 0, 17
                                                require ext_code.size(brushAddress)
                                                call brushAddress.0x42966c68 with:
                                                     gas gas_remaining wei
                                                    args mem[_9165 + ceil32(return_data.size) + 64]
                            else:
                                if wftmAddress == address(ext_call.return_data[0]):
                                    if brushAddress != address(ext_call.return_data[0]):
                                        if wftmAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_6377:
                                                revert with 0, 17
                                            mem[_6381 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_6381 + 100] = ext_call.return_data[32] + _6377
                                            mem[_6381 + 132] = 0
                                            mem[_6381 + 164] = 160
                                            mem[_6381 + 260] = mem[_6381]
                                            idx = 0
                                            s = _6381 + 292
                                            t = _6381 + 32
                                            while idx < mem[_6381]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_6381 + 196] = this.address
                                            mem[_6381 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _6381 + (32 * mem[_6381]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9166 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _9310 = mem[_9166]
                                            require mem[_9166] <= test266151307()
                                            require _9166 + mem[_9166] + 31 < _9166 + return_data.size
                                            _9454 = mem[_9166 + mem[_9166]]
                                            if mem[_9166 + mem[_9166]] > test266151307():
                                                revert with 0, 65
                                            if _9166 + ceil32(return_data.size) + ceil32(32 * mem[_9166 + mem[_9166]]) + 1 > test266151307() or ceil32(32 * mem[_9166 + mem[_9166]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _9166 + ceil32(return_data.size) + ceil32(32 * mem[_9166 + mem[_9166]]) + 1
                                            mem[_9166 + ceil32(return_data.size)] = _9454
                                            require return_data.size >= _9310 + (32 * _9454) + 32
                                            mem[_9166 + ceil32(return_data.size) + 32 len 32 * _9454] = mem[_9166 + _9310 + 32 len 32 * _9454]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                            if 1 >= _9454:
                                                revert with 0, 50
                                            if mem[_9166 + ceil32(return_data.size) + 64] > -1:
                                                revert with 0, 17
                                            require ext_code.size(brushAddress)
                                            call brushAddress.0x42966c68 with:
                                                 gas gas_remaining wei
                                                args mem[_9166 + ceil32(return_data.size) + 64]
                                        else:
                                            if ext_call.return_data[0] > !_6377:
                                                revert with 0, 17
                                            mem[_6381 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_6381 + 100] = ext_call.return_data[0] + _6377
                                            mem[_6381 + 132] = 0
                                            mem[_6381 + 164] = 160
                                            mem[_6381 + 260] = mem[_6381]
                                            idx = 0
                                            s = _6381 + 292
                                            t = _6381 + 32
                                            while idx < mem[_6381]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_6381 + 196] = this.address
                                            mem[_6381 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _6381 + (32 * mem[_6381]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9167 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _9311 = mem[_9167]
                                            require mem[_9167] <= test266151307()
                                            require _9167 + mem[_9167] + 31 < _9167 + return_data.size
                                            _9455 = mem[_9167 + mem[_9167]]
                                            if mem[_9167 + mem[_9167]] > test266151307():
                                                revert with 0, 65
                                            if _9167 + ceil32(return_data.size) + ceil32(32 * mem[_9167 + mem[_9167]]) + 1 > test266151307() or ceil32(32 * mem[_9167 + mem[_9167]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _9167 + ceil32(return_data.size) + ceil32(32 * mem[_9167 + mem[_9167]]) + 1
                                            mem[_9167 + ceil32(return_data.size)] = _9455
                                            require return_data.size >= _9311 + (32 * _9455) + 32
                                            mem[_9167 + ceil32(return_data.size) + 32 len 32 * _9455] = mem[_9167 + _9311 + 32 len 32 * _9455]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                            if 1 >= _9455:
                                                revert with 0, 50
                                            if mem[_9167 + ceil32(return_data.size) + 64] > -1:
                                                revert with 0, 17
                                            require ext_code.size(brushAddress)
                                            call brushAddress.0x42966c68 with:
                                                 gas gas_remaining wei
                                                args mem[_9167 + ceil32(return_data.size) + 64]
                                    else:
                                        if brushAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_6377:
                                                revert with 0, 17
                                            mem[_6381 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_6381 + 100] = ext_call.return_data[32] + _6377
                                            mem[_6381 + 132] = 0
                                            mem[_6381 + 164] = 160
                                            mem[_6381 + 260] = mem[_6381]
                                            idx = 0
                                            s = _6381 + 292
                                            t = _6381 + 32
                                            while idx < mem[_6381]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_6381 + 196] = this.address
                                            mem[_6381 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _6381 + (32 * mem[_6381]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9168 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _9312 = mem[_9168]
                                            require mem[_9168] <= test266151307()
                                            require _9168 + mem[_9168] + 31 < _9168 + return_data.size
                                            _9456 = mem[_9168 + mem[_9168]]
                                            if mem[_9168 + mem[_9168]] > test266151307():
                                                revert with 0, 65
                                            if _9168 + ceil32(return_data.size) + ceil32(32 * mem[_9168 + mem[_9168]]) + 1 > test266151307() or ceil32(32 * mem[_9168 + mem[_9168]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _9168 + ceil32(return_data.size) + ceil32(32 * mem[_9168 + mem[_9168]]) + 1
                                            mem[_9168 + ceil32(return_data.size)] = _9456
                                            require return_data.size >= _9312 + (32 * _9456) + 32
                                            mem[_9168 + ceil32(return_data.size) + 32 len 32 * _9456] = mem[_9168 + _9312 + 32 len 32 * _9456]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                            if 1 >= _9456:
                                                revert with 0, 50
                                            if mem[_9168 + ceil32(return_data.size) + 64] > -1:
                                                revert with 0, 17
                                            require ext_code.size(brushAddress)
                                            call brushAddress.0x42966c68 with:
                                                 gas gas_remaining wei
                                                args mem[_9168 + ceil32(return_data.size) + 64]
                                        else:
                                            if brushAddress == address(ext_call.return_data[0]):
                                                if ext_call.return_data[0] > !_6377:
                                                    revert with 0, 17
                                                mem[_6381 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[_6381 + 100] = ext_call.return_data[0] + _6377
                                                mem[_6381 + 132] = 0
                                                mem[_6381 + 164] = 160
                                                mem[_6381 + 260] = mem[_6381]
                                                idx = 0
                                                s = _6381 + 292
                                                t = _6381 + 32
                                                while idx < mem[_6381]:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[_6381 + 196] = this.address
                                                mem[_6381 + 228] = block.timestamp + 10000
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len _6381 + (32 * mem[_6381]) + -mem[64] + 288]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _9169 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _9313 = mem[_9169]
                                                require mem[_9169] <= test266151307()
                                                require _9169 + mem[_9169] + 31 < _9169 + return_data.size
                                                _9457 = mem[_9169 + mem[_9169]]
                                                if mem[_9169 + mem[_9169]] > test266151307():
                                                    revert with 0, 65
                                                if _9169 + ceil32(return_data.size) + ceil32(32 * mem[_9169 + mem[_9169]]) + 1 > test266151307() or ceil32(32 * mem[_9169 + mem[_9169]]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[64] = _9169 + ceil32(return_data.size) + ceil32(32 * mem[_9169 + mem[_9169]]) + 1
                                                mem[_9169 + ceil32(return_data.size)] = _9457
                                                require return_data.size >= _9313 + (32 * _9457) + 32
                                                mem[_9169 + ceil32(return_data.size) + 32 len 32 * _9457] = mem[_9169 + _9313 + 32 len 32 * _9457]
                                                if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                    revert with 0, 17
                                                maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                                if 1 >= _9457:
                                                    revert with 0, 50
                                                if mem[_9169 + ceil32(return_data.size) + 64] > -1:
                                                    revert with 0, 17
                                                require ext_code.size(brushAddress)
                                                call brushAddress.0x42966c68 with:
                                                     gas gas_remaining wei
                                                    args mem[_9169 + ceil32(return_data.size) + 64]
                                            else:
                                                if wftmAddress == address(ext_call.return_data[0]):
                                                    if ext_call.return_data[32] > !_6377:
                                                        revert with 0, 17
                                                    mem[_6381 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[_6381 + 100] = ext_call.return_data[32] + _6377
                                                    mem[_6381 + 132] = 0
                                                    mem[_6381 + 164] = 160
                                                    mem[_6381 + 260] = mem[_6381]
                                                    idx = 0
                                                    s = _6381 + 292
                                                    t = _6381 + 32
                                                    while idx < mem[_6381]:
                                                        mem[s] = mem[t + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[_6381 + 196] = this.address
                                                    mem[_6381 + 228] = block.timestamp + 10000
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len _6381 + (32 * mem[_6381]) + -mem[64] + 288]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _9170 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _9314 = mem[_9170]
                                                    require mem[_9170] <= test266151307()
                                                    require _9170 + mem[_9170] + 31 < _9170 + return_data.size
                                                    _9458 = mem[_9170 + mem[_9170]]
                                                    if mem[_9170 + mem[_9170]] > test266151307():
                                                        revert with 0, 65
                                                    if _9170 + ceil32(return_data.size) + ceil32(32 * mem[_9170 + mem[_9170]]) + 1 > test266151307() or ceil32(32 * mem[_9170 + mem[_9170]]) + 1 < 0:
                                                        revert with 0, 65
                                                    mem[64] = _9170 + ceil32(return_data.size) + ceil32(32 * mem[_9170 + mem[_9170]]) + 1
                                                    mem[_9170 + ceil32(return_data.size)] = _9458
                                                    require return_data.size >= _9314 + (32 * _9458) + 32
                                                    mem[_9170 + ceil32(return_data.size) + 32 len 32 * _9458] = mem[_9170 + _9314 + 32 len 32 * _9458]
                                                    if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                        revert with 0, 17
                                                    maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                                    if 1 >= _9458:
                                                        revert with 0, 50
                                                    if mem[_9170 + ceil32(return_data.size) + 64] > -1:
                                                        revert with 0, 17
                                                    require ext_code.size(brushAddress)
                                                    call brushAddress.0x42966c68 with:
                                                         gas gas_remaining wei
                                                        args mem[_9170 + ceil32(return_data.size) + 64]
                                                else:
                                                    if ext_call.return_data[0] > !_6377:
                                                        revert with 0, 17
                                                    mem[_6381 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[_6381 + 100] = ext_call.return_data[0] + _6377
                                                    mem[_6381 + 132] = 0
                                                    mem[_6381 + 164] = 160
                                                    mem[_6381 + 260] = mem[_6381]
                                                    idx = 0
                                                    s = _6381 + 292
                                                    t = _6381 + 32
                                                    while idx < mem[_6381]:
                                                        mem[s] = mem[t + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[_6381 + 196] = this.address
                                                    mem[_6381 + 228] = block.timestamp + 10000
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len _6381 + (32 * mem[_6381]) + -mem[64] + 288]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _9171 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _9315 = mem[_9171]
                                                    require mem[_9171] <= test266151307()
                                                    require _9171 + mem[_9171] + 31 < _9171 + return_data.size
                                                    _9459 = mem[_9171 + mem[_9171]]
                                                    if mem[_9171 + mem[_9171]] > test266151307():
                                                        revert with 0, 65
                                                    if _9171 + ceil32(return_data.size) + ceil32(32 * mem[_9171 + mem[_9171]]) + 1 > test266151307() or ceil32(32 * mem[_9171 + mem[_9171]]) + 1 < 0:
                                                        revert with 0, 65
                                                    mem[64] = _9171 + ceil32(return_data.size) + ceil32(32 * mem[_9171 + mem[_9171]]) + 1
                                                    mem[_9171 + ceil32(return_data.size)] = _9459
                                                    require return_data.size >= _9315 + (32 * _9459) + 32
                                                    mem[_9171 + ceil32(return_data.size) + 32 len 32 * _9459] = mem[_9171 + _9315 + 32 len 32 * _9459]
                                                    if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                        revert with 0, 17
                                                    maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                                    if 1 >= _9459:
                                                        revert with 0, 50
                                                    if mem[_9171 + ceil32(return_data.size) + 64] > -1:
                                                        revert with 0, 17
                                                    require ext_code.size(brushAddress)
                                                    call brushAddress.0x42966c68 with:
                                                         gas gas_remaining wei
                                                        args mem[_9171 + ceil32(return_data.size) + 64]
                                else:
                                    if brushAddress != address(ext_call.return_data[0]):
                                        if wftmAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_6377:
                                                revert with 0, 17
                                            mem[_6381 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_6381 + 100] = ext_call.return_data[32] + _6377
                                            mem[_6381 + 132] = 0
                                            mem[_6381 + 164] = 160
                                            mem[_6381 + 260] = mem[_6381]
                                            idx = 0
                                            s = _6381 + 292
                                            t = _6381 + 32
                                            while idx < mem[_6381]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_6381 + 196] = this.address
                                            mem[_6381 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _6381 + (32 * mem[_6381]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9172 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _9316 = mem[_9172]
                                            require mem[_9172] <= test266151307()
                                            require _9172 + mem[_9172] + 31 < _9172 + return_data.size
                                            _9460 = mem[_9172 + mem[_9172]]
                                            if mem[_9172 + mem[_9172]] > test266151307():
                                                revert with 0, 65
                                            if _9172 + ceil32(return_data.size) + ceil32(32 * mem[_9172 + mem[_9172]]) + 1 > test266151307() or ceil32(32 * mem[_9172 + mem[_9172]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _9172 + ceil32(return_data.size) + ceil32(32 * mem[_9172 + mem[_9172]]) + 1
                                            mem[_9172 + ceil32(return_data.size)] = _9460
                                            require return_data.size >= _9316 + (32 * _9460) + 32
                                            mem[_9172 + ceil32(return_data.size) + 32 len 32 * _9460] = mem[_9172 + _9316 + 32 len 32 * _9460]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                            if 1 >= _9460:
                                                revert with 0, 50
                                            if mem[_9172 + ceil32(return_data.size) + 64] > -1:
                                                revert with 0, 17
                                            require ext_code.size(brushAddress)
                                            call brushAddress.0x42966c68 with:
                                                 gas gas_remaining wei
                                                args mem[_9172 + ceil32(return_data.size) + 64]
                                        else:
                                            if ext_call.return_data[0] > !_6377:
                                                revert with 0, 17
                                            mem[_6381 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_6381 + 100] = ext_call.return_data[0] + _6377
                                            mem[_6381 + 132] = 0
                                            mem[_6381 + 164] = 160
                                            mem[_6381 + 260] = mem[_6381]
                                            idx = 0
                                            s = _6381 + 292
                                            t = _6381 + 32
                                            while idx < mem[_6381]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_6381 + 196] = this.address
                                            mem[_6381 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _6381 + (32 * mem[_6381]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9173 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _9317 = mem[_9173]
                                            require mem[_9173] <= test266151307()
                                            require _9173 + mem[_9173] + 31 < _9173 + return_data.size
                                            _9461 = mem[_9173 + mem[_9173]]
                                            if mem[_9173 + mem[_9173]] > test266151307():
                                                revert with 0, 65
                                            if _9173 + ceil32(return_data.size) + ceil32(32 * mem[_9173 + mem[_9173]]) + 1 > test266151307() or ceil32(32 * mem[_9173 + mem[_9173]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _9173 + ceil32(return_data.size) + ceil32(32 * mem[_9173 + mem[_9173]]) + 1
                                            mem[_9173 + ceil32(return_data.size)] = _9461
                                            require return_data.size >= _9317 + (32 * _9461) + 32
                                            mem[_9173 + ceil32(return_data.size) + 32 len 32 * _9461] = mem[_9173 + _9317 + 32 len 32 * _9461]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                            if 1 >= _9461:
                                                revert with 0, 50
                                            if mem[_9173 + ceil32(return_data.size) + 64] > -1:
                                                revert with 0, 17
                                            require ext_code.size(brushAddress)
                                            call brushAddress.0x42966c68 with:
                                                 gas gas_remaining wei
                                                args mem[_9173 + ceil32(return_data.size) + 64]
                                    else:
                                        if brushAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_6377:
                                                revert with 0, 17
                                            mem[_6381 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_6381 + 100] = ext_call.return_data[32] + _6377
                                            mem[_6381 + 132] = 0
                                            mem[_6381 + 164] = 160
                                            mem[_6381 + 260] = mem[_6381]
                                            idx = 0
                                            s = _6381 + 292
                                            t = _6381 + 32
                                            while idx < mem[_6381]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_6381 + 196] = this.address
                                            mem[_6381 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _6381 + (32 * mem[_6381]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9174 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _9318 = mem[_9174]
                                            require mem[_9174] <= test266151307()
                                            require _9174 + mem[_9174] + 31 < _9174 + return_data.size
                                            _9462 = mem[_9174 + mem[_9174]]
                                            if mem[_9174 + mem[_9174]] > test266151307():
                                                revert with 0, 65
                                            if _9174 + ceil32(return_data.size) + ceil32(32 * mem[_9174 + mem[_9174]]) + 1 > test266151307() or ceil32(32 * mem[_9174 + mem[_9174]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _9174 + ceil32(return_data.size) + ceil32(32 * mem[_9174 + mem[_9174]]) + 1
                                            mem[_9174 + ceil32(return_data.size)] = _9462
                                            require return_data.size >= _9318 + (32 * _9462) + 32
                                            mem[_9174 + ceil32(return_data.size) + 32 len 32 * _9462] = mem[_9174 + _9318 + 32 len 32 * _9462]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                            if 1 >= _9462:
                                                revert with 0, 50
                                            if mem[_9174 + ceil32(return_data.size) + 64] > -1:
                                                revert with 0, 17
                                            require ext_code.size(brushAddress)
                                            call brushAddress.0x42966c68 with:
                                                 gas gas_remaining wei
                                                args mem[_9174 + ceil32(return_data.size) + 64]
                                        else:
                                            if brushAddress == address(ext_call.return_data[0]):
                                                if ext_call.return_data[0] > !_6377:
                                                    revert with 0, 17
                                                mem[_6381 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[_6381 + 100] = ext_call.return_data[0] + _6377
                                                mem[_6381 + 132] = 0
                                                mem[_6381 + 164] = 160
                                                mem[_6381 + 260] = mem[_6381]
                                                idx = 0
                                                s = _6381 + 292
                                                t = _6381 + 32
                                                while idx < mem[_6381]:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[_6381 + 196] = this.address
                                                mem[_6381 + 228] = block.timestamp + 10000
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len _6381 + (32 * mem[_6381]) + -mem[64] + 288]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _9175 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _9319 = mem[_9175]
                                                require mem[_9175] <= test266151307()
                                                require _9175 + mem[_9175] + 31 < _9175 + return_data.size
                                                _9463 = mem[_9175 + mem[_9175]]
                                                if mem[_9175 + mem[_9175]] > test266151307():
                                                    revert with 0, 65
                                                if _9175 + ceil32(return_data.size) + ceil32(32 * mem[_9175 + mem[_9175]]) + 1 > test266151307() or ceil32(32 * mem[_9175 + mem[_9175]]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[64] = _9175 + ceil32(return_data.size) + ceil32(32 * mem[_9175 + mem[_9175]]) + 1
                                                mem[_9175 + ceil32(return_data.size)] = _9463
                                                require return_data.size >= _9319 + (32 * _9463) + 32
                                                mem[_9175 + ceil32(return_data.size) + 32 len 32 * _9463] = mem[_9175 + _9319 + 32 len 32 * _9463]
                                                if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                    revert with 0, 17
                                                maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                                if 1 >= _9463:
                                                    revert with 0, 50
                                                if mem[_9175 + ceil32(return_data.size) + 64] > -1:
                                                    revert with 0, 17
                                                require ext_code.size(brushAddress)
                                                call brushAddress.0x42966c68 with:
                                                     gas gas_remaining wei
                                                    args mem[_9175 + ceil32(return_data.size) + 64]
                                            else:
                                                if wftmAddress == address(ext_call.return_data[0]):
                                                    if ext_call.return_data[32] > !_6377:
                                                        revert with 0, 17
                                                    mem[_6381 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[_6381 + 100] = ext_call.return_data[32] + _6377
                                                    mem[_6381 + 132] = 0
                                                    mem[_6381 + 164] = 160
                                                    mem[_6381 + 260] = mem[_6381]
                                                    idx = 0
                                                    s = _6381 + 292
                                                    t = _6381 + 32
                                                    while idx < mem[_6381]:
                                                        mem[s] = mem[t + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[_6381 + 196] = this.address
                                                    mem[_6381 + 228] = block.timestamp + 10000
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len _6381 + (32 * mem[_6381]) + -mem[64] + 288]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _9176 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _9320 = mem[_9176]
                                                    require mem[_9176] <= test266151307()
                                                    require _9176 + mem[_9176] + 31 < _9176 + return_data.size
                                                    _9464 = mem[_9176 + mem[_9176]]
                                                    if mem[_9176 + mem[_9176]] > test266151307():
                                                        revert with 0, 65
                                                    if _9176 + ceil32(return_data.size) + ceil32(32 * mem[_9176 + mem[_9176]]) + 1 > test266151307() or ceil32(32 * mem[_9176 + mem[_9176]]) + 1 < 0:
                                                        revert with 0, 65
                                                    mem[64] = _9176 + ceil32(return_data.size) + ceil32(32 * mem[_9176 + mem[_9176]]) + 1
                                                    mem[_9176 + ceil32(return_data.size)] = _9464
                                                    require return_data.size >= _9320 + (32 * _9464) + 32
                                                    mem[_9176 + ceil32(return_data.size) + 32 len 32 * _9464] = mem[_9176 + _9320 + 32 len 32 * _9464]
                                                    if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                        revert with 0, 17
                                                    maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                                    if 1 >= _9464:
                                                        revert with 0, 50
                                                    if mem[_9176 + ceil32(return_data.size) + 64] > -1:
                                                        revert with 0, 17
                                                    require ext_code.size(brushAddress)
                                                    call brushAddress.0x42966c68 with:
                                                         gas gas_remaining wei
                                                        args mem[_9176 + ceil32(return_data.size) + 64]
                                                else:
                                                    if ext_call.return_data[0] > !_6377:
                                                        revert with 0, 17
                                                    mem[_6381 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[_6381 + 100] = ext_call.return_data[0] + _6377
                                                    mem[_6381 + 132] = 0
                                                    mem[_6381 + 164] = 160
                                                    mem[_6381 + 260] = mem[_6381]
                                                    idx = 0
                                                    s = _6381 + 292
                                                    t = _6381 + 32
                                                    while idx < mem[_6381]:
                                                        mem[s] = mem[t + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[_6381 + 196] = this.address
                                                    mem[_6381 + 228] = block.timestamp + 10000
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len _6381 + (32 * mem[_6381]) + -mem[64] + 288]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _9177 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _9321 = mem[_9177]
                                                    require mem[_9177] <= test266151307()
                                                    require _9177 + mem[_9177] + 31 < _9177 + return_data.size
                                                    _9465 = mem[_9177 + mem[_9177]]
                                                    if mem[_9177 + mem[_9177]] > test266151307():
                                                        revert with 0, 65
                                                    if _9177 + ceil32(return_data.size) + ceil32(32 * mem[_9177 + mem[_9177]]) + 1 > test266151307() or ceil32(32 * mem[_9177 + mem[_9177]]) + 1 < 0:
                                                        revert with 0, 65
                                                    mem[64] = _9177 + ceil32(return_data.size) + ceil32(32 * mem[_9177 + mem[_9177]]) + 1
                                                    mem[_9177 + ceil32(return_data.size)] = _9465
                                                    require return_data.size >= _9321 + (32 * _9465) + 32
                                                    mem[_9177 + ceil32(return_data.size) + 32 len 32 * _9465] = mem[_9177 + _9321 + 32 len 32 * _9465]
                                                    if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                        revert with 0, 17
                                                    maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                                    if 1 >= _9465:
                                                        revert with 0, 50
                                                    if mem[_9177 + ceil32(return_data.size) + 64] > -1:
                                                        revert with 0, 17
                                                    require ext_code.size(brushAddress)
                                                    call brushAddress.0x42966c68 with:
                                                         gas gas_remaining wei
                                                        args mem[_9177 + ceil32(return_data.size) + 64]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
}



}
