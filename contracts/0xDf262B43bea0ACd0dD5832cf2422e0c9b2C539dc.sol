contract main {




// =====================  Runtime code  =====================


#
#  - harvest()
#  - migrate(address arg1)
#
const name = 'StrategyLenderYieldOptimiser', 0

const apiVersion = '', 0

const weth = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83

const uniswapRouter = 0xf491e7b69e4244ad4002bc14e878a34207e38c29

const delegatedAssets = 0

const SECONDSPERYEAR = 31556952


array of uint256 metadataURI;
uint8 doHealthCheck;
address healthCheckAddress; offset 8
address vaultAddress;
address strategistAddress;
address rewardsAddress;
address keeperAddress;
address wantAddress;
uint256 minReportDelay;
uint256 maxReportDelay;
uint256 profitFactor;
uint256 debtThreshold;
uint8 emergencyExit;
uint256 withdrawalThreshold;
array of address lenders;
uint8 externalOracle;
address wantToEthOracleAddress; offset 8

function metadataURI() payable {
    return metadataURI[0 len metadataURI.length]
}

function debtThreshold() payable {
    return debtThreshold
}

function want() payable {
    return wantAddress
}

function strategist() payable {
    return strategistAddress
}

function maxReportDelay() payable {
    return maxReportDelay
}

function wantToEthOracle() payable {
    return wantToEthOracleAddress
}

function externalOracle() payable {
    return bool(externalOracle)
}

function emergencyExit() payable {
    return bool(emergencyExit)
}

function doHealthCheck() payable {
    return bool(doHealthCheck)
}

function withdrawalThreshold() payable {
    return withdrawalThreshold
}

function profitFactor() payable {
    return profitFactor
}

function lenders(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 < lenders.length
    return lenders[arg1]
}

function minReportDelay() payable {
    return minReportDelay
}

function rewards() payable {
    return rewardsAddress
}

function keeper() payable {
    return keeperAddress
}

function healthCheck() payable {
    return healthCheckAddress
}

function numLenders() payable {
    return lenders.length
}

function vault() payable {
    return vaultAddress
}

function _fallback() payable {
    revert
}

function clone(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    require ext_code.size(this.address)
    call this.address.0xd0511842 with:
         gas gas_remaining wei
        args 0, 0, msg.sender, msg.sender, msg.sender
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    return ext_call.return_data[12 len 20]
}

function setWithdrawalThreshold(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if strategistAddress != msg.sender:
        require ext_code.size(vaultAddress)
        staticcall vaultAddress.governance() with:
                gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
        if ext_call.return_data[12 len 20] != msg.sender:
            revert with 0, '!authorized'
    withdrawalThreshold = arg1
}

function setPriceOracle(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if strategistAddress != msg.sender:
        require ext_code.size(vaultAddress)
        staticcall vaultAddress.governance() with:
                gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
        if ext_call.return_data[12 len 20] != msg.sender:
            revert with 0, '!authorized'
    wantToEthOracleAddress = arg1
}

function setProfitFactor(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if strategistAddress != msg.sender:
        require ext_code.size(vaultAddress)
        staticcall vaultAddress.governance() with:
                gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
        if ext_call.return_data[12 len 20] != msg.sender:
            revert with 0, '!authorized'
    profitFactor = arg1
    emit UpdatedProfitFactor(arg1);
}

function setDebtThreshold(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if strategistAddress != msg.sender:
        require ext_code.size(vaultAddress)
        staticcall vaultAddress.governance() with:
                gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
        if ext_call.return_data[12 len 20] != msg.sender:
            revert with 0, '!authorized'
    debtThreshold = arg1
    emit UpdatedDebtThreshold(arg1);
}

function setMinReportDelay(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if strategistAddress != msg.sender:
        require ext_code.size(vaultAddress)
        staticcall vaultAddress.governance() with:
                gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
        if ext_call.return_data[12 len 20] != msg.sender:
            revert with 0, '!authorized'
    minReportDelay = arg1
    emit UpdatedMinReportDelay(arg1);
}

function setMaxReportDelay(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if strategistAddress != msg.sender:
        require ext_code.size(vaultAddress)
        staticcall vaultAddress.governance() with:
                gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
        if ext_call.return_data[12 len 20] != msg.sender:
            revert with 0, '!authorized'
    maxReportDelay = arg1
    emit UpdatedMaxReportDelay(arg1);
}

function setKeeper(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if strategistAddress != msg.sender:
        require ext_code.size(vaultAddress)
        staticcall vaultAddress.governance() with:
                gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
        if ext_call.return_data[12 len 20] != msg.sender:
            revert with 0, '!authorized'
    require arg1
    keeperAddress = arg1
    emit UpdatedKeeper(arg1);
}

function setStrategist(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if strategistAddress != msg.sender:
        require ext_code.size(vaultAddress)
        staticcall vaultAddress.governance() with:
                gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
        if ext_call.return_data[12 len 20] != msg.sender:
            revert with 0, '!authorized'
    require arg1
    strategistAddress = arg1
    emit UpdatedStrategist(arg1);
}

function lentTotalAssets() payable {
    mem[64] = 96
    idx = 0
    s = 0
    while idx < lenders.length:
        mem[0] = 13
        require ext_code.size(lenders[idx])
        staticcall lenders[idx].nav() with:
                gas gas_remaining wei
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _15 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        if mem[_15] + s < s:
            revert with 0, 'SafeMath: addition overflow'
        idx = idx + 1
        s = mem[_15] + s
        continue 
    return (_16 * lenders.length)
}

function clone(address arg1, address arg2, address arg3, address arg4) payable {
    require calldata.size - 4 >= 128
    require arg1 == arg1
    require arg2 == arg2
    require arg3 == arg3
    require arg4 == arg4
    create contract with 0 wei
                    code: 0x3d602d80600a3d3981f3363d3d373d3d3d363d73, Mask(160, 96, this.address) >> 96, 0x5af43d82803e903d91602b57fd5bf3
    require ext_code.size(address(create.new_address))
    call address(create.new_address).0xf8c8765e with:
         gas gas_remaining wei
        args 0, 0, address(arg2), address(arg3), arg4
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    emit Cloned(address(create.new_address));
    return address(create.new_address)
}

function setHealthCheck(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    require ext_code.size(vaultAddress)
    staticcall vaultAddress.management() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    if ext_call.return_data[12 len 20] != msg.sender:
        require ext_code.size(vaultAddress)
        staticcall vaultAddress.governance() with:
                gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
        if ext_call.return_data[12 len 20] != msg.sender:
            revert with 0, '!authorized'
    healthCheckAddress = arg1
}

function setDoHealthCheck(bool arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    require ext_code.size(vaultAddress)
    staticcall vaultAddress.management() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    if ext_call.return_data[12 len 20] != msg.sender:
        require ext_code.size(vaultAddress)
        staticcall vaultAddress.governance() with:
                gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
        if ext_call.return_data[12 len 20] != msg.sender:
            revert with 0, '!authorized'
    doHealthCheck = uint8(arg1)
}

function setRewards(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if strategistAddress != msg.sender:
        revert with 0, '!strategist'
    require arg1
    require ext_code.size(vaultAddress)
    call vaultAddress.approve(address arg1, uint256 arg2) with:
         gas gas_remaining wei
        args rewardsAddress, 0
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    rewardsAddress = arg1
    require ext_code.size(vaultAddress)
    call vaultAddress.approve(address arg1, uint256 arg2) with:
         gas gas_remaining wei
        args address(arg1), -1
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    emit UpdatedRewards(arg1);
}

function addLender(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    require ext_code.size(vaultAddress)
    staticcall vaultAddress.governance() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    if ext_call.return_data[12 len 20] != msg.sender:
        revert with 0, '!authorized'
    require ext_code.size(arg1)
    staticcall arg1.strategy() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    if ext_call.return_data[12 len 20] != this.address:
        revert with 0, 'Undocked Lender'
    idx = 0
    while idx < lenders.length:
        mem[0] = 13
        if lenders[idx] == arg1:
            revert with 0, 'Already Added'
        idx = idx + 1
        continue 
    lenders.length++
    lenders[lenders.length] = arg1
}

function setMetadataURI(string arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 <= test266151307()
    require arg1 + 35 < calldata.size
    require arg1.length <= test266151307()
    require arg1 + arg1.length + 36 <= calldata.size
    if strategistAddress != msg.sender:
        require ext_code.size(vaultAddress)
        staticcall vaultAddress.governance() with:
                gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
        if ext_call.return_data[12 len 20] != msg.sender:
            revert with 0, '!authorized'
    metadataURI.length = (2 * arg1.length) + 1
    s = 0
    idx = arg1 + 36
    while arg1 + arg1.length + 36 > idx:
        metadataURI[s] = cd[idx]
        s = s + 1
        idx = idx + 32
        continue 
    idx = Mask(251, 0, arg1.length + 31) >> 5
    while metadataURI.length + 31 / 32 > idx:
        metadataURI[idx] = 0
        idx = idx + 1
        continue 
    emit UpdatedMetadataURI(Array(len=arg1.length, data=arg1[all]));
}

function estimatedTotalAssets() payable {
    mem[64] = 96
    idx = 0
    s = 0
    while idx < lenders.length:
        mem[0] = 13
        require ext_code.size(lenders[idx])
        staticcall lenders[idx].nav() with:
                gas gas_remaining wei
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _21 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        if mem[_21] + s < s:
            revert with 0, 'SafeMath: addition overflow'
        idx = idx + 1
        s = mem[_21] + s
        continue 
    mem[mem[64] + 4] = this.address
    require ext_code.size(wantAddress)
    staticcall wantAddress.balanceOf(address arg1) with:
            gas gas_remaining wei
           args address(this.address)
    mem[mem[64]] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _22 = mem[64]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 32
    if mem[_22] + (_23 * lenders.length) < _23 * lenders.length:
        revert with 0, 'SafeMath: addition overflow'
    mem[mem[64]] = mem[_22] + (_23 * lenders.length)
    return memory
      from mem[64]
       len 32
}

function setEmergencyExit() payable {
    if strategistAddress != msg.sender:
        require ext_code.size(vaultAddress)
        staticcall vaultAddress.governance() with:
                gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
        if ext_call.return_data[12 len 20] != msg.sender:
            require ext_code.size(vaultAddress)
            staticcall vaultAddress.guardian() with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
            if ext_call.return_data[12 len 20] != msg.sender:
                require ext_code.size(vaultAddress)
                staticcall vaultAddress.management() with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                if ext_call.return_data[12 len 20] != msg.sender:
                    revert with 0, '!authorized'
    emergencyExit = 1
    require ext_code.size(vaultAddress)
    call vaultAddress.revokeStrategy() with:
         gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    emit EmergencyExitEnabled()
}

function isActive() payable {
    require ext_code.size(vaultAddress)
    staticcall vaultAddress.strategies(address arg1) with:
            gas gas_remaining wei
           args this.address
    mem[96 len 288] = ext_call.return_data[0 len 288]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 288
    require bool(ceil32(return_data.size) + 384 <= test266151307())
    mem[64] = ceil32(return_data.size) + 384
    mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
    mem[ceil32(return_data.size) + 128] = ext_call.return_data[32]
    mem[ceil32(return_data.size) + 160] = ext_call.return_data[64]
    mem[ceil32(return_data.size) + 192] = ext_call.return_data[96]
    mem[ceil32(return_data.size) + 224] = ext_call.return_data[128]
    mem[ceil32(return_data.size) + 256] = ext_call.return_data[160]
    mem[ceil32(return_data.size) + 288] = ext_call.return_data[192]
    mem[ceil32(return_data.size) + 320] = ext_call.return_data[224]
    mem[ceil32(return_data.size) + 352] = ext_call.return_data[256]
    if ext_call.return_data[64] > 0:
        return (ext_call.return_data[64] > 0)
    idx = 0
    s = 0
    while idx < lenders.length:
        mem[0] = 13
        require ext_code.size(lenders[idx])
        staticcall lenders[idx].nav() with:
                gas gas_remaining wei
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _37 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        if mem[_37] + s < s:
            revert with 0, 'SafeMath: addition overflow'
        idx = idx + 1
        s = mem[_37] + s
        continue 
    mem[mem[64] + 4] = this.address
    require ext_code.size(wantAddress)
    staticcall wantAddress.balanceOf(address arg1) with:
            gas gas_remaining wei
           args address(this.address)
    mem[mem[64]] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _38 = mem[64]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 32
    if mem[_38] + (_39 * lenders.length) < _39 * lenders.length:
        revert with 0, 'SafeMath: addition overflow'
    mem[mem[64]] = mem[_38] + (_39 * lenders.length) > 0
    return memory
      from mem[64]
       len 32
}

function ethToWant(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83 == wantAddress:
        return arg1
    if wantToEthOracleAddress:
        require ext_code.size(wantToEthOracleAddress)
        staticcall wantToEthOracleAddress.0x780022a0 with:
                gas gas_remaining wei
               args arg1
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        return ext_call.return_data[0]
    mem[96] = 2
    mem[128] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
    mem[160] = wantAddress
    mem[192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
    mem[196] = arg1
    mem[228] = 64
    mem[260] = 2
    idx = 0
    s = 292
    t = 128
    while idx < 2:
        mem[s] = mem[t + 12 len 20]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ext_code.size(0xf491e7b69e4244ad4002bc14e878a34207e38c29)
    staticcall 0xf491e7b69e4244ad4002bc14e878a34207e38c29.getAmountsOut(uint256 arg1, address[] arg2) with:
            gas gas_remaining wei
           args arg1, Array(len=2, data=mem[292 len 64])
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    mem[192 len return_data.size] = ext_call.return_data[0 len return_data.size]
    mem[64] = ceil32(return_data.size) + 192
    require return_data.size >= 32
    _29 = mem[192 len 4], Mask(224, 32, arg1) >> 32
    require mem[192 len 4], Mask(224, 32, arg1) >> 32 <= test266151307()
    require return_data.size + 192 > mem[192 len 4], Mask(224, 32, arg1) >> 32 + 223
    _30 = mem[mem[192 len 4], Mask(224, 32, arg1) >> 32 + 192]
    require mem[mem[192 len 4], Mask(224, 32, arg1) >> 32 + 192] <= test266151307()
    require (32 * mem[mem[192 len 4], Mask(224, 32, arg1) >> 32 + 192]) + 32 >= 0 and ceil32(return_data.size) + (32 * mem[mem[192 len 4], Mask(224, 32, arg1) >> 32 + 192]) + 224 <= test266151307()
    mem[64] = ceil32(return_data.size) + (32 * mem[mem[192 len 4], Mask(224, 32, arg1) >> 32 + 192]) + 224
    mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg1) >> 32 + 192]
    require return_data.size >= _29 + (32 * _30) + 32
    mem[ceil32(return_data.size) + 224 len 32 * _30] = mem[_29 + 224 len 32 * _30]
    require _30 - 1 < _30
    mem[mem[64]] = mem[(32 * _30 - 1) + ceil32(return_data.size) + 224]
    return memory
      from mem[64]
       len 32
}

function estimatedAPR() payable {
    mem[64] = 96
    idx = 0
    s = 0
    while idx < lenders.length:
        mem[0] = 13
        require ext_code.size(lenders[idx])
        staticcall lenders[idx].nav() with:
                gas gas_remaining wei
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _36 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        if mem[_36] + s < s:
            revert with 0, 'SafeMath: addition overflow'
        idx = idx + 1
        s = mem[_36] + s
        continue 
    mem[mem[64] + 4] = this.address
    require ext_code.size(wantAddress)
    staticcall wantAddress.balanceOf(address arg1) with:
            gas gas_remaining wei
           args address(this.address)
    mem[mem[64]] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _37 = mem[64]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 32
    _39 = mem[_37]
    if mem[_37] + (_38 * lenders.length) < _38 * lenders.length:
        revert with 0, 'SafeMath: addition overflow'
    if not mem[_37] + (_38 * lenders.length):
        return 0
    idx = 0
    s = 0
    while idx < lenders.length:
        mem[0] = 13
        require ext_code.size(lenders[idx])
        staticcall lenders[idx].weightedApr() with:
                gas gas_remaining wei
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _66 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _68 = mem[_66]
        if mem[_66] + s < s:
            revert with 0, 'SafeMath: addition overflow'
        idx = idx + 1
        s = mem[_66] + s
        continue 
    _61 = mem[64]
    mem[64] = mem[64] + 64
    mem[_61] = 26
    mem[_61 + 32] = 'SafeMath: division by zero'
    if _39 + (_38 * lenders.length):
        return (_68 * lenders.length / _39 + (_38 * lenders.length))
    _65 = mem[64]
    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
    mem[mem[64] + 4] = 32
    mem[mem[64] + 36] = 26
    s = 0
    while lenders.length < 26:
        mem[lenders.length + _65 + 68] = mem[lenders.length + _61 + 32]
        s = lenders.length + 32
        continue 
    if lenders.length > 26:
        mem[_65 + 94] = 0
    revert with memory
      from mem[64]
       len _65 + -mem[64] + 100
}

function estimateAdjustPosition() payable {
    mem[100] = this.address
    require ext_code.size(wantAddress)
    staticcall wantAddress.balanceOf(address arg1) with:
            gas gas_remaining wei
           args this.address
    mem[96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    mem[64] = ceil32(return_data.size) + 96
    require return_data.size >= 32
    idx = 0
    s = 0
    t = -1
    while idx < lenders.length:
        mem[0] = 13
        require ext_code.size(lenders[idx])
        staticcall lenders[idx].hasAssets() with:
                gas gas_remaining wei
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _31 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        require mem[_31] == bool(mem[_31])
        if not mem[_31]:
            idx = idx + 1
            s = s
            t = t
            continue 
        require idx < lenders.length
        mem[0] = 13
        require ext_code.size(lenders[idx])
        staticcall lenders[idx].apr() with:
                gas gas_remaining wei
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _42 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _43 = mem[_42]
        if mem[_42] >= t:
            idx = idx + 1
            s = s
            t = t
            continue 
        require idx < lenders.length
        mem[0] = 13
        require ext_code.size(lenders[idx])
        staticcall lenders[idx].nav() with:
                gas gas_remaining wei
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _47 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        idx = idx + 1
        s = mem[_47]
        t = _43
        continue 
    if ext_call.return_data[0] + s < s:
        revert with 0, 'SafeMath: addition overflow'
    idx = 0
    u = 0
    while idx < lenders.length:
        mem[0] = 13
        mem[mem[64] + 4] = ext_call.return_data[0]
        require ext_code.size(lenders[idx])
        staticcall lenders[idx].aprAfterDeposit(uint256 arg1) with:
                gas gas_remaining wei
               args ext_call.return_data[0]
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _56 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        if mem[_56] <= u:
            idx = idx + 1
            u = u
            continue 
        idx = idx + 1
        u = mem[_56]
        continue 
    require 0 < lenders.length
    mem[0] = 13
    mem[mem[64] + 4] = ext_call.return_data[0] + s
    require ext_code.size(lenders)
    staticcall lenders.aprAfterDeposit(uint256 arg1) with:
            gas gas_remaining wei
           args (ext_call.return_data[0] + s)
    mem[mem[64]] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _55 = mem[64]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 32
    return 0, t, 0, mem[_55]
}

function initialize(address arg1, address arg2, address arg3, address arg4) payable {
    require calldata.size - 4 >= 128
    require arg1 == arg1
    require arg2 == arg2
    require arg3 == arg3
    require arg4 == arg4
    if wantAddress:
        revert with 0, 'Strategy already initialized'
    vaultAddress = arg1
    require ext_code.size(arg1)
    staticcall arg1.token() with:
            gas gas_remaining wei
    mem[96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    wantAddress = ext_call.return_data[12 len 20]
    mem[ceil32(return_data.size) + 100] = this.address
    mem[ceil32(return_data.size) + 132] = arg1
    require ext_code.size(address(ext_call.return_data[0]))
    staticcall address(ext_call.return_data[0]).allowance(address arg1, address arg2) with:
            gas gas_remaining wei
           args address(this.address), arg1
    mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if ext_call.return_data[0]:
        revert with 0, 'SafeERC20: approve from non-zero to non-zero allowance'
    mem[(2 * ceil32(return_data.size)) + 132] = arg1
    mem[(2 * ceil32(return_data.size)) + 164] = -1
    mem[(2 * ceil32(return_data.size)) + 96] = 68
    mem[(2 * ceil32(return_data.size)) + 132 len 28] = address(arg1) << 64
    mem[(2 * ceil32(return_data.size)) + 128 len 4] = approve(address arg1, uint256 arg2)
    mem[(2 * ceil32(return_data.size)) + 196] = 32
    mem[(2 * ceil32(return_data.size)) + 228] = 'SafeERC20: low-level call failed'
    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(address(ext_call.return_data[0])):
        revert with 0, 'Address: call to non-contract'
    if not ext_code.hash(address(ext_call.return_data[0])):
        revert with 0, 'Address: call to non-contract'
    mem[(2 * ceil32(return_data.size)) + 260 len 96] = approve(address arg1, uint256 arg2), address(arg1) << 64, 0, -1, 0
    mem[(2 * ceil32(return_data.size)) + 328] = 0
    call address(ext_call.return_data[0]) with:
       funct Mask(32, 224, approve(address arg1, uint256 arg2), address(arg1) << 64, 0, -1, 0) >> 224
         gas gas_remaining wei
        args (Mask(512, -288, approve(address arg1, uint256 arg2), address(arg1) << 64, 0, -1, 0) << 288)
    if not return_data.size:
        if not ext_call.success:
            if ext_call.return_data[0]:
                revert with memory
                  from 128
                   len ext_call.return_data[0]
            revert with 0, 'SafeERC20: low-level call failed'
        if ext_call.return_data[0]:
            require ext_call.return_data[0] >= 32
            require mem[128] == bool(mem[128])
            if not mem[128]:
                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
    else:
        mem[(2 * ceil32(return_data.size)) + 292 len return_data.size] = ext_call.return_data[0 len return_data.size]
        if not ext_call.success:
            if return_data.size:
                revert with ext_call.return_data[0 len return_data.size]
            revert with 0, 'SafeERC20: low-level call failed'
        if return_data.size:
            require return_data.size >= 32
            require mem[(2 * ceil32(return_data.size)) + 292] == bool(mem[(2 * ceil32(return_data.size)) + 292])
            if not mem[(2 * ceil32(return_data.size)) + 292]:
                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
    strategistAddress = arg2
    rewardsAddress = arg3
    keeperAddress = arg4
    minReportDelay = 0
    maxReportDelay = 24 * 3600
    profitFactor = 100
    debtThreshold = 0
    require ext_code.size(vaultAddress)
    call vaultAddress.approve(address arg1, uint256 arg2) with:
         gas gas_remaining wei
        args address(arg3), -1
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
}

function sweep(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    require ext_code.size(vaultAddress)
    staticcall vaultAddress.governance() with:
            gas gas_remaining wei
    mem[96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    if ext_call.return_data[12 len 20] != msg.sender:
        revert with 0, '!authorized'
    if wantAddress == arg1:
        revert with 0, '!want'
    if vaultAddress == arg1:
        revert with 0, '!shares'
    mem[ceil32(return_data.size) + 96] = 1
    mem[ceil32(return_data.size) + 128] = wantAddress
    idx = 0
    while idx < 1:
        require idx < 1
        if arg1 == mem[(32 * idx) + ceil32(return_data.size) + 140 len 20]:
            revert with 0, '!protected'
        idx = idx + 1
        continue 
    require ext_code.size(vaultAddress)
    staticcall vaultAddress.governance() with:
            gas gas_remaining wei
    mem[ceil32(return_data.size) + 160] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    mem[(2 * ceil32(return_data.size)) + 164] = this.address
    require ext_code.size(arg1)
    staticcall arg1.balanceOf(address arg1) with:
            gas gas_remaining wei
           args mem[(2 * ceil32(return_data.size)) + 164 len ceil32(return_data.size) + 32]
    mem[(2 * ceil32(return_data.size)) + 160] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    mem[(4 * ceil32(return_data.size)) + 196] = address(ext_call.return_data[0])
    mem[(4 * ceil32(return_data.size)) + 228] = ext_call.return_data[0]
    mem[(4 * ceil32(return_data.size)) + 160] = (5 * ceil32(return_data.size)) + 68
    mem[(4 * ceil32(return_data.size)) + 196 len 28] = address(ext_call.return_data[0]) << 64
    mem[(4 * ceil32(return_data.size)) + 192 len 4] = transfer(address arg1, uint256 arg2)
    mem[(4 * ceil32(return_data.size)) + 260] = 32
    mem[(4 * ceil32(return_data.size)) + 292] = 'SafeERC20: low-level call failed'
    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
        revert with 0, 'Address: call to non-contract'
    if not ext_code.hash(arg1):
        revert with 0, 'Address: call to non-contract'
    mem[(4 * ceil32(return_data.size)) + 324 len floor32((5 * ceil32(return_data.size)) + 99)] = transfer(address arg1, uint256 arg2), address(ext_call.return_data[0]) << 64, 0, ext_call.return_data[0], mem[(4 * ceil32(return_data.size)) + 260 len floor32((5 * ceil32(return_data.size)) + 99) - 68]
    if floor32((5 * ceil32(return_data.size)) + 99) > (5 * ceil32(return_data.size)) + 68:
        mem[(10 * ceil32(return_data.size)) + 392] = 0
    call arg1.mem[(4 * ceil32(return_data.size)) + 324 len 4] with:
         gas gas_remaining wei
        args mem[(4 * ceil32(return_data.size)) + 328 len (13 * ceil32(return_data.size)) + 64]
    if not return_data.size:
        if not ext_call.success:
            if ext_call.return_data[0]:
                revert with memory
                  from 128
                   len ext_call.return_data[0]
            revert with 0, 'SafeERC20: low-level call failed'
        if ext_call.return_data[0]:
            require ext_call.return_data[0] >= 32
            require mem[128] == bool(mem[128])
            if not mem[128]:
                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
    else:
        mem[(4 * ceil32(return_data.size)) + 356 len return_data.size] = ext_call.return_data[0 len return_data.size]
        if not ext_call.success:
            if return_data.size:
                revert with ext_call.return_data[0 len return_data.size]
            revert with 0, 'SafeERC20: low-level call failed'
        if return_data.size:
            require return_data.size >= 32
            require mem[(4 * ceil32(return_data.size)) + 356] == bool(mem[(4 * ceil32(return_data.size)) + 356])
            if not mem[(4 * ceil32(return_data.size)) + 356]:
                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
}

function lendStatuses() payable {
    require lenders.length <= test266151307()
    mem[96] = lenders.length
    mem[64] = (32 * lenders.length) + 128
    if not lenders.length:
        idx = 0
        while idx < lenders.length:
            _97 = mem[64]
            mem[64] = mem[64] + 128
            mem[_97] = 96
            mem[_97 + 32] = 0
            mem[_97 + 64] = 0
            mem[_97 + 96] = 0
            mem[0] = 13
            mem[mem[64]] = 0x8b20217600000000000000000000000000000000000000000000000000000000
            require ext_code.size(lenders[idx])
            staticcall lenders[idx].lenderName() with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _106 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _109 = mem[_106]
            require mem[_106] <= test266151307()
            require _106 + mem[_106] + 31 < _106 + return_data.size
            _115 = mem[_106 + mem[_106]]
            require mem[_106 + mem[_106]] <= test266151307()
            require ceil32(mem[_106 + mem[_106]]) + 32 >= 0 and _106 + ceil32(return_data.size) + ceil32(mem[_106 + mem[_106]]) + 32 <= test266151307()
            mem[64] = _106 + ceil32(return_data.size) + ceil32(mem[_106 + mem[_106]]) + 32
            mem[_106 + ceil32(return_data.size)] = _115
            require _109 + _115 + 32 <= return_data.size
            s = 0
            while s < _115:
                mem[s + _106 + ceil32(return_data.size) + 32] = mem[s + _106 + _109 + 32]
                s = s + 32
                continue 
            if ceil32(_115) <= _115:
                mem[_97] = _106 + ceil32(return_data.size)
                require idx < lenders.length
                mem[_97 + 96] = lenders[idx]
                mem[0] = 13
                require ext_code.size(lenders[idx])
                staticcall lenders[idx].nav() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _212 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[_97 + 32] = mem[_212]
                require idx < lenders.length
                mem[0] = 13
                require ext_code.size(lenders[idx])
                staticcall lenders[idx].apr() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _232 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[_97 + 64] = mem[_232]
            else:
                mem[_115 + _106 + ceil32(return_data.size) + 32] = 0
                mem[_97] = _106 + ceil32(return_data.size)
                require idx < lenders.length
                mem[_97 + 96] = lenders[idx]
                mem[0] = 13
                require ext_code.size(lenders[idx])
                staticcall lenders[idx].nav() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _213 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[_97 + 32] = mem[_213]
                require idx < lenders.length
                mem[0] = 13
                require ext_code.size(lenders[idx])
                staticcall lenders[idx].apr() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _233 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[_97 + 64] = mem[_233]
            require idx < mem[96]
            mem[(32 * idx) + 128] = _97
            idx = idx + 1
            continue 
        _96 = mem[64]
        mem[mem[64]] = 32
        _98 = mem[96]
        mem[mem[64] + 32] = mem[96]
        idx = 0
        s = 128
        t = mem[64] + (32 * mem[96]) + 64
        u = mem[64] + 64
        while idx < _98:
            mem[u] = t + -_96 - 64
            _189 = mem[s]
            _190 = mem[mem[s]]
            mem[t] = 128
            _193 = mem[_190]
            mem[t + 128] = mem[_190]
            v = 0
            while v < _193:
                mem[v + t + 160] = mem[v + _190 + 32]
                v = v + 32
                continue 
            if ceil32(_193) > _193:
                mem[_193 + t + 160] = 0
            mem[t + 32] = mem[_189 + 32]
            mem[t + 64] = mem[_189 + 64]
            mem[t + 96] = mem[_189 + 108 len 20]
            idx = idx + 1
            s = s + 32
            t = ceil32(_193) + t + 160
            u = u + 32
            continue 
    else:
        mem[64] = (32 * lenders.length) + 256
        mem[(32 * lenders.length) + 128] = 96
        mem[(32 * lenders.length) + 160] = 0
        mem[(32 * lenders.length) + 192] = 0
        mem[(32 * lenders.length) + 224] = 0
        mem[var8001] = (32 * lenders.length) + 128
        s = var8001
        idx = var8002
        while idx - 1:
            mem[64] = mem[64] + 128
            mem[(32 * lenders.length) + 128] = 96
            mem[(32 * lenders.length) + 160] = 0
            mem[(32 * lenders.length) + 192] = 0
            mem[(32 * lenders.length) + 224] = 0
            mem[s + 32] = (32 * lenders.length) + 128
            s = s + 32
            idx = idx - 1
            continue 
        idx = 0
        while idx < lenders.length:
            _273 = mem[64]
            mem[64] = mem[64] + 128
            mem[_273] = 96
            mem[_273 + 32] = 0
            mem[_273 + 64] = 0
            mem[_273 + 96] = 0
            mem[0] = 13
            mem[mem[64]] = 0x8b20217600000000000000000000000000000000000000000000000000000000
            require ext_code.size(lenders[idx])
            staticcall lenders[idx].lenderName() with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _288 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _289 = mem[_288]
            require mem[_288] <= test266151307()
            require _288 + mem[_288] + 31 < _288 + return_data.size
            _291 = mem[_288 + mem[_288]]
            require mem[_288 + mem[_288]] <= test266151307()
            require ceil32(mem[_288 + mem[_288]]) + 32 >= 0 and _288 + ceil32(return_data.size) + ceil32(mem[_288 + mem[_288]]) + 32 <= test266151307()
            mem[64] = _288 + ceil32(return_data.size) + ceil32(mem[_288 + mem[_288]]) + 32
            mem[_288 + ceil32(return_data.size)] = _291
            require _289 + _291 + 32 <= return_data.size
            s = 0
            while s < _291:
                mem[s + _288 + ceil32(return_data.size) + 32] = mem[s + _288 + _289 + 32]
                s = s + 32
                continue 
            if ceil32(_291) <= _291:
                mem[_273] = _288 + ceil32(return_data.size)
                require idx < lenders.length
                mem[_273 + 96] = lenders[idx]
                mem[0] = 13
                require ext_code.size(lenders[idx])
                staticcall lenders[idx].nav() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _344 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[_273 + 32] = mem[_344]
                require idx < lenders.length
                mem[0] = 13
                require ext_code.size(lenders[idx])
                staticcall lenders[idx].apr() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _354 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[_273 + 64] = mem[_354]
            else:
                mem[_291 + _288 + ceil32(return_data.size) + 32] = 0
                mem[_273] = _288 + ceil32(return_data.size)
                require idx < lenders.length
                mem[_273 + 96] = lenders[idx]
                mem[0] = 13
                require ext_code.size(lenders[idx])
                staticcall lenders[idx].nav() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _345 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[_273 + 32] = mem[_345]
                require idx < lenders.length
                mem[0] = 13
                require ext_code.size(lenders[idx])
                staticcall lenders[idx].apr() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _355 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[_273 + 64] = mem[_355]
            require idx < mem[96]
            mem[(32 * idx) + 128] = _273
            idx = idx + 1
            continue 
        _272 = mem[64]
        mem[mem[64]] = 32
        _274 = mem[96]
        mem[mem[64] + 32] = mem[96]
        idx = 0
        s = 128
        t = mem[64] + (32 * mem[96]) + 64
        u = mem[64] + 64
        while idx < _274:
            mem[u] = t + -_272 - 64
            _324 = mem[s]
            _325 = mem[mem[s]]
            mem[t] = 128
            _328 = mem[_325]
            mem[t + 128] = mem[_325]
            v = 0
            while v < _328:
                mem[v + t + 160] = mem[v + _325 + 32]
                v = v + 32
                continue 
            if ceil32(_328) > _328:
                mem[_328 + t + 160] = 0
            mem[t + 32] = mem[_324 + 32]
            mem[t + 64] = mem[_324 + 64]
            mem[t + 96] = mem[_324 + 108 len 20]
            idx = idx + 1
            s = s + 32
            t = ceil32(_328) + t + 160
            u = u + 32
            continue 
    return memory
      from mem[64]
       len t - mem[64]
}

function estimatedFutureAPR(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    require ext_code.size(vaultAddress)
    staticcall vaultAddress.strategies(address arg1) with:
            gas gas_remaining wei
           args this.address
    mem[96 len 288] = ext_call.return_data[0 len 288]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 288
    require bool(ceil32(return_data.size) + 384 <= test266151307())
    mem[64] = ceil32(return_data.size) + 384
    mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
    mem[ceil32(return_data.size) + 128] = ext_call.return_data[32]
    mem[ceil32(return_data.size) + 160] = ext_call.return_data[64]
    mem[ceil32(return_data.size) + 192] = ext_call.return_data[96]
    mem[ceil32(return_data.size) + 224] = ext_call.return_data[128]
    mem[ceil32(return_data.size) + 256] = ext_call.return_data[160]
    mem[ceil32(return_data.size) + 288] = ext_call.return_data[192]
    mem[ceil32(return_data.size) + 320] = ext_call.return_data[224]
    mem[ceil32(return_data.size) + 352] = ext_call.return_data[256]
    if ext_call.return_data[192] >= arg1:
        idx = 0
        s = -1
        while idx < lenders.length:
            mem[0] = 13
            mem[mem[64] + 4] = ext_call.return_data[192] - arg1
            require ext_code.size(lenders[idx])
            staticcall lenders[idx].aprAfterDeposit(uint256 arg1) with:
                    gas gas_remaining wei
                   args (ext_call.return_data[192] - arg1)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _75 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            if mem[_75] >= s:
                idx = idx + 1
                s = s
                continue 
            idx = idx + 1
            s = mem[_75]
            continue 
        idx = 0
        t = ext_call.return_data[192] - arg1
        while idx < lenders.length:
            require idx < lenders.length
            mem[0] = 13
            require ext_code.size(lenders[idx])
            if idx:
                staticcall lenders[idx].weightedApr() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _157 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if mem[_157] < 0:
                    revert with 0, 'SafeMath: addition overflow'
                idx = idx + 1
                t = t
                continue 
            staticcall lenders[idx].nav() with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _156 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            if mem[_156] >= t:
                if s:
                    if t * s / s != t:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if t * s < 0:
                        revert with 0, 'SafeMath: addition overflow'
                idx = idx + 1
                t = t
                continue 
            if s:
                if mem[_156] * s / s != mem[_156]:
                    revert with 0, 'SafeMath: multiplication overflow'
                if mem[_156] * s < 0:
                    revert with 0, 'SafeMath: addition overflow'
            idx = idx + 1
            t = mem[_156]
            continue 
        idx = 0
        s = 0
        while idx < lenders.length:
            mem[0] = 13
            require ext_code.size(lenders[idx])
            staticcall lenders[idx].nav() with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _260 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            if mem[_260] + s < s:
                revert with 0, 'SafeMath: addition overflow'
            idx = idx + 1
            s = mem[_260] + s
            continue 
        mem[mem[64] + 4] = this.address
        require ext_code.size(wantAddress)
        staticcall wantAddress.balanceOf(address arg1) with:
                gas gas_remaining wei
               args address(this.address)
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _265 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        if mem[_265] + (_266 * lenders.length) < _266 * lenders.length:
            revert with 0, 'SafeMath: addition overflow'
        if t < 0:
            revert with 0, 'SafeMath: addition overflow'
        if not t + mem[_265] + (_266 * lenders.length):
            revert with 0, 'SafeMath: division by zero', 0
        return (0 / t + mem[_265] + (_266 * lenders.length))
    idx = 0
    s = 0
    t = 0
    while idx < lenders.length:
        mem[0] = 13
        mem[mem[64] + 4] = arg1 - ext_call.return_data[192]
        require ext_code.size(lenders[idx])
        staticcall lenders[idx].aprAfterDeposit(uint256 arg1) with:
                gas gas_remaining wei
               args (arg1 - ext_call.return_data[192])
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _76 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _81 = mem[_76]
        if mem[_76] <= t:
            idx = idx + 1
            s = s
            t = t
            continue 
        require idx < lenders.length
        mem[0] = 13
        require ext_code.size(lenders[idx])
        staticcall lenders[idx].nav() with:
                gas gas_remaining wei
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _89 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        idx = idx + 1
        s = mem[_89]
        t = _81
        continue 
    if arg1 - ext_call.return_data[192] + s < s:
        revert with 0, 'SafeMath: addition overflow'
    if not t:
        idx = 0
        while idx < lenders.length:
            if idx:
                require idx < lenders.length
                mem[0] = 13
                require ext_code.size(lenders[idx])
                staticcall lenders[idx].weightedApr() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _159 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if mem[_159] < 0:
                    revert with 0, 'SafeMath: addition overflow'
            idx = idx + 1
            continue 
        idx = 0
        s = 0
        while idx < lenders.length:
            mem[0] = 13
            require ext_code.size(lenders[idx])
            staticcall lenders[idx].nav() with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _264 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            if mem[_264] + s < s:
                revert with 0, 'SafeMath: addition overflow'
            idx = idx + 1
            s = mem[_264] + s
            continue 
        mem[mem[64] + 4] = this.address
        require ext_code.size(wantAddress)
        staticcall wantAddress.balanceOf(address arg1) with:
                gas gas_remaining wei
               args address(this.address)
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _269 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        if mem[_269] + (_270 * lenders.length) < _270 * lenders.length:
            revert with 0, 'SafeMath: addition overflow'
        if arg1 - ext_call.return_data[192] < 0:
            revert with 0, 'SafeMath: addition overflow'
        if not arg1 - ext_call.return_data[192] + mem[_269] + (_270 * lenders.length):
            revert with 0, 'SafeMath: division by zero', 0
        return (0 / arg1 - ext_call.return_data[192] + mem[_269] + (_270 * lenders.length))
    if (arg1 * t) - (ext_call.return_data[192] * t) + (s * t) / t != arg1 - ext_call.return_data[192] + s:
        revert with 0, 'SafeMath: multiplication overflow'
    idx = 0
    while idx < lenders.length:
        if idx:
            require idx < lenders.length
            mem[0] = 13
            require ext_code.size(lenders[idx])
            staticcall lenders[idx].weightedApr() with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _158 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            if mem[_158] < 0:
                revert with 0, 'SafeMath: addition overflow'
        idx = idx + 1
        continue 
    idx = 0
    u = 0
    while idx < lenders.length:
        mem[0] = 13
        require ext_code.size(lenders[idx])
        staticcall lenders[idx].nav() with:
                gas gas_remaining wei
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _262 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        if mem[_262] + u < u:
            revert with 0, 'SafeMath: addition overflow'
        idx = idx + 1
        u = mem[_262] + u
        continue 
    mem[mem[64] + 4] = this.address
    require ext_code.size(wantAddress)
    staticcall wantAddress.balanceOf(address arg1) with:
            gas gas_remaining wei
           args address(this.address)
    mem[mem[64]] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _267 = mem[64]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 32
    if mem[_267] + (_268 * lenders.length) < _268 * lenders.length:
        revert with 0, 'SafeMath: addition overflow'
    if arg1 - ext_call.return_data[192] < 0:
        revert with 0, 'SafeMath: addition overflow'
    if not arg1 - ext_call.return_data[192] + mem[_267] + (_268 * lenders.length):
        revert with 0, 'SafeMath: division by zero', 0
    return ((arg1 * t) - (ext_call.return_data[192] * t) + (s * t) / arg1 - ext_call.return_data[192] + mem[_267] + (_268 * lenders.length))
}

function harvestTrigger(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83 == wantAddress:
        mem[96] = 0
        mem[128] = 0
        mem[160] = 0
        mem[192] = 0
        mem[224] = 0
        mem[256] = 0
        mem[288] = 0
        mem[320] = 0
        mem[352] = 0
        require ext_code.size(vaultAddress)
        staticcall vaultAddress.strategies(address arg1) with:
                gas gas_remaining wei
               args this.address
        mem[384 len 288] = ext_call.return_data[0 len 288]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 288
        require bool(ceil32(return_data.size) + 672 <= test266151307())
        mem[ceil32(return_data.size) + 384] = ext_call.return_data[0]
        mem[ceil32(return_data.size) + 416] = ext_call.return_data[32]
        mem[ceil32(return_data.size) + 448] = ext_call.return_data[64]
        mem[ceil32(return_data.size) + 480] = ext_call.return_data[96]
        mem[ceil32(return_data.size) + 512] = ext_call.return_data[128]
        mem[ceil32(return_data.size) + 544] = ext_call.return_data[160]
        mem[ceil32(return_data.size) + 576] = ext_call.return_data[192]
        mem[ceil32(return_data.size) + 608] = ext_call.return_data[224]
        mem[ceil32(return_data.size) + 640] = ext_call.return_data[256]
        if 0 == ext_call.return_data[32]:
            return 0
        mem[ceil32(return_data.size) + 672] = 30
        mem[ceil32(return_data.size) + 704] = 'SafeMath: subtraction overflow'
        if ext_call.return_data[160] > block.timestamp:
            revert with 0, 'SafeMath: subtraction overflow', 0
        if block.timestamp - ext_call.return_data[160] < minReportDelay:
            return 0
        mem[ceil32(return_data.size) + 736] = 30
        mem[ceil32(return_data.size) + 768] = 'SafeMath: subtraction overflow'
        if ext_call.return_data[160] > block.timestamp:
            revert with 0, 'SafeMath: subtraction overflow', 0
        if block.timestamp - ext_call.return_data[160] >= maxReportDelay:
            return 1
        require ext_code.size(vaultAddress)
        staticcall vaultAddress.debtOutstanding() with:
                gas gas_remaining wei
        mem[ceil32(return_data.size) + 800] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        mem[64] = (2 * ceil32(return_data.size)) + 800
        require return_data.size >= 32
        if ext_call.return_data[0] > debtThreshold:
            return 1
        idx = 0
        s = 0
        while idx < lenders.length:
            mem[0] = 13
            require ext_code.size(lenders[idx])
            staticcall lenders[idx].nav() with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _311 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            if mem[_311] + s < s:
                revert with 0, 'SafeMath: addition overflow'
            idx = idx + 1
            s = mem[_311] + s
            continue 
        mem[mem[64] + 4] = this.address
        require ext_code.size(wantAddress)
        staticcall wantAddress.balanceOf(address arg1) with:
                gas gas_remaining wei
               args address(this.address)
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _323 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _327 = mem[_323]
        if mem[_323] + (_324 * lenders.length) < _324 * lenders.length:
            revert with 0, 'SafeMath: addition overflow'
        if debtThreshold < 0:
            revert with 0, 'SafeMath: addition overflow'
        if debtThreshold + mem[_323] + (_324 * lenders.length) < mem[ceil32(return_data.size) + 576]:
            return 1
        if mem[_323] + (_324 * lenders.length) <= mem[ceil32(return_data.size) + 576]:
            require ext_code.size(vaultAddress)
            staticcall vaultAddress.creditAvailable() with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _360 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            if mem[_360] < mem[_360]:
                revert with 0, 'SafeMath: addition overflow'
            if not profitFactor:
                mem[mem[64]] = 0 < mem[_360]
            else:
                if arg1 * profitFactor / profitFactor != arg1:
                    revert with 0, 'SafeMath: multiplication overflow'
                mem[mem[64]] = arg1 * profitFactor < mem[_360]
        else:
            _353 = mem[ceil32(return_data.size) + 576]
            _357 = mem[64]
            mem[64] = mem[64] + 64
            mem[_357] = 30
            mem[_357 + 32] = 'SafeMath: subtraction overflow'
            if _353 > _327 + (_324 * lenders.length):
                revert with 0, 'SafeMath: subtraction overflow', 0
            require ext_code.size(vaultAddress)
            staticcall vaultAddress.creditAvailable() with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _381 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            if _327 + (_324 * lenders.length) - _353 + mem[_381] < mem[_381]:
                revert with 0, 'SafeMath: addition overflow'
            if not profitFactor:
                mem[mem[64]] = 0 < _327 + (_324 * lenders.length) - _353 + mem[_381]
            else:
                if arg1 * profitFactor / profitFactor != arg1:
                    revert with 0, 'SafeMath: multiplication overflow'
                mem[mem[64]] = arg1 * profitFactor < _327 + (_324 * lenders.length) - _353 + mem[_381]
    else:
        if wantToEthOracleAddress:
            mem[100] = arg1
            require ext_code.size(wantToEthOracleAddress)
            staticcall wantToEthOracleAddress.0x780022a0 with:
                    gas gas_remaining wei
                   args arg1
            mem[96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            mem[ceil32(return_data.size) + 96] = 0
            mem[ceil32(return_data.size) + 128] = 0
            mem[ceil32(return_data.size) + 160] = 0
            mem[ceil32(return_data.size) + 192] = 0
            mem[ceil32(return_data.size) + 224] = 0
            mem[ceil32(return_data.size) + 256] = 0
            mem[ceil32(return_data.size) + 288] = 0
            mem[ceil32(return_data.size) + 320] = 0
            mem[ceil32(return_data.size) + 352] = 0
            require ext_code.size(vaultAddress)
            staticcall vaultAddress.strategies(address arg1) with:
                    gas gas_remaining wei
                   args this.address
            mem[ceil32(return_data.size) + 384 len 288] = ext_call.return_data[0 len 288]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 288
            require bool((2 * ceil32(return_data.size)) + 672 <= test266151307())
            mem[(2 * ceil32(return_data.size)) + 384] = ext_call.return_data[0]
            mem[(2 * ceil32(return_data.size)) + 416] = ext_call.return_data[32]
            mem[(2 * ceil32(return_data.size)) + 448] = ext_call.return_data[64]
            mem[(2 * ceil32(return_data.size)) + 480] = ext_call.return_data[96]
            mem[(2 * ceil32(return_data.size)) + 512] = ext_call.return_data[128]
            mem[(2 * ceil32(return_data.size)) + 544] = ext_call.return_data[160]
            mem[(2 * ceil32(return_data.size)) + 576] = ext_call.return_data[192]
            mem[(2 * ceil32(return_data.size)) + 608] = ext_call.return_data[224]
            mem[(2 * ceil32(return_data.size)) + 640] = ext_call.return_data[256]
            if 0 == ext_call.return_data[32]:
                return 0
            mem[(2 * ceil32(return_data.size)) + 672] = 30
            mem[(2 * ceil32(return_data.size)) + 704] = 'SafeMath: subtraction overflow'
            if ext_call.return_data[160] > block.timestamp:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if block.timestamp - ext_call.return_data[160] < minReportDelay:
                return 0
            mem[(2 * ceil32(return_data.size)) + 736] = 30
            mem[(2 * ceil32(return_data.size)) + 768] = 'SafeMath: subtraction overflow'
            if ext_call.return_data[160] > block.timestamp:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if block.timestamp - ext_call.return_data[160] >= maxReportDelay:
                return 1
            require ext_code.size(vaultAddress)
            staticcall vaultAddress.debtOutstanding() with:
                    gas gas_remaining wei
            mem[(2 * ceil32(return_data.size)) + 800] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[64] = (4 * ceil32(return_data.size)) + 800
            require return_data.size >= 32
            if ext_call.return_data[0] > debtThreshold:
                return 1
            idx = 0
            s = 0
            while idx < lenders.length:
                mem[0] = 13
                require ext_code.size(lenders[idx])
                staticcall lenders[idx].nav() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _309 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if mem[_309] + s < s:
                    revert with 0, 'SafeMath: addition overflow'
                idx = idx + 1
                s = mem[_309] + s
                continue 
            mem[mem[64] + 4] = this.address
            require ext_code.size(wantAddress)
            staticcall wantAddress.balanceOf(address arg1) with:
                    gas gas_remaining wei
                   args address(this.address)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _321 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _326 = mem[_321]
            if mem[_321] + (_322 * lenders.length) < _322 * lenders.length:
                revert with 0, 'SafeMath: addition overflow'
            if debtThreshold < 0:
                revert with 0, 'SafeMath: addition overflow'
            if debtThreshold + mem[_321] + (_322 * lenders.length) < mem[(2 * ceil32(return_data.size)) + 576]:
                return 1
            if mem[_321] + (_322 * lenders.length) <= mem[(2 * ceil32(return_data.size)) + 576]:
                require ext_code.size(vaultAddress)
                staticcall vaultAddress.creditAvailable() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _359 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if mem[_359] < mem[_359]:
                    revert with 0, 'SafeMath: addition overflow'
                if not profitFactor:
                    mem[mem[64]] = 0 < mem[_359]
                else:
                    if ext_call.return_data[0] * profitFactor / profitFactor != ext_call.return_data[0]:
                        revert with 0, 'SafeMath: multiplication overflow'
                    mem[mem[64]] = ext_call.return_data[0] * profitFactor < mem[_359]
            else:
                _350 = mem[(2 * ceil32(return_data.size)) + 576]
                _355 = mem[64]
                mem[64] = mem[64] + 64
                mem[_355] = 30
                mem[_355 + 32] = 'SafeMath: subtraction overflow'
                if _350 > _326 + (_322 * lenders.length):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                require ext_code.size(vaultAddress)
                staticcall vaultAddress.creditAvailable() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _379 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if _326 + (_322 * lenders.length) - _350 + mem[_379] < mem[_379]:
                    revert with 0, 'SafeMath: addition overflow'
                if not profitFactor:
                    mem[mem[64]] = 0 < _326 + (_322 * lenders.length) - _350 + mem[_379]
                else:
                    if ext_call.return_data[0] * profitFactor / profitFactor != ext_call.return_data[0]:
                        revert with 0, 'SafeMath: multiplication overflow'
                    mem[mem[64]] = ext_call.return_data[0] * profitFactor < _326 + (_322 * lenders.length) - _350 + mem[_379]
        else:
            mem[96] = 2
            mem[128] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
            mem[160] = wantAddress
            mem[192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
            mem[196] = arg1
            mem[228] = 64
            mem[260] = 2
            idx = 0
            s = 292
            t = 128
            while idx < 2:
                mem[s] = mem[t + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            require ext_code.size(0xf491e7b69e4244ad4002bc14e878a34207e38c29)
            staticcall 0xf491e7b69e4244ad4002bc14e878a34207e38c29.getAmountsOut(uint256 arg1, address[] arg2) with:
                    gas gas_remaining wei
                   args arg1, Array(len=2, data=mem[292 len 64])
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[192 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(return_data.size) + 192
            require return_data.size >= 32
            _320 = mem[192 len 4], Mask(224, 32, arg1) >> 32
            require mem[192 len 4], Mask(224, 32, arg1) >> 32 <= test266151307()
            require return_data.size + 192 > mem[192 len 4], Mask(224, 32, arg1) >> 32 + 223
            _325 = mem[mem[192 len 4], Mask(224, 32, arg1) >> 32 + 192]
            require mem[mem[192 len 4], Mask(224, 32, arg1) >> 32 + 192] <= test266151307()
            require (32 * mem[mem[192 len 4], Mask(224, 32, arg1) >> 32 + 192]) + 32 >= 0 and ceil32(return_data.size) + (32 * mem[mem[192 len 4], Mask(224, 32, arg1) >> 32 + 192]) + 224 <= test266151307()
            mem[64] = ceil32(return_data.size) + (32 * mem[mem[192 len 4], Mask(224, 32, arg1) >> 32 + 192]) + 224
            mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg1) >> 32 + 192]
            require return_data.size >= _320 + (32 * _325) + 32
            mem[ceil32(return_data.size) + 224 len 32 * _325] = mem[_320 + 224 len 32 * _325]
            require _325 - 1 < _325
            _511 = mem[(32 * _325 - 1) + ceil32(return_data.size) + 224]
            _512 = mem[64]
            mem[64] = mem[64] + 288
            mem[_512] = 0
            mem[_512 + 32] = 0
            mem[_512 + 64] = 0
            mem[_512 + 96] = 0
            mem[_512 + 128] = 0
            mem[_512 + 160] = 0
            mem[_512 + 192] = 0
            mem[_512 + 224] = 0
            mem[_512 + 256] = 0
            require ext_code.size(vaultAddress)
            staticcall vaultAddress.strategies(address arg1) with:
                    gas gas_remaining wei
                   args address(this.address)
            mem[mem[64] len 288] = ext_call.return_data[0 len 288]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _519 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 288
            _520 = mem[64]
            require mem[64] + 288 >= mem[64] and mem[64] + 288 <= test266151307()
            mem[64] = mem[64] + 288
            mem[_520] = mem[_519]
            mem[_520 + 32] = mem[_519 + 32]
            mem[_520 + 64] = mem[_519 + 64]
            mem[_520 + 96] = mem[_519 + 96]
            mem[_520 + 128] = mem[_519 + 128]
            mem[_520 + 160] = mem[_519 + 160]
            mem[_520 + 192] = mem[_519 + 192]
            mem[_520 + 224] = mem[_519 + 224]
            mem[_520 + 256] = mem[_519 + 256]
            if 0 == mem[_520 + 32]:
                return 0
            _531 = mem[_520 + 160]
            _532 = mem[64]
            mem[64] = mem[64] + 64
            mem[_532] = 30
            mem[_532 + 32] = 'SafeMath: subtraction overflow'
            if _531 > block.timestamp:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if block.timestamp - _531 < minReportDelay:
                return 0
            _537 = mem[_520 + 160]
            _538 = mem[64]
            mem[64] = mem[64] + 64
            mem[_538] = 30
            mem[_538 + 32] = 'SafeMath: subtraction overflow'
            if _537 > block.timestamp:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if block.timestamp - _537 >= maxReportDelay:
                return 1
            require ext_code.size(vaultAddress)
            staticcall vaultAddress.debtOutstanding() with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _548 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            if mem[_548] > debtThreshold:
                return 1
            idx = 0
            s = 0
            while idx < lenders.length:
                mem[0] = 13
                require ext_code.size(lenders[idx])
                staticcall lenders[idx].nav() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _614 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _620 = mem[_614]
                if mem[_614] + s < s:
                    revert with 0, 'SafeMath: addition overflow'
                idx = idx + 1
                s = mem[_614] + s
                continue 
            mem[mem[64] + 4] = this.address
            require ext_code.size(wantAddress)
            staticcall wantAddress.balanceOf(address arg1) with:
                    gas gas_remaining wei
                   args address(this.address)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _619 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _621 = mem[_619]
            if mem[_619] + (_620 * lenders.length) < _620 * lenders.length:
                revert with 0, 'SafeMath: addition overflow'
            if debtThreshold < 0:
                revert with 0, 'SafeMath: addition overflow'
            if debtThreshold + mem[_619] + (_620 * lenders.length) < mem[_520 + 192]:
                return 1
            if mem[_619] + (_620 * lenders.length) <= mem[_520 + 192]:
                require ext_code.size(vaultAddress)
                staticcall vaultAddress.creditAvailable() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _635 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if mem[_635] < mem[_635]:
                    revert with 0, 'SafeMath: addition overflow'
                if not profitFactor:
                    mem[mem[64]] = 0 < mem[_635]
                else:
                    if _511 * profitFactor / profitFactor != _511:
                        revert with 0, 'SafeMath: multiplication overflow'
                    mem[mem[64]] = _511 * profitFactor < mem[_635]
            else:
                _632 = mem[_520 + 192]
                _633 = mem[64]
                mem[64] = mem[64] + 64
                mem[_633] = 30
                mem[_633 + 32] = 'SafeMath: subtraction overflow'
                if _632 > _621 + (_620 * lenders.length):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                require ext_code.size(vaultAddress)
                staticcall vaultAddress.creditAvailable() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _643 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if _621 + (_620 * lenders.length) - _632 + mem[_643] < mem[_643]:
                    revert with 0, 'SafeMath: addition overflow'
                if not profitFactor:
                    mem[mem[64]] = 0 < _621 + (_620 * lenders.length) - _632 + mem[_643]
                else:
                    if _511 * profitFactor / profitFactor != _511:
                        revert with 0, 'SafeMath: multiplication overflow'
                    mem[mem[64]] = _511 * profitFactor < _621 + (_620 * lenders.length) - _632 + mem[_643]
    return memory
      from mem[64]
       len 32
}

function withdraw(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if vaultAddress != msg.sender:
        revert with 0, '!vault'
    mem[100] = this.address
    require ext_code.size(wantAddress)
    staticcall wantAddress.balanceOf(address arg1) with:
            gas gas_remaining wei
           args this.address
    mem[96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    mem[64] = ceil32(return_data.size) + 96
    require return_data.size >= 32
    if ext_call.return_data[0] >= arg1:
        mem[ceil32(return_data.size) + 132] = msg.sender
        mem[ceil32(return_data.size) + 164] = arg1
        mem[ceil32(return_data.size) + 96] = 68
        mem[ceil32(return_data.size) + 132 len 28] = Mask(224, 32, msg.sender) >> 32
        mem[ceil32(return_data.size) + 128 len 4] = transfer(address arg1, uint256 arg2)
        mem[ceil32(return_data.size) + 196] = 32
        mem[ceil32(return_data.size) + 228] = 'SafeERC20: low-level call failed'
        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(wantAddress):
            revert with 0, 'Address: call to non-contract'
        if not ext_code.hash(wantAddress):
            revert with 0, 'Address: call to non-contract'
        mem[ceil32(return_data.size) + 260 len 96] = transfer(address arg1, uint256 arg2), msg.sender, arg1, 0
        mem[ceil32(return_data.size) + 328] = 0
        call wantAddress with:
           funct Mask(32, 224, transfer(address arg1, uint256 arg2), msg.sender, arg1, 0) >> 224
             gas gas_remaining wei
            args (Mask(512, -288, transfer(address arg1, uint256 arg2), msg.sender, arg1, 0) << 288)
        if not return_data.size:
            if not ext_call.success:
                if ext_call.return_data[0]:
                    revert with memory
                      from 128
                       len ext_call.return_data[0]
                revert with 0, 'SafeERC20: low-level call failed'
            if ext_call.return_data[0]:
                require ext_call.return_data[0] >= 32
                require 0, mem[132 len 28] == bool(0, mem[132 len 28])
                if not 0, mem[132 len 28]:
                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
        else:
            mem[ceil32(return_data.size) + 292 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if not ext_call.success:
                if return_data.size:
                    revert with ext_call.return_data[0 len return_data.size]
                revert with 0, 'SafeERC20: low-level call failed'
            if return_data.size:
                require return_data.size >= 32
                require mem[ceil32(return_data.size) + 292] == bool(mem[ceil32(return_data.size) + 292])
                if not mem[ceil32(return_data.size) + 292]:
                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
    else:
        if not lenders.length:
            if ext_call.return_data[0] < 0:
                revert with 0, 'SafeMath: addition overflow'
            mem[ceil32(return_data.size) + 132] = msg.sender
            if ext_call.return_data[0] < arg1:
                mem[ceil32(return_data.size) + 164] = ext_call.return_data[0]
                mem[ceil32(return_data.size) + 96] = 68
                mem[ceil32(return_data.size) + 132 len 28] = Mask(224, 32, msg.sender) >> 32
                mem[ceil32(return_data.size) + 128 len 4] = transfer(address arg1, uint256 arg2)
                mem[ceil32(return_data.size) + 196] = 32
                mem[ceil32(return_data.size) + 228] = 'SafeERC20: low-level call failed'
                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(wantAddress):
                    revert with 0, 'Address: call to non-contract'
                if not ext_code.hash(wantAddress):
                    revert with 0, 'Address: call to non-contract'
                mem[ceil32(return_data.size) + 260 len 96] = transfer(address arg1, uint256 arg2), msg.sender, ext_call.return_data[0], 0
                mem[ceil32(return_data.size) + 328] = 0
                call wantAddress with:
                   funct Mask(32, 224, transfer(address arg1, uint256 arg2), msg.sender, ext_call.return_data[0], 0) >> 224
                     gas gas_remaining wei
                    args (Mask(512, -288, transfer(address arg1, uint256 arg2), msg.sender, ext_call.return_data[0], 0) << 288)
            else:
                mem[ceil32(return_data.size) + 164] = arg1
                mem[ceil32(return_data.size) + 96] = 68
                mem[ceil32(return_data.size) + 132 len 28] = Mask(224, 32, msg.sender) >> 32
                mem[ceil32(return_data.size) + 128 len 4] = transfer(address arg1, uint256 arg2)
                mem[ceil32(return_data.size) + 196] = 32
                mem[ceil32(return_data.size) + 228] = 'SafeERC20: low-level call failed'
                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(wantAddress):
                    revert with 0, 'Address: call to non-contract'
                if not ext_code.hash(wantAddress):
                    revert with 0, 'Address: call to non-contract'
                mem[ceil32(return_data.size) + 260 len 96] = transfer(address arg1, uint256 arg2), msg.sender, arg1, 0
                mem[ceil32(return_data.size) + 328] = 0
                call wantAddress with:
                   funct Mask(32, 224, transfer(address arg1, uint256 arg2), msg.sender, arg1, 0) >> 224
                     gas gas_remaining wei
                    args (Mask(512, -288, transfer(address arg1, uint256 arg2), msg.sender, arg1, 0) << 288)
            if not return_data.size:
                if not ext_call.success:
                    if ext_call.return_data[0]:
                        revert with memory
                          from 128
                           len ext_call.return_data[0]
                    revert with 0, 'SafeERC20: low-level call failed'
                if ext_call.return_data[0]:
                    require ext_call.return_data[0] >= 32
                    require 0, mem[132 len 28] == bool(0, mem[132 len 28])
                    if not 0, mem[132 len 28]:
                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
            else:
                mem[ceil32(return_data.size) + 292 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not ext_call.success:
                    if return_data.size:
                        revert with ext_call.return_data[0 len return_data.size]
                    revert with 0, 'SafeERC20: low-level call failed'
                if return_data.size:
                    require return_data.size >= 32
                    require mem[ceil32(return_data.size) + 292] == bool(mem[ceil32(return_data.size) + 292])
                    if not mem[ceil32(return_data.size) + 292]:
                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
        else:
            if arg1 - ext_call.return_data[0] < withdrawalThreshold:
                if ext_call.return_data[0] < 0:
                    revert with 0, 'SafeMath: addition overflow'
                mem[ceil32(return_data.size) + 132] = msg.sender
                if ext_call.return_data[0] < arg1:
                    mem[ceil32(return_data.size) + 164] = ext_call.return_data[0]
                    mem[ceil32(return_data.size) + 96] = 68
                    mem[ceil32(return_data.size) + 132 len 28] = Mask(224, 32, msg.sender) >> 32
                    mem[ceil32(return_data.size) + 128 len 4] = transfer(address arg1, uint256 arg2)
                    mem[ceil32(return_data.size) + 196] = 32
                    mem[ceil32(return_data.size) + 228] = 'SafeERC20: low-level call failed'
                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(wantAddress):
                        revert with 0, 'Address: call to non-contract'
                    if not ext_code.hash(wantAddress):
                        revert with 0, 'Address: call to non-contract'
                    mem[ceil32(return_data.size) + 260 len 96] = transfer(address arg1, uint256 arg2), msg.sender, ext_call.return_data[0], 0
                    mem[ceil32(return_data.size) + 328] = 0
                    call wantAddress with:
                       funct Mask(32, 224, transfer(address arg1, uint256 arg2), msg.sender, ext_call.return_data[0], 0) >> 224
                         gas gas_remaining wei
                        args (Mask(512, -288, transfer(address arg1, uint256 arg2), msg.sender, ext_call.return_data[0], 0) << 288)
                else:
                    mem[ceil32(return_data.size) + 164] = arg1
                    mem[ceil32(return_data.size) + 96] = 68
                    mem[ceil32(return_data.size) + 132 len 28] = Mask(224, 32, msg.sender) >> 32
                    mem[ceil32(return_data.size) + 128 len 4] = transfer(address arg1, uint256 arg2)
                    mem[ceil32(return_data.size) + 196] = 32
                    mem[ceil32(return_data.size) + 228] = 'SafeERC20: low-level call failed'
                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(wantAddress):
                        revert with 0, 'Address: call to non-contract'
                    if not ext_code.hash(wantAddress):
                        revert with 0, 'Address: call to non-contract'
                    mem[ceil32(return_data.size) + 260 len 96] = transfer(address arg1, uint256 arg2), msg.sender, arg1, 0
                    mem[ceil32(return_data.size) + 328] = 0
                    call wantAddress with:
                       funct Mask(32, 224, transfer(address arg1, uint256 arg2), msg.sender, arg1, 0) >> 224
                         gas gas_remaining wei
                        args (Mask(512, -288, transfer(address arg1, uint256 arg2), msg.sender, arg1, 0) << 288)
                if not return_data.size:
                    if not ext_call.success:
                        if ext_call.return_data[0]:
                            revert with memory
                              from 128
                               len ext_call.return_data[0]
                        revert with 0, 'SafeERC20: low-level call failed'
                    if ext_call.return_data[0]:
                        require ext_call.return_data[0] >= 32
                        require 0, mem[132 len 28] == bool(0, mem[132 len 28])
                        if not 0, mem[132 len 28]:
                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                else:
                    mem[ceil32(return_data.size) + 292 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not ext_call.success:
                        if return_data.size:
                            revert with ext_call.return_data[0 len return_data.size]
                        revert with 0, 'SafeERC20: low-level call failed'
                    if return_data.size:
                        require return_data.size >= 32
                        require mem[ceil32(return_data.size) + 292] == bool(mem[ceil32(return_data.size) + 292])
                        if not mem[ceil32(return_data.size) + 292]:
                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
            else:
                s = 0
                idx = 0
                while idx < arg1 - ext_call.return_data[0]:
                    t = 0
                    u = -1
                    while t < lenders.length:
                        mem[0] = 13
                        require ext_code.size(lenders[t])
                        staticcall lenders[t].hasAssets() with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1484 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_1484] == bool(mem[_1484])
                        if not mem[_1484]:
                            t = t + 1
                            u = u
                            continue 
                        require t < lenders.length
                        mem[0] = 13
                        require ext_code.size(lenders[t])
                        staticcall lenders[t].apr() with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1569 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if mem[_1569] >= u:
                            t = t + 1
                            u = u
                            continue 
                        t = t + 1
                        u = mem[_1569]
                        continue 
                    require 0 < lenders.length
                    mem[0] = 13
                    require ext_code.size(lenders)
                    staticcall lenders.hasAssets() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1483 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_1483] == bool(mem[_1483])
                    if not mem[_1483]:
                        if ext_call.return_data[0] + idx < idx:
                            revert with 0, 'SafeMath: addition overflow'
                        if ext_call.return_data[0] + idx < arg1:
                            _1615 = mem[64]
                            mem[mem[64] + 36] = msg.sender
                            mem[mem[64] + 68] = ext_call.return_data[0] + idx
                            _1626 = mem[64]
                            mem[mem[64]] = 68
                            mem[64] = mem[64] + 100
                            mem[_1626 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_1626 + 36 len 28]
                            mem[64] = _1615 + 164
                            mem[_1615 + 100] = 32
                            mem[_1615 + 132] = 'SafeERC20: low-level call failed'
                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(wantAddress):
                                revert with 0, 'Address: call to non-contract'
                            if not ext_code.hash(wantAddress):
                                revert with 0, 'Address: call to non-contract'
                            _1649 = mem[_1626]
                            idx = 0
                            while idx < _1649:
                                mem[idx + _1615 + 164] = mem[idx + _1626 + 32]
                                idx = idx + 32
                                continue 
                            if ceil32(_1649) > _1649:
                                mem[_1649 + _1615 + 164] = 0
                            call wantAddress.mem[_1615 + 164 len 4] with:
                                 gas gas_remaining wei
                                args mem[_1615 + 168 len _1649 - 4]
                            if not return_data.size:
                                if not ext_call.success:
                                    if mem[96]:
                                        revert with memory
                                          from 128
                                           len mem[96]
                                    mem[_1615 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[_1615 + 168] = 32
                                    idx = 0
                                    while idx < 32:
                                        mem[idx + _1615 + 232] = mem[idx + _1615 + 132]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 32, 32, mem[_1615 + 232]
                                if mem[96]:
                                    require mem[96] >= 32
                                    require mem[128] == bool(mem[128])
                                    if not mem[128]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                            else:
                                mem[_1615 + 164] = return_data.size
                                mem[_1615 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    if return_data.size:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_1615 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[_1615 + ceil32(return_data.size) + 169] = 32
                                    idx = 0
                                    while idx < 32:
                                        mem[idx + _1615 + ceil32(return_data.size) + 233] = mem[idx + _1615 + 132]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 32, 32, mem[_1615 + ceil32(return_data.size) + 233]
                                if return_data.size:
                                    require return_data.size >= 32
                                    require mem[_1615 + 196] == bool(mem[_1615 + 196])
                                    if not mem[_1615 + 196]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                        else:
                            _1616 = mem[64]
                            mem[mem[64] + 36] = msg.sender
                            mem[mem[64] + 68] = arg1
                            _1628 = mem[64]
                            mem[mem[64]] = 68
                            mem[64] = mem[64] + 100
                            mem[_1628 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_1628 + 36 len 28]
                            mem[64] = _1616 + 164
                            mem[_1616 + 100] = 32
                            mem[_1616 + 132] = 'SafeERC20: low-level call failed'
                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(wantAddress):
                                revert with 0, 'Address: call to non-contract'
                            if not ext_code.hash(wantAddress):
                                revert with 0, 'Address: call to non-contract'
                            _1650 = mem[_1628]
                            idx = 0
                            while idx < _1650:
                                mem[idx + _1616 + 164] = mem[idx + _1628 + 32]
                                idx = idx + 32
                                continue 
                            if ceil32(_1650) > _1650:
                                mem[_1650 + _1616 + 164] = 0
                            call wantAddress.mem[_1616 + 164 len 4] with:
                                 gas gas_remaining wei
                                args mem[_1616 + 168 len _1650 - 4]
                            if not return_data.size:
                                if not ext_call.success:
                                    if mem[96]:
                                        revert with memory
                                          from 128
                                           len mem[96]
                                    mem[_1616 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[_1616 + 168] = 32
                                    idx = 0
                                    while idx < 32:
                                        mem[idx + _1616 + 232] = mem[idx + _1616 + 132]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 32, 32, mem[_1616 + 232]
                                if mem[96]:
                                    require mem[96] >= 32
                                    require mem[128] == bool(mem[128])
                                    if not mem[128]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                            else:
                                mem[_1616 + 164] = return_data.size
                                mem[_1616 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    if return_data.size:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_1616 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[_1616 + ceil32(return_data.size) + 169] = 32
                                    idx = 0
                                    while idx < 32:
                                        mem[idx + _1616 + ceil32(return_data.size) + 233] = mem[idx + _1616 + 132]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 32, 32, mem[_1616 + ceil32(return_data.size) + 233]
                                if return_data.size:
                                    require return_data.size >= 32
                                    require mem[_1616 + 196] == bool(mem[_1616 + 196])
                                    if not mem[_1616 + 196]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    else:
                        require 0 < lenders.length
                        mem[0] = 13
                        mem[mem[64] + 4] = arg1 - ext_call.return_data[0] - idx
                        require ext_code.size(lenders)
                        call lenders.0x2e1a7d4d with:
                             gas gas_remaining wei
                            args (arg1 - ext_call.return_data[0] - idx)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1579 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _1606 = mem[_1579]
                        if mem[_1579] + idx < idx:
                            revert with 0, 'SafeMath: addition overflow'
                        if s + 1 < 6:
                            s = s + 1
                            idx = mem[_1579] + idx
                            continue 
                        if ext_call.return_data[0] < 0:
                            revert with 0, 'SafeMath: addition overflow'
                        if ext_call.return_data[0] + mem[_1579] + idx < arg1:
                            _1655 = mem[64]
                            mem[mem[64] + 36] = msg.sender
                            mem[mem[64] + 68] = ext_call.return_data[0] + _1606 + idx
                            _1659 = mem[64]
                            mem[mem[64]] = 68
                            mem[64] = mem[64] + 100
                            mem[_1659 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_1659 + 36 len 28]
                            mem[64] = _1655 + 164
                            mem[_1655 + 100] = 32
                            mem[_1655 + 132] = 'SafeERC20: low-level call failed'
                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(wantAddress):
                                revert with 0, 'Address: call to non-contract'
                            if not ext_code.hash(wantAddress):
                                revert with 0, 'Address: call to non-contract'
                            _1703 = mem[_1659]
                            idx = 0
                            while idx < _1703:
                                mem[idx + _1655 + 164] = mem[idx + _1659 + 32]
                                idx = idx + 32
                                continue 
                            if ceil32(_1703) > _1703:
                                mem[_1703 + _1655 + 164] = 0
                            call wantAddress.mem[_1655 + 164 len 4] with:
                                 gas gas_remaining wei
                                args mem[_1655 + 168 len _1703 - 4]
                            if not return_data.size:
                                if not ext_call.success:
                                    if mem[96]:
                                        revert with memory
                                          from 128
                                           len mem[96]
                                    mem[_1655 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[_1655 + 168] = 32
                                    idx = 0
                                    while idx < 32:
                                        mem[idx + _1655 + 232] = mem[idx + _1655 + 132]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 32, 32, mem[_1655 + 232]
                                if mem[96]:
                                    require mem[96] >= 32
                                    require mem[128] == bool(mem[128])
                                    if not mem[128]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                            else:
                                mem[_1655 + 164] = return_data.size
                                mem[_1655 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    if return_data.size:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_1655 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[_1655 + ceil32(return_data.size) + 169] = 32
                                    idx = 0
                                    while idx < 32:
                                        mem[idx + _1655 + ceil32(return_data.size) + 233] = mem[idx + _1655 + 132]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 32, 32, mem[_1655 + ceil32(return_data.size) + 233]
                                if return_data.size:
                                    require return_data.size >= 32
                                    require mem[_1655 + 196] == bool(mem[_1655 + 196])
                                    if not mem[_1655 + 196]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                        else:
                            _1656 = mem[64]
                            mem[mem[64] + 36] = msg.sender
                            mem[mem[64] + 68] = arg1
                            _1661 = mem[64]
                            mem[mem[64]] = 68
                            mem[64] = mem[64] + 100
                            mem[_1661 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_1661 + 36 len 28]
                            mem[64] = _1656 + 164
                            mem[_1656 + 100] = 32
                            mem[_1656 + 132] = 'SafeERC20: low-level call failed'
                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(wantAddress):
                                revert with 0, 'Address: call to non-contract'
                            if not ext_code.hash(wantAddress):
                                revert with 0, 'Address: call to non-contract'
                            _1704 = mem[_1661]
                            idx = 0
                            while idx < _1704:
                                mem[idx + _1656 + 164] = mem[idx + _1661 + 32]
                                idx = idx + 32
                                continue 
                            if ceil32(_1704) > _1704:
                                mem[_1704 + _1656 + 164] = 0
                            call wantAddress.mem[_1656 + 164 len 4] with:
                                 gas gas_remaining wei
                                args mem[_1656 + 168 len _1704 - 4]
                            if not return_data.size:
                                if not ext_call.success:
                                    if mem[96]:
                                        revert with memory
                                          from 128
                                           len mem[96]
                                    mem[_1656 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[_1656 + 168] = 32
                                    idx = 0
                                    while idx < 32:
                                        mem[idx + _1656 + 232] = mem[idx + _1656 + 132]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 32, 32, mem[_1656 + 232]
                                if mem[96]:
                                    require mem[96] >= 32
                                    require mem[128] == bool(mem[128])
                                    if not mem[128]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                            else:
                                mem[_1656 + 164] = return_data.size
                                mem[_1656 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    if return_data.size:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_1656 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[_1656 + ceil32(return_data.size) + 169] = 32
                                    idx = 0
                                    while idx < 32:
                                        mem[idx + _1656 + ceil32(return_data.size) + 233] = mem[idx + _1656 + 132]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 32, 32, mem[_1656 + ceil32(return_data.size) + 233]
                                if return_data.size:
                                    require return_data.size >= 32
                                    require mem[_1656 + 196] == bool(mem[_1656 + 196])
                                    if not mem[_1656 + 196]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    return 0
                if ext_call.return_data[0] + idx < idx:
                    revert with 0, 'SafeMath: addition overflow'
                if ext_call.return_data[0] + idx < arg1:
                    _1308 = mem[64]
                    mem[mem[64] + 36] = msg.sender
                    mem[mem[64] + 68] = ext_call.return_data[0] + idx
                    _1310 = mem[64]
                    mem[mem[64]] = 68
                    mem[mem[64] + 32 len 4] = transfer(address arg1, uint256 arg2)
                    mem[64] = mem[64] + 164
                    mem[_1308 + 100] = 32
                    mem[_1308 + 132] = 'SafeERC20: low-level call failed'
                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(wantAddress):
                        revert with 0, 'Address: call to non-contract'
                    if not ext_code.hash(wantAddress):
                        revert with 0, 'Address: call to non-contract'
                    _1327 = mem[_1310]
                    mem[_1308 + 164 len ceil32(mem[_1310])] = mem[_1310 + 32 len ceil32(mem[_1310])]
                    if ceil32(_1327) > _1327:
                        mem[_1327 + _1308 + 164] = 0
                    call wantAddress with:
                         gas gas_remaining wei
                        args mem[_1308 + 168 len _1327 - 4]
                    if not return_data.size:
                        if not ext_call.success:
                            if mem[96]:
                                revert with memory
                                  from 128
                                   len mem[96]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if mem[96]:
                            require mem[96] >= 32
                            require mem[128] == bool(mem[128])
                            if not mem[128]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    else:
                        mem[_1308 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size:
                                revert with ext_call.return_data[0 len return_data.size]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if return_data.size:
                            require return_data.size >= 32
                            require mem[_1308 + 196] == bool(mem[_1308 + 196])
                            if not mem[_1308 + 196]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                else:
                    _1309 = mem[64]
                    mem[mem[64] + 36] = msg.sender
                    mem[mem[64] + 68] = arg1
                    _1312 = mem[64]
                    mem[mem[64]] = 68
                    mem[mem[64] + 32 len 4] = transfer(address arg1, uint256 arg2)
                    mem[64] = mem[64] + 164
                    mem[_1309 + 100] = 32
                    mem[_1309 + 132] = 'SafeERC20: low-level call failed'
                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(wantAddress):
                        revert with 0, 'Address: call to non-contract'
                    if not ext_code.hash(wantAddress):
                        revert with 0, 'Address: call to non-contract'
                    _1328 = mem[_1312]
                    mem[_1309 + 164 len ceil32(mem[_1312])] = mem[_1312 + 32 len ceil32(mem[_1312])]
                    if ceil32(_1328) > _1328:
                        mem[_1328 + _1309 + 164] = 0
                    call wantAddress with:
                         gas gas_remaining wei
                        args mem[_1309 + 168 len _1328 - 4]
                    if not return_data.size:
                        if not ext_call.success:
                            if mem[96]:
                                revert with memory
                                  from 128
                                   len mem[96]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if mem[96]:
                            require mem[96] >= 32
                            require mem[128] == bool(mem[128])
                            if not mem[128]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    else:
                        mem[_1309 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size:
                                revert with ext_call.return_data[0 len return_data.size]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if return_data.size:
                            require return_data.size >= 32
                            require mem[_1309 + 196] == bool(mem[_1309 + 196])
                            if not mem[_1309 + 196]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
    return 0
}

function manualAllocation(address arg1, uint16[] arg2) payable {
    require calldata.size - 4 >= 32
    require arg1 <= test266151307()
    require calldata.size > arg1 + 35
    require arg1.length <= test266151307()
    require (32 * arg1.length) + 128 >= 96 and (32 * arg1.length) + 128 <= test266151307()
    mem[64] = (32 * arg1.length) + 128
    mem[96] = arg1.length
    require calldata.size >= arg1 + (64 * arg1.length) + 36
    s = arg1 + 36
    t = 128
    idx = 0
    while idx < arg1.length:
        require calldata.size - s >= 64
        _45 = mem[64]
        require mem[64] + 64 >= mem[64] and mem[64] + 64 <= test266151307()
        mem[64] = mem[64] + 64
        require cd[s] == address(cd[s])
        mem[_45] = cd[s]
        require cd[(s + 32)] == uint16(cd[(s + 32)])
        mem[_45 + 32] = cd[(s + 32)]
        mem[t] = _45
        s = s + 64
        t = t + 32
        idx = idx + 1
        continue 
    if msg.sender == strategistAddress:
        idx = 0
        while idx < lenders.length:
            mem[0] = 13
            require ext_code.size(lenders[idx])
            call lenders[idx].withdrawAll() with:
                 gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _98 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            require mem[_98] == bool(mem[_98])
            idx = idx + 1
            continue 
        mem[mem[64] + 4] = this.address
        require ext_code.size(wantAddress)
        staticcall wantAddress.balanceOf(address arg1) with:
                gas gas_remaining wei
               args address(this.address)
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _100 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _104 = mem[_100]
        _584 = mem[96]
        idx = 0
        s = 0
        while idx < _584:
            t = 0
            u = 0
            while t < lenders.length:
                require idx < mem[96]
                _607 = mem[mem[(32 * idx) + 128]]
                require t < lenders.length
                mem[0] = 13
                _584 = mem[96]
                if lenders[t] != address(_607):
                    t = t + 1
                    u = u
                    continue 
                t = t + 1
                u = 1
                continue 
            if not u:
                revert with 0, 'NOT LENDER'
            require idx < mem[96]
            _613 = mem[mem[(32 * idx) + 128] + 32]
            if mem[mem[(32 * idx) + 128] + 62 len 2] + s < s:
                revert with 0, 'SafeMath: addition overflow'
            require idx < mem[96]
            _625 = mem[mem[(32 * idx) + 128] + 32]
            if not _104:
                _632 = mem[64]
                mem[64] = mem[64] + 64
                mem[_632] = 26
                mem[_632 + 32] = 'SafeMath: division by zero'
                require idx < mem[96]
                _648 = mem[64]
                mem[mem[64] + 36] = mem[mem[(32 * idx) + 128] + 12 len 20]
                mem[mem[64] + 68] = 0
                _654 = mem[64]
                mem[mem[64]] = 68
                mem[64] = mem[64] + 100
                mem[_654 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_654 + 36 len 28]
                mem[64] = _648 + 164
                mem[_648 + 100] = 32
                mem[_648 + 132] = 'SafeERC20: low-level call failed'
                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(wantAddress):
                    revert with 0, 'Address: call to non-contract'
                if not ext_code.hash(wantAddress):
                    revert with 0, 'Address: call to non-contract'
                _675 = mem[_654]
                t = 0
                while t < _675:
                    mem[t + _648 + 164] = mem[t + _654 + 32]
                    _584 = mem[96]
                    t = t + 32
                    continue 
                if ceil32(_675) <= _675:
                    call wantAddress.mem[_648 + 164 len 4] with:
                         gas gas_remaining wei
                        args mem[_648 + 168 len _675 - 4]
                    if not return_data.size:
                        if not ext_call.success:
                            if mem[96]:
                                revert with memory
                                  from 128
                                   len mem[96]
                            mem[_648 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[_648 + 168] = 32
                            idx = 0
                            while idx < 32:
                                mem[idx + _648 + 232] = mem[idx + _648 + 132]
                                _584 = mem[96]
                                idx = idx + 32
                                continue 
                            revert with 0, 32, 32, mem[_648 + 232]
                        if not mem[96]:
                            require idx < mem[96]
                            _1243 = mem[mem[(32 * idx) + 128]]
                            mem[_648 + 164] = 0xd0e30db000000000000000000000000000000000000000000000000000000000
                            require ext_code.size(address(_1243))
                            call address(_1243).deposit() with:
                                 gas gas_remaining wei
                        else:
                            require mem[96] >= 32
                            require mem[128] == bool(mem[128])
                            if not mem[128]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                            require idx < mem[96]
                            _1387 = mem[mem[(32 * idx) + 128]]
                            mem[_648 + 164] = 0xd0e30db000000000000000000000000000000000000000000000000000000000
                            require ext_code.size(address(_1387))
                            call address(_1387).deposit() with:
                                 gas gas_remaining wei
                    else:
                        mem[64] = _648 + ceil32(return_data.size) + 165
                        mem[_648 + 164] = return_data.size
                        mem[_648 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_648 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[_648 + ceil32(return_data.size) + 169] = 32
                            idx = 0
                            while idx < 32:
                                mem[idx + _648 + ceil32(return_data.size) + 233] = mem[idx + _648 + 132]
                                _584 = mem[96]
                                idx = idx + 32
                                continue 
                            revert with 0, 32, 32, mem[_648 + ceil32(return_data.size) + 233]
                        if not return_data.size:
                            require idx < mem[96]
                            _1247 = mem[mem[(32 * idx) + 128]]
                            mem[_648 + ceil32(return_data.size) + 165] = 0xd0e30db000000000000000000000000000000000000000000000000000000000
                            require ext_code.size(address(_1247))
                            call address(_1247).deposit() with:
                                 gas gas_remaining wei
                        else:
                            require return_data.size >= 32
                            require mem[_648 + 196] == bool(mem[_648 + 196])
                            if not mem[_648 + 196]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                            require idx < mem[96]
                            _1391 = mem[mem[(32 * idx) + 128]]
                            mem[_648 + ceil32(return_data.size) + 165] = 0xd0e30db000000000000000000000000000000000000000000000000000000000
                            require ext_code.size(address(_1391))
                            call address(_1391).deposit() with:
                                 gas gas_remaining wei
                else:
                    mem[_675 + _648 + 164] = 0
                    call wantAddress.mem[_648 + 164 len 4] with:
                         gas gas_remaining wei
                        args mem[_648 + 168 len _675 - 4]
                    if not return_data.size:
                        if not ext_call.success:
                            if mem[96]:
                                revert with memory
                                  from 128
                                   len mem[96]
                            mem[_648 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[_648 + 168] = 32
                            idx = 0
                            while idx < 32:
                                mem[idx + _648 + 232] = mem[idx + _648 + 132]
                                _584 = mem[96]
                                idx = idx + 32
                                continue 
                            revert with 0, 32, 32, mem[_648 + 232]
                        if not mem[96]:
                            require idx < mem[96]
                            _1251 = mem[mem[(32 * idx) + 128]]
                            mem[_648 + 164] = 0xd0e30db000000000000000000000000000000000000000000000000000000000
                            require ext_code.size(address(_1251))
                            call address(_1251).deposit() with:
                                 gas gas_remaining wei
                        else:
                            require mem[96] >= 32
                            require mem[128] == bool(mem[128])
                            if not mem[128]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                            require idx < mem[96]
                            _1395 = mem[mem[(32 * idx) + 128]]
                            mem[_648 + 164] = 0xd0e30db000000000000000000000000000000000000000000000000000000000
                            require ext_code.size(address(_1395))
                            call address(_1395).deposit() with:
                                 gas gas_remaining wei
                    else:
                        mem[64] = _648 + ceil32(return_data.size) + 165
                        mem[_648 + 164] = return_data.size
                        mem[_648 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_648 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[_648 + ceil32(return_data.size) + 169] = 32
                            idx = 0
                            while idx < 32:
                                mem[idx + _648 + ceil32(return_data.size) + 233] = mem[idx + _648 + 132]
                                _584 = mem[96]
                                idx = idx + 32
                                continue 
                            revert with 0, 32, 32, mem[_648 + ceil32(return_data.size) + 233]
                        if not return_data.size:
                            require idx < mem[96]
                            _1255 = mem[mem[(32 * idx) + 128]]
                            mem[_648 + ceil32(return_data.size) + 165] = 0xd0e30db000000000000000000000000000000000000000000000000000000000
                            require ext_code.size(address(_1255))
                            call address(_1255).deposit() with:
                                 gas gas_remaining wei
                        else:
                            require return_data.size >= 32
                            require mem[_648 + 196] == bool(mem[_648 + 196])
                            if not mem[_648 + 196]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                            require idx < mem[96]
                            _1399 = mem[mem[(32 * idx) + 128]]
                            mem[_648 + ceil32(return_data.size) + 165] = 0xd0e30db000000000000000000000000000000000000000000000000000000000
                            require ext_code.size(address(_1399))
                            call address(_1399).deposit() with:
                                 gas gas_remaining wei
            else:
                if mem[mem[(32 * idx) + 128] + 62 len 2] * _104 / _104 != mem[mem[(32 * idx) + 128] + 62 len 2]:
                    revert with 0, 'SafeMath: multiplication overflow'
                _634 = mem[64]
                mem[64] = mem[64] + 64
                mem[_634] = 26
                mem[_634 + 32] = 'SafeMath: division by zero'
                require idx < mem[96]
                _652 = mem[64]
                mem[mem[64] + 36] = mem[mem[(32 * idx) + 128] + 12 len 20]
                mem[mem[64] + 68] = uint16(_625) * _104 / 1000
                _658 = mem[64]
                mem[mem[64]] = 68
                mem[64] = mem[64] + 100
                mem[_658 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_658 + 36 len 28]
                mem[64] = _652 + 164
                mem[_652 + 100] = 32
                mem[_652 + 132] = 'SafeERC20: low-level call failed'
                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(wantAddress):
                    revert with 0, 'Address: call to non-contract'
                if not ext_code.hash(wantAddress):
                    revert with 0, 'Address: call to non-contract'
                _680 = mem[_658]
                t = 0
                while t < _680:
                    mem[t + _652 + 164] = mem[t + _658 + 32]
                    _584 = mem[96]
                    t = t + 32
                    continue 
                if ceil32(_680) <= _680:
                    call wantAddress.mem[_652 + 164 len 4] with:
                         gas gas_remaining wei
                        args mem[_652 + 168 len _680 - 4]
                    if not return_data.size:
                        if not ext_call.success:
                            if mem[96]:
                                revert with memory
                                  from 128
                                   len mem[96]
                            mem[_652 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[_652 + 168] = 32
                            idx = 0
                            while idx < 32:
                                mem[idx + _652 + 232] = mem[idx + _652 + 132]
                                _584 = mem[96]
                                idx = idx + 32
                                continue 
                            revert with 0, 32, 32, mem[_652 + 232]
                        if not mem[96]:
                            require idx < mem[96]
                            _1227 = mem[mem[(32 * idx) + 128]]
                            mem[_652 + 164] = 0xd0e30db000000000000000000000000000000000000000000000000000000000
                            require ext_code.size(address(_1227))
                            call address(_1227).deposit() with:
                                 gas gas_remaining wei
                        else:
                            require mem[96] >= 32
                            require mem[128] == bool(mem[128])
                            if not mem[128]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                            require idx < mem[96]
                            _1371 = mem[mem[(32 * idx) + 128]]
                            mem[_652 + 164] = 0xd0e30db000000000000000000000000000000000000000000000000000000000
                            require ext_code.size(address(_1371))
                            call address(_1371).deposit() with:
                                 gas gas_remaining wei
                    else:
                        mem[64] = _652 + ceil32(return_data.size) + 165
                        mem[_652 + 164] = return_data.size
                        mem[_652 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_652 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[_652 + ceil32(return_data.size) + 169] = 32
                            idx = 0
                            while idx < 32:
                                mem[idx + _652 + ceil32(return_data.size) + 233] = mem[idx + _652 + 132]
                                _584 = mem[96]
                                idx = idx + 32
                                continue 
                            revert with 0, 32, 32, mem[_652 + ceil32(return_data.size) + 233]
                        if not return_data.size:
                            require idx < mem[96]
                            _1231 = mem[mem[(32 * idx) + 128]]
                            mem[_652 + ceil32(return_data.size) + 165] = 0xd0e30db000000000000000000000000000000000000000000000000000000000
                            require ext_code.size(address(_1231))
                            call address(_1231).deposit() with:
                                 gas gas_remaining wei
                        else:
                            require return_data.size >= 32
                            require mem[_652 + 196] == bool(mem[_652 + 196])
                            if not mem[_652 + 196]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                            require idx < mem[96]
                            _1375 = mem[mem[(32 * idx) + 128]]
                            mem[_652 + ceil32(return_data.size) + 165] = 0xd0e30db000000000000000000000000000000000000000000000000000000000
                            require ext_code.size(address(_1375))
                            call address(_1375).deposit() with:
                                 gas gas_remaining wei
                else:
                    mem[_680 + _652 + 164] = 0
                    call wantAddress.mem[_652 + 164 len 4] with:
                         gas gas_remaining wei
                        args mem[_652 + 168 len _680 - 4]
                    if not return_data.size:
                        if not ext_call.success:
                            if mem[96]:
                                revert with memory
                                  from 128
                                   len mem[96]
                            mem[_652 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[_652 + 168] = 32
                            idx = 0
                            while idx < 32:
                                mem[idx + _652 + 232] = mem[idx + _652 + 132]
                                _584 = mem[96]
                                idx = idx + 32
                                continue 
                            revert with 0, 32, 32, mem[_652 + 232]
                        if not mem[96]:
                            require idx < mem[96]
                            _1235 = mem[mem[(32 * idx) + 128]]
                            mem[_652 + 164] = 0xd0e30db000000000000000000000000000000000000000000000000000000000
                            require ext_code.size(address(_1235))
                            call address(_1235).deposit() with:
                                 gas gas_remaining wei
                        else:
                            require mem[96] >= 32
                            require mem[128] == bool(mem[128])
                            if not mem[128]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                            require idx < mem[96]
                            _1379 = mem[mem[(32 * idx) + 128]]
                            mem[_652 + 164] = 0xd0e30db000000000000000000000000000000000000000000000000000000000
                            require ext_code.size(address(_1379))
                            call address(_1379).deposit() with:
                                 gas gas_remaining wei
                    else:
                        mem[64] = _652 + ceil32(return_data.size) + 165
                        mem[_652 + 164] = return_data.size
                        mem[_652 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_652 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[_652 + ceil32(return_data.size) + 169] = 32
                            idx = 0
                            while idx < 32:
                                mem[idx + _652 + ceil32(return_data.size) + 233] = mem[idx + _652 + 132]
                                _584 = mem[96]
                                idx = idx + 32
                                continue 
                            revert with 0, 32, 32, mem[_652 + ceil32(return_data.size) + 233]
                        if not return_data.size:
                            require idx < mem[96]
                            _1239 = mem[mem[(32 * idx) + 128]]
                            mem[_652 + ceil32(return_data.size) + 165] = 0xd0e30db000000000000000000000000000000000000000000000000000000000
                            require ext_code.size(address(_1239))
                            call address(_1239).deposit() with:
                                 gas gas_remaining wei
                        else:
                            require return_data.size >= 32
                            require mem[_652 + 196] == bool(mem[_652 + 196])
                            if not mem[_652 + 196]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                            require idx < mem[96]
                            _1383 = mem[mem[(32 * idx) + 128]]
                            mem[_652 + ceil32(return_data.size) + 165] = 0xd0e30db000000000000000000000000000000000000000000000000000000000
                            require ext_code.size(address(_1383))
                            call address(_1383).deposit() with:
                                 gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _584 = mem[96]
            idx = idx + 1
            s = uint16(_613) + s
            continue 
    else:
        require ext_code.size(vaultAddress)
        staticcall vaultAddress.governance() with:
                gas gas_remaining wei
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _49 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        require mem[_49] == mem[_49 + 12 len 20]
        if mem[_49 + 12 len 20] != msg.sender:
            revert with 0, '!authorized'
        idx = 0
        while idx < lenders.length:
            mem[0] = 13
            require ext_code.size(lenders[idx])
            call lenders[idx].withdrawAll() with:
                 gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _99 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            require mem[_99] == bool(mem[_99])
            idx = idx + 1
            continue 
        mem[mem[64] + 4] = this.address
        require ext_code.size(wantAddress)
        staticcall wantAddress.balanceOf(address arg1) with:
                gas gas_remaining wei
               args address(this.address)
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _101 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _105 = mem[_101]
        _585 = mem[96]
        idx = 0
        s = 0
        while idx < _585:
            t = 0
            u = 0
            while t < lenders.length:
                require idx < mem[96]
                _611 = mem[mem[(32 * idx) + 128]]
                require t < lenders.length
                mem[0] = 13
                _585 = mem[96]
                if lenders[t] != address(_611):
                    t = t + 1
                    u = u
                    continue 
                t = t + 1
                u = 1
                continue 
            if not u:
                revert with 0, 'NOT LENDER'
            require idx < mem[96]
            _616 = mem[mem[(32 * idx) + 128] + 32]
            if mem[mem[(32 * idx) + 128] + 62 len 2] + s < s:
                revert with 0, 'SafeMath: addition overflow'
            require idx < mem[96]
            _628 = mem[mem[(32 * idx) + 128] + 32]
            if not _105:
                _633 = mem[64]
                mem[64] = mem[64] + 64
                mem[_633] = 26
                mem[_633 + 32] = 'SafeMath: division by zero'
                require idx < mem[96]
                _651 = mem[64]
                mem[mem[64] + 36] = mem[mem[(32 * idx) + 128] + 12 len 20]
                mem[mem[64] + 68] = 0
                _656 = mem[64]
                mem[mem[64]] = 68
                mem[64] = mem[64] + 100
                mem[_656 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_656 + 36 len 28]
                mem[64] = _651 + 164
                mem[_651 + 100] = 32
                mem[_651 + 132] = 'SafeERC20: low-level call failed'
                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(wantAddress):
                    revert with 0, 'Address: call to non-contract'
                if not ext_code.hash(wantAddress):
                    revert with 0, 'Address: call to non-contract'
                _679 = mem[_656]
                t = 0
                while t < _679:
                    mem[t + _651 + 164] = mem[t + _656 + 32]
                    _585 = mem[96]
                    t = t + 32
                    continue 
                if ceil32(_679) <= _679:
                    call wantAddress.mem[_651 + 164 len 4] with:
                         gas gas_remaining wei
                        args mem[_651 + 168 len _679 - 4]
                    if not return_data.size:
                        if not ext_call.success:
                            if mem[96]:
                                revert with memory
                                  from 128
                                   len mem[96]
                            mem[_651 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[_651 + 168] = 32
                            idx = 0
                            while idx < 32:
                                mem[idx + _651 + 232] = mem[idx + _651 + 132]
                                _585 = mem[96]
                                idx = idx + 32
                                continue 
                            revert with 0, 32, 32, mem[_651 + 232]
                        if not mem[96]:
                            require idx < mem[96]
                            _1275 = mem[mem[(32 * idx) + 128]]
                            mem[_651 + 164] = 0xd0e30db000000000000000000000000000000000000000000000000000000000
                            require ext_code.size(address(_1275))
                            call address(_1275).deposit() with:
                                 gas gas_remaining wei
                        else:
                            require mem[96] >= 32
                            require mem[128] == bool(mem[128])
                            if not mem[128]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                            require idx < mem[96]
                            _1419 = mem[mem[(32 * idx) + 128]]
                            mem[_651 + 164] = 0xd0e30db000000000000000000000000000000000000000000000000000000000
                            require ext_code.size(address(_1419))
                            call address(_1419).deposit() with:
                                 gas gas_remaining wei
                    else:
                        mem[64] = _651 + ceil32(return_data.size) + 165
                        mem[_651 + 164] = return_data.size
                        mem[_651 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_651 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[_651 + ceil32(return_data.size) + 169] = 32
                            idx = 0
                            while idx < 32:
                                mem[idx + _651 + ceil32(return_data.size) + 233] = mem[idx + _651 + 132]
                                _585 = mem[96]
                                idx = idx + 32
                                continue 
                            revert with 0, 32, 32, mem[_651 + ceil32(return_data.size) + 233]
                        if not return_data.size:
                            require idx < mem[96]
                            _1279 = mem[mem[(32 * idx) + 128]]
                            mem[_651 + ceil32(return_data.size) + 165] = 0xd0e30db000000000000000000000000000000000000000000000000000000000
                            require ext_code.size(address(_1279))
                            call address(_1279).deposit() with:
                                 gas gas_remaining wei
                        else:
                            require return_data.size >= 32
                            require mem[_651 + 196] == bool(mem[_651 + 196])
                            if not mem[_651 + 196]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                            require idx < mem[96]
                            _1423 = mem[mem[(32 * idx) + 128]]
                            mem[_651 + ceil32(return_data.size) + 165] = 0xd0e30db000000000000000000000000000000000000000000000000000000000
                            require ext_code.size(address(_1423))
                            call address(_1423).deposit() with:
                                 gas gas_remaining wei
                else:
                    mem[_679 + _651 + 164] = 0
                    call wantAddress.mem[_651 + 164 len 4] with:
                         gas gas_remaining wei
                        args mem[_651 + 168 len _679 - 4]
                    if not return_data.size:
                        if not ext_call.success:
                            if mem[96]:
                                revert with memory
                                  from 128
                                   len mem[96]
                            mem[_651 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[_651 + 168] = 32
                            idx = 0
                            while idx < 32:
                                mem[idx + _651 + 232] = mem[idx + _651 + 132]
                                _585 = mem[96]
                                idx = idx + 32
                                continue 
                            revert with 0, 32, 32, mem[_651 + 232]
                        if not mem[96]:
                            require idx < mem[96]
                            _1283 = mem[mem[(32 * idx) + 128]]
                            mem[_651 + 164] = 0xd0e30db000000000000000000000000000000000000000000000000000000000
                            require ext_code.size(address(_1283))
                            call address(_1283).deposit() with:
                                 gas gas_remaining wei
                        else:
                            require mem[96] >= 32
                            require mem[128] == bool(mem[128])
                            if not mem[128]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                            require idx < mem[96]
                            _1427 = mem[mem[(32 * idx) + 128]]
                            mem[_651 + 164] = 0xd0e30db000000000000000000000000000000000000000000000000000000000
                            require ext_code.size(address(_1427))
                            call address(_1427).deposit() with:
                                 gas gas_remaining wei
                    else:
                        mem[64] = _651 + ceil32(return_data.size) + 165
                        mem[_651 + 164] = return_data.size
                        mem[_651 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_651 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[_651 + ceil32(return_data.size) + 169] = 32
                            idx = 0
                            while idx < 32:
                                mem[idx + _651 + ceil32(return_data.size) + 233] = mem[idx + _651 + 132]
                                _585 = mem[96]
                                idx = idx + 32
                                continue 
                            revert with 0, 32, 32, mem[_651 + ceil32(return_data.size) + 233]
                        if not return_data.size:
                            require idx < mem[96]
                            _1287 = mem[mem[(32 * idx) + 128]]
                            mem[_651 + ceil32(return_data.size) + 165] = 0xd0e30db000000000000000000000000000000000000000000000000000000000
                            require ext_code.size(address(_1287))
                            call address(_1287).deposit() with:
                                 gas gas_remaining wei
                        else:
                            require return_data.size >= 32
                            require mem[_651 + 196] == bool(mem[_651 + 196])
                            if not mem[_651 + 196]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                            require idx < mem[96]
                            _1431 = mem[mem[(32 * idx) + 128]]
                            mem[_651 + ceil32(return_data.size) + 165] = 0xd0e30db000000000000000000000000000000000000000000000000000000000
                            require ext_code.size(address(_1431))
                            call address(_1431).deposit() with:
                                 gas gas_remaining wei
            else:
                if mem[mem[(32 * idx) + 128] + 62 len 2] * _105 / _105 != mem[mem[(32 * idx) + 128] + 62 len 2]:
                    revert with 0, 'SafeMath: multiplication overflow'
                _636 = mem[64]
                mem[64] = mem[64] + 64
                mem[_636] = 26
                mem[_636 + 32] = 'SafeMath: division by zero'
                require idx < mem[96]
                _653 = mem[64]
                mem[mem[64] + 36] = mem[mem[(32 * idx) + 128] + 12 len 20]
                mem[mem[64] + 68] = uint16(_628) * _105 / 1000
                _661 = mem[64]
                mem[mem[64]] = 68
                mem[64] = mem[64] + 100
                mem[_661 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_661 + 36 len 28]
                mem[64] = _653 + 164
                mem[_653 + 100] = 32
                mem[_653 + 132] = 'SafeERC20: low-level call failed'
                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(wantAddress):
                    revert with 0, 'Address: call to non-contract'
                if not ext_code.hash(wantAddress):
                    revert with 0, 'Address: call to non-contract'
                _683 = mem[_661]
                t = 0
                while t < _683:
                    mem[t + _653 + 164] = mem[t + _661 + 32]
                    _585 = mem[96]
                    t = t + 32
                    continue 
                if ceil32(_683) <= _683:
                    call wantAddress.mem[_653 + 164 len 4] with:
                         gas gas_remaining wei
                        args mem[_653 + 168 len _683 - 4]
                    if not return_data.size:
                        if not ext_call.success:
                            if mem[96]:
                                revert with memory
                                  from 128
                                   len mem[96]
                            mem[_653 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[_653 + 168] = 32
                            idx = 0
                            while idx < 32:
                                mem[idx + _653 + 232] = mem[idx + _653 + 132]
                                _585 = mem[96]
                                idx = idx + 32
                                continue 
                            revert with 0, 32, 32, mem[_653 + 232]
                        if not mem[96]:
                            require idx < mem[96]
                            _1259 = mem[mem[(32 * idx) + 128]]
                            mem[_653 + 164] = 0xd0e30db000000000000000000000000000000000000000000000000000000000
                            require ext_code.size(address(_1259))
                            call address(_1259).deposit() with:
                                 gas gas_remaining wei
                        else:
                            require mem[96] >= 32
                            require mem[128] == bool(mem[128])
                            if not mem[128]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                            require idx < mem[96]
                            _1403 = mem[mem[(32 * idx) + 128]]
                            mem[_653 + 164] = 0xd0e30db000000000000000000000000000000000000000000000000000000000
                            require ext_code.size(address(_1403))
                            call address(_1403).deposit() with:
                                 gas gas_remaining wei
                    else:
                        mem[64] = _653 + ceil32(return_data.size) + 165
                        mem[_653 + 164] = return_data.size
                        mem[_653 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_653 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[_653 + ceil32(return_data.size) + 169] = 32
                            idx = 0
                            while idx < 32:
                                mem[idx + _653 + ceil32(return_data.size) + 233] = mem[idx + _653 + 132]
                                _585 = mem[96]
                                idx = idx + 32
                                continue 
                            revert with 0, 32, 32, mem[_653 + ceil32(return_data.size) + 233]
                        if not return_data.size:
                            require idx < mem[96]
                            _1263 = mem[mem[(32 * idx) + 128]]
                            mem[_653 + ceil32(return_data.size) + 165] = 0xd0e30db000000000000000000000000000000000000000000000000000000000
                            require ext_code.size(address(_1263))
                            call address(_1263).deposit() with:
                                 gas gas_remaining wei
                        else:
                            require return_data.size >= 32
                            require mem[_653 + 196] == bool(mem[_653 + 196])
                            if not mem[_653 + 196]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                            require idx < mem[96]
                            _1407 = mem[mem[(32 * idx) + 128]]
                            mem[_653 + ceil32(return_data.size) + 165] = 0xd0e30db000000000000000000000000000000000000000000000000000000000
                            require ext_code.size(address(_1407))
                            call address(_1407).deposit() with:
                                 gas gas_remaining wei
                else:
                    mem[_683 + _653 + 164] = 0
                    call wantAddress.mem[_653 + 164 len 4] with:
                         gas gas_remaining wei
                        args mem[_653 + 168 len _683 - 4]
                    if not return_data.size:
                        if not ext_call.success:
                            if mem[96]:
                                revert with memory
                                  from 128
                                   len mem[96]
                            mem[_653 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[_653 + 168] = 32
                            idx = 0
                            while idx < 32:
                                mem[idx + _653 + 232] = mem[idx + _653 + 132]
                                _585 = mem[96]
                                idx = idx + 32
                                continue 
                            revert with 0, 32, 32, mem[_653 + 232]
                        if not mem[96]:
                            require idx < mem[96]
                            _1267 = mem[mem[(32 * idx) + 128]]
                            mem[_653 + 164] = 0xd0e30db000000000000000000000000000000000000000000000000000000000
                            require ext_code.size(address(_1267))
                            call address(_1267).deposit() with:
                                 gas gas_remaining wei
                        else:
                            require mem[96] >= 32
                            require mem[128] == bool(mem[128])
                            if not mem[128]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                            require idx < mem[96]
                            _1411 = mem[mem[(32 * idx) + 128]]
                            mem[_653 + 164] = 0xd0e30db000000000000000000000000000000000000000000000000000000000
                            require ext_code.size(address(_1411))
                            call address(_1411).deposit() with:
                                 gas gas_remaining wei
                    else:
                        mem[64] = _653 + ceil32(return_data.size) + 165
                        mem[_653 + 164] = return_data.size
                        mem[_653 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_653 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[_653 + ceil32(return_data.size) + 169] = 32
                            idx = 0
                            while idx < 32:
                                mem[idx + _653 + ceil32(return_data.size) + 233] = mem[idx + _653 + 132]
                                _585 = mem[96]
                                idx = idx + 32
                                continue 
                            revert with 0, 32, 32, mem[_653 + ceil32(return_data.size) + 233]
                        if not return_data.size:
                            require idx < mem[96]
                            _1271 = mem[mem[(32 * idx) + 128]]
                            mem[_653 + ceil32(return_data.size) + 165] = 0xd0e30db000000000000000000000000000000000000000000000000000000000
                            require ext_code.size(address(_1271))
                            call address(_1271).deposit() with:
                                 gas gas_remaining wei
                        else:
                            require return_data.size >= 32
                            require mem[_653 + 196] == bool(mem[_653 + 196])
                            if not mem[_653 + 196]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                            require idx < mem[96]
                            _1415 = mem[mem[(32 * idx) + 128]]
                            mem[_653 + ceil32(return_data.size) + 165] = 0xd0e30db000000000000000000000000000000000000000000000000000000000
                            require ext_code.size(address(_1415))
                            call address(_1415).deposit() with:
                                 gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _585 = mem[96]
            idx = idx + 1
            s = uint16(_616) + s
            continue 
    if s != 1000:
        revert with 0, 'SHARE!=1000'
}

function tend() payable {
    require ext_code.size(vaultAddress)
    if msg.sender == keeperAddress:
        staticcall vaultAddress.debtOutstanding() with:
                gas gas_remaining wei
        mem[96] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if not emergencyExit:
            if lenders.length:
                mem[ceil32(return_data.size) + 100] = this.address
                require ext_code.size(wantAddress)
                staticcall wantAddress.balanceOf(address arg1) with:
                        gas gas_remaining wei
                       args this.address
                mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[64] = (2 * ceil32(return_data.size)) + 96
                require return_data.size >= 32
                idx = 0
                s = 0
                t = -1
                while idx < lenders.length:
                    mem[0] = 13
                    require ext_code.size(lenders[idx])
                    staticcall lenders[idx].hasAssets() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _185 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_185] == bool(mem[_185])
                    if not mem[_185]:
                        idx = idx + 1
                        s = s
                        t = t
                        continue 
                    require idx < lenders.length
                    mem[0] = 13
                    require ext_code.size(lenders[idx])
                    staticcall lenders[idx].apr() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _240 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _245 = mem[_240]
                    if mem[_240] >= t:
                        idx = idx + 1
                        s = s
                        t = t
                        continue 
                    require idx < lenders.length
                    mem[0] = 13
                    require ext_code.size(lenders[idx])
                    staticcall lenders[idx].nav() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _265 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    idx = idx + 1
                    s = mem[_265]
                    t = _245
                    continue 
                if ext_call.return_data[0] + s < s:
                    revert with 0, 'SafeMath: addition overflow'
                idx = 0
                u = 0
                while idx < lenders.length:
                    mem[0] = 13
                    mem[mem[64] + 4] = ext_call.return_data[0]
                    require ext_code.size(lenders[idx])
                    staticcall lenders[idx].aprAfterDeposit(uint256 arg1) with:
                            gas gas_remaining wei
                           args ext_call.return_data[0]
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _306 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if mem[_306] <= u:
                        idx = idx + 1
                        u = u
                        continue 
                    idx = idx + 1
                    u = mem[_306]
                    continue 
                require 0 < lenders.length
                mem[0] = 13
                mem[mem[64] + 4] = ext_call.return_data[0] + s
                require ext_code.size(lenders)
                staticcall lenders.aprAfterDeposit(uint256 arg1) with:
                        gas gas_remaining wei
                       args (ext_call.return_data[0] + s)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _305 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if mem[_305] <= t:
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(wantAddress)
                    staticcall wantAddress.balanceOf(address arg1) with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _355 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _365 = mem[_355]
                    if mem[_355]:
                        require 0 < lenders.length
                        mem[0] = 13
                        _375 = mem[64]
                        mem[mem[64] + 36] = lenders
                        mem[mem[64] + 68] = _365
                        _385 = mem[64]
                        mem[mem[64]] = 68
                        mem[mem[64] + 32 len 4] = transfer(address arg1, uint256 arg2)
                        mem[64] = mem[64] + 164
                        mem[_375 + 100] = 32
                        mem[_375 + 132] = 'SafeERC20: low-level call failed'
                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(wantAddress):
                            revert with 0, 'Address: call to non-contract'
                        if not ext_code.hash(wantAddress):
                            revert with 0, 'Address: call to non-contract'
                        _435 = mem[_385]
                        mem[_375 + 164 len ceil32(mem[_385])] = mem[_385 + 32 len ceil32(mem[_385])]
                        if ceil32(_435) > _435:
                            mem[_435 + _375 + 164] = 0
                        call wantAddress with:
                             gas gas_remaining wei
                            args mem[_375 + 168 len _435 - 4]
                        if not return_data.size:
                            if not ext_call.success:
                                if mem[96]:
                                    revert with memory
                                      from 128
                                       len mem[96]
                                revert with 0, 'SafeERC20: low-level call failed'
                            if mem[96]:
                                require mem[96] >= 32
                                require mem[128] == bool(mem[128])
                                if not mem[128]:
                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                        else:
                            mem[_375 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                if return_data.size:
                                    revert with ext_call.return_data[0 len return_data.size]
                                revert with 0, 'SafeERC20: low-level call failed'
                            if return_data.size:
                                require return_data.size >= 32
                                require mem[_375 + 196] == bool(mem[_375 + 196])
                                if not mem[_375 + 196]:
                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                        require 0 < lenders.length
                        require ext_code.size(lenders)
                        call lenders.deposit() with:
                             gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                else:
                    require 0 < lenders.length
                    mem[0] = 13
                    require ext_code.size(lenders)
                    call lenders.withdrawAll() with:
                         gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _350 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_350] == bool(mem[_350])
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(wantAddress)
                    staticcall wantAddress.balanceOf(address arg1) with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _405 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _410 = mem[_405]
                    if mem[_405]:
                        require 0 < lenders.length
                        mem[0] = 13
                        _436 = mem[64]
                        mem[mem[64] + 36] = lenders
                        mem[mem[64] + 68] = _410
                        _455 = mem[64]
                        mem[mem[64]] = 68
                        mem[mem[64] + 32 len 4] = transfer(address arg1, uint256 arg2)
                        mem[64] = mem[64] + 164
                        mem[_436 + 100] = 32
                        mem[_436 + 132] = 'SafeERC20: low-level call failed'
                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(wantAddress):
                            revert with 0, 'Address: call to non-contract'
                        if not ext_code.hash(wantAddress):
                            revert with 0, 'Address: call to non-contract'
                        _538 = mem[_455]
                        mem[_436 + 164 len ceil32(mem[_455])] = mem[_455 + 32 len ceil32(mem[_455])]
                        if ceil32(_538) > _538:
                            mem[_538 + _436 + 164] = 0
                        call wantAddress with:
                             gas gas_remaining wei
                            args mem[_436 + 168 len _538 - 4]
                        if not return_data.size:
                            if not ext_call.success:
                                if mem[96]:
                                    revert with memory
                                      from 128
                                       len mem[96]
                                revert with 0, 'SafeERC20: low-level call failed'
                            if mem[96]:
                                require mem[96] >= 32
                                require mem[128] == bool(mem[128])
                                if not mem[128]:
                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                        else:
                            mem[_436 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                if return_data.size:
                                    revert with ext_call.return_data[0 len return_data.size]
                                revert with 0, 'SafeERC20: low-level call failed'
                            if return_data.size:
                                require return_data.size >= 32
                                require mem[_436 + 196] == bool(mem[_436 + 196])
                                if not mem[_436 + 196]:
                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                        require 0 < lenders.length
                        require ext_code.size(lenders)
                        call lenders.deposit() with:
                             gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
    else:
        if msg.sender == strategistAddress:
            staticcall vaultAddress.debtOutstanding() with:
                    gas gas_remaining wei
            mem[96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if not emergencyExit:
                if lenders.length:
                    mem[ceil32(return_data.size) + 100] = this.address
                    require ext_code.size(wantAddress)
                    staticcall wantAddress.balanceOf(address arg1) with:
                            gas gas_remaining wei
                           args this.address
                    mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = (2 * ceil32(return_data.size)) + 96
                    require return_data.size >= 32
                    idx = 0
                    s = 0
                    t = -1
                    while idx < lenders.length:
                        mem[0] = 13
                        require ext_code.size(lenders[idx])
                        staticcall lenders[idx].hasAssets() with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _186 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_186] == bool(mem[_186])
                        if not mem[_186]:
                            idx = idx + 1
                            s = s
                            t = t
                            continue 
                        require idx < lenders.length
                        mem[0] = 13
                        require ext_code.size(lenders[idx])
                        staticcall lenders[idx].apr() with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _241 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _246 = mem[_241]
                        if mem[_241] >= t:
                            idx = idx + 1
                            s = s
                            t = t
                            continue 
                        require idx < lenders.length
                        mem[0] = 13
                        require ext_code.size(lenders[idx])
                        staticcall lenders[idx].nav() with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _266 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        idx = idx + 1
                        s = mem[_266]
                        t = _246
                        continue 
                    if ext_call.return_data[0] + s < s:
                        revert with 0, 'SafeMath: addition overflow'
                    idx = 0
                    u = 0
                    while idx < lenders.length:
                        mem[0] = 13
                        mem[mem[64] + 4] = ext_call.return_data[0]
                        require ext_code.size(lenders[idx])
                        staticcall lenders[idx].aprAfterDeposit(uint256 arg1) with:
                                gas gas_remaining wei
                               args ext_call.return_data[0]
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _308 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if mem[_308] <= u:
                            idx = idx + 1
                            u = u
                            continue 
                        idx = idx + 1
                        u = mem[_308]
                        continue 
                    require 0 < lenders.length
                    mem[0] = 13
                    mem[mem[64] + 4] = ext_call.return_data[0] + s
                    require ext_code.size(lenders)
                    staticcall lenders.aprAfterDeposit(uint256 arg1) with:
                            gas gas_remaining wei
                           args (ext_call.return_data[0] + s)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _307 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if mem[_307] <= t:
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(wantAddress)
                        staticcall wantAddress.balanceOf(address arg1) with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _356 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _366 = mem[_356]
                        if mem[_356]:
                            require 0 < lenders.length
                            mem[0] = 13
                            _377 = mem[64]
                            mem[mem[64] + 36] = lenders
                            mem[mem[64] + 68] = _366
                            _388 = mem[64]
                            mem[mem[64]] = 68
                            mem[mem[64] + 32 len 4] = transfer(address arg1, uint256 arg2)
                            mem[64] = mem[64] + 164
                            mem[_377 + 100] = 32
                            mem[_377 + 132] = 'SafeERC20: low-level call failed'
                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(wantAddress):
                                revert with 0, 'Address: call to non-contract'
                            if not ext_code.hash(wantAddress):
                                revert with 0, 'Address: call to non-contract'
                            _437 = mem[_388]
                            mem[_377 + 164 len ceil32(mem[_388])] = mem[_388 + 32 len ceil32(mem[_388])]
                            if ceil32(_437) > _437:
                                mem[_437 + _377 + 164] = 0
                            call wantAddress with:
                                 gas gas_remaining wei
                                args mem[_377 + 168 len _437 - 4]
                            if not return_data.size:
                                if not ext_call.success:
                                    if mem[96]:
                                        revert with memory
                                          from 128
                                           len mem[96]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if mem[96]:
                                    require mem[96] >= 32
                                    require mem[128] == bool(mem[128])
                                    if not mem[128]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                            else:
                                mem[_377 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    if return_data.size:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if return_data.size:
                                    require return_data.size >= 32
                                    require mem[_377 + 196] == bool(mem[_377 + 196])
                                    if not mem[_377 + 196]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                            require 0 < lenders.length
                            require ext_code.size(lenders)
                            call lenders.deposit() with:
                                 gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                    else:
                        require 0 < lenders.length
                        mem[0] = 13
                        require ext_code.size(lenders)
                        call lenders.withdrawAll() with:
                             gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _351 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_351] == bool(mem[_351])
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(wantAddress)
                        staticcall wantAddress.balanceOf(address arg1) with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _406 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _411 = mem[_406]
                        if mem[_406]:
                            require 0 < lenders.length
                            mem[0] = 13
                            _438 = mem[64]
                            mem[mem[64] + 36] = lenders
                            mem[mem[64] + 68] = _411
                            _457 = mem[64]
                            mem[mem[64]] = 68
                            mem[mem[64] + 32 len 4] = transfer(address arg1, uint256 arg2)
                            mem[64] = mem[64] + 164
                            mem[_438 + 100] = 32
                            mem[_438 + 132] = 'SafeERC20: low-level call failed'
                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(wantAddress):
                                revert with 0, 'Address: call to non-contract'
                            if not ext_code.hash(wantAddress):
                                revert with 0, 'Address: call to non-contract'
                            _547 = mem[_457]
                            mem[_438 + 164 len ceil32(mem[_457])] = mem[_457 + 32 len ceil32(mem[_457])]
                            if ceil32(_547) > _547:
                                mem[_547 + _438 + 164] = 0
                            call wantAddress with:
                                 gas gas_remaining wei
                                args mem[_438 + 168 len _547 - 4]
                            if not return_data.size:
                                if not ext_call.success:
                                    if mem[96]:
                                        revert with memory
                                          from 128
                                           len mem[96]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if mem[96]:
                                    require mem[96] >= 32
                                    require mem[128] == bool(mem[128])
                                    if not mem[128]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                            else:
                                mem[_438 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    if return_data.size:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if return_data.size:
                                    require return_data.size >= 32
                                    require mem[_438 + 196] == bool(mem[_438 + 196])
                                    if not mem[_438 + 196]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                            require 0 < lenders.length
                            require ext_code.size(lenders)
                            call lenders.deposit() with:
                                 gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
        else:
            staticcall vaultAddress.governance() with:
                    gas gas_remaining wei
            mem[96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
            require ext_code.size(vaultAddress)
            if msg.sender == ext_call.return_data[12 len 20]:
                staticcall vaultAddress.debtOutstanding() with:
                        gas gas_remaining wei
                mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if not emergencyExit:
                    if lenders.length:
                        mem[(2 * ceil32(return_data.size)) + 100] = this.address
                        require ext_code.size(wantAddress)
                        staticcall wantAddress.balanceOf(address arg1) with:
                                gas gas_remaining wei
                               args this.address
                        mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[64] = (4 * ceil32(return_data.size)) + 96
                        require return_data.size >= 32
                        idx = 0
                        s = 0
                        t = -1
                        while idx < lenders.length:
                            mem[0] = 13
                            require ext_code.size(lenders[idx])
                            staticcall lenders[idx].hasAssets() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _187 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_187] == bool(mem[_187])
                            if not mem[_187]:
                                idx = idx + 1
                                s = s
                                t = t
                                continue 
                            require idx < lenders.length
                            mem[0] = 13
                            require ext_code.size(lenders[idx])
                            staticcall lenders[idx].apr() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _242 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _247 = mem[_242]
                            if mem[_242] >= t:
                                idx = idx + 1
                                s = s
                                t = t
                                continue 
                            require idx < lenders.length
                            mem[0] = 13
                            require ext_code.size(lenders[idx])
                            staticcall lenders[idx].nav() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _267 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            idx = idx + 1
                            s = mem[_267]
                            t = _247
                            continue 
                        if ext_call.return_data[0] + s < s:
                            revert with 0, 'SafeMath: addition overflow'
                        idx = 0
                        u = 0
                        while idx < lenders.length:
                            mem[0] = 13
                            mem[mem[64] + 4] = ext_call.return_data[0]
                            require ext_code.size(lenders[idx])
                            staticcall lenders[idx].aprAfterDeposit(uint256 arg1) with:
                                    gas gas_remaining wei
                                   args ext_call.return_data[0]
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _310 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if mem[_310] <= u:
                                idx = idx + 1
                                u = u
                                continue 
                            idx = idx + 1
                            u = mem[_310]
                            continue 
                        require 0 < lenders.length
                        mem[0] = 13
                        mem[mem[64] + 4] = ext_call.return_data[0] + s
                        require ext_code.size(lenders)
                        staticcall lenders.aprAfterDeposit(uint256 arg1) with:
                                gas gas_remaining wei
                               args (ext_call.return_data[0] + s)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _309 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if mem[_309] <= t:
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(wantAddress)
                            staticcall wantAddress.balanceOf(address arg1) with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _357 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _367 = mem[_357]
                            if mem[_357]:
                                require 0 < lenders.length
                                mem[0] = 13
                                _379 = mem[64]
                                mem[mem[64] + 36] = lenders
                                mem[mem[64] + 68] = _367
                                _391 = mem[64]
                                mem[mem[64]] = 68
                                mem[mem[64] + 32 len 4] = transfer(address arg1, uint256 arg2)
                                mem[64] = mem[64] + 164
                                mem[_379 + 100] = 32
                                mem[_379 + 132] = 'SafeERC20: low-level call failed'
                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(wantAddress):
                                    revert with 0, 'Address: call to non-contract'
                                if not ext_code.hash(wantAddress):
                                    revert with 0, 'Address: call to non-contract'
                                _439 = mem[_391]
                                mem[_379 + 164 len ceil32(mem[_391])] = mem[_391 + 32 len ceil32(mem[_391])]
                                if ceil32(_439) > _439:
                                    mem[_439 + _379 + 164] = 0
                                call wantAddress with:
                                     gas gas_remaining wei
                                    args mem[_379 + 168 len _439 - 4]
                                if not return_data.size:
                                    if not ext_call.success:
                                        if mem[96]:
                                            revert with memory
                                              from 128
                                               len mem[96]
                                        revert with 0, 'SafeERC20: low-level call failed'
                                    if mem[96]:
                                        require mem[96] >= 32
                                        require mem[128] == bool(mem[128])
                                        if not mem[128]:
                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                else:
                                    mem[_379 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    if not ext_call.success:
                                        if return_data.size:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        revert with 0, 'SafeERC20: low-level call failed'
                                    if return_data.size:
                                        require return_data.size >= 32
                                        require mem[_379 + 196] == bool(mem[_379 + 196])
                                        if not mem[_379 + 196]:
                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                require 0 < lenders.length
                                require ext_code.size(lenders)
                                call lenders.deposit() with:
                                     gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                        else:
                            require 0 < lenders.length
                            mem[0] = 13
                            require ext_code.size(lenders)
                            call lenders.withdrawAll() with:
                                 gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _352 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_352] == bool(mem[_352])
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(wantAddress)
                            staticcall wantAddress.balanceOf(address arg1) with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _407 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _412 = mem[_407]
                            if mem[_407]:
                                require 0 < lenders.length
                                mem[0] = 13
                                _440 = mem[64]
                                mem[mem[64] + 36] = lenders
                                mem[mem[64] + 68] = _412
                                _459 = mem[64]
                                mem[mem[64]] = 68
                                mem[mem[64] + 32 len 4] = transfer(address arg1, uint256 arg2)
                                mem[64] = mem[64] + 164
                                mem[_440 + 100] = 32
                                mem[_440 + 132] = 'SafeERC20: low-level call failed'
                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(wantAddress):
                                    revert with 0, 'Address: call to non-contract'
                                if not ext_code.hash(wantAddress):
                                    revert with 0, 'Address: call to non-contract'
                                _556 = mem[_459]
                                mem[_440 + 164 len ceil32(mem[_459])] = mem[_459 + 32 len ceil32(mem[_459])]
                                if ceil32(_556) > _556:
                                    mem[_556 + _440 + 164] = 0
                                call wantAddress with:
                                     gas gas_remaining wei
                                    args mem[_440 + 168 len _556 - 4]
                                if not return_data.size:
                                    if not ext_call.success:
                                        if mem[96]:
                                            revert with memory
                                              from 128
                                               len mem[96]
                                        revert with 0, 'SafeERC20: low-level call failed'
                                    if mem[96]:
                                        require mem[96] >= 32
                                        require mem[128] == bool(mem[128])
                                        if not mem[128]:
                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                else:
                                    mem[_440 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    if not ext_call.success:
                                        if return_data.size:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        revert with 0, 'SafeERC20: low-level call failed'
                                    if return_data.size:
                                        require return_data.size >= 32
                                        require mem[_440 + 196] == bool(mem[_440 + 196])
                                        if not mem[_440 + 196]:
                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                require 0 < lenders.length
                                require ext_code.size(lenders)
                                call lenders.deposit() with:
                                     gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
            else:
                staticcall vaultAddress.guardian() with:
                        gas gas_remaining wei
                mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                require ext_code.size(vaultAddress)
                if msg.sender == ext_call.return_data[12 len 20]:
                    staticcall vaultAddress.debtOutstanding() with:
                            gas gas_remaining wei
                    mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if not emergencyExit:
                        if lenders.length:
                            mem[(4 * ceil32(return_data.size)) + 100] = this.address
                            require ext_code.size(wantAddress)
                            staticcall wantAddress.balanceOf(address arg1) with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[64] = (6 * ceil32(return_data.size)) + 96
                            require return_data.size >= 32
                            idx = 0
                            s = 0
                            t = -1
                            while idx < lenders.length:
                                mem[0] = 13
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].hasAssets() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _188 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_188] == bool(mem[_188])
                                if not mem[_188]:
                                    idx = idx + 1
                                    s = s
                                    t = t
                                    continue 
                                require idx < lenders.length
                                mem[0] = 13
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].apr() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _243 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _248 = mem[_243]
                                if mem[_243] >= t:
                                    idx = idx + 1
                                    s = s
                                    t = t
                                    continue 
                                require idx < lenders.length
                                mem[0] = 13
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].nav() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _268 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                idx = idx + 1
                                s = mem[_268]
                                t = _248
                                continue 
                            if ext_call.return_data[0] + s < s:
                                revert with 0, 'SafeMath: addition overflow'
                            idx = 0
                            u = 0
                            while idx < lenders.length:
                                mem[0] = 13
                                mem[mem[64] + 4] = ext_call.return_data[0]
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].aprAfterDeposit(uint256 arg1) with:
                                        gas gas_remaining wei
                                       args ext_call.return_data[0]
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _312 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if mem[_312] <= u:
                                    idx = idx + 1
                                    u = u
                                    continue 
                                idx = idx + 1
                                u = mem[_312]
                                continue 
                            require 0 < lenders.length
                            mem[0] = 13
                            mem[mem[64] + 4] = ext_call.return_data[0] + s
                            require ext_code.size(lenders)
                            staticcall lenders.aprAfterDeposit(uint256 arg1) with:
                                    gas gas_remaining wei
                                   args (ext_call.return_data[0] + s)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _311 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if mem[_311] <= t:
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(wantAddress)
                                staticcall wantAddress.balanceOf(address arg1) with:
                                        gas gas_remaining wei
                                       args address(this.address)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _358 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _368 = mem[_358]
                                if mem[_358]:
                                    require 0 < lenders.length
                                    mem[0] = 13
                                    _381 = mem[64]
                                    mem[mem[64] + 36] = lenders
                                    mem[mem[64] + 68] = _368
                                    _394 = mem[64]
                                    mem[mem[64]] = 68
                                    mem[mem[64] + 32 len 4] = transfer(address arg1, uint256 arg2)
                                    mem[64] = mem[64] + 164
                                    mem[_381 + 100] = 32
                                    mem[_381 + 132] = 'SafeERC20: low-level call failed'
                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(wantAddress):
                                        revert with 0, 'Address: call to non-contract'
                                    if not ext_code.hash(wantAddress):
                                        revert with 0, 'Address: call to non-contract'
                                    _441 = mem[_394]
                                    mem[_381 + 164 len ceil32(mem[_394])] = mem[_394 + 32 len ceil32(mem[_394])]
                                    if ceil32(_441) > _441:
                                        mem[_441 + _381 + 164] = 0
                                    call wantAddress with:
                                         gas gas_remaining wei
                                        args mem[_381 + 168 len _441 - 4]
                                    if not return_data.size:
                                        if not ext_call.success:
                                            if mem[96]:
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            revert with 0, 'SafeERC20: low-level call failed'
                                        if mem[96]:
                                            require mem[96] >= 32
                                            require mem[128] == bool(mem[128])
                                            if not mem[128]:
                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    else:
                                        mem[_381 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            if return_data.size:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            revert with 0, 'SafeERC20: low-level call failed'
                                        if return_data.size:
                                            require return_data.size >= 32
                                            require mem[_381 + 196] == bool(mem[_381 + 196])
                                            if not mem[_381 + 196]:
                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    require 0 < lenders.length
                                    require ext_code.size(lenders)
                                    call lenders.deposit() with:
                                         gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                            else:
                                require 0 < lenders.length
                                mem[0] = 13
                                require ext_code.size(lenders)
                                call lenders.withdrawAll() with:
                                     gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _353 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_353] == bool(mem[_353])
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(wantAddress)
                                staticcall wantAddress.balanceOf(address arg1) with:
                                        gas gas_remaining wei
                                       args address(this.address)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _408 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _413 = mem[_408]
                                if mem[_408]:
                                    require 0 < lenders.length
                                    mem[0] = 13
                                    _442 = mem[64]
                                    mem[mem[64] + 36] = lenders
                                    mem[mem[64] + 68] = _413
                                    _461 = mem[64]
                                    mem[mem[64]] = 68
                                    mem[mem[64] + 32 len 4] = transfer(address arg1, uint256 arg2)
                                    mem[64] = mem[64] + 164
                                    mem[_442 + 100] = 32
                                    mem[_442 + 132] = 'SafeERC20: low-level call failed'
                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(wantAddress):
                                        revert with 0, 'Address: call to non-contract'
                                    if not ext_code.hash(wantAddress):
                                        revert with 0, 'Address: call to non-contract'
                                    _565 = mem[_461]
                                    mem[_442 + 164 len ceil32(mem[_461])] = mem[_461 + 32 len ceil32(mem[_461])]
                                    if ceil32(_565) > _565:
                                        mem[_565 + _442 + 164] = 0
                                    call wantAddress with:
                                         gas gas_remaining wei
                                        args mem[_442 + 168 len _565 - 4]
                                    if not return_data.size:
                                        if not ext_call.success:
                                            if mem[96]:
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            revert with 0, 'SafeERC20: low-level call failed'
                                        if mem[96]:
                                            require mem[96] >= 32
                                            require mem[128] == bool(mem[128])
                                            if not mem[128]:
                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    else:
                                        mem[_442 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            if return_data.size:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            revert with 0, 'SafeERC20: low-level call failed'
                                        if return_data.size:
                                            require return_data.size >= 32
                                            require mem[_442 + 196] == bool(mem[_442 + 196])
                                            if not mem[_442 + 196]:
                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    require 0 < lenders.length
                                    require ext_code.size(lenders)
                                    call lenders.deposit() with:
                                         gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                else:
                    staticcall vaultAddress.management() with:
                            gas gas_remaining wei
                    mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                    if ext_call.return_data[12 len 20] != msg.sender:
                        revert with 0, '!authorized'
                    require ext_code.size(vaultAddress)
                    staticcall vaultAddress.debtOutstanding() with:
                            gas gas_remaining wei
                    mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if not emergencyExit:
                        if lenders.length:
                            mem[(6 * ceil32(return_data.size)) + 100] = this.address
                            require ext_code.size(wantAddress)
                            staticcall wantAddress.balanceOf(address arg1) with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[(6 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[64] = (7 * ceil32(return_data.size)) + 96
                            require return_data.size >= 32
                            idx = 0
                            s = 0
                            t = -1
                            while idx < lenders.length:
                                mem[0] = 13
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].hasAssets() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _189 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_189] == bool(mem[_189])
                                if not mem[_189]:
                                    idx = idx + 1
                                    s = s
                                    t = t
                                    continue 
                                require idx < lenders.length
                                mem[0] = 13
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].apr() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _244 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _249 = mem[_244]
                                if mem[_244] >= t:
                                    idx = idx + 1
                                    s = s
                                    t = t
                                    continue 
                                require idx < lenders.length
                                mem[0] = 13
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].nav() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _269 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                idx = idx + 1
                                s = mem[_269]
                                t = _249
                                continue 
                            if ext_call.return_data[0] + s < s:
                                revert with 0, 'SafeMath: addition overflow'
                            idx = 0
                            u = 0
                            while idx < lenders.length:
                                mem[0] = 13
                                mem[mem[64] + 4] = ext_call.return_data[0]
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].aprAfterDeposit(uint256 arg1) with:
                                        gas gas_remaining wei
                                       args ext_call.return_data[0]
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _314 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if mem[_314] <= u:
                                    idx = idx + 1
                                    u = u
                                    continue 
                                idx = idx + 1
                                u = mem[_314]
                                continue 
                            require 0 < lenders.length
                            mem[0] = 13
                            mem[mem[64] + 4] = ext_call.return_data[0] + s
                            require ext_code.size(lenders)
                            staticcall lenders.aprAfterDeposit(uint256 arg1) with:
                                    gas gas_remaining wei
                                   args (ext_call.return_data[0] + s)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _313 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if mem[_313] <= t:
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(wantAddress)
                                staticcall wantAddress.balanceOf(address arg1) with:
                                        gas gas_remaining wei
                                       args address(this.address)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _359 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _369 = mem[_359]
                                if mem[_359]:
                                    require 0 < lenders.length
                                    mem[0] = 13
                                    _383 = mem[64]
                                    mem[mem[64] + 36] = lenders
                                    mem[mem[64] + 68] = _369
                                    _397 = mem[64]
                                    mem[mem[64]] = 68
                                    mem[mem[64] + 32 len 4] = transfer(address arg1, uint256 arg2)
                                    mem[64] = mem[64] + 164
                                    mem[_383 + 100] = 32
                                    mem[_383 + 132] = 'SafeERC20: low-level call failed'
                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(wantAddress):
                                        revert with 0, 'Address: call to non-contract'
                                    if not ext_code.hash(wantAddress):
                                        revert with 0, 'Address: call to non-contract'
                                    _443 = mem[_397]
                                    mem[_383 + 164 len ceil32(mem[_397])] = mem[_397 + 32 len ceil32(mem[_397])]
                                    if ceil32(_443) > _443:
                                        mem[_443 + _383 + 164] = 0
                                    call wantAddress with:
                                         gas gas_remaining wei
                                        args mem[_383 + 168 len _443 - 4]
                                    if not return_data.size:
                                        if not ext_call.success:
                                            if mem[96]:
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            revert with 0, 'SafeERC20: low-level call failed'
                                        if mem[96]:
                                            require mem[96] >= 32
                                            require mem[128] == bool(mem[128])
                                            if not mem[128]:
                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    else:
                                        mem[_383 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            if return_data.size:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            revert with 0, 'SafeERC20: low-level call failed'
                                        if return_data.size:
                                            require return_data.size >= 32
                                            require mem[_383 + 196] == bool(mem[_383 + 196])
                                            if not mem[_383 + 196]:
                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    require 0 < lenders.length
                                    require ext_code.size(lenders)
                                    call lenders.deposit() with:
                                         gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                            else:
                                require 0 < lenders.length
                                mem[0] = 13
                                require ext_code.size(lenders)
                                call lenders.withdrawAll() with:
                                     gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _354 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_354] == bool(mem[_354])
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(wantAddress)
                                staticcall wantAddress.balanceOf(address arg1) with:
                                        gas gas_remaining wei
                                       args address(this.address)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _409 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _414 = mem[_409]
                                if mem[_409]:
                                    require 0 < lenders.length
                                    mem[0] = 13
                                    _444 = mem[64]
                                    mem[mem[64] + 36] = lenders
                                    mem[mem[64] + 68] = _414
                                    _463 = mem[64]
                                    mem[mem[64]] = 68
                                    mem[mem[64] + 32 len 4] = transfer(address arg1, uint256 arg2)
                                    mem[64] = mem[64] + 164
                                    mem[_444 + 100] = 32
                                    mem[_444 + 132] = 'SafeERC20: low-level call failed'
                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(wantAddress):
                                        revert with 0, 'Address: call to non-contract'
                                    if not ext_code.hash(wantAddress):
                                        revert with 0, 'Address: call to non-contract'
                                    _574 = mem[_463]
                                    mem[_444 + 164 len ceil32(mem[_463])] = mem[_463 + 32 len ceil32(mem[_463])]
                                    if ceil32(_574) > _574:
                                        mem[_574 + _444 + 164] = 0
                                    call wantAddress with:
                                         gas gas_remaining wei
                                        args mem[_444 + 168 len _574 - 4]
                                    if not return_data.size:
                                        if not ext_call.success:
                                            if mem[96]:
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            revert with 0, 'SafeERC20: low-level call failed'
                                        if mem[96]:
                                            require mem[96] >= 32
                                            require mem[128] == bool(mem[128])
                                            if not mem[128]:
                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    else:
                                        mem[_444 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            if return_data.size:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            revert with 0, 'SafeERC20: low-level call failed'
                                        if return_data.size:
                                            require return_data.size >= 32
                                            require mem[_444 + 196] == bool(mem[_444 + 196])
                                            if not mem[_444 + 196]:
                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    require 0 < lenders.length
                                    require ext_code.size(lenders)
                                    call lenders.deposit() with:
                                         gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
}

function forceRemoveLender(address arg1) payable {
    mem[64] = 96
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if msg.sender == strategistAddress:
        idx = 0
        while idx < lenders.length:
            mem[0] = 13
            if lenders[idx] != arg1:
                idx = idx + 1
                continue 
            require idx < lenders.length
            require ext_code.size(lenders[idx])
            call lenders[idx].withdrawAll() with:
                 gas gas_remaining wei
            mem[96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == bool(ext_call.return_data[0])
            if idx == lenders.length - 1:
                require lenders.length
                mem[0] = 13
                lenders[lenders.length] = 0
                lenders.length--
                mem[ceil32(return_data.size) + 100] = this.address
                require ext_code.size(wantAddress)
                staticcall wantAddress.balanceOf(address arg1) with:
                        gas gas_remaining wei
                       args this.address
                mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if ext_call.return_data[0] > 0:
                    if not emergencyExit:
                        if lenders.length:
                            mem[(2 * ceil32(return_data.size)) + 100] = this.address
                            require ext_code.size(wantAddress)
                            staticcall wantAddress.balanceOf(address arg1) with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[64] = (4 * ceil32(return_data.size)) + 96
                            require return_data.size >= 32
                            idx = 0
                            s = 0
                            t = -1
                            while idx < lenders.length:
                                mem[0] = 13
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].hasAssets() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _311 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_311] == bool(mem[_311])
                                if not mem[_311]:
                                    idx = idx + 1
                                    s = s
                                    t = t
                                    continue 
                                require idx < lenders.length
                                mem[0] = 13
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].apr() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _355 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _359 = mem[_355]
                                if mem[_355] >= t:
                                    idx = idx + 1
                                    s = s
                                    t = t
                                    continue 
                                require idx < lenders.length
                                mem[0] = 13
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].nav() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _375 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                idx = idx + 1
                                s = mem[_375]
                                t = _359
                                continue 
                            if ext_call.return_data[0] + s < s:
                                revert with 0, 'SafeMath: addition overflow'
                            idx = 0
                            u = 0
                            while idx < lenders.length:
                                mem[0] = 13
                                mem[mem[64] + 4] = ext_call.return_data[0]
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].aprAfterDeposit(uint256 arg1) with:
                                        gas gas_remaining wei
                                       args ext_call.return_data[0]
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _408 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if mem[_408] <= u:
                                    idx = idx + 1
                                    u = u
                                    continue 
                                idx = idx + 1
                                u = mem[_408]
                                continue 
                            require 0 < lenders.length
                            mem[0] = 13
                            mem[mem[64] + 4] = ext_call.return_data[0] + s
                            require ext_code.size(lenders)
                            staticcall lenders.aprAfterDeposit(uint256 arg1) with:
                                    gas gas_remaining wei
                                   args (ext_call.return_data[0] + s)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _407 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if mem[_407] <= t:
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(wantAddress)
                                staticcall wantAddress.balanceOf(address arg1) with:
                                        gas gas_remaining wei
                                       args address(this.address)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _447 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _455 = mem[_447]
                                if mem[_447]:
                                    require 0 < lenders.length
                                    mem[0] = 13
                                    _463 = mem[64]
                                    mem[mem[64] + 36] = lenders
                                    mem[mem[64] + 68] = _455
                                    _471 = mem[64]
                                    mem[mem[64]] = 68
                                    mem[64] = mem[64] + 100
                                    mem[_471 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_471 + 36 len 28]
                                    mem[64] = _463 + 164
                                    mem[_463 + 100] = 32
                                    mem[_463 + 132] = 'SafeERC20: low-level call failed'
                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(wantAddress):
                                        revert with 0, 'Address: call to non-contract'
                                    if not ext_code.hash(wantAddress):
                                        revert with 0, 'Address: call to non-contract'
                                    _511 = mem[_471]
                                    idx = 0
                                    while idx < _511:
                                        mem[idx + _463 + 164] = mem[idx + _471 + 32]
                                        idx = idx + 32
                                        continue 
                                    if ceil32(_511) > _511:
                                        mem[_511 + _463 + 164] = 0
                                    call wantAddress.mem[_463 + 164 len 4] with:
                                         gas gas_remaining wei
                                        args mem[_463 + 168 len _511 - 4]
                                    if not return_data.size:
                                        if not ext_call.success:
                                            if mem[96]:
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            mem[_463 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_463 + 168] = 32
                                            idx = 0
                                            while idx < 32:
                                                mem[idx + _463 + 232] = mem[idx + _463 + 132]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 32, 32, mem[_463 + 232]
                                        if mem[96]:
                                            require mem[96] >= 32
                                            require mem[128] == bool(mem[128])
                                            if not mem[128]:
                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    else:
                                        mem[_463 + 164] = return_data.size
                                        mem[_463 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            if return_data.size:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[_463 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_463 + ceil32(return_data.size) + 169] = 32
                                            idx = 0
                                            while idx < 32:
                                                mem[idx + _463 + ceil32(return_data.size) + 233] = mem[idx + _463 + 132]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 32, 32, mem[_463 + ceil32(return_data.size) + 233]
                                        if return_data.size:
                                            require return_data.size >= 32
                                            require mem[_463 + 196] == bool(mem[_463 + 196])
                                            if not mem[_463 + 196]:
                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    require 0 < lenders.length
                                    require ext_code.size(lenders)
                                    call lenders.deposit() with:
                                         gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                            else:
                                require 0 < lenders.length
                                mem[0] = 13
                                require ext_code.size(lenders)
                                call lenders.withdrawAll() with:
                                     gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _443 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_443] == bool(mem[_443])
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(wantAddress)
                                staticcall wantAddress.balanceOf(address arg1) with:
                                        gas gas_remaining wei
                                       args address(this.address)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _487 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _491 = mem[_487]
                                if mem[_487]:
                                    require 0 < lenders.length
                                    mem[0] = 13
                                    _512 = mem[64]
                                    mem[mem[64] + 36] = lenders
                                    mem[mem[64] + 68] = _491
                                    _527 = mem[64]
                                    mem[mem[64]] = 68
                                    mem[64] = mem[64] + 100
                                    mem[_527 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_527 + 36 len 28]
                                    mem[64] = _512 + 164
                                    mem[_512 + 100] = 32
                                    mem[_512 + 132] = 'SafeERC20: low-level call failed'
                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(wantAddress):
                                        revert with 0, 'Address: call to non-contract'
                                    if not ext_code.hash(wantAddress):
                                        revert with 0, 'Address: call to non-contract'
                                    _595 = mem[_527]
                                    idx = 0
                                    while idx < _595:
                                        mem[idx + _512 + 164] = mem[idx + _527 + 32]
                                        idx = idx + 32
                                        continue 
                                    if ceil32(_595) > _595:
                                        mem[_595 + _512 + 164] = 0
                                    call wantAddress.mem[_512 + 164 len 4] with:
                                         gas gas_remaining wei
                                        args mem[_512 + 168 len _595 - 4]
                                    if not return_data.size:
                                        if not ext_call.success:
                                            if mem[96]:
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            mem[_512 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_512 + 168] = 32
                                            idx = 0
                                            while idx < 32:
                                                mem[idx + _512 + 232] = mem[idx + _512 + 132]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 32, 32, mem[_512 + 232]
                                        if mem[96]:
                                            require mem[96] >= 32
                                            require mem[128] == bool(mem[128])
                                            if not mem[128]:
                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    else:
                                        mem[_512 + 164] = return_data.size
                                        mem[_512 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            if return_data.size:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[_512 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_512 + ceil32(return_data.size) + 169] = 32
                                            idx = 0
                                            while idx < 32:
                                                mem[idx + _512 + ceil32(return_data.size) + 233] = mem[idx + _512 + 132]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 32, 32, mem[_512 + ceil32(return_data.size) + 233]
                                        if return_data.size:
                                            require return_data.size >= 32
                                            require mem[_512 + 196] == bool(mem[_512 + 196])
                                            if not mem[_512 + 196]:
                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    require 0 < lenders.length
                                    require ext_code.size(lenders)
                                    call lenders.deposit() with:
                                         gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
            else:
                require lenders.length - 1 < lenders.length
                require idx < lenders.length
                lenders[idx] = lenders[lenders.length]
                require lenders.length
                mem[0] = 13
                lenders[lenders.length] = 0
                lenders.length--
                mem[ceil32(return_data.size) + 100] = this.address
                require ext_code.size(wantAddress)
                staticcall wantAddress.balanceOf(address arg1) with:
                        gas gas_remaining wei
                       args this.address
                mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if ext_call.return_data[0] > 0:
                    if not emergencyExit:
                        if lenders.length:
                            mem[(2 * ceil32(return_data.size)) + 100] = this.address
                            require ext_code.size(wantAddress)
                            staticcall wantAddress.balanceOf(address arg1) with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[64] = (4 * ceil32(return_data.size)) + 96
                            require return_data.size >= 32
                            idx = 0
                            s = 0
                            t = -1
                            while idx < lenders.length:
                                mem[0] = 13
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].hasAssets() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _312 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_312] == bool(mem[_312])
                                if not mem[_312]:
                                    idx = idx + 1
                                    s = s
                                    t = t
                                    continue 
                                require idx < lenders.length
                                mem[0] = 13
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].apr() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _356 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _360 = mem[_356]
                                if mem[_356] >= t:
                                    idx = idx + 1
                                    s = s
                                    t = t
                                    continue 
                                require idx < lenders.length
                                mem[0] = 13
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].nav() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _376 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                idx = idx + 1
                                s = mem[_376]
                                t = _360
                                continue 
                            if ext_call.return_data[0] + s < s:
                                revert with 0, 'SafeMath: addition overflow'
                            idx = 0
                            u = 0
                            while idx < lenders.length:
                                mem[0] = 13
                                mem[mem[64] + 4] = ext_call.return_data[0]
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].aprAfterDeposit(uint256 arg1) with:
                                        gas gas_remaining wei
                                       args ext_call.return_data[0]
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _410 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if mem[_410] <= u:
                                    idx = idx + 1
                                    u = u
                                    continue 
                                idx = idx + 1
                                u = mem[_410]
                                continue 
                            require 0 < lenders.length
                            mem[0] = 13
                            mem[mem[64] + 4] = ext_call.return_data[0] + s
                            require ext_code.size(lenders)
                            staticcall lenders.aprAfterDeposit(uint256 arg1) with:
                                    gas gas_remaining wei
                                   args (ext_call.return_data[0] + s)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _409 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if mem[_409] <= t:
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(wantAddress)
                                staticcall wantAddress.balanceOf(address arg1) with:
                                        gas gas_remaining wei
                                       args address(this.address)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _448 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _456 = mem[_448]
                                if mem[_448]:
                                    require 0 < lenders.length
                                    mem[0] = 13
                                    _465 = mem[64]
                                    mem[mem[64] + 36] = lenders
                                    mem[mem[64] + 68] = _456
                                    _474 = mem[64]
                                    mem[mem[64]] = 68
                                    mem[64] = mem[64] + 100
                                    mem[_474 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_474 + 36 len 28]
                                    mem[64] = _465 + 164
                                    mem[_465 + 100] = 32
                                    mem[_465 + 132] = 'SafeERC20: low-level call failed'
                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(wantAddress):
                                        revert with 0, 'Address: call to non-contract'
                                    if not ext_code.hash(wantAddress):
                                        revert with 0, 'Address: call to non-contract'
                                    _513 = mem[_474]
                                    idx = 0
                                    while idx < _513:
                                        mem[idx + _465 + 164] = mem[idx + _474 + 32]
                                        idx = idx + 32
                                        continue 
                                    if ceil32(_513) > _513:
                                        mem[_513 + _465 + 164] = 0
                                    call wantAddress.mem[_465 + 164 len 4] with:
                                         gas gas_remaining wei
                                        args mem[_465 + 168 len _513 - 4]
                                    if not return_data.size:
                                        if not ext_call.success:
                                            if mem[96]:
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            mem[_465 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_465 + 168] = 32
                                            idx = 0
                                            while idx < 32:
                                                mem[idx + _465 + 232] = mem[idx + _465 + 132]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 32, 32, mem[_465 + 232]
                                        if mem[96]:
                                            require mem[96] >= 32
                                            require mem[128] == bool(mem[128])
                                            if not mem[128]:
                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    else:
                                        mem[_465 + 164] = return_data.size
                                        mem[_465 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            if return_data.size:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[_465 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_465 + ceil32(return_data.size) + 169] = 32
                                            idx = 0
                                            while idx < 32:
                                                mem[idx + _465 + ceil32(return_data.size) + 233] = mem[idx + _465 + 132]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 32, 32, mem[_465 + ceil32(return_data.size) + 233]
                                        if return_data.size:
                                            require return_data.size >= 32
                                            require mem[_465 + 196] == bool(mem[_465 + 196])
                                            if not mem[_465 + 196]:
                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    require 0 < lenders.length
                                    require ext_code.size(lenders)
                                    call lenders.deposit() with:
                                         gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                            else:
                                require 0 < lenders.length
                                mem[0] = 13
                                require ext_code.size(lenders)
                                call lenders.withdrawAll() with:
                                     gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _444 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_444] == bool(mem[_444])
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(wantAddress)
                                staticcall wantAddress.balanceOf(address arg1) with:
                                        gas gas_remaining wei
                                       args address(this.address)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _488 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _492 = mem[_488]
                                if mem[_488]:
                                    require 0 < lenders.length
                                    mem[0] = 13
                                    _514 = mem[64]
                                    mem[mem[64] + 36] = lenders
                                    mem[mem[64] + 68] = _492
                                    _529 = mem[64]
                                    mem[mem[64]] = 68
                                    mem[64] = mem[64] + 100
                                    mem[_529 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_529 + 36 len 28]
                                    mem[64] = _514 + 164
                                    mem[_514 + 100] = 32
                                    mem[_514 + 132] = 'SafeERC20: low-level call failed'
                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(wantAddress):
                                        revert with 0, 'Address: call to non-contract'
                                    if not ext_code.hash(wantAddress):
                                        revert with 0, 'Address: call to non-contract'
                                    _604 = mem[_529]
                                    idx = 0
                                    while idx < _604:
                                        mem[idx + _514 + 164] = mem[idx + _529 + 32]
                                        idx = idx + 32
                                        continue 
                                    if ceil32(_604) > _604:
                                        mem[_604 + _514 + 164] = 0
                                    call wantAddress.mem[_514 + 164 len 4] with:
                                         gas gas_remaining wei
                                        args mem[_514 + 168 len _604 - 4]
                                    if not return_data.size:
                                        if not ext_call.success:
                                            if mem[96]:
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            mem[_514 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_514 + 168] = 32
                                            idx = 0
                                            while idx < 32:
                                                mem[idx + _514 + 232] = mem[idx + _514 + 132]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 32, 32, mem[_514 + 232]
                                        if mem[96]:
                                            require mem[96] >= 32
                                            require mem[128] == bool(mem[128])
                                            if not mem[128]:
                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    else:
                                        mem[_514 + 164] = return_data.size
                                        mem[_514 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            if return_data.size:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[_514 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_514 + ceil32(return_data.size) + 169] = 32
                                            idx = 0
                                            while idx < 32:
                                                mem[idx + _514 + ceil32(return_data.size) + 233] = mem[idx + _514 + 132]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 32, 32, mem[_514 + ceil32(return_data.size) + 233]
                                        if return_data.size:
                                            require return_data.size >= 32
                                            require mem[_514 + 196] == bool(mem[_514 + 196])
                                            if not mem[_514 + 196]:
                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    require 0 < lenders.length
                                    require ext_code.size(lenders)
                                    call lenders.deposit() with:
                                         gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
    else:
        require ext_code.size(vaultAddress)
        staticcall vaultAddress.governance() with:
                gas gas_remaining wei
        mem[96] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        mem[64] = ceil32(return_data.size) + 96
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
        if ext_call.return_data[12 len 20] != msg.sender:
            revert with 0, '!authorized'
        idx = 0
        while idx < lenders.length:
            mem[0] = 13
            if lenders[idx] != arg1:
                idx = idx + 1
                continue 
            require idx < lenders.length
            require ext_code.size(lenders[idx])
            call lenders[idx].withdrawAll() with:
                 gas gas_remaining wei
            mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == bool(ext_call.return_data[0])
            if idx == lenders.length - 1:
                require lenders.length
                mem[0] = 13
                lenders[lenders.length] = 0
                lenders.length--
                mem[(2 * ceil32(return_data.size)) + 100] = this.address
                require ext_code.size(wantAddress)
                staticcall wantAddress.balanceOf(address arg1) with:
                        gas gas_remaining wei
                       args this.address
                mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if ext_call.return_data[0] > 0:
                    if not emergencyExit:
                        if lenders.length:
                            mem[(4 * ceil32(return_data.size)) + 100] = this.address
                            require ext_code.size(wantAddress)
                            staticcall wantAddress.balanceOf(address arg1) with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[64] = (6 * ceil32(return_data.size)) + 96
                            require return_data.size >= 32
                            idx = 0
                            s = 0
                            t = -1
                            while idx < lenders.length:
                                mem[0] = 13
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].hasAssets() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _313 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_313] == bool(mem[_313])
                                if not mem[_313]:
                                    idx = idx + 1
                                    s = s
                                    t = t
                                    continue 
                                require idx < lenders.length
                                mem[0] = 13
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].apr() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _357 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _361 = mem[_357]
                                if mem[_357] >= t:
                                    idx = idx + 1
                                    s = s
                                    t = t
                                    continue 
                                require idx < lenders.length
                                mem[0] = 13
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].nav() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _377 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                idx = idx + 1
                                s = mem[_377]
                                t = _361
                                continue 
                            if ext_call.return_data[0] + s < s:
                                revert with 0, 'SafeMath: addition overflow'
                            idx = 0
                            u = 0
                            while idx < lenders.length:
                                mem[0] = 13
                                mem[mem[64] + 4] = ext_call.return_data[0]
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].aprAfterDeposit(uint256 arg1) with:
                                        gas gas_remaining wei
                                       args ext_call.return_data[0]
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _412 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if mem[_412] <= u:
                                    idx = idx + 1
                                    u = u
                                    continue 
                                idx = idx + 1
                                u = mem[_412]
                                continue 
                            require 0 < lenders.length
                            mem[0] = 13
                            mem[mem[64] + 4] = ext_call.return_data[0] + s
                            require ext_code.size(lenders)
                            staticcall lenders.aprAfterDeposit(uint256 arg1) with:
                                    gas gas_remaining wei
                                   args (ext_call.return_data[0] + s)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _411 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if mem[_411] <= t:
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(wantAddress)
                                staticcall wantAddress.balanceOf(address arg1) with:
                                        gas gas_remaining wei
                                       args address(this.address)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _449 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _457 = mem[_449]
                                if mem[_449]:
                                    require 0 < lenders.length
                                    mem[0] = 13
                                    _467 = mem[64]
                                    mem[mem[64] + 36] = lenders
                                    mem[mem[64] + 68] = _457
                                    _477 = mem[64]
                                    mem[mem[64]] = 68
                                    mem[64] = mem[64] + 100
                                    mem[_477 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_477 + 36 len 28]
                                    mem[64] = _467 + 164
                                    mem[_467 + 100] = 32
                                    mem[_467 + 132] = 'SafeERC20: low-level call failed'
                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(wantAddress):
                                        revert with 0, 'Address: call to non-contract'
                                    if not ext_code.hash(wantAddress):
                                        revert with 0, 'Address: call to non-contract'
                                    _515 = mem[_477]
                                    idx = 0
                                    while idx < _515:
                                        mem[idx + _467 + 164] = mem[idx + _477 + 32]
                                        idx = idx + 32
                                        continue 
                                    if ceil32(_515) > _515:
                                        mem[_515 + _467 + 164] = 0
                                    call wantAddress.mem[_467 + 164 len 4] with:
                                         gas gas_remaining wei
                                        args mem[_467 + 168 len _515 - 4]
                                    if not return_data.size:
                                        if not ext_call.success:
                                            if mem[96]:
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            mem[_467 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_467 + 168] = 32
                                            idx = 0
                                            while idx < 32:
                                                mem[idx + _467 + 232] = mem[idx + _467 + 132]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 32, 32, mem[_467 + 232]
                                        if mem[96]:
                                            require mem[96] >= 32
                                            require mem[128] == bool(mem[128])
                                            if not mem[128]:
                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    else:
                                        mem[_467 + 164] = return_data.size
                                        mem[_467 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            if return_data.size:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[_467 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_467 + ceil32(return_data.size) + 169] = 32
                                            idx = 0
                                            while idx < 32:
                                                mem[idx + _467 + ceil32(return_data.size) + 233] = mem[idx + _467 + 132]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 32, 32, mem[_467 + ceil32(return_data.size) + 233]
                                        if return_data.size:
                                            require return_data.size >= 32
                                            require mem[_467 + 196] == bool(mem[_467 + 196])
                                            if not mem[_467 + 196]:
                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    require 0 < lenders.length
                                    require ext_code.size(lenders)
                                    call lenders.deposit() with:
                                         gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                            else:
                                require 0 < lenders.length
                                mem[0] = 13
                                require ext_code.size(lenders)
                                call lenders.withdrawAll() with:
                                     gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _445 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_445] == bool(mem[_445])
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(wantAddress)
                                staticcall wantAddress.balanceOf(address arg1) with:
                                        gas gas_remaining wei
                                       args address(this.address)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _489 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _493 = mem[_489]
                                if mem[_489]:
                                    require 0 < lenders.length
                                    mem[0] = 13
                                    _516 = mem[64]
                                    mem[mem[64] + 36] = lenders
                                    mem[mem[64] + 68] = _493
                                    _531 = mem[64]
                                    mem[mem[64]] = 68
                                    mem[64] = mem[64] + 100
                                    mem[_531 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_531 + 36 len 28]
                                    mem[64] = _516 + 164
                                    mem[_516 + 100] = 32
                                    mem[_516 + 132] = 'SafeERC20: low-level call failed'
                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(wantAddress):
                                        revert with 0, 'Address: call to non-contract'
                                    if not ext_code.hash(wantAddress):
                                        revert with 0, 'Address: call to non-contract'
                                    _613 = mem[_531]
                                    idx = 0
                                    while idx < _613:
                                        mem[idx + _516 + 164] = mem[idx + _531 + 32]
                                        idx = idx + 32
                                        continue 
                                    if ceil32(_613) > _613:
                                        mem[_613 + _516 + 164] = 0
                                    call wantAddress.mem[_516 + 164 len 4] with:
                                         gas gas_remaining wei
                                        args mem[_516 + 168 len _613 - 4]
                                    if not return_data.size:
                                        if not ext_call.success:
                                            if mem[96]:
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            mem[_516 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_516 + 168] = 32
                                            idx = 0
                                            while idx < 32:
                                                mem[idx + _516 + 232] = mem[idx + _516 + 132]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 32, 32, mem[_516 + 232]
                                        if mem[96]:
                                            require mem[96] >= 32
                                            require mem[128] == bool(mem[128])
                                            if not mem[128]:
                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    else:
                                        mem[_516 + 164] = return_data.size
                                        mem[_516 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            if return_data.size:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[_516 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_516 + ceil32(return_data.size) + 169] = 32
                                            idx = 0
                                            while idx < 32:
                                                mem[idx + _516 + ceil32(return_data.size) + 233] = mem[idx + _516 + 132]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 32, 32, mem[_516 + ceil32(return_data.size) + 233]
                                        if return_data.size:
                                            require return_data.size >= 32
                                            require mem[_516 + 196] == bool(mem[_516 + 196])
                                            if not mem[_516 + 196]:
                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    require 0 < lenders.length
                                    require ext_code.size(lenders)
                                    call lenders.deposit() with:
                                         gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
            else:
                require lenders.length - 1 < lenders.length
                require idx < lenders.length
                lenders[idx] = lenders[lenders.length]
                require lenders.length
                mem[0] = 13
                lenders[lenders.length] = 0
                lenders.length--
                mem[(2 * ceil32(return_data.size)) + 100] = this.address
                require ext_code.size(wantAddress)
                staticcall wantAddress.balanceOf(address arg1) with:
                        gas gas_remaining wei
                       args this.address
                mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if ext_call.return_data[0] > 0:
                    if not emergencyExit:
                        if lenders.length:
                            mem[(4 * ceil32(return_data.size)) + 100] = this.address
                            require ext_code.size(wantAddress)
                            staticcall wantAddress.balanceOf(address arg1) with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[64] = (6 * ceil32(return_data.size)) + 96
                            require return_data.size >= 32
                            idx = 0
                            s = 0
                            t = -1
                            while idx < lenders.length:
                                mem[0] = 13
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].hasAssets() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _314 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_314] == bool(mem[_314])
                                if not mem[_314]:
                                    idx = idx + 1
                                    s = s
                                    t = t
                                    continue 
                                require idx < lenders.length
                                mem[0] = 13
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].apr() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _358 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _362 = mem[_358]
                                if mem[_358] >= t:
                                    idx = idx + 1
                                    s = s
                                    t = t
                                    continue 
                                require idx < lenders.length
                                mem[0] = 13
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].nav() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _378 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                idx = idx + 1
                                s = mem[_378]
                                t = _362
                                continue 
                            if ext_call.return_data[0] + s < s:
                                revert with 0, 'SafeMath: addition overflow'
                            idx = 0
                            u = 0
                            while idx < lenders.length:
                                mem[0] = 13
                                mem[mem[64] + 4] = ext_call.return_data[0]
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].aprAfterDeposit(uint256 arg1) with:
                                        gas gas_remaining wei
                                       args ext_call.return_data[0]
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _414 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if mem[_414] <= u:
                                    idx = idx + 1
                                    u = u
                                    continue 
                                idx = idx + 1
                                u = mem[_414]
                                continue 
                            require 0 < lenders.length
                            mem[0] = 13
                            mem[mem[64] + 4] = ext_call.return_data[0] + s
                            require ext_code.size(lenders)
                            staticcall lenders.aprAfterDeposit(uint256 arg1) with:
                                    gas gas_remaining wei
                                   args (ext_call.return_data[0] + s)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _413 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if mem[_413] <= t:
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(wantAddress)
                                staticcall wantAddress.balanceOf(address arg1) with:
                                        gas gas_remaining wei
                                       args address(this.address)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _450 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _458 = mem[_450]
                                if mem[_450]:
                                    require 0 < lenders.length
                                    mem[0] = 13
                                    _469 = mem[64]
                                    mem[mem[64] + 36] = lenders
                                    mem[mem[64] + 68] = _458
                                    _480 = mem[64]
                                    mem[mem[64]] = 68
                                    mem[64] = mem[64] + 100
                                    mem[_480 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_480 + 36 len 28]
                                    mem[64] = _469 + 164
                                    mem[_469 + 100] = 32
                                    mem[_469 + 132] = 'SafeERC20: low-level call failed'
                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(wantAddress):
                                        revert with 0, 'Address: call to non-contract'
                                    if not ext_code.hash(wantAddress):
                                        revert with 0, 'Address: call to non-contract'
                                    _517 = mem[_480]
                                    idx = 0
                                    while idx < _517:
                                        mem[idx + _469 + 164] = mem[idx + _480 + 32]
                                        idx = idx + 32
                                        continue 
                                    if ceil32(_517) > _517:
                                        mem[_517 + _469 + 164] = 0
                                    call wantAddress.mem[_469 + 164 len 4] with:
                                         gas gas_remaining wei
                                        args mem[_469 + 168 len _517 - 4]
                                    if not return_data.size:
                                        if not ext_call.success:
                                            if mem[96]:
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            mem[_469 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_469 + 168] = 32
                                            idx = 0
                                            while idx < 32:
                                                mem[idx + _469 + 232] = mem[idx + _469 + 132]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 32, 32, mem[_469 + 232]
                                        if mem[96]:
                                            require mem[96] >= 32
                                            require mem[128] == bool(mem[128])
                                            if not mem[128]:
                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    else:
                                        mem[_469 + 164] = return_data.size
                                        mem[_469 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            if return_data.size:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[_469 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_469 + ceil32(return_data.size) + 169] = 32
                                            idx = 0
                                            while idx < 32:
                                                mem[idx + _469 + ceil32(return_data.size) + 233] = mem[idx + _469 + 132]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 32, 32, mem[_469 + ceil32(return_data.size) + 233]
                                        if return_data.size:
                                            require return_data.size >= 32
                                            require mem[_469 + 196] == bool(mem[_469 + 196])
                                            if not mem[_469 + 196]:
                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    require 0 < lenders.length
                                    require ext_code.size(lenders)
                                    call lenders.deposit() with:
                                         gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                            else:
                                require 0 < lenders.length
                                mem[0] = 13
                                require ext_code.size(lenders)
                                call lenders.withdrawAll() with:
                                     gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _446 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_446] == bool(mem[_446])
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(wantAddress)
                                staticcall wantAddress.balanceOf(address arg1) with:
                                        gas gas_remaining wei
                                       args address(this.address)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _490 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _494 = mem[_490]
                                if mem[_490]:
                                    require 0 < lenders.length
                                    mem[0] = 13
                                    _518 = mem[64]
                                    mem[mem[64] + 36] = lenders
                                    mem[mem[64] + 68] = _494
                                    _533 = mem[64]
                                    mem[mem[64]] = 68
                                    mem[64] = mem[64] + 100
                                    mem[_533 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_533 + 36 len 28]
                                    mem[64] = _518 + 164
                                    mem[_518 + 100] = 32
                                    mem[_518 + 132] = 'SafeERC20: low-level call failed'
                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(wantAddress):
                                        revert with 0, 'Address: call to non-contract'
                                    if not ext_code.hash(wantAddress):
                                        revert with 0, 'Address: call to non-contract'
                                    _622 = mem[_533]
                                    idx = 0
                                    while idx < _622:
                                        mem[idx + _518 + 164] = mem[idx + _533 + 32]
                                        idx = idx + 32
                                        continue 
                                    if ceil32(_622) > _622:
                                        mem[_622 + _518 + 164] = 0
                                    call wantAddress.mem[_518 + 164 len 4] with:
                                         gas gas_remaining wei
                                        args mem[_518 + 168 len _622 - 4]
                                    if not return_data.size:
                                        if not ext_call.success:
                                            if mem[96]:
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            mem[_518 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_518 + 168] = 32
                                            idx = 0
                                            while idx < 32:
                                                mem[idx + _518 + 232] = mem[idx + _518 + 132]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 32, 32, mem[_518 + 232]
                                        if mem[96]:
                                            require mem[96] >= 32
                                            require mem[128] == bool(mem[128])
                                            if not mem[128]:
                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    else:
                                        mem[_518 + 164] = return_data.size
                                        mem[_518 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            if return_data.size:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[_518 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_518 + ceil32(return_data.size) + 169] = 32
                                            idx = 0
                                            while idx < 32:
                                                mem[idx + _518 + ceil32(return_data.size) + 233] = mem[idx + _518 + 132]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 32, 32, mem[_518 + ceil32(return_data.size) + 233]
                                        if return_data.size:
                                            require return_data.size >= 32
                                            require mem[_518 + 196] == bool(mem[_518 + 196])
                                            if not mem[_518 + 196]:
                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    require 0 < lenders.length
                                    require ext_code.size(lenders)
                                    call lenders.deposit() with:
                                         gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
    revert with 0, 'NOT LENDER'
}

function safeRemoveLender(address arg1) payable {
    mem[64] = 96
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if msg.sender == strategistAddress:
        idx = 0
        while idx < lenders.length:
            mem[0] = 13
            if lenders[idx] != arg1:
                idx = idx + 1
                continue 
            require idx < lenders.length
            require ext_code.size(lenders[idx])
            call lenders[idx].withdrawAll() with:
                 gas gas_remaining wei
            mem[96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == bool(ext_call.return_data[0])
            if not ext_call.return_data[0]:
                revert with 0, 'WITHDRAW FAILED'
            if idx == lenders.length - 1:
                require lenders.length
                mem[0] = 13
                lenders[lenders.length] = 0
                lenders.length--
                mem[ceil32(return_data.size) + 100] = this.address
                require ext_code.size(wantAddress)
                staticcall wantAddress.balanceOf(address arg1) with:
                        gas gas_remaining wei
                       args this.address
                mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if ext_call.return_data[0] > 0:
                    if not emergencyExit:
                        if lenders.length:
                            mem[(2 * ceil32(return_data.size)) + 100] = this.address
                            require ext_code.size(wantAddress)
                            staticcall wantAddress.balanceOf(address arg1) with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[64] = (4 * ceil32(return_data.size)) + 96
                            require return_data.size >= 32
                            idx = 0
                            s = 0
                            t = -1
                            while idx < lenders.length:
                                mem[0] = 13
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].hasAssets() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _319 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_319] == bool(mem[_319])
                                if not mem[_319]:
                                    idx = idx + 1
                                    s = s
                                    t = t
                                    continue 
                                require idx < lenders.length
                                mem[0] = 13
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].apr() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _363 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _367 = mem[_363]
                                if mem[_363] >= t:
                                    idx = idx + 1
                                    s = s
                                    t = t
                                    continue 
                                require idx < lenders.length
                                mem[0] = 13
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].nav() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _383 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                idx = idx + 1
                                s = mem[_383]
                                t = _367
                                continue 
                            if ext_call.return_data[0] + s < s:
                                revert with 0, 'SafeMath: addition overflow'
                            idx = 0
                            u = 0
                            while idx < lenders.length:
                                mem[0] = 13
                                mem[mem[64] + 4] = ext_call.return_data[0]
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].aprAfterDeposit(uint256 arg1) with:
                                        gas gas_remaining wei
                                       args ext_call.return_data[0]
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _416 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if mem[_416] <= u:
                                    idx = idx + 1
                                    u = u
                                    continue 
                                idx = idx + 1
                                u = mem[_416]
                                continue 
                            require 0 < lenders.length
                            mem[0] = 13
                            mem[mem[64] + 4] = ext_call.return_data[0] + s
                            require ext_code.size(lenders)
                            staticcall lenders.aprAfterDeposit(uint256 arg1) with:
                                    gas gas_remaining wei
                                   args (ext_call.return_data[0] + s)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _415 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if mem[_415] <= t:
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(wantAddress)
                                staticcall wantAddress.balanceOf(address arg1) with:
                                        gas gas_remaining wei
                                       args address(this.address)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _455 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _463 = mem[_455]
                                if mem[_455]:
                                    require 0 < lenders.length
                                    mem[0] = 13
                                    _471 = mem[64]
                                    mem[mem[64] + 36] = lenders
                                    mem[mem[64] + 68] = _463
                                    _479 = mem[64]
                                    mem[mem[64]] = 68
                                    mem[64] = mem[64] + 100
                                    mem[_479 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_479 + 36 len 28]
                                    mem[64] = _471 + 164
                                    mem[_471 + 100] = 32
                                    mem[_471 + 132] = 'SafeERC20: low-level call failed'
                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(wantAddress):
                                        revert with 0, 'Address: call to non-contract'
                                    if not ext_code.hash(wantAddress):
                                        revert with 0, 'Address: call to non-contract'
                                    _519 = mem[_479]
                                    idx = 0
                                    while idx < _519:
                                        mem[idx + _471 + 164] = mem[idx + _479 + 32]
                                        idx = idx + 32
                                        continue 
                                    if ceil32(_519) > _519:
                                        mem[_519 + _471 + 164] = 0
                                    call wantAddress.mem[_471 + 164 len 4] with:
                                         gas gas_remaining wei
                                        args mem[_471 + 168 len _519 - 4]
                                    if not return_data.size:
                                        if not ext_call.success:
                                            if mem[96]:
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            mem[_471 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_471 + 168] = 32
                                            idx = 0
                                            while idx < 32:
                                                mem[idx + _471 + 232] = mem[idx + _471 + 132]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 32, 32, mem[_471 + 232]
                                        if mem[96]:
                                            require mem[96] >= 32
                                            require mem[128] == bool(mem[128])
                                            if not mem[128]:
                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    else:
                                        mem[_471 + 164] = return_data.size
                                        mem[_471 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            if return_data.size:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[_471 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_471 + ceil32(return_data.size) + 169] = 32
                                            idx = 0
                                            while idx < 32:
                                                mem[idx + _471 + ceil32(return_data.size) + 233] = mem[idx + _471 + 132]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 32, 32, mem[_471 + ceil32(return_data.size) + 233]
                                        if return_data.size:
                                            require return_data.size >= 32
                                            require mem[_471 + 196] == bool(mem[_471 + 196])
                                            if not mem[_471 + 196]:
                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    require 0 < lenders.length
                                    require ext_code.size(lenders)
                                    call lenders.deposit() with:
                                         gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                            else:
                                require 0 < lenders.length
                                mem[0] = 13
                                require ext_code.size(lenders)
                                call lenders.withdrawAll() with:
                                     gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _451 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_451] == bool(mem[_451])
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(wantAddress)
                                staticcall wantAddress.balanceOf(address arg1) with:
                                        gas gas_remaining wei
                                       args address(this.address)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _495 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _499 = mem[_495]
                                if mem[_495]:
                                    require 0 < lenders.length
                                    mem[0] = 13
                                    _520 = mem[64]
                                    mem[mem[64] + 36] = lenders
                                    mem[mem[64] + 68] = _499
                                    _535 = mem[64]
                                    mem[mem[64]] = 68
                                    mem[64] = mem[64] + 100
                                    mem[_535 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_535 + 36 len 28]
                                    mem[64] = _520 + 164
                                    mem[_520 + 100] = 32
                                    mem[_520 + 132] = 'SafeERC20: low-level call failed'
                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(wantAddress):
                                        revert with 0, 'Address: call to non-contract'
                                    if not ext_code.hash(wantAddress):
                                        revert with 0, 'Address: call to non-contract'
                                    _603 = mem[_535]
                                    idx = 0
                                    while idx < _603:
                                        mem[idx + _520 + 164] = mem[idx + _535 + 32]
                                        idx = idx + 32
                                        continue 
                                    if ceil32(_603) > _603:
                                        mem[_603 + _520 + 164] = 0
                                    call wantAddress.mem[_520 + 164 len 4] with:
                                         gas gas_remaining wei
                                        args mem[_520 + 168 len _603 - 4]
                                    if not return_data.size:
                                        if not ext_call.success:
                                            if mem[96]:
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            mem[_520 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_520 + 168] = 32
                                            idx = 0
                                            while idx < 32:
                                                mem[idx + _520 + 232] = mem[idx + _520 + 132]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 32, 32, mem[_520 + 232]
                                        if mem[96]:
                                            require mem[96] >= 32
                                            require mem[128] == bool(mem[128])
                                            if not mem[128]:
                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    else:
                                        mem[_520 + 164] = return_data.size
                                        mem[_520 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            if return_data.size:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[_520 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_520 + ceil32(return_data.size) + 169] = 32
                                            idx = 0
                                            while idx < 32:
                                                mem[idx + _520 + ceil32(return_data.size) + 233] = mem[idx + _520 + 132]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 32, 32, mem[_520 + ceil32(return_data.size) + 233]
                                        if return_data.size:
                                            require return_data.size >= 32
                                            require mem[_520 + 196] == bool(mem[_520 + 196])
                                            if not mem[_520 + 196]:
                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    require 0 < lenders.length
                                    require ext_code.size(lenders)
                                    call lenders.deposit() with:
                                         gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
            else:
                require lenders.length - 1 < lenders.length
                require idx < lenders.length
                lenders[idx] = lenders[lenders.length]
                require lenders.length
                mem[0] = 13
                lenders[lenders.length] = 0
                lenders.length--
                mem[ceil32(return_data.size) + 100] = this.address
                require ext_code.size(wantAddress)
                staticcall wantAddress.balanceOf(address arg1) with:
                        gas gas_remaining wei
                       args this.address
                mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if ext_call.return_data[0] > 0:
                    if not emergencyExit:
                        if lenders.length:
                            mem[(2 * ceil32(return_data.size)) + 100] = this.address
                            require ext_code.size(wantAddress)
                            staticcall wantAddress.balanceOf(address arg1) with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[64] = (4 * ceil32(return_data.size)) + 96
                            require return_data.size >= 32
                            idx = 0
                            s = 0
                            t = -1
                            while idx < lenders.length:
                                mem[0] = 13
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].hasAssets() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _320 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_320] == bool(mem[_320])
                                if not mem[_320]:
                                    idx = idx + 1
                                    s = s
                                    t = t
                                    continue 
                                require idx < lenders.length
                                mem[0] = 13
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].apr() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _364 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _368 = mem[_364]
                                if mem[_364] >= t:
                                    idx = idx + 1
                                    s = s
                                    t = t
                                    continue 
                                require idx < lenders.length
                                mem[0] = 13
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].nav() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _384 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                idx = idx + 1
                                s = mem[_384]
                                t = _368
                                continue 
                            if ext_call.return_data[0] + s < s:
                                revert with 0, 'SafeMath: addition overflow'
                            idx = 0
                            u = 0
                            while idx < lenders.length:
                                mem[0] = 13
                                mem[mem[64] + 4] = ext_call.return_data[0]
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].aprAfterDeposit(uint256 arg1) with:
                                        gas gas_remaining wei
                                       args ext_call.return_data[0]
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _418 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if mem[_418] <= u:
                                    idx = idx + 1
                                    u = u
                                    continue 
                                idx = idx + 1
                                u = mem[_418]
                                continue 
                            require 0 < lenders.length
                            mem[0] = 13
                            mem[mem[64] + 4] = ext_call.return_data[0] + s
                            require ext_code.size(lenders)
                            staticcall lenders.aprAfterDeposit(uint256 arg1) with:
                                    gas gas_remaining wei
                                   args (ext_call.return_data[0] + s)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _417 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if mem[_417] <= t:
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(wantAddress)
                                staticcall wantAddress.balanceOf(address arg1) with:
                                        gas gas_remaining wei
                                       args address(this.address)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _456 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _464 = mem[_456]
                                if mem[_456]:
                                    require 0 < lenders.length
                                    mem[0] = 13
                                    _473 = mem[64]
                                    mem[mem[64] + 36] = lenders
                                    mem[mem[64] + 68] = _464
                                    _482 = mem[64]
                                    mem[mem[64]] = 68
                                    mem[64] = mem[64] + 100
                                    mem[_482 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_482 + 36 len 28]
                                    mem[64] = _473 + 164
                                    mem[_473 + 100] = 32
                                    mem[_473 + 132] = 'SafeERC20: low-level call failed'
                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(wantAddress):
                                        revert with 0, 'Address: call to non-contract'
                                    if not ext_code.hash(wantAddress):
                                        revert with 0, 'Address: call to non-contract'
                                    _521 = mem[_482]
                                    idx = 0
                                    while idx < _521:
                                        mem[idx + _473 + 164] = mem[idx + _482 + 32]
                                        idx = idx + 32
                                        continue 
                                    if ceil32(_521) > _521:
                                        mem[_521 + _473 + 164] = 0
                                    call wantAddress.mem[_473 + 164 len 4] with:
                                         gas gas_remaining wei
                                        args mem[_473 + 168 len _521 - 4]
                                    if not return_data.size:
                                        if not ext_call.success:
                                            if mem[96]:
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            mem[_473 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_473 + 168] = 32
                                            idx = 0
                                            while idx < 32:
                                                mem[idx + _473 + 232] = mem[idx + _473 + 132]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 32, 32, mem[_473 + 232]
                                        if mem[96]:
                                            require mem[96] >= 32
                                            require mem[128] == bool(mem[128])
                                            if not mem[128]:
                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    else:
                                        mem[_473 + 164] = return_data.size
                                        mem[_473 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            if return_data.size:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[_473 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_473 + ceil32(return_data.size) + 169] = 32
                                            idx = 0
                                            while idx < 32:
                                                mem[idx + _473 + ceil32(return_data.size) + 233] = mem[idx + _473 + 132]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 32, 32, mem[_473 + ceil32(return_data.size) + 233]
                                        if return_data.size:
                                            require return_data.size >= 32
                                            require mem[_473 + 196] == bool(mem[_473 + 196])
                                            if not mem[_473 + 196]:
                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    require 0 < lenders.length
                                    require ext_code.size(lenders)
                                    call lenders.deposit() with:
                                         gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                            else:
                                require 0 < lenders.length
                                mem[0] = 13
                                require ext_code.size(lenders)
                                call lenders.withdrawAll() with:
                                     gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _452 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_452] == bool(mem[_452])
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(wantAddress)
                                staticcall wantAddress.balanceOf(address arg1) with:
                                        gas gas_remaining wei
                                       args address(this.address)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _496 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _500 = mem[_496]
                                if mem[_496]:
                                    require 0 < lenders.length
                                    mem[0] = 13
                                    _522 = mem[64]
                                    mem[mem[64] + 36] = lenders
                                    mem[mem[64] + 68] = _500
                                    _537 = mem[64]
                                    mem[mem[64]] = 68
                                    mem[64] = mem[64] + 100
                                    mem[_537 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_537 + 36 len 28]
                                    mem[64] = _522 + 164
                                    mem[_522 + 100] = 32
                                    mem[_522 + 132] = 'SafeERC20: low-level call failed'
                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(wantAddress):
                                        revert with 0, 'Address: call to non-contract'
                                    if not ext_code.hash(wantAddress):
                                        revert with 0, 'Address: call to non-contract'
                                    _612 = mem[_537]
                                    idx = 0
                                    while idx < _612:
                                        mem[idx + _522 + 164] = mem[idx + _537 + 32]
                                        idx = idx + 32
                                        continue 
                                    if ceil32(_612) > _612:
                                        mem[_612 + _522 + 164] = 0
                                    call wantAddress.mem[_522 + 164 len 4] with:
                                         gas gas_remaining wei
                                        args mem[_522 + 168 len _612 - 4]
                                    if not return_data.size:
                                        if not ext_call.success:
                                            if mem[96]:
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            mem[_522 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_522 + 168] = 32
                                            idx = 0
                                            while idx < 32:
                                                mem[idx + _522 + 232] = mem[idx + _522 + 132]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 32, 32, mem[_522 + 232]
                                        if mem[96]:
                                            require mem[96] >= 32
                                            require mem[128] == bool(mem[128])
                                            if not mem[128]:
                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    else:
                                        mem[_522 + 164] = return_data.size
                                        mem[_522 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            if return_data.size:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[_522 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_522 + ceil32(return_data.size) + 169] = 32
                                            idx = 0
                                            while idx < 32:
                                                mem[idx + _522 + ceil32(return_data.size) + 233] = mem[idx + _522 + 132]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 32, 32, mem[_522 + ceil32(return_data.size) + 233]
                                        if return_data.size:
                                            require return_data.size >= 32
                                            require mem[_522 + 196] == bool(mem[_522 + 196])
                                            if not mem[_522 + 196]:
                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    require 0 < lenders.length
                                    require ext_code.size(lenders)
                                    call lenders.deposit() with:
                                         gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
    else:
        require ext_code.size(vaultAddress)
        staticcall vaultAddress.governance() with:
                gas gas_remaining wei
        mem[96] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        mem[64] = ceil32(return_data.size) + 96
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
        if ext_call.return_data[12 len 20] != msg.sender:
            revert with 0, '!authorized'
        idx = 0
        while idx < lenders.length:
            mem[0] = 13
            if lenders[idx] != arg1:
                idx = idx + 1
                continue 
            require idx < lenders.length
            require ext_code.size(lenders[idx])
            call lenders[idx].withdrawAll() with:
                 gas gas_remaining wei
            mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == bool(ext_call.return_data[0])
            if not ext_call.return_data[0]:
                revert with 0, 'WITHDRAW FAILED'
            if idx == lenders.length - 1:
                require lenders.length
                mem[0] = 13
                lenders[lenders.length] = 0
                lenders.length--
                mem[(2 * ceil32(return_data.size)) + 100] = this.address
                require ext_code.size(wantAddress)
                staticcall wantAddress.balanceOf(address arg1) with:
                        gas gas_remaining wei
                       args this.address
                mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if ext_call.return_data[0] > 0:
                    if not emergencyExit:
                        if lenders.length:
                            mem[(4 * ceil32(return_data.size)) + 100] = this.address
                            require ext_code.size(wantAddress)
                            staticcall wantAddress.balanceOf(address arg1) with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[64] = (6 * ceil32(return_data.size)) + 96
                            require return_data.size >= 32
                            idx = 0
                            s = 0
                            t = -1
                            while idx < lenders.length:
                                mem[0] = 13
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].hasAssets() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _321 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_321] == bool(mem[_321])
                                if not mem[_321]:
                                    idx = idx + 1
                                    s = s
                                    t = t
                                    continue 
                                require idx < lenders.length
                                mem[0] = 13
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].apr() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _365 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _369 = mem[_365]
                                if mem[_365] >= t:
                                    idx = idx + 1
                                    s = s
                                    t = t
                                    continue 
                                require idx < lenders.length
                                mem[0] = 13
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].nav() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _385 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                idx = idx + 1
                                s = mem[_385]
                                t = _369
                                continue 
                            if ext_call.return_data[0] + s < s:
                                revert with 0, 'SafeMath: addition overflow'
                            idx = 0
                            u = 0
                            while idx < lenders.length:
                                mem[0] = 13
                                mem[mem[64] + 4] = ext_call.return_data[0]
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].aprAfterDeposit(uint256 arg1) with:
                                        gas gas_remaining wei
                                       args ext_call.return_data[0]
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _420 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if mem[_420] <= u:
                                    idx = idx + 1
                                    u = u
                                    continue 
                                idx = idx + 1
                                u = mem[_420]
                                continue 
                            require 0 < lenders.length
                            mem[0] = 13
                            mem[mem[64] + 4] = ext_call.return_data[0] + s
                            require ext_code.size(lenders)
                            staticcall lenders.aprAfterDeposit(uint256 arg1) with:
                                    gas gas_remaining wei
                                   args (ext_call.return_data[0] + s)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _419 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if mem[_419] <= t:
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(wantAddress)
                                staticcall wantAddress.balanceOf(address arg1) with:
                                        gas gas_remaining wei
                                       args address(this.address)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _457 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _465 = mem[_457]
                                if mem[_457]:
                                    require 0 < lenders.length
                                    mem[0] = 13
                                    _475 = mem[64]
                                    mem[mem[64] + 36] = lenders
                                    mem[mem[64] + 68] = _465
                                    _485 = mem[64]
                                    mem[mem[64]] = 68
                                    mem[64] = mem[64] + 100
                                    mem[_485 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_485 + 36 len 28]
                                    mem[64] = _475 + 164
                                    mem[_475 + 100] = 32
                                    mem[_475 + 132] = 'SafeERC20: low-level call failed'
                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(wantAddress):
                                        revert with 0, 'Address: call to non-contract'
                                    if not ext_code.hash(wantAddress):
                                        revert with 0, 'Address: call to non-contract'
                                    _523 = mem[_485]
                                    idx = 0
                                    while idx < _523:
                                        mem[idx + _475 + 164] = mem[idx + _485 + 32]
                                        idx = idx + 32
                                        continue 
                                    if ceil32(_523) > _523:
                                        mem[_523 + _475 + 164] = 0
                                    call wantAddress.mem[_475 + 164 len 4] with:
                                         gas gas_remaining wei
                                        args mem[_475 + 168 len _523 - 4]
                                    if not return_data.size:
                                        if not ext_call.success:
                                            if mem[96]:
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            mem[_475 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_475 + 168] = 32
                                            idx = 0
                                            while idx < 32:
                                                mem[idx + _475 + 232] = mem[idx + _475 + 132]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 32, 32, mem[_475 + 232]
                                        if mem[96]:
                                            require mem[96] >= 32
                                            require mem[128] == bool(mem[128])
                                            if not mem[128]:
                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    else:
                                        mem[_475 + 164] = return_data.size
                                        mem[_475 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            if return_data.size:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[_475 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_475 + ceil32(return_data.size) + 169] = 32
                                            idx = 0
                                            while idx < 32:
                                                mem[idx + _475 + ceil32(return_data.size) + 233] = mem[idx + _475 + 132]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 32, 32, mem[_475 + ceil32(return_data.size) + 233]
                                        if return_data.size:
                                            require return_data.size >= 32
                                            require mem[_475 + 196] == bool(mem[_475 + 196])
                                            if not mem[_475 + 196]:
                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    require 0 < lenders.length
                                    require ext_code.size(lenders)
                                    call lenders.deposit() with:
                                         gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                            else:
                                require 0 < lenders.length
                                mem[0] = 13
                                require ext_code.size(lenders)
                                call lenders.withdrawAll() with:
                                     gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _453 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_453] == bool(mem[_453])
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(wantAddress)
                                staticcall wantAddress.balanceOf(address arg1) with:
                                        gas gas_remaining wei
                                       args address(this.address)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _497 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _501 = mem[_497]
                                if mem[_497]:
                                    require 0 < lenders.length
                                    mem[0] = 13
                                    _524 = mem[64]
                                    mem[mem[64] + 36] = lenders
                                    mem[mem[64] + 68] = _501
                                    _539 = mem[64]
                                    mem[mem[64]] = 68
                                    mem[64] = mem[64] + 100
                                    mem[_539 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_539 + 36 len 28]
                                    mem[64] = _524 + 164
                                    mem[_524 + 100] = 32
                                    mem[_524 + 132] = 'SafeERC20: low-level call failed'
                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(wantAddress):
                                        revert with 0, 'Address: call to non-contract'
                                    if not ext_code.hash(wantAddress):
                                        revert with 0, 'Address: call to non-contract'
                                    _621 = mem[_539]
                                    idx = 0
                                    while idx < _621:
                                        mem[idx + _524 + 164] = mem[idx + _539 + 32]
                                        idx = idx + 32
                                        continue 
                                    if ceil32(_621) > _621:
                                        mem[_621 + _524 + 164] = 0
                                    call wantAddress.mem[_524 + 164 len 4] with:
                                         gas gas_remaining wei
                                        args mem[_524 + 168 len _621 - 4]
                                    if not return_data.size:
                                        if not ext_call.success:
                                            if mem[96]:
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            mem[_524 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_524 + 168] = 32
                                            idx = 0
                                            while idx < 32:
                                                mem[idx + _524 + 232] = mem[idx + _524 + 132]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 32, 32, mem[_524 + 232]
                                        if mem[96]:
                                            require mem[96] >= 32
                                            require mem[128] == bool(mem[128])
                                            if not mem[128]:
                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    else:
                                        mem[_524 + 164] = return_data.size
                                        mem[_524 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            if return_data.size:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[_524 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_524 + ceil32(return_data.size) + 169] = 32
                                            idx = 0
                                            while idx < 32:
                                                mem[idx + _524 + ceil32(return_data.size) + 233] = mem[idx + _524 + 132]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 32, 32, mem[_524 + ceil32(return_data.size) + 233]
                                        if return_data.size:
                                            require return_data.size >= 32
                                            require mem[_524 + 196] == bool(mem[_524 + 196])
                                            if not mem[_524 + 196]:
                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    require 0 < lenders.length
                                    require ext_code.size(lenders)
                                    call lenders.deposit() with:
                                         gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
            else:
                require lenders.length - 1 < lenders.length
                require idx < lenders.length
                lenders[idx] = lenders[lenders.length]
                require lenders.length
                mem[0] = 13
                lenders[lenders.length] = 0
                lenders.length--
                mem[(2 * ceil32(return_data.size)) + 100] = this.address
                require ext_code.size(wantAddress)
                staticcall wantAddress.balanceOf(address arg1) with:
                        gas gas_remaining wei
                       args this.address
                mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if ext_call.return_data[0] > 0:
                    if not emergencyExit:
                        if lenders.length:
                            mem[(4 * ceil32(return_data.size)) + 100] = this.address
                            require ext_code.size(wantAddress)
                            staticcall wantAddress.balanceOf(address arg1) with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[64] = (6 * ceil32(return_data.size)) + 96
                            require return_data.size >= 32
                            idx = 0
                            s = 0
                            t = -1
                            while idx < lenders.length:
                                mem[0] = 13
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].hasAssets() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _322 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_322] == bool(mem[_322])
                                if not mem[_322]:
                                    idx = idx + 1
                                    s = s
                                    t = t
                                    continue 
                                require idx < lenders.length
                                mem[0] = 13
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].apr() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _366 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _370 = mem[_366]
                                if mem[_366] >= t:
                                    idx = idx + 1
                                    s = s
                                    t = t
                                    continue 
                                require idx < lenders.length
                                mem[0] = 13
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].nav() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _386 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                idx = idx + 1
                                s = mem[_386]
                                t = _370
                                continue 
                            if ext_call.return_data[0] + s < s:
                                revert with 0, 'SafeMath: addition overflow'
                            idx = 0
                            u = 0
                            while idx < lenders.length:
                                mem[0] = 13
                                mem[mem[64] + 4] = ext_call.return_data[0]
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].aprAfterDeposit(uint256 arg1) with:
                                        gas gas_remaining wei
                                       args ext_call.return_data[0]
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _422 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if mem[_422] <= u:
                                    idx = idx + 1
                                    u = u
                                    continue 
                                idx = idx + 1
                                u = mem[_422]
                                continue 
                            require 0 < lenders.length
                            mem[0] = 13
                            mem[mem[64] + 4] = ext_call.return_data[0] + s
                            require ext_code.size(lenders)
                            staticcall lenders.aprAfterDeposit(uint256 arg1) with:
                                    gas gas_remaining wei
                                   args (ext_call.return_data[0] + s)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _421 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if mem[_421] <= t:
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(wantAddress)
                                staticcall wantAddress.balanceOf(address arg1) with:
                                        gas gas_remaining wei
                                       args address(this.address)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _458 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _466 = mem[_458]
                                if mem[_458]:
                                    require 0 < lenders.length
                                    mem[0] = 13
                                    _477 = mem[64]
                                    mem[mem[64] + 36] = lenders
                                    mem[mem[64] + 68] = _466
                                    _488 = mem[64]
                                    mem[mem[64]] = 68
                                    mem[64] = mem[64] + 100
                                    mem[_488 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_488 + 36 len 28]
                                    mem[64] = _477 + 164
                                    mem[_477 + 100] = 32
                                    mem[_477 + 132] = 'SafeERC20: low-level call failed'
                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(wantAddress):
                                        revert with 0, 'Address: call to non-contract'
                                    if not ext_code.hash(wantAddress):
                                        revert with 0, 'Address: call to non-contract'
                                    _525 = mem[_488]
                                    idx = 0
                                    while idx < _525:
                                        mem[idx + _477 + 164] = mem[idx + _488 + 32]
                                        idx = idx + 32
                                        continue 
                                    if ceil32(_525) > _525:
                                        mem[_525 + _477 + 164] = 0
                                    call wantAddress.mem[_477 + 164 len 4] with:
                                         gas gas_remaining wei
                                        args mem[_477 + 168 len _525 - 4]
                                    if not return_data.size:
                                        if not ext_call.success:
                                            if mem[96]:
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            mem[_477 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_477 + 168] = 32
                                            idx = 0
                                            while idx < 32:
                                                mem[idx + _477 + 232] = mem[idx + _477 + 132]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 32, 32, mem[_477 + 232]
                                        if mem[96]:
                                            require mem[96] >= 32
                                            require mem[128] == bool(mem[128])
                                            if not mem[128]:
                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    else:
                                        mem[_477 + 164] = return_data.size
                                        mem[_477 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            if return_data.size:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[_477 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_477 + ceil32(return_data.size) + 169] = 32
                                            idx = 0
                                            while idx < 32:
                                                mem[idx + _477 + ceil32(return_data.size) + 233] = mem[idx + _477 + 132]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 32, 32, mem[_477 + ceil32(return_data.size) + 233]
                                        if return_data.size:
                                            require return_data.size >= 32
                                            require mem[_477 + 196] == bool(mem[_477 + 196])
                                            if not mem[_477 + 196]:
                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    require 0 < lenders.length
                                    require ext_code.size(lenders)
                                    call lenders.deposit() with:
                                         gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                            else:
                                require 0 < lenders.length
                                mem[0] = 13
                                require ext_code.size(lenders)
                                call lenders.withdrawAll() with:
                                     gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _454 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_454] == bool(mem[_454])
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(wantAddress)
                                staticcall wantAddress.balanceOf(address arg1) with:
                                        gas gas_remaining wei
                                       args address(this.address)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _498 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _502 = mem[_498]
                                if mem[_498]:
                                    require 0 < lenders.length
                                    mem[0] = 13
                                    _526 = mem[64]
                                    mem[mem[64] + 36] = lenders
                                    mem[mem[64] + 68] = _502
                                    _541 = mem[64]
                                    mem[mem[64]] = 68
                                    mem[64] = mem[64] + 100
                                    mem[_541 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_541 + 36 len 28]
                                    mem[64] = _526 + 164
                                    mem[_526 + 100] = 32
                                    mem[_526 + 132] = 'SafeERC20: low-level call failed'
                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(wantAddress):
                                        revert with 0, 'Address: call to non-contract'
                                    if not ext_code.hash(wantAddress):
                                        revert with 0, 'Address: call to non-contract'
                                    _630 = mem[_541]
                                    idx = 0
                                    while idx < _630:
                                        mem[idx + _526 + 164] = mem[idx + _541 + 32]
                                        idx = idx + 32
                                        continue 
                                    if ceil32(_630) > _630:
                                        mem[_630 + _526 + 164] = 0
                                    call wantAddress.mem[_526 + 164 len 4] with:
                                         gas gas_remaining wei
                                        args mem[_526 + 168 len _630 - 4]
                                    if not return_data.size:
                                        if not ext_call.success:
                                            if mem[96]:
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            mem[_526 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_526 + 168] = 32
                                            idx = 0
                                            while idx < 32:
                                                mem[idx + _526 + 232] = mem[idx + _526 + 132]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 32, 32, mem[_526 + 232]
                                        if mem[96]:
                                            require mem[96] >= 32
                                            require mem[128] == bool(mem[128])
                                            if not mem[128]:
                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    else:
                                        mem[_526 + 164] = return_data.size
                                        mem[_526 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            if return_data.size:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[_526 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_526 + ceil32(return_data.size) + 169] = 32
                                            idx = 0
                                            while idx < 32:
                                                mem[idx + _526 + ceil32(return_data.size) + 233] = mem[idx + _526 + 132]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 32, 32, mem[_526 + ceil32(return_data.size) + 233]
                                        if return_data.size:
                                            require return_data.size >= 32
                                            require mem[_526 + 196] == bool(mem[_526 + 196])
                                            if not mem[_526 + 196]:
                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    require 0 < lenders.length
                                    require ext_code.size(lenders)
                                    call lenders.deposit() with:
                                         gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
    revert with 0, 'NOT LENDER'
}

function tendTrigger(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83 == wantAddress:
        mem[96] = 0
        mem[128] = 0
        mem[160] = 0
        mem[192] = 0
        mem[224] = 0
        mem[256] = 0
        mem[288] = 0
        mem[320] = 0
        mem[352] = 0
        require ext_code.size(vaultAddress)
        staticcall vaultAddress.strategies(address arg1) with:
                gas gas_remaining wei
               args this.address
        mem[384 len 288] = ext_call.return_data[0 len 288]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 288
        require bool(ceil32(return_data.size) + 672 <= test266151307())
        mem[ceil32(return_data.size) + 384] = ext_call.return_data[0]
        mem[ceil32(return_data.size) + 416] = ext_call.return_data[32]
        mem[ceil32(return_data.size) + 448] = ext_call.return_data[64]
        mem[ceil32(return_data.size) + 480] = ext_call.return_data[96]
        mem[ceil32(return_data.size) + 512] = ext_call.return_data[128]
        mem[ceil32(return_data.size) + 544] = ext_call.return_data[160]
        mem[ceil32(return_data.size) + 576] = ext_call.return_data[192]
        mem[ceil32(return_data.size) + 608] = ext_call.return_data[224]
        mem[ceil32(return_data.size) + 640] = ext_call.return_data[256]
        if 0 == ext_call.return_data[32]:
            mem[ceil32(return_data.size) + 676] = this.address
            require ext_code.size(wantAddress)
            staticcall wantAddress.balanceOf(address arg1) with:
                    gas gas_remaining wei
                   args this.address
            mem[ceil32(return_data.size) + 672] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[64] = (2 * ceil32(return_data.size)) + 672
            require return_data.size >= 32
            idx = 0
            s = 0
            t = -1
            while idx < lenders.length:
                mem[0] = 13
                require ext_code.size(lenders[idx])
                staticcall lenders[idx].hasAssets() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _787 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_787] == bool(mem[_787])
                if not mem[_787]:
                    idx = idx + 1
                    s = s
                    t = t
                    continue 
                require idx < lenders.length
                mem[0] = 13
                require ext_code.size(lenders[idx])
                staticcall lenders[idx].apr() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _858 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _864 = mem[_858]
                if mem[_858] >= t:
                    idx = idx + 1
                    s = s
                    t = t
                    continue 
                require idx < lenders.length
                mem[0] = 13
                require ext_code.size(lenders[idx])
                staticcall lenders[idx].nav() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _901 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                idx = idx + 1
                s = mem[_901]
                t = _864
                continue 
            if ext_call.return_data[0] + s < s:
                revert with 0, 'SafeMath: addition overflow'
            idx = 0
            u = 0
            while idx < lenders.length:
                mem[0] = 13
                mem[mem[64] + 4] = ext_call.return_data[0]
                require ext_code.size(lenders[idx])
                staticcall lenders[idx].aprAfterDeposit(uint256 arg1) with:
                        gas gas_remaining wei
                       args ext_call.return_data[0]
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1509 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if mem[_1509] <= u:
                    idx = idx + 1
                    u = u
                    continue 
                idx = idx + 1
                u = mem[_1509]
                continue 
            require 0 < lenders.length
            mem[0] = 13
            mem[mem[64] + 4] = ext_call.return_data[0] + s
            require ext_code.size(lenders)
            staticcall lenders.aprAfterDeposit(uint256 arg1) with:
                    gas gas_remaining wei
                   args (ext_call.return_data[0] + s)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1508 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _1533 = mem[_1508]
            if mem[_1508] <= t:
                return 0
            require 0 < lenders.length
            mem[0] = 13
            require ext_code.size(lenders)
            staticcall lenders.nav() with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1616 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _1638 = mem[_1616]
            if not mem[_1616]:
                _1705 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1705] = 26
                mem[_1705 + 32] = 'SafeMath: division by zero'
                _1751 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1751] = 26
                mem[_1751 + 32] = 'SafeMath: division by zero'
                if 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83 == wantAddress:
                    if not arg1:
                        return 0
                    if profitFactor * arg1 / arg1 != profitFactor:
                        revert with 0, 'SafeMath: multiplication overflow'
                    return (profitFactor * arg1 < 0)
                if wantToEthOracleAddress:
                    mem[mem[64] + 4] = arg1
                    require ext_code.size(wantToEthOracleAddress)
                    staticcall wantToEthOracleAddress.0x780022a0 with:
                            gas gas_remaining wei
                           args arg1
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1941 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if not mem[_1941]:
                        return 0
                    if profitFactor * mem[_1941] / mem[_1941] != profitFactor:
                        revert with 0, 'SafeMath: multiplication overflow'
                    mem[mem[64]] = profitFactor * mem[_1941] < 0
                else:
                    _1816 = mem[64]
                    mem[mem[64]] = 2
                    mem[64] = mem[64] + 96
                    require 0 < mem[_1816]
                    mem[_1816 + 32] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                    require 1 < mem[_1816]
                    mem[_1816 + 64] = wantAddress
                    mem[_1816 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                    mem[_1816 + 100] = arg1
                    mem[_1816 + 132] = 64
                    mem[_1816 + 164] = mem[_1816]
                    idx = 0
                    s = _1816 + 196
                    t = _1816 + 32
                    while idx < mem[_1816]:
                        mem[s] = mem[t + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    require ext_code.size(0xf491e7b69e4244ad4002bc14e878a34207e38c29)
                    staticcall 0xf491e7b69e4244ad4002bc14e878a34207e38c29.mem[mem[64] len 4] with:
                            gas gas_remaining wei
                           args mem[mem[64] + 4 len _1816 + (32 * mem[_1816]) + -mem[64] + 192]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2836 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2882 = mem[_2836]
                    require mem[_2836] <= test266151307()
                    require _2836 + return_data.size > _2836 + mem[_2836] + 31
                    _2923 = mem[_2836 + mem[_2836]]
                    require mem[_2836 + mem[_2836]] <= test266151307()
                    require (32 * mem[_2836 + mem[_2836]]) + 32 >= 0 and _2836 + ceil32(return_data.size) + (32 * mem[_2836 + mem[_2836]]) + 32 <= test266151307()
                    mem[64] = _2836 + ceil32(return_data.size) + (32 * mem[_2836 + mem[_2836]]) + 32
                    mem[_2836 + ceil32(return_data.size)] = _2923
                    require return_data.size >= _2882 + (32 * _2923) + 32
                    mem[_2836 + ceil32(return_data.size) + 32 len 32 * _2923] = mem[_2836 + _2882 + 32 len 32 * _2923]
                    require _2923 - 1 < _2923
                    if not mem[(32 * _2923 - 1) + _2836 + ceil32(return_data.size) + 32]:
                        return 0
                    if profitFactor * mem[(32 * _2923 - 1) + _2836 + ceil32(return_data.size) + 32] / mem[(32 * _2923 - 1) + _2836 + ceil32(return_data.size) + 32] != profitFactor:
                        revert with 0, 'SafeMath: multiplication overflow'
                    mem[mem[64]] = profitFactor * mem[(32 * _2923 - 1) + _2836 + ceil32(return_data.size) + 32] < 0
            else:
                if t * mem[_1616] / mem[_1616] != t:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not mem[_1616]:
                    _1711 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1711] = 26
                    mem[_1711 + 32] = 'SafeMath: division by zero'
                    if not -1 * t * _1638 / 10^18:
                        _1762 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1762] = 26
                        mem[_1762 + 32] = 'SafeMath: division by zero'
                        if 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83 == wantAddress:
                            if not arg1:
                                return 0
                            if profitFactor * arg1 / arg1 != profitFactor:
                                revert with 0, 'SafeMath: multiplication overflow'
                            return (profitFactor * arg1 < 0)
                        if wantToEthOracleAddress:
                            mem[mem[64] + 4] = arg1
                            require ext_code.size(wantToEthOracleAddress)
                            staticcall wantToEthOracleAddress.0x780022a0 with:
                                    gas gas_remaining wei
                                   args arg1
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _1970 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if not mem[_1970]:
                                return 0
                            if profitFactor * mem[_1970] / mem[_1970] != profitFactor:
                                revert with 0, 'SafeMath: multiplication overflow'
                            mem[mem[64]] = profitFactor * mem[_1970] < 0
                        else:
                            _1832 = mem[64]
                            mem[mem[64]] = 2
                            mem[64] = mem[64] + 96
                            require 0 < mem[_1832]
                            mem[_1832 + 32] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                            require 1 < mem[_1832]
                            mem[_1832 + 64] = wantAddress
                            mem[_1832 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                            mem[_1832 + 100] = arg1
                            mem[_1832 + 132] = 64
                            mem[_1832 + 164] = mem[_1832]
                            idx = 0
                            s = _1832 + 196
                            t = _1832 + 32
                            while idx < mem[_1832]:
                                mem[s] = mem[t + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            require ext_code.size(0xf491e7b69e4244ad4002bc14e878a34207e38c29)
                            staticcall 0xf491e7b69e4244ad4002bc14e878a34207e38c29.mem[mem[64] len 4] with:
                                    gas gas_remaining wei
                                   args mem[mem[64] + 4 len _1832 + (32 * mem[_1832]) + -mem[64] + 192]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2835 = mem[64]
                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _2881 = mem[_2835]
                            require mem[_2835] <= test266151307()
                            require _2835 + return_data.size > _2835 + mem[_2835] + 31
                            _2922 = mem[_2835 + mem[_2835]]
                            require mem[_2835 + mem[_2835]] <= test266151307()
                            require (32 * mem[_2835 + mem[_2835]]) + 32 >= 0 and _2835 + ceil32(return_data.size) + (32 * mem[_2835 + mem[_2835]]) + 32 <= test266151307()
                            mem[64] = _2835 + ceil32(return_data.size) + (32 * mem[_2835 + mem[_2835]]) + 32
                            mem[_2835 + ceil32(return_data.size)] = _2922
                            require return_data.size >= _2881 + (32 * _2922) + 32
                            mem[_2835 + ceil32(return_data.size) + 32 len 32 * _2922] = mem[_2835 + _2881 + 32 len 32 * _2922]
                            require _2922 - 1 < _2922
                            if not mem[(32 * _2922 - 1) + _2835 + ceil32(return_data.size) + 32]:
                                return 0
                            if profitFactor * mem[(32 * _2922 - 1) + _2835 + ceil32(return_data.size) + 32] / mem[(32 * _2922 - 1) + _2835 + ceil32(return_data.size) + 32] != profitFactor:
                                revert with 0, 'SafeMath: multiplication overflow'
                            mem[mem[64]] = profitFactor * mem[(32 * _2922 - 1) + _2835 + ceil32(return_data.size) + 32] < 0
                    else:
                        if maxReportDelay * -1 * t * _1638 / 10^18 / -1 * t * _1638 / 10^18 != maxReportDelay:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _1775 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1775] = 26
                        mem[_1775 + 32] = 'SafeMath: division by zero'
                        if 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83 == wantAddress:
                            if not arg1:
                                return (0 < maxReportDelay * -1 * t * _1638 / 10^18 / 31556952)
                            if profitFactor * arg1 / arg1 != profitFactor:
                                revert with 0, 'SafeMath: multiplication overflow'
                            return (profitFactor * arg1 < maxReportDelay * -1 * t * _1638 / 10^18 / 31556952)
                        if wantToEthOracleAddress:
                            mem[mem[64] + 4] = arg1
                            require ext_code.size(wantToEthOracleAddress)
                            staticcall wantToEthOracleAddress.0x780022a0 with:
                                    gas gas_remaining wei
                                   args arg1
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _1997 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if not mem[_1997]:
                                return (0 < maxReportDelay * -1 * t * _1638 / 10^18 / 31556952)
                            if profitFactor * mem[_1997] / mem[_1997] != profitFactor:
                                revert with 0, 'SafeMath: multiplication overflow'
                            mem[mem[64]] = profitFactor * mem[_1997] < maxReportDelay * -1 * t * _1638 / 10^18 / 31556952
                        else:
                            _1868 = mem[64]
                            mem[mem[64]] = 2
                            mem[64] = mem[64] + 96
                            require 0 < mem[_1868]
                            mem[_1868 + 32] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                            require 1 < mem[_1868]
                            mem[_1868 + 64] = wantAddress
                            mem[_1868 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                            mem[_1868 + 100] = arg1
                            mem[_1868 + 132] = 64
                            mem[_1868 + 164] = mem[_1868]
                            idx = 0
                            s = _1868 + 196
                            u = _1868 + 32
                            while idx < mem[_1868]:
                                mem[s] = mem[u + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                u = u + 32
                                continue 
                            require ext_code.size(0xf491e7b69e4244ad4002bc14e878a34207e38c29)
                            staticcall 0xf491e7b69e4244ad4002bc14e878a34207e38c29.mem[mem[64] len 4] with:
                                    gas gas_remaining wei
                                   args mem[mem[64] + 4 len _1868 + (32 * mem[_1868]) + -mem[64] + 192]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2834 = mem[64]
                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _2880 = mem[_2834]
                            require mem[_2834] <= test266151307()
                            require _2834 + return_data.size > _2834 + mem[_2834] + 31
                            _2921 = mem[_2834 + mem[_2834]]
                            require mem[_2834 + mem[_2834]] <= test266151307()
                            require (32 * mem[_2834 + mem[_2834]]) + 32 >= 0 and _2834 + ceil32(return_data.size) + (32 * mem[_2834 + mem[_2834]]) + 32 <= test266151307()
                            mem[64] = _2834 + ceil32(return_data.size) + (32 * mem[_2834 + mem[_2834]]) + 32
                            mem[_2834 + ceil32(return_data.size)] = _2921
                            require return_data.size >= _2880 + (32 * _2921) + 32
                            mem[_2834 + ceil32(return_data.size) + 32 len 32 * _2921] = mem[_2834 + _2880 + 32 len 32 * _2921]
                            require _2921 - 1 < _2921
                            if not mem[(32 * _2921 - 1) + _2834 + ceil32(return_data.size) + 32]:
                                return (0 < maxReportDelay * -1 * t * _1638 / 10^18 / 31556952)
                            if profitFactor * mem[(32 * _2921 - 1) + _2834 + ceil32(return_data.size) + 32] / mem[(32 * _2921 - 1) + _2834 + ceil32(return_data.size) + 32] != profitFactor:
                                revert with 0, 'SafeMath: multiplication overflow'
                            mem[mem[64]] = profitFactor * mem[(32 * _2921 - 1) + _2834 + ceil32(return_data.size) + 32] < maxReportDelay * -1 * t * _1638 / 10^18 / 31556952
                else:
                    if _1533 * mem[_1616] / mem[_1616] != _1533:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _1719 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1719] = 26
                    mem[_1719 + 32] = 'SafeMath: division by zero'
                    if not (_1533 * _1638) - (t * _1638) / 10^18:
                        _1774 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1774] = 26
                        mem[_1774 + 32] = 'SafeMath: division by zero'
                        if 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83 == wantAddress:
                            if not arg1:
                                return 0
                            if profitFactor * arg1 / arg1 != profitFactor:
                                revert with 0, 'SafeMath: multiplication overflow'
                            return (profitFactor * arg1 < 0)
                        if wantToEthOracleAddress:
                            mem[mem[64] + 4] = arg1
                            require ext_code.size(wantToEthOracleAddress)
                            staticcall wantToEthOracleAddress.0x780022a0 with:
                                    gas gas_remaining wei
                                   args arg1
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _1996 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if not mem[_1996]:
                                return 0
                            if profitFactor * mem[_1996] / mem[_1996] != profitFactor:
                                revert with 0, 'SafeMath: multiplication overflow'
                            mem[mem[64]] = profitFactor * mem[_1996] < 0
                        else:
                            _1865 = mem[64]
                            mem[mem[64]] = 2
                            mem[64] = mem[64] + 96
                            require 0 < mem[_1865]
                            mem[_1865 + 32] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                            require 1 < mem[_1865]
                            mem[_1865 + 64] = wantAddress
                            mem[_1865 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                            mem[_1865 + 100] = arg1
                            mem[_1865 + 132] = 64
                            mem[_1865 + 164] = mem[_1865]
                            idx = 0
                            s = _1865 + 196
                            t = _1865 + 32
                            while idx < mem[_1865]:
                                mem[s] = mem[t + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            require ext_code.size(0xf491e7b69e4244ad4002bc14e878a34207e38c29)
                            staticcall 0xf491e7b69e4244ad4002bc14e878a34207e38c29.mem[mem[64] len 4] with:
                                    gas gas_remaining wei
                                   args mem[mem[64] + 4 len _1865 + (32 * mem[_1865]) + -mem[64] + 192]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2833 = mem[64]
                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _2879 = mem[_2833]
                            require mem[_2833] <= test266151307()
                            require _2833 + return_data.size > _2833 + mem[_2833] + 31
                            _2920 = mem[_2833 + mem[_2833]]
                            require mem[_2833 + mem[_2833]] <= test266151307()
                            require (32 * mem[_2833 + mem[_2833]]) + 32 >= 0 and _2833 + ceil32(return_data.size) + (32 * mem[_2833 + mem[_2833]]) + 32 <= test266151307()
                            mem[64] = _2833 + ceil32(return_data.size) + (32 * mem[_2833 + mem[_2833]]) + 32
                            mem[_2833 + ceil32(return_data.size)] = _2920
                            require return_data.size >= _2879 + (32 * _2920) + 32
                            mem[_2833 + ceil32(return_data.size) + 32 len 32 * _2920] = mem[_2833 + _2879 + 32 len 32 * _2920]
                            require _2920 - 1 < _2920
                            if not mem[(32 * _2920 - 1) + _2833 + ceil32(return_data.size) + 32]:
                                return 0
                            if profitFactor * mem[(32 * _2920 - 1) + _2833 + ceil32(return_data.size) + 32] / mem[(32 * _2920 - 1) + _2833 + ceil32(return_data.size) + 32] != profitFactor:
                                revert with 0, 'SafeMath: multiplication overflow'
                            mem[mem[64]] = profitFactor * mem[(32 * _2920 - 1) + _2833 + ceil32(return_data.size) + 32] < 0
                    else:
                        if maxReportDelay * (_1533 * _1638) - (t * _1638) / 10^18 / (_1533 * _1638) - (t * _1638) / 10^18 != maxReportDelay:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _1784 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1784] = 26
                        mem[_1784 + 32] = 'SafeMath: division by zero'
                        if 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83 == wantAddress:
                            if not arg1:
                                return (0 < maxReportDelay * (_1533 * _1638) - (t * _1638) / 10^18 / 31556952)
                            if profitFactor * arg1 / arg1 != profitFactor:
                                revert with 0, 'SafeMath: multiplication overflow'
                            return (profitFactor * arg1 < maxReportDelay * (_1533 * _1638) - (t * _1638) / 10^18 / 31556952)
                        if wantToEthOracleAddress:
                            mem[mem[64] + 4] = arg1
                            require ext_code.size(wantToEthOracleAddress)
                            staticcall wantToEthOracleAddress.0x780022a0 with:
                                    gas gas_remaining wei
                                   args arg1
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2032 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if not mem[_2032]:
                                return (0 < maxReportDelay * (_1533 * _1638) - (t * _1638) / 10^18 / 31556952)
                            if profitFactor * mem[_2032] / mem[_2032] != profitFactor:
                                revert with 0, 'SafeMath: multiplication overflow'
                            mem[mem[64]] = profitFactor * mem[_2032] < maxReportDelay * (_1533 * _1638) - (t * _1638) / 10^18 / 31556952
                        else:
                            _1902 = mem[64]
                            mem[mem[64]] = 2
                            mem[64] = mem[64] + 96
                            require 0 < mem[_1902]
                            mem[_1902 + 32] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                            require 1 < mem[_1902]
                            mem[_1902 + 64] = wantAddress
                            mem[_1902 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                            mem[_1902 + 100] = arg1
                            mem[_1902 + 132] = 64
                            mem[_1902 + 164] = mem[_1902]
                            idx = 0
                            s = _1902 + 196
                            u = _1902 + 32
                            while idx < mem[_1902]:
                                mem[s] = mem[u + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                u = u + 32
                                continue 
                            require ext_code.size(0xf491e7b69e4244ad4002bc14e878a34207e38c29)
                            staticcall 0xf491e7b69e4244ad4002bc14e878a34207e38c29.mem[mem[64] len 4] with:
                                    gas gas_remaining wei
                                   args mem[mem[64] + 4 len _1902 + (32 * mem[_1902]) + -mem[64] + 192]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2832 = mem[64]
                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _2878 = mem[_2832]
                            require mem[_2832] <= test266151307()
                            require _2832 + return_data.size > _2832 + mem[_2832] + 31
                            _2919 = mem[_2832 + mem[_2832]]
                            require mem[_2832 + mem[_2832]] <= test266151307()
                            require (32 * mem[_2832 + mem[_2832]]) + 32 >= 0 and _2832 + ceil32(return_data.size) + (32 * mem[_2832 + mem[_2832]]) + 32 <= test266151307()
                            mem[64] = _2832 + ceil32(return_data.size) + (32 * mem[_2832 + mem[_2832]]) + 32
                            mem[_2832 + ceil32(return_data.size)] = _2919
                            require return_data.size >= _2878 + (32 * _2919) + 32
                            mem[_2832 + ceil32(return_data.size) + 32 len 32 * _2919] = mem[_2832 + _2878 + 32 len 32 * _2919]
                            require _2919 - 1 < _2919
                            if not mem[(32 * _2919 - 1) + _2832 + ceil32(return_data.size) + 32]:
                                return (0 < maxReportDelay * (_1533 * _1638) - (t * _1638) / 10^18 / 31556952)
                            if profitFactor * mem[(32 * _2919 - 1) + _2832 + ceil32(return_data.size) + 32] / mem[(32 * _2919 - 1) + _2832 + ceil32(return_data.size) + 32] != profitFactor:
                                revert with 0, 'SafeMath: multiplication overflow'
                            mem[mem[64]] = profitFactor * mem[(32 * _2919 - 1) + _2832 + ceil32(return_data.size) + 32] < maxReportDelay * (_1533 * _1638) - (t * _1638) / 10^18 / 31556952
        else:
            mem[ceil32(return_data.size) + 672] = 30
            mem[ceil32(return_data.size) + 704] = 'SafeMath: subtraction overflow'
            if ext_call.return_data[160] > block.timestamp:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if block.timestamp - ext_call.return_data[160] < minReportDelay:
                mem[ceil32(return_data.size) + 740] = this.address
                require ext_code.size(wantAddress)
                staticcall wantAddress.balanceOf(address arg1) with:
                        gas gas_remaining wei
                       args this.address
                mem[ceil32(return_data.size) + 736] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[64] = (2 * ceil32(return_data.size)) + 736
                require return_data.size >= 32
                idx = 0
                s = 0
                t = -1
                while idx < lenders.length:
                    mem[0] = 13
                    require ext_code.size(lenders[idx])
                    staticcall lenders[idx].hasAssets() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _786 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_786] == bool(mem[_786])
                    if not mem[_786]:
                        idx = idx + 1
                        s = s
                        t = t
                        continue 
                    require idx < lenders.length
                    mem[0] = 13
                    require ext_code.size(lenders[idx])
                    staticcall lenders[idx].apr() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _857 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _863 = mem[_857]
                    if mem[_857] >= t:
                        idx = idx + 1
                        s = s
                        t = t
                        continue 
                    require idx < lenders.length
                    mem[0] = 13
                    require ext_code.size(lenders[idx])
                    staticcall lenders[idx].nav() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _900 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    idx = idx + 1
                    s = mem[_900]
                    t = _863
                    continue 
                if ext_call.return_data[0] + s < s:
                    revert with 0, 'SafeMath: addition overflow'
                idx = 0
                u = 0
                while idx < lenders.length:
                    mem[0] = 13
                    mem[mem[64] + 4] = ext_call.return_data[0]
                    require ext_code.size(lenders[idx])
                    staticcall lenders[idx].aprAfterDeposit(uint256 arg1) with:
                            gas gas_remaining wei
                           args ext_call.return_data[0]
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1507 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if mem[_1507] <= u:
                        idx = idx + 1
                        u = u
                        continue 
                    idx = idx + 1
                    u = mem[_1507]
                    continue 
                require 0 < lenders.length
                mem[0] = 13
                mem[mem[64] + 4] = ext_call.return_data[0] + s
                require ext_code.size(lenders)
                staticcall lenders.aprAfterDeposit(uint256 arg1) with:
                        gas gas_remaining wei
                       args (ext_call.return_data[0] + s)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1506 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _1531 = mem[_1506]
                if mem[_1506] <= t:
                    return 0
                require 0 < lenders.length
                mem[0] = 13
                require ext_code.size(lenders)
                staticcall lenders.nav() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1614 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _1637 = mem[_1614]
                if not mem[_1614]:
                    _1703 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1703] = 26
                    mem[_1703 + 32] = 'SafeMath: division by zero'
                    _1749 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1749] = 26
                    mem[_1749 + 32] = 'SafeMath: division by zero'
                    if 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83 == wantAddress:
                        if not arg1:
                            return 0
                        if profitFactor * arg1 / arg1 != profitFactor:
                            revert with 0, 'SafeMath: multiplication overflow'
                        return (profitFactor * arg1 < 0)
                    if wantToEthOracleAddress:
                        mem[mem[64] + 4] = arg1
                        require ext_code.size(wantToEthOracleAddress)
                        staticcall wantToEthOracleAddress.0x780022a0 with:
                                gas gas_remaining wei
                               args arg1
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1934 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if not mem[_1934]:
                            return 0
                        if profitFactor * mem[_1934] / mem[_1934] != profitFactor:
                            revert with 0, 'SafeMath: multiplication overflow'
                        mem[mem[64]] = profitFactor * mem[_1934] < 0
                    else:
                        _1813 = mem[64]
                        mem[mem[64]] = 2
                        mem[64] = mem[64] + 96
                        require 0 < mem[_1813]
                        mem[_1813 + 32] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                        require 1 < mem[_1813]
                        mem[_1813 + 64] = wantAddress
                        mem[_1813 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                        mem[_1813 + 100] = arg1
                        mem[_1813 + 132] = 64
                        mem[_1813 + 164] = mem[_1813]
                        idx = 0
                        s = _1813 + 196
                        t = _1813 + 32
                        while idx < mem[_1813]:
                            mem[s] = mem[t + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        require ext_code.size(0xf491e7b69e4244ad4002bc14e878a34207e38c29)
                        staticcall 0xf491e7b69e4244ad4002bc14e878a34207e38c29.mem[mem[64] len 4] with:
                                gas gas_remaining wei
                               args mem[mem[64] + 4 len _1813 + (32 * mem[_1813]) + -mem[64] + 192]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2831 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _2877 = mem[_2831]
                        require mem[_2831] <= test266151307()
                        require _2831 + return_data.size > _2831 + mem[_2831] + 31
                        _2918 = mem[_2831 + mem[_2831]]
                        require mem[_2831 + mem[_2831]] <= test266151307()
                        require (32 * mem[_2831 + mem[_2831]]) + 32 >= 0 and _2831 + ceil32(return_data.size) + (32 * mem[_2831 + mem[_2831]]) + 32 <= test266151307()
                        mem[64] = _2831 + ceil32(return_data.size) + (32 * mem[_2831 + mem[_2831]]) + 32
                        mem[_2831 + ceil32(return_data.size)] = _2918
                        require return_data.size >= _2877 + (32 * _2918) + 32
                        mem[_2831 + ceil32(return_data.size) + 32 len 32 * _2918] = mem[_2831 + _2877 + 32 len 32 * _2918]
                        require _2918 - 1 < _2918
                        if not mem[(32 * _2918 - 1) + _2831 + ceil32(return_data.size) + 32]:
                            return 0
                        if profitFactor * mem[(32 * _2918 - 1) + _2831 + ceil32(return_data.size) + 32] / mem[(32 * _2918 - 1) + _2831 + ceil32(return_data.size) + 32] != profitFactor:
                            revert with 0, 'SafeMath: multiplication overflow'
                        mem[mem[64]] = profitFactor * mem[(32 * _2918 - 1) + _2831 + ceil32(return_data.size) + 32] < 0
                else:
                    if t * mem[_1614] / mem[_1614] != t:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not mem[_1614]:
                        _1710 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1710] = 26
                        mem[_1710 + 32] = 'SafeMath: division by zero'
                        if not -1 * t * _1637 / 10^18:
                            _1760 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1760] = 26
                            mem[_1760 + 32] = 'SafeMath: division by zero'
                            if 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83 == wantAddress:
                                if not arg1:
                                    return 0
                                if profitFactor * arg1 / arg1 != profitFactor:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                return (profitFactor * arg1 < 0)
                            if wantToEthOracleAddress:
                                mem[mem[64] + 4] = arg1
                                require ext_code.size(wantToEthOracleAddress)
                                staticcall wantToEthOracleAddress.0x780022a0 with:
                                        gas gas_remaining wei
                                       args arg1
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _1963 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if not mem[_1963]:
                                    return 0
                                if profitFactor * mem[_1963] / mem[_1963] != profitFactor:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[mem[64]] = profitFactor * mem[_1963] < 0
                            else:
                                _1828 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                require 0 < mem[_1828]
                                mem[_1828 + 32] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                require 1 < mem[_1828]
                                mem[_1828 + 64] = wantAddress
                                mem[_1828 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[_1828 + 100] = arg1
                                mem[_1828 + 132] = 64
                                mem[_1828 + 164] = mem[_1828]
                                idx = 0
                                s = _1828 + 196
                                t = _1828 + 32
                                while idx < mem[_1828]:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(0xf491e7b69e4244ad4002bc14e878a34207e38c29)
                                staticcall 0xf491e7b69e4244ad4002bc14e878a34207e38c29.mem[mem[64] len 4] with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len _1828 + (32 * mem[_1828]) + -mem[64] + 192]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _2830 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _2876 = mem[_2830]
                                require mem[_2830] <= test266151307()
                                require _2830 + return_data.size > _2830 + mem[_2830] + 31
                                _2917 = mem[_2830 + mem[_2830]]
                                require mem[_2830 + mem[_2830]] <= test266151307()
                                require (32 * mem[_2830 + mem[_2830]]) + 32 >= 0 and _2830 + ceil32(return_data.size) + (32 * mem[_2830 + mem[_2830]]) + 32 <= test266151307()
                                mem[64] = _2830 + ceil32(return_data.size) + (32 * mem[_2830 + mem[_2830]]) + 32
                                mem[_2830 + ceil32(return_data.size)] = _2917
                                require return_data.size >= _2876 + (32 * _2917) + 32
                                mem[_2830 + ceil32(return_data.size) + 32 len 32 * _2917] = mem[_2830 + _2876 + 32 len 32 * _2917]
                                require _2917 - 1 < _2917
                                if not mem[(32 * _2917 - 1) + _2830 + ceil32(return_data.size) + 32]:
                                    return 0
                                if profitFactor * mem[(32 * _2917 - 1) + _2830 + ceil32(return_data.size) + 32] / mem[(32 * _2917 - 1) + _2830 + ceil32(return_data.size) + 32] != profitFactor:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[mem[64]] = profitFactor * mem[(32 * _2917 - 1) + _2830 + ceil32(return_data.size) + 32] < 0
                        else:
                            if maxReportDelay * -1 * t * _1637 / 10^18 / -1 * t * _1637 / 10^18 != maxReportDelay:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _1772 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1772] = 26
                            mem[_1772 + 32] = 'SafeMath: division by zero'
                            if 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83 == wantAddress:
                                if not arg1:
                                    return (0 < maxReportDelay * -1 * t * _1637 / 10^18 / 31556952)
                                if profitFactor * arg1 / arg1 != profitFactor:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                return (profitFactor * arg1 < maxReportDelay * -1 * t * _1637 / 10^18 / 31556952)
                            if wantToEthOracleAddress:
                                mem[mem[64] + 4] = arg1
                                require ext_code.size(wantToEthOracleAddress)
                                staticcall wantToEthOracleAddress.0x780022a0 with:
                                        gas gas_remaining wei
                                       args arg1
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _1990 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if not mem[_1990]:
                                    return (0 < maxReportDelay * -1 * t * _1637 / 10^18 / 31556952)
                                if profitFactor * mem[_1990] / mem[_1990] != profitFactor:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[mem[64]] = profitFactor * mem[_1990] < maxReportDelay * -1 * t * _1637 / 10^18 / 31556952
                            else:
                                _1859 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                require 0 < mem[_1859]
                                mem[_1859 + 32] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                require 1 < mem[_1859]
                                mem[_1859 + 64] = wantAddress
                                mem[_1859 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[_1859 + 100] = arg1
                                mem[_1859 + 132] = 64
                                mem[_1859 + 164] = mem[_1859]
                                idx = 0
                                s = _1859 + 196
                                u = _1859 + 32
                                while idx < mem[_1859]:
                                    mem[s] = mem[u + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    u = u + 32
                                    continue 
                                require ext_code.size(0xf491e7b69e4244ad4002bc14e878a34207e38c29)
                                staticcall 0xf491e7b69e4244ad4002bc14e878a34207e38c29.mem[mem[64] len 4] with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len _1859 + (32 * mem[_1859]) + -mem[64] + 192]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _2829 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _2875 = mem[_2829]
                                require mem[_2829] <= test266151307()
                                require _2829 + return_data.size > _2829 + mem[_2829] + 31
                                _2916 = mem[_2829 + mem[_2829]]
                                require mem[_2829 + mem[_2829]] <= test266151307()
                                require (32 * mem[_2829 + mem[_2829]]) + 32 >= 0 and _2829 + ceil32(return_data.size) + (32 * mem[_2829 + mem[_2829]]) + 32 <= test266151307()
                                mem[64] = _2829 + ceil32(return_data.size) + (32 * mem[_2829 + mem[_2829]]) + 32
                                mem[_2829 + ceil32(return_data.size)] = _2916
                                require return_data.size >= _2875 + (32 * _2916) + 32
                                mem[_2829 + ceil32(return_data.size) + 32 len 32 * _2916] = mem[_2829 + _2875 + 32 len 32 * _2916]
                                require _2916 - 1 < _2916
                                if not mem[(32 * _2916 - 1) + _2829 + ceil32(return_data.size) + 32]:
                                    return (0 < maxReportDelay * -1 * t * _1637 / 10^18 / 31556952)
                                if profitFactor * mem[(32 * _2916 - 1) + _2829 + ceil32(return_data.size) + 32] / mem[(32 * _2916 - 1) + _2829 + ceil32(return_data.size) + 32] != profitFactor:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[mem[64]] = profitFactor * mem[(32 * _2916 - 1) + _2829 + ceil32(return_data.size) + 32] < maxReportDelay * -1 * t * _1637 / 10^18 / 31556952
                    else:
                        if _1531 * mem[_1614] / mem[_1614] != _1531:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _1717 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1717] = 26
                        mem[_1717 + 32] = 'SafeMath: division by zero'
                        if not (_1531 * _1637) - (t * _1637) / 10^18:
                            _1771 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1771] = 26
                            mem[_1771 + 32] = 'SafeMath: division by zero'
                            if 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83 == wantAddress:
                                if not arg1:
                                    return 0
                                if profitFactor * arg1 / arg1 != profitFactor:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                return (profitFactor * arg1 < 0)
                            if wantToEthOracleAddress:
                                mem[mem[64] + 4] = arg1
                                require ext_code.size(wantToEthOracleAddress)
                                staticcall wantToEthOracleAddress.0x780022a0 with:
                                        gas gas_remaining wei
                                       args arg1
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _1989 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if not mem[_1989]:
                                    return 0
                                if profitFactor * mem[_1989] / mem[_1989] != profitFactor:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[mem[64]] = profitFactor * mem[_1989] < 0
                            else:
                                _1856 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                require 0 < mem[_1856]
                                mem[_1856 + 32] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                require 1 < mem[_1856]
                                mem[_1856 + 64] = wantAddress
                                mem[_1856 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[_1856 + 100] = arg1
                                mem[_1856 + 132] = 64
                                mem[_1856 + 164] = mem[_1856]
                                idx = 0
                                s = _1856 + 196
                                t = _1856 + 32
                                while idx < mem[_1856]:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(0xf491e7b69e4244ad4002bc14e878a34207e38c29)
                                staticcall 0xf491e7b69e4244ad4002bc14e878a34207e38c29.mem[mem[64] len 4] with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len _1856 + (32 * mem[_1856]) + -mem[64] + 192]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _2828 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _2874 = mem[_2828]
                                require mem[_2828] <= test266151307()
                                require _2828 + return_data.size > _2828 + mem[_2828] + 31
                                _2915 = mem[_2828 + mem[_2828]]
                                require mem[_2828 + mem[_2828]] <= test266151307()
                                require (32 * mem[_2828 + mem[_2828]]) + 32 >= 0 and _2828 + ceil32(return_data.size) + (32 * mem[_2828 + mem[_2828]]) + 32 <= test266151307()
                                mem[64] = _2828 + ceil32(return_data.size) + (32 * mem[_2828 + mem[_2828]]) + 32
                                mem[_2828 + ceil32(return_data.size)] = _2915
                                require return_data.size >= _2874 + (32 * _2915) + 32
                                mem[_2828 + ceil32(return_data.size) + 32 len 32 * _2915] = mem[_2828 + _2874 + 32 len 32 * _2915]
                                require _2915 - 1 < _2915
                                if not mem[(32 * _2915 - 1) + _2828 + ceil32(return_data.size) + 32]:
                                    return 0
                                if profitFactor * mem[(32 * _2915 - 1) + _2828 + ceil32(return_data.size) + 32] / mem[(32 * _2915 - 1) + _2828 + ceil32(return_data.size) + 32] != profitFactor:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[mem[64]] = profitFactor * mem[(32 * _2915 - 1) + _2828 + ceil32(return_data.size) + 32] < 0
                        else:
                            if maxReportDelay * (_1531 * _1637) - (t * _1637) / 10^18 / (_1531 * _1637) - (t * _1637) / 10^18 != maxReportDelay:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _1782 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1782] = 26
                            mem[_1782 + 32] = 'SafeMath: division by zero'
                            if 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83 == wantAddress:
                                if not arg1:
                                    return (0 < maxReportDelay * (_1531 * _1637) - (t * _1637) / 10^18 / 31556952)
                                if profitFactor * arg1 / arg1 != profitFactor:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                return (profitFactor * arg1 < maxReportDelay * (_1531 * _1637) - (t * _1637) / 10^18 / 31556952)
                            if wantToEthOracleAddress:
                                mem[mem[64] + 4] = arg1
                                require ext_code.size(wantToEthOracleAddress)
                                staticcall wantToEthOracleAddress.0x780022a0 with:
                                        gas gas_remaining wei
                                       args arg1
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _2023 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if not mem[_2023]:
                                    return (0 < maxReportDelay * (_1531 * _1637) - (t * _1637) / 10^18 / 31556952)
                                if profitFactor * mem[_2023] / mem[_2023] != profitFactor:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[mem[64]] = profitFactor * mem[_2023] < maxReportDelay * (_1531 * _1637) - (t * _1637) / 10^18 / 31556952
                            else:
                                _1894 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                require 0 < mem[_1894]
                                mem[_1894 + 32] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                require 1 < mem[_1894]
                                mem[_1894 + 64] = wantAddress
                                mem[_1894 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[_1894 + 100] = arg1
                                mem[_1894 + 132] = 64
                                mem[_1894 + 164] = mem[_1894]
                                idx = 0
                                s = _1894 + 196
                                u = _1894 + 32
                                while idx < mem[_1894]:
                                    mem[s] = mem[u + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    u = u + 32
                                    continue 
                                require ext_code.size(0xf491e7b69e4244ad4002bc14e878a34207e38c29)
                                staticcall 0xf491e7b69e4244ad4002bc14e878a34207e38c29.mem[mem[64] len 4] with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len _1894 + (32 * mem[_1894]) + -mem[64] + 192]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _2827 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _2873 = mem[_2827]
                                require mem[_2827] <= test266151307()
                                require _2827 + return_data.size > _2827 + mem[_2827] + 31
                                _2914 = mem[_2827 + mem[_2827]]
                                require mem[_2827 + mem[_2827]] <= test266151307()
                                require (32 * mem[_2827 + mem[_2827]]) + 32 >= 0 and _2827 + ceil32(return_data.size) + (32 * mem[_2827 + mem[_2827]]) + 32 <= test266151307()
                                mem[64] = _2827 + ceil32(return_data.size) + (32 * mem[_2827 + mem[_2827]]) + 32
                                mem[_2827 + ceil32(return_data.size)] = _2914
                                require return_data.size >= _2873 + (32 * _2914) + 32
                                mem[_2827 + ceil32(return_data.size) + 32 len 32 * _2914] = mem[_2827 + _2873 + 32 len 32 * _2914]
                                require _2914 - 1 < _2914
                                if not mem[(32 * _2914 - 1) + _2827 + ceil32(return_data.size) + 32]:
                                    return (0 < maxReportDelay * (_1531 * _1637) - (t * _1637) / 10^18 / 31556952)
                                if profitFactor * mem[(32 * _2914 - 1) + _2827 + ceil32(return_data.size) + 32] / mem[(32 * _2914 - 1) + _2827 + ceil32(return_data.size) + 32] != profitFactor:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[mem[64]] = profitFactor * mem[(32 * _2914 - 1) + _2827 + ceil32(return_data.size) + 32] < maxReportDelay * (_1531 * _1637) - (t * _1637) / 10^18 / 31556952
            else:
                mem[ceil32(return_data.size) + 736] = 30
                mem[ceil32(return_data.size) + 768] = 'SafeMath: subtraction overflow'
                if ext_call.return_data[160] > block.timestamp:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if block.timestamp - ext_call.return_data[160] >= maxReportDelay:
                    return 0
                require ext_code.size(vaultAddress)
                staticcall vaultAddress.debtOutstanding() with:
                        gas gas_remaining wei
                mem[ceil32(return_data.size) + 800] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[64] = (2 * ceil32(return_data.size)) + 800
                require return_data.size >= 32
                if ext_call.return_data[0] > debtThreshold:
                    return 0
                idx = 0
                s = 0
                while idx < lenders.length:
                    mem[0] = 13
                    require ext_code.size(lenders[idx])
                    staticcall lenders[idx].nav() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _785 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if mem[_785] + s < s:
                        revert with 0, 'SafeMath: addition overflow'
                    idx = idx + 1
                    s = mem[_785] + s
                    continue 
                mem[mem[64] + 4] = this.address
                require ext_code.size(wantAddress)
                staticcall wantAddress.balanceOf(address arg1) with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _805 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _819 = mem[_805]
                if mem[_805] + (_806 * lenders.length) < _806 * lenders.length:
                    revert with 0, 'SafeMath: addition overflow'
                if debtThreshold < 0:
                    revert with 0, 'SafeMath: addition overflow'
                if debtThreshold + mem[_805] + (_806 * lenders.length) < mem[ceil32(return_data.size) + 576]:
                    return 0
                if mem[_805] + (_806 * lenders.length) <= mem[ceil32(return_data.size) + 576]:
                    require ext_code.size(vaultAddress)
                    staticcall vaultAddress.creditAvailable() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _894 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if mem[_894] < mem[_894]:
                        revert with 0, 'SafeMath: addition overflow'
                    if not profitFactor:
                        if 0 < mem[_894]:
                            return 0
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(wantAddress)
                        staticcall wantAddress.balanceOf(address arg1) with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _977 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _987 = mem[_977]
                        idx = 0
                        s = 0
                        t = -1
                        while idx < lenders.length:
                            mem[0] = 13
                            require ext_code.size(lenders[idx])
                            staticcall lenders[idx].hasAssets() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _1473 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_1473] == bool(mem[_1473])
                            if not mem[_1473]:
                                idx = idx + 1
                                s = s
                                t = t
                                continue 
                            require idx < lenders.length
                            mem[0] = 13
                            require ext_code.size(lenders[idx])
                            staticcall lenders[idx].apr() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _1610 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _1634 = mem[_1610]
                            if mem[_1610] >= t:
                                idx = idx + 1
                                s = s
                                t = t
                                continue 
                            require idx < lenders.length
                            mem[0] = 13
                            require ext_code.size(lenders[idx])
                            staticcall lenders[idx].nav() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _1674 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            idx = idx + 1
                            s = mem[_1674]
                            t = _1634
                            continue 
                        if _987 + s < s:
                            revert with 0, 'SafeMath: addition overflow'
                        idx = 0
                        u = 0
                        while idx < lenders.length:
                            mem[0] = 13
                            mem[mem[64] + 4] = _987
                            require ext_code.size(lenders[idx])
                            staticcall lenders[idx].aprAfterDeposit(uint256 arg1) with:
                                    gas gas_remaining wei
                                   args _987
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2868 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if mem[_2868] <= u:
                                idx = idx + 1
                                u = u
                                continue 
                            idx = idx + 1
                            u = mem[_2868]
                            continue 
                        require 0 < lenders.length
                        mem[0] = 13
                        mem[mem[64] + 4] = _987 + s
                        require ext_code.size(lenders)
                        staticcall lenders.aprAfterDeposit(uint256 arg1) with:
                                gas gas_remaining wei
                               args (_987 + s)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2867 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _2908 = mem[_2867]
                        if mem[_2867] <= t:
                            return 0
                        require 0 < lenders.length
                        mem[0] = 13
                        require ext_code.size(lenders)
                        staticcall lenders.nav() with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3006 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _3019 = mem[_3006]
                        if not mem[_3006]:
                            _3196 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3196] = 26
                            mem[_3196 + 32] = 'SafeMath: division by zero'
                            _3332 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3332] = 26
                            mem[_3332 + 32] = 'SafeMath: division by zero'
                            if 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83 == wantAddress:
                                if not arg1:
                                    return 0
                                if profitFactor * arg1 / arg1 != profitFactor:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                return (profitFactor * arg1 < 0)
                            if wantToEthOracleAddress:
                                mem[mem[64] + 4] = arg1
                                require ext_code.size(wantToEthOracleAddress)
                                staticcall wantToEthOracleAddress.0x780022a0 with:
                                        gas gas_remaining wei
                                       args arg1
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _3660 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if not mem[_3660]:
                                    return 0
                                if profitFactor * mem[_3660] / mem[_3660] != profitFactor:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[mem[64]] = profitFactor * mem[_3660] < 0
                            else:
                                _3431 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                require 0 < mem[_3431]
                                mem[_3431 + 32] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                require 1 < mem[_3431]
                                mem[_3431 + 64] = wantAddress
                                mem[_3431 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[_3431 + 100] = arg1
                                mem[_3431 + 132] = 64
                                mem[_3431 + 164] = mem[_3431]
                                idx = 0
                                s = _3431 + 196
                                t = _3431 + 32
                                while idx < mem[_3431]:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(0xf491e7b69e4244ad4002bc14e878a34207e38c29)
                                staticcall 0xf491e7b69e4244ad4002bc14e878a34207e38c29.mem[mem[64] len 4] with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len _3431 + (32 * mem[_3431]) + -mem[64] + 192]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _5201 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _5255 = mem[_5201]
                                require mem[_5201] <= test266151307()
                                require _5201 + return_data.size > _5201 + mem[_5201] + 31
                                _5317 = mem[_5201 + mem[_5201]]
                                require mem[_5201 + mem[_5201]] <= test266151307()
                                require (32 * mem[_5201 + mem[_5201]]) + 32 >= 0 and _5201 + ceil32(return_data.size) + (32 * mem[_5201 + mem[_5201]]) + 32 <= test266151307()
                                mem[64] = _5201 + ceil32(return_data.size) + (32 * mem[_5201 + mem[_5201]]) + 32
                                mem[_5201 + ceil32(return_data.size)] = _5317
                                require return_data.size >= _5255 + (32 * _5317) + 32
                                mem[_5201 + ceil32(return_data.size) + 32 len 32 * _5317] = mem[_5201 + _5255 + 32 len 32 * _5317]
                                require _5317 - 1 < _5317
                                if not mem[(32 * _5317 - 1) + _5201 + ceil32(return_data.size) + 32]:
                                    return 0
                                if profitFactor * mem[(32 * _5317 - 1) + _5201 + ceil32(return_data.size) + 32] / mem[(32 * _5317 - 1) + _5201 + ceil32(return_data.size) + 32] != profitFactor:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[mem[64]] = profitFactor * mem[(32 * _5317 - 1) + _5201 + ceil32(return_data.size) + 32] < 0
                        else:
                            if t * mem[_3006] / mem[_3006] != t:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not mem[_3006]:
                                _3237 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3237] = 26
                                mem[_3237 + 32] = 'SafeMath: division by zero'
                                if not -1 * t * _3019 / 10^18:
                                    _3350 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3350] = 26
                                    mem[_3350 + 32] = 'SafeMath: division by zero'
                                    if 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83 == wantAddress:
                                        if not arg1:
                                            return 0
                                        if profitFactor * arg1 / arg1 != profitFactor:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        return (profitFactor * arg1 < 0)
                                    if wantToEthOracleAddress:
                                        mem[mem[64] + 4] = arg1
                                        require ext_code.size(wantToEthOracleAddress)
                                        staticcall wantToEthOracleAddress.0x780022a0 with:
                                                gas gas_remaining wei
                                               args arg1
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _3719 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if not mem[_3719]:
                                            return 0
                                        if profitFactor * mem[_3719] / mem[_3719] != profitFactor:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        mem[mem[64]] = profitFactor * mem[_3719] < 0
                                    else:
                                        _3463 = mem[64]
                                        mem[mem[64]] = 2
                                        mem[64] = mem[64] + 96
                                        require 0 < mem[_3463]
                                        mem[_3463 + 32] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                        require 1 < mem[_3463]
                                        mem[_3463 + 64] = wantAddress
                                        mem[_3463 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                        mem[_3463 + 100] = arg1
                                        mem[_3463 + 132] = 64
                                        mem[_3463 + 164] = mem[_3463]
                                        idx = 0
                                        s = _3463 + 196
                                        t = _3463 + 32
                                        while idx < mem[_3463]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        require ext_code.size(0xf491e7b69e4244ad4002bc14e878a34207e38c29)
                                        staticcall 0xf491e7b69e4244ad4002bc14e878a34207e38c29.mem[mem[64] len 4] with:
                                                gas gas_remaining wei
                                               args mem[mem[64] + 4 len _3463 + (32 * mem[_3463]) + -mem[64] + 192]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5200 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _5254 = mem[_5200]
                                        require mem[_5200] <= test266151307()
                                        require _5200 + return_data.size > _5200 + mem[_5200] + 31
                                        _5316 = mem[_5200 + mem[_5200]]
                                        require mem[_5200 + mem[_5200]] <= test266151307()
                                        require (32 * mem[_5200 + mem[_5200]]) + 32 >= 0 and _5200 + ceil32(return_data.size) + (32 * mem[_5200 + mem[_5200]]) + 32 <= test266151307()
                                        mem[64] = _5200 + ceil32(return_data.size) + (32 * mem[_5200 + mem[_5200]]) + 32
                                        mem[_5200 + ceil32(return_data.size)] = _5316
                                        require return_data.size >= _5254 + (32 * _5316) + 32
                                        mem[_5200 + ceil32(return_data.size) + 32 len 32 * _5316] = mem[_5200 + _5254 + 32 len 32 * _5316]
                                        require _5316 - 1 < _5316
                                        if not mem[(32 * _5316 - 1) + _5200 + ceil32(return_data.size) + 32]:
                                            return 0
                                        if profitFactor * mem[(32 * _5316 - 1) + _5200 + ceil32(return_data.size) + 32] / mem[(32 * _5316 - 1) + _5200 + ceil32(return_data.size) + 32] != profitFactor:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        mem[mem[64]] = profitFactor * mem[(32 * _5316 - 1) + _5200 + ceil32(return_data.size) + 32] < 0
                                else:
                                    if maxReportDelay * -1 * t * _3019 / 10^18 / -1 * t * _3019 / 10^18 != maxReportDelay:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _3373 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3373] = 26
                                    mem[_3373 + 32] = 'SafeMath: division by zero'
                                    if 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83 == wantAddress:
                                        if not arg1:
                                            return (0 < maxReportDelay * -1 * t * _3019 / 10^18 / 31556952)
                                        if profitFactor * arg1 / arg1 != profitFactor:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        return (profitFactor * arg1 < maxReportDelay * -1 * t * _3019 / 10^18 / 31556952)
                                    if wantToEthOracleAddress:
                                        mem[mem[64] + 4] = arg1
                                        require ext_code.size(wantToEthOracleAddress)
                                        staticcall wantToEthOracleAddress.0x780022a0 with:
                                                gas gas_remaining wei
                                               args arg1
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _3778 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if not mem[_3778]:
                                            return (0 < maxReportDelay * -1 * t * _3019 / 10^18 / 31556952)
                                        if profitFactor * mem[_3778] / mem[_3778] != profitFactor:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        mem[mem[64]] = profitFactor * mem[_3778] < maxReportDelay * -1 * t * _3019 / 10^18 / 31556952
                                    else:
                                        _3526 = mem[64]
                                        mem[mem[64]] = 2
                                        mem[64] = mem[64] + 96
                                        require 0 < mem[_3526]
                                        mem[_3526 + 32] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                        require 1 < mem[_3526]
                                        mem[_3526 + 64] = wantAddress
                                        mem[_3526 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                        mem[_3526 + 100] = arg1
                                        mem[_3526 + 132] = 64
                                        mem[_3526 + 164] = mem[_3526]
                                        idx = 0
                                        s = _3526 + 196
                                        u = _3526 + 32
                                        while idx < mem[_3526]:
                                            mem[s] = mem[u + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            u = u + 32
                                            continue 
                                        require ext_code.size(0xf491e7b69e4244ad4002bc14e878a34207e38c29)
                                        staticcall 0xf491e7b69e4244ad4002bc14e878a34207e38c29.mem[mem[64] len 4] with:
                                                gas gas_remaining wei
                                               args mem[mem[64] + 4 len _3526 + (32 * mem[_3526]) + -mem[64] + 192]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5199 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _5253 = mem[_5199]
                                        require mem[_5199] <= test266151307()
                                        require _5199 + return_data.size > _5199 + mem[_5199] + 31
                                        _5315 = mem[_5199 + mem[_5199]]
                                        require mem[_5199 + mem[_5199]] <= test266151307()
                                        require (32 * mem[_5199 + mem[_5199]]) + 32 >= 0 and _5199 + ceil32(return_data.size) + (32 * mem[_5199 + mem[_5199]]) + 32 <= test266151307()
                                        mem[64] = _5199 + ceil32(return_data.size) + (32 * mem[_5199 + mem[_5199]]) + 32
                                        mem[_5199 + ceil32(return_data.size)] = _5315
                                        require return_data.size >= _5253 + (32 * _5315) + 32
                                        mem[_5199 + ceil32(return_data.size) + 32 len 32 * _5315] = mem[_5199 + _5253 + 32 len 32 * _5315]
                                        require _5315 - 1 < _5315
                                        if not mem[(32 * _5315 - 1) + _5199 + ceil32(return_data.size) + 32]:
                                            return (0 < maxReportDelay * -1 * t * _3019 / 10^18 / 31556952)
                                        if profitFactor * mem[(32 * _5315 - 1) + _5199 + ceil32(return_data.size) + 32] / mem[(32 * _5315 - 1) + _5199 + ceil32(return_data.size) + 32] != profitFactor:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        mem[mem[64]] = profitFactor * mem[(32 * _5315 - 1) + _5199 + ceil32(return_data.size) + 32] < maxReportDelay * -1 * t * _3019 / 10^18 / 31556952
                            else:
                                if _2908 * mem[_3006] / mem[_3006] != _2908:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _3271 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3271] = 26
                                mem[_3271 + 32] = 'SafeMath: division by zero'
                                if not (_2908 * _3019) - (t * _3019) / 10^18:
                                    _3372 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3372] = 26
                                    mem[_3372 + 32] = 'SafeMath: division by zero'
                                    if 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83 == wantAddress:
                                        if not arg1:
                                            return 0
                                        if profitFactor * arg1 / arg1 != profitFactor:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        return (profitFactor * arg1 < 0)
                                    if wantToEthOracleAddress:
                                        mem[mem[64] + 4] = arg1
                                        require ext_code.size(wantToEthOracleAddress)
                                        staticcall wantToEthOracleAddress.0x780022a0 with:
                                                gas gas_remaining wei
                                               args arg1
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _3777 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if not mem[_3777]:
                                            return 0
                                        if profitFactor * mem[_3777] / mem[_3777] != profitFactor:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        mem[mem[64]] = profitFactor * mem[_3777] < 0
                                    else:
                                        _3523 = mem[64]
                                        mem[mem[64]] = 2
                                        mem[64] = mem[64] + 96
                                        require 0 < mem[_3523]
                                        mem[_3523 + 32] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                        require 1 < mem[_3523]
                                        mem[_3523 + 64] = wantAddress
                                        mem[_3523 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                        mem[_3523 + 100] = arg1
                                        mem[_3523 + 132] = 64
                                        mem[_3523 + 164] = mem[_3523]
                                        idx = 0
                                        s = _3523 + 196
                                        t = _3523 + 32
                                        while idx < mem[_3523]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        require ext_code.size(0xf491e7b69e4244ad4002bc14e878a34207e38c29)
                                        staticcall 0xf491e7b69e4244ad4002bc14e878a34207e38c29.mem[mem[64] len 4] with:
                                                gas gas_remaining wei
                                               args mem[mem[64] + 4 len _3523 + (32 * mem[_3523]) + -mem[64] + 192]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5198 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _5252 = mem[_5198]
                                        require mem[_5198] <= test266151307()
                                        require _5198 + return_data.size > _5198 + mem[_5198] + 31
                                        _5314 = mem[_5198 + mem[_5198]]
                                        require mem[_5198 + mem[_5198]] <= test266151307()
                                        require (32 * mem[_5198 + mem[_5198]]) + 32 >= 0 and _5198 + ceil32(return_data.size) + (32 * mem[_5198 + mem[_5198]]) + 32 <= test266151307()
                                        mem[64] = _5198 + ceil32(return_data.size) + (32 * mem[_5198 + mem[_5198]]) + 32
                                        mem[_5198 + ceil32(return_data.size)] = _5314
                                        require return_data.size >= _5252 + (32 * _5314) + 32
                                        mem[_5198 + ceil32(return_data.size) + 32 len 32 * _5314] = mem[_5198 + _5252 + 32 len 32 * _5314]
                                        require _5314 - 1 < _5314
                                        if not mem[(32 * _5314 - 1) + _5198 + ceil32(return_data.size) + 32]:
                                            return 0
                                        if profitFactor * mem[(32 * _5314 - 1) + _5198 + ceil32(return_data.size) + 32] / mem[(32 * _5314 - 1) + _5198 + ceil32(return_data.size) + 32] != profitFactor:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        mem[mem[64]] = profitFactor * mem[(32 * _5314 - 1) + _5198 + ceil32(return_data.size) + 32] < 0
                                else:
                                    if maxReportDelay * (_2908 * _3019) - (t * _3019) / 10^18 / (_2908 * _3019) - (t * _3019) / 10^18 != maxReportDelay:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _3393 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3393] = 26
                                    mem[_3393 + 32] = 'SafeMath: division by zero'
                                    if 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83 == wantAddress:
                                        if not arg1:
                                            return (0 < maxReportDelay * (_2908 * _3019) - (t * _3019) / 10^18 / 31556952)
                                        if profitFactor * arg1 / arg1 != profitFactor:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        return (profitFactor * arg1 < maxReportDelay * (_2908 * _3019) - (t * _3019) / 10^18 / 31556952)
                                    if wantToEthOracleAddress:
                                        mem[mem[64] + 4] = arg1
                                        require ext_code.size(wantToEthOracleAddress)
                                        staticcall wantToEthOracleAddress.0x780022a0 with:
                                                gas gas_remaining wei
                                               args arg1
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _3845 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if not mem[_3845]:
                                            return (0 < maxReportDelay * (_2908 * _3019) - (t * _3019) / 10^18 / 31556952)
                                        if profitFactor * mem[_3845] / mem[_3845] != profitFactor:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        mem[mem[64]] = profitFactor * mem[_3845] < maxReportDelay * (_2908 * _3019) - (t * _3019) / 10^18 / 31556952
                                    else:
                                        _3592 = mem[64]
                                        mem[mem[64]] = 2
                                        mem[64] = mem[64] + 96
                                        require 0 < mem[_3592]
                                        mem[_3592 + 32] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                        require 1 < mem[_3592]
                                        mem[_3592 + 64] = wantAddress
                                        mem[_3592 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                        mem[_3592 + 100] = arg1
                                        mem[_3592 + 132] = 64
                                        mem[_3592 + 164] = mem[_3592]
                                        idx = 0
                                        s = _3592 + 196
                                        u = _3592 + 32
                                        while idx < mem[_3592]:
                                            mem[s] = mem[u + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            u = u + 32
                                            continue 
                                        require ext_code.size(0xf491e7b69e4244ad4002bc14e878a34207e38c29)
                                        staticcall 0xf491e7b69e4244ad4002bc14e878a34207e38c29.mem[mem[64] len 4] with:
                                                gas gas_remaining wei
                                               args mem[mem[64] + 4 len _3592 + (32 * mem[_3592]) + -mem[64] + 192]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5197 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _5251 = mem[_5197]
                                        require mem[_5197] <= test266151307()
                                        require _5197 + return_data.size > _5197 + mem[_5197] + 31
                                        _5313 = mem[_5197 + mem[_5197]]
                                        require mem[_5197 + mem[_5197]] <= test266151307()
                                        require (32 * mem[_5197 + mem[_5197]]) + 32 >= 0 and _5197 + ceil32(return_data.size) + (32 * mem[_5197 + mem[_5197]]) + 32 <= test266151307()
                                        mem[64] = _5197 + ceil32(return_data.size) + (32 * mem[_5197 + mem[_5197]]) + 32
                                        mem[_5197 + ceil32(return_data.size)] = _5313
                                        require return_data.size >= _5251 + (32 * _5313) + 32
                                        mem[_5197 + ceil32(return_data.size) + 32 len 32 * _5313] = mem[_5197 + _5251 + 32 len 32 * _5313]
                                        require _5313 - 1 < _5313
                                        if not mem[(32 * _5313 - 1) + _5197 + ceil32(return_data.size) + 32]:
                                            return (0 < maxReportDelay * (_2908 * _3019) - (t * _3019) / 10^18 / 31556952)
                                        if profitFactor * mem[(32 * _5313 - 1) + _5197 + ceil32(return_data.size) + 32] / mem[(32 * _5313 - 1) + _5197 + ceil32(return_data.size) + 32] != profitFactor:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        mem[mem[64]] = profitFactor * mem[(32 * _5313 - 1) + _5197 + ceil32(return_data.size) + 32] < maxReportDelay * (_2908 * _3019) - (t * _3019) / 10^18 / 31556952
                    else:
                        if arg1 * profitFactor / profitFactor != arg1:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg1 * profitFactor < mem[_894]:
                            return 0
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(wantAddress)
                        staticcall wantAddress.balanceOf(address arg1) with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _981 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _993 = mem[_981]
                        idx = 0
                        s = 0
                        t = -1
                        while idx < lenders.length:
                            mem[0] = 13
                            require ext_code.size(lenders[idx])
                            staticcall lenders[idx].hasAssets() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _1472 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_1472] == bool(mem[_1472])
                            if not mem[_1472]:
                                idx = idx + 1
                                s = s
                                t = t
                                continue 
                            require idx < lenders.length
                            mem[0] = 13
                            require ext_code.size(lenders[idx])
                            staticcall lenders[idx].apr() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _1609 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _1633 = mem[_1609]
                            if mem[_1609] >= t:
                                idx = idx + 1
                                s = s
                                t = t
                                continue 
                            require idx < lenders.length
                            mem[0] = 13
                            require ext_code.size(lenders[idx])
                            staticcall lenders[idx].nav() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _1673 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            idx = idx + 1
                            s = mem[_1673]
                            t = _1633
                            continue 
                        if _993 + s < s:
                            revert with 0, 'SafeMath: addition overflow'
                        idx = 0
                        u = 0
                        while idx < lenders.length:
                            mem[0] = 13
                            mem[mem[64] + 4] = _993
                            require ext_code.size(lenders[idx])
                            staticcall lenders[idx].aprAfterDeposit(uint256 arg1) with:
                                    gas gas_remaining wei
                                   args _993
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2866 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if mem[_2866] <= u:
                                idx = idx + 1
                                u = u
                                continue 
                            idx = idx + 1
                            u = mem[_2866]
                            continue 
                        require 0 < lenders.length
                        mem[0] = 13
                        mem[mem[64] + 4] = _993 + s
                        require ext_code.size(lenders)
                        staticcall lenders.aprAfterDeposit(uint256 arg1) with:
                                gas gas_remaining wei
                               args (_993 + s)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2865 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _2906 = mem[_2865]
                        if mem[_2865] <= t:
                            return 0
                        require 0 < lenders.length
                        mem[0] = 13
                        require ext_code.size(lenders)
                        staticcall lenders.nav() with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3004 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _3018 = mem[_3004]
                        if not mem[_3004]:
                            _3194 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3194] = 26
                            mem[_3194 + 32] = 'SafeMath: division by zero'
                            _3330 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3330] = 26
                            mem[_3330 + 32] = 'SafeMath: division by zero'
                            if 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83 == wantAddress:
                                if not arg1:
                                    return 0
                                if profitFactor * arg1 / arg1 != profitFactor:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                return (profitFactor * arg1 < 0)
                            if wantToEthOracleAddress:
                                mem[mem[64] + 4] = arg1
                                require ext_code.size(wantToEthOracleAddress)
                                staticcall wantToEthOracleAddress.0x780022a0 with:
                                        gas gas_remaining wei
                                       args arg1
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _3653 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if not mem[_3653]:
                                    return 0
                                if profitFactor * mem[_3653] / mem[_3653] != profitFactor:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[mem[64]] = profitFactor * mem[_3653] < 0
                            else:
                                _3428 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                require 0 < mem[_3428]
                                mem[_3428 + 32] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                require 1 < mem[_3428]
                                mem[_3428 + 64] = wantAddress
                                mem[_3428 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[_3428 + 100] = arg1
                                mem[_3428 + 132] = 64
                                mem[_3428 + 164] = mem[_3428]
                                idx = 0
                                s = _3428 + 196
                                t = _3428 + 32
                                while idx < mem[_3428]:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(0xf491e7b69e4244ad4002bc14e878a34207e38c29)
                                staticcall 0xf491e7b69e4244ad4002bc14e878a34207e38c29.mem[mem[64] len 4] with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len _3428 + (32 * mem[_3428]) + -mem[64] + 192]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _5196 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _5250 = mem[_5196]
                                require mem[_5196] <= test266151307()
                                require _5196 + return_data.size > _5196 + mem[_5196] + 31
                                _5312 = mem[_5196 + mem[_5196]]
                                require mem[_5196 + mem[_5196]] <= test266151307()
                                require (32 * mem[_5196 + mem[_5196]]) + 32 >= 0 and _5196 + ceil32(return_data.size) + (32 * mem[_5196 + mem[_5196]]) + 32 <= test266151307()
                                mem[64] = _5196 + ceil32(return_data.size) + (32 * mem[_5196 + mem[_5196]]) + 32
                                mem[_5196 + ceil32(return_data.size)] = _5312
                                require return_data.size >= _5250 + (32 * _5312) + 32
                                mem[_5196 + ceil32(return_data.size) + 32 len 32 * _5312] = mem[_5196 + _5250 + 32 len 32 * _5312]
                                require _5312 - 1 < _5312
                                if not mem[(32 * _5312 - 1) + _5196 + ceil32(return_data.size) + 32]:
                                    return 0
                                if profitFactor * mem[(32 * _5312 - 1) + _5196 + ceil32(return_data.size) + 32] / mem[(32 * _5312 - 1) + _5196 + ceil32(return_data.size) + 32] != profitFactor:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[mem[64]] = profitFactor * mem[(32 * _5312 - 1) + _5196 + ceil32(return_data.size) + 32] < 0
                        else:
                            if t * mem[_3004] / mem[_3004] != t:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not mem[_3004]:
                                _3236 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3236] = 26
                                mem[_3236 + 32] = 'SafeMath: division by zero'
                                if not -1 * t * _3018 / 10^18:
                                    _3348 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3348] = 26
                                    mem[_3348 + 32] = 'SafeMath: division by zero'
                                    if 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83 == wantAddress:
                                        if not arg1:
                                            return 0
                                        if profitFactor * arg1 / arg1 != profitFactor:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        return (profitFactor * arg1 < 0)
                                    if wantToEthOracleAddress:
                                        mem[mem[64] + 4] = arg1
                                        require ext_code.size(wantToEthOracleAddress)
                                        staticcall wantToEthOracleAddress.0x780022a0 with:
                                                gas gas_remaining wei
                                               args arg1
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _3712 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if not mem[_3712]:
                                            return 0
                                        if profitFactor * mem[_3712] / mem[_3712] != profitFactor:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        mem[mem[64]] = profitFactor * mem[_3712] < 0
                                    else:
                                        _3459 = mem[64]
                                        mem[mem[64]] = 2
                                        mem[64] = mem[64] + 96
                                        require 0 < mem[_3459]
                                        mem[_3459 + 32] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                        require 1 < mem[_3459]
                                        mem[_3459 + 64] = wantAddress
                                        mem[_3459 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                        mem[_3459 + 100] = arg1
                                        mem[_3459 + 132] = 64
                                        mem[_3459 + 164] = mem[_3459]
                                        idx = 0
                                        s = _3459 + 196
                                        t = _3459 + 32
                                        while idx < mem[_3459]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        require ext_code.size(0xf491e7b69e4244ad4002bc14e878a34207e38c29)
                                        staticcall 0xf491e7b69e4244ad4002bc14e878a34207e38c29.mem[mem[64] len 4] with:
                                                gas gas_remaining wei
                                               args mem[mem[64] + 4 len _3459 + (32 * mem[_3459]) + -mem[64] + 192]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5195 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _5249 = mem[_5195]
                                        require mem[_5195] <= test266151307()
                                        require _5195 + return_data.size > _5195 + mem[_5195] + 31
                                        _5311 = mem[_5195 + mem[_5195]]
                                        require mem[_5195 + mem[_5195]] <= test266151307()
                                        require (32 * mem[_5195 + mem[_5195]]) + 32 >= 0 and _5195 + ceil32(return_data.size) + (32 * mem[_5195 + mem[_5195]]) + 32 <= test266151307()
                                        mem[64] = _5195 + ceil32(return_data.size) + (32 * mem[_5195 + mem[_5195]]) + 32
                                        mem[_5195 + ceil32(return_data.size)] = _5311
                                        require return_data.size >= _5249 + (32 * _5311) + 32
                                        mem[_5195 + ceil32(return_data.size) + 32 len 32 * _5311] = mem[_5195 + _5249 + 32 len 32 * _5311]
                                        require _5311 - 1 < _5311
                                        if not mem[(32 * _5311 - 1) + _5195 + ceil32(return_data.size) + 32]:
                                            return 0
                                        if profitFactor * mem[(32 * _5311 - 1) + _5195 + ceil32(return_data.size) + 32] / mem[(32 * _5311 - 1) + _5195 + ceil32(return_data.size) + 32] != profitFactor:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        mem[mem[64]] = profitFactor * mem[(32 * _5311 - 1) + _5195 + ceil32(return_data.size) + 32] < 0
                                else:
                                    if maxReportDelay * -1 * t * _3018 / 10^18 / -1 * t * _3018 / 10^18 != maxReportDelay:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _3370 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3370] = 26
                                    mem[_3370 + 32] = 'SafeMath: division by zero'
                                    if 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83 == wantAddress:
                                        if not arg1:
                                            return (0 < maxReportDelay * -1 * t * _3018 / 10^18 / 31556952)
                                        if profitFactor * arg1 / arg1 != profitFactor:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        return (profitFactor * arg1 < maxReportDelay * -1 * t * _3018 / 10^18 / 31556952)
                                    if wantToEthOracleAddress:
                                        mem[mem[64] + 4] = arg1
                                        require ext_code.size(wantToEthOracleAddress)
                                        staticcall wantToEthOracleAddress.0x780022a0 with:
                                                gas gas_remaining wei
                                               args arg1
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _3771 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if not mem[_3771]:
                                            return (0 < maxReportDelay * -1 * t * _3018 / 10^18 / 31556952)
                                        if profitFactor * mem[_3771] / mem[_3771] != profitFactor:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        mem[mem[64]] = profitFactor * mem[_3771] < maxReportDelay * -1 * t * _3018 / 10^18 / 31556952
                                    else:
                                        _3517 = mem[64]
                                        mem[mem[64]] = 2
                                        mem[64] = mem[64] + 96
                                        require 0 < mem[_3517]
                                        mem[_3517 + 32] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                        require 1 < mem[_3517]
                                        mem[_3517 + 64] = wantAddress
                                        mem[_3517 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                        mem[_3517 + 100] = arg1
                                        mem[_3517 + 132] = 64
                                        mem[_3517 + 164] = mem[_3517]
                                        idx = 0
                                        s = _3517 + 196
                                        u = _3517 + 32
                                        while idx < mem[_3517]:
                                            mem[s] = mem[u + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            u = u + 32
                                            continue 
                                        require ext_code.size(0xf491e7b69e4244ad4002bc14e878a34207e38c29)
                                        staticcall 0xf491e7b69e4244ad4002bc14e878a34207e38c29.mem[mem[64] len 4] with:
                                                gas gas_remaining wei
                                               args mem[mem[64] + 4 len _3517 + (32 * mem[_3517]) + -mem[64] + 192]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5194 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _5248 = mem[_5194]
                                        require mem[_5194] <= test266151307()
                                        require _5194 + return_data.size > _5194 + mem[_5194] + 31
                                        _5310 = mem[_5194 + mem[_5194]]
                                        require mem[_5194 + mem[_5194]] <= test266151307()
                                        require (32 * mem[_5194 + mem[_5194]]) + 32 >= 0 and _5194 + ceil32(return_data.size) + (32 * mem[_5194 + mem[_5194]]) + 32 <= test266151307()
                                        mem[64] = _5194 + ceil32(return_data.size) + (32 * mem[_5194 + mem[_5194]]) + 32
                                        mem[_5194 + ceil32(return_data.size)] = _5310
                                        require return_data.size >= _5248 + (32 * _5310) + 32
                                        mem[_5194 + ceil32(return_data.size) + 32 len 32 * _5310] = mem[_5194 + _5248 + 32 len 32 * _5310]
                                        require _5310 - 1 < _5310
                                        if not mem[(32 * _5310 - 1) + _5194 + ceil32(return_data.size) + 32]:
                                            return (0 < maxReportDelay * -1 * t * _3018 / 10^18 / 31556952)
                                        if profitFactor * mem[(32 * _5310 - 1) + _5194 + ceil32(return_data.size) + 32] / mem[(32 * _5310 - 1) + _5194 + ceil32(return_data.size) + 32] != profitFactor:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        mem[mem[64]] = profitFactor * mem[(32 * _5310 - 1) + _5194 + ceil32(return_data.size) + 32] < maxReportDelay * -1 * t * _3018 / 10^18 / 31556952
                            else:
                                if _2906 * mem[_3004] / mem[_3004] != _2906:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _3269 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3269] = 26
                                mem[_3269 + 32] = 'SafeMath: division by zero'
                                if not (_2906 * _3018) - (t * _3018) / 10^18:
                                    _3369 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3369] = 26
                                    mem[_3369 + 32] = 'SafeMath: division by zero'
                                    if 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83 == wantAddress:
                                        if not arg1:
                                            return 0
                                        if profitFactor * arg1 / arg1 != profitFactor:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        return (profitFactor * arg1 < 0)
                                    if wantToEthOracleAddress:
                                        mem[mem[64] + 4] = arg1
                                        require ext_code.size(wantToEthOracleAddress)
                                        staticcall wantToEthOracleAddress.0x780022a0 with:
                                                gas gas_remaining wei
                                               args arg1
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _3770 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if not mem[_3770]:
                                            return 0
                                        if profitFactor * mem[_3770] / mem[_3770] != profitFactor:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        mem[mem[64]] = profitFactor * mem[_3770] < 0
                                    else:
                                        _3514 = mem[64]
                                        mem[mem[64]] = 2
                                        mem[64] = mem[64] + 96
                                        require 0 < mem[_3514]
                                        mem[_3514 + 32] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                        require 1 < mem[_3514]
                                        mem[_3514 + 64] = wantAddress
                                        mem[_3514 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                        mem[_3514 + 100] = arg1
                                        mem[_3514 + 132] = 64
                                        mem[_3514 + 164] = mem[_3514]
                                        idx = 0
                                        s = _3514 + 196
                                        t = _3514 + 32
                                        while idx < mem[_3514]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        require ext_code.size(0xf491e7b69e4244ad4002bc14e878a34207e38c29)
                                        staticcall 0xf491e7b69e4244ad4002bc14e878a34207e38c29.mem[mem[64] len 4] with:
                                                gas gas_remaining wei
                                               args mem[mem[64] + 4 len _3514 + (32 * mem[_3514]) + -mem[64] + 192]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5193 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _5247 = mem[_5193]
                                        require mem[_5193] <= test266151307()
                                        require _5193 + return_data.size > _5193 + mem[_5193] + 31
                                        _5309 = mem[_5193 + mem[_5193]]
                                        require mem[_5193 + mem[_5193]] <= test266151307()
                                        require (32 * mem[_5193 + mem[_5193]]) + 32 >= 0 and _5193 + ceil32(return_data.size) + (32 * mem[_5193 + mem[_5193]]) + 32 <= test266151307()
                                        mem[64] = _5193 + ceil32(return_data.size) + (32 * mem[_5193 + mem[_5193]]) + 32
                                        mem[_5193 + ceil32(return_data.size)] = _5309
                                        require return_data.size >= _5247 + (32 * _5309) + 32
                                        mem[_5193 + ceil32(return_data.size) + 32 len 32 * _5309] = mem[_5193 + _5247 + 32 len 32 * _5309]
                                        require _5309 - 1 < _5309
                                        if not mem[(32 * _5309 - 1) + _5193 + ceil32(return_data.size) + 32]:
                                            return 0
                                        if profitFactor * mem[(32 * _5309 - 1) + _5193 + ceil32(return_data.size) + 32] / mem[(32 * _5309 - 1) + _5193 + ceil32(return_data.size) + 32] != profitFactor:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        mem[mem[64]] = profitFactor * mem[(32 * _5309 - 1) + _5193 + ceil32(return_data.size) + 32] < 0
                                else:
                                    if maxReportDelay * (_2906 * _3018) - (t * _3018) / 10^18 / (_2906 * _3018) - (t * _3018) / 10^18 != maxReportDelay:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _3391 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3391] = 26
                                    mem[_3391 + 32] = 'SafeMath: division by zero'
                                    if 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83 == wantAddress:
                                        if not arg1:
                                            return (0 < maxReportDelay * (_2906 * _3018) - (t * _3018) / 10^18 / 31556952)
                                        if profitFactor * arg1 / arg1 != profitFactor:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        return (profitFactor * arg1 < maxReportDelay * (_2906 * _3018) - (t * _3018) / 10^18 / 31556952)
                                    if wantToEthOracleAddress:
                                        mem[mem[64] + 4] = arg1
                                        require ext_code.size(wantToEthOracleAddress)
                                        staticcall wantToEthOracleAddress.0x780022a0 with:
                                                gas gas_remaining wei
                                               args arg1
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _3836 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if not mem[_3836]:
                                            return (0 < maxReportDelay * (_2906 * _3018) - (t * _3018) / 10^18 / 31556952)
                                        if profitFactor * mem[_3836] / mem[_3836] != profitFactor:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        mem[mem[64]] = profitFactor * mem[_3836] < maxReportDelay * (_2906 * _3018) - (t * _3018) / 10^18 / 31556952
                                    else:
                                        _3584 = mem[64]
                                        mem[mem[64]] = 2
                                        mem[64] = mem[64] + 96
                                        require 0 < mem[_3584]
                                        mem[_3584 + 32] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                        require 1 < mem[_3584]
                                        mem[_3584 + 64] = wantAddress
                                        mem[_3584 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                        mem[_3584 + 100] = arg1
                                        mem[_3584 + 132] = 64
                                        mem[_3584 + 164] = mem[_3584]
                                        idx = 0
                                        s = _3584 + 196
                                        u = _3584 + 32
                                        while idx < mem[_3584]:
                                            mem[s] = mem[u + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            u = u + 32
                                            continue 
                                        require ext_code.size(0xf491e7b69e4244ad4002bc14e878a34207e38c29)
                                        staticcall 0xf491e7b69e4244ad4002bc14e878a34207e38c29.mem[mem[64] len 4] with:
                                                gas gas_remaining wei
                                               args mem[mem[64] + 4 len _3584 + (32 * mem[_3584]) + -mem[64] + 192]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5192 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _5246 = mem[_5192]
                                        require mem[_5192] <= test266151307()
                                        require _5192 + return_data.size > _5192 + mem[_5192] + 31
                                        _5308 = mem[_5192 + mem[_5192]]
                                        require mem[_5192 + mem[_5192]] <= test266151307()
                                        require (32 * mem[_5192 + mem[_5192]]) + 32 >= 0 and _5192 + ceil32(return_data.size) + (32 * mem[_5192 + mem[_5192]]) + 32 <= test266151307()
                                        mem[64] = _5192 + ceil32(return_data.size) + (32 * mem[_5192 + mem[_5192]]) + 32
                                        mem[_5192 + ceil32(return_data.size)] = _5308
                                        require return_data.size >= _5246 + (32 * _5308) + 32
                                        mem[_5192 + ceil32(return_data.size) + 32 len 32 * _5308] = mem[_5192 + _5246 + 32 len 32 * _5308]
                                        require _5308 - 1 < _5308
                                        if not mem[(32 * _5308 - 1) + _5192 + ceil32(return_data.size) + 32]:
                                            return (0 < maxReportDelay * (_2906 * _3018) - (t * _3018) / 10^18 / 31556952)
                                        if profitFactor * mem[(32 * _5308 - 1) + _5192 + ceil32(return_data.size) + 32] / mem[(32 * _5308 - 1) + _5192 + ceil32(return_data.size) + 32] != profitFactor:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        mem[mem[64]] = profitFactor * mem[(32 * _5308 - 1) + _5192 + ceil32(return_data.size) + 32] < maxReportDelay * (_2906 * _3018) - (t * _3018) / 10^18 / 31556952
                else:
                    _877 = mem[ceil32(return_data.size) + 576]
                    _886 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_886] = 30
                    mem[_886 + 32] = 'SafeMath: subtraction overflow'
                    if _877 > _819 + (_806 * lenders.length):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    require ext_code.size(vaultAddress)
                    staticcall vaultAddress.creditAvailable() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _925 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if _819 + (_806 * lenders.length) - _877 + mem[_925] < mem[_925]:
                        revert with 0, 'SafeMath: addition overflow'
                    if not profitFactor:
                        if 0 < _819 + (_806 * lenders.length) - _877 + mem[_925]:
                            return 0
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(wantAddress)
                        staticcall wantAddress.balanceOf(address arg1) with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1018 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _1040 = mem[_1018]
                        idx = 0
                        s = 0
                        t = -1
                        while idx < lenders.length:
                            mem[0] = 13
                            require ext_code.size(lenders[idx])
                            staticcall lenders[idx].hasAssets() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _1475 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_1475] == bool(mem[_1475])
                            if not mem[_1475]:
                                idx = idx + 1
                                s = s
                                t = t
                                continue 
                            require idx < lenders.length
                            mem[0] = 13
                            require ext_code.size(lenders[idx])
                            staticcall lenders[idx].apr() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _1612 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _1636 = mem[_1612]
                            if mem[_1612] >= t:
                                idx = idx + 1
                                s = s
                                t = t
                                continue 
                            require idx < lenders.length
                            mem[0] = 13
                            require ext_code.size(lenders[idx])
                            staticcall lenders[idx].nav() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _1676 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            idx = idx + 1
                            s = mem[_1676]
                            t = _1636
                            continue 
                        if _1040 + s < s:
                            revert with 0, 'SafeMath: addition overflow'
                        idx = 0
                        u = 0
                        while idx < lenders.length:
                            mem[0] = 13
                            mem[mem[64] + 4] = _1040
                            require ext_code.size(lenders[idx])
                            staticcall lenders[idx].aprAfterDeposit(uint256 arg1) with:
                                    gas gas_remaining wei
                                   args _1040
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2872 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if mem[_2872] <= u:
                                idx = idx + 1
                                u = u
                                continue 
                            idx = idx + 1
                            u = mem[_2872]
                            continue 
                        require 0 < lenders.length
                        mem[0] = 13
                        mem[mem[64] + 4] = _1040 + s
                        require ext_code.size(lenders)
                        staticcall lenders.aprAfterDeposit(uint256 arg1) with:
                                gas gas_remaining wei
                               args (_1040 + s)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2871 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _2912 = mem[_2871]
                        if mem[_2871] <= t:
                            return 0
                        require 0 < lenders.length
                        mem[0] = 13
                        require ext_code.size(lenders)
                        staticcall lenders.nav() with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3010 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _3021 = mem[_3010]
                        if not mem[_3010]:
                            _3200 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3200] = 26
                            mem[_3200 + 32] = 'SafeMath: division by zero'
                            _3336 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3336] = 26
                            mem[_3336 + 32] = 'SafeMath: division by zero'
                            if 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83 == wantAddress:
                                if not arg1:
                                    return 0
                                if profitFactor * arg1 / arg1 != profitFactor:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                return (profitFactor * arg1 < 0)
                            if wantToEthOracleAddress:
                                mem[mem[64] + 4] = arg1
                                require ext_code.size(wantToEthOracleAddress)
                                staticcall wantToEthOracleAddress.0x780022a0 with:
                                        gas gas_remaining wei
                                       args arg1
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _3674 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if not mem[_3674]:
                                    return 0
                                if profitFactor * mem[_3674] / mem[_3674] != profitFactor:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[mem[64]] = profitFactor * mem[_3674] < 0
                            else:
                                _3437 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                require 0 < mem[_3437]
                                mem[_3437 + 32] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                require 1 < mem[_3437]
                                mem[_3437 + 64] = wantAddress
                                mem[_3437 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[_3437 + 100] = arg1
                                mem[_3437 + 132] = 64
                                mem[_3437 + 164] = mem[_3437]
                                idx = 0
                                s = _3437 + 196
                                t = _3437 + 32
                                while idx < mem[_3437]:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(0xf491e7b69e4244ad4002bc14e878a34207e38c29)
                                staticcall 0xf491e7b69e4244ad4002bc14e878a34207e38c29.mem[mem[64] len 4] with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len _3437 + (32 * mem[_3437]) + -mem[64] + 192]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _5211 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _5265 = mem[_5211]
                                require mem[_5211] <= test266151307()
                                require _5211 + return_data.size > _5211 + mem[_5211] + 31
                                _5327 = mem[_5211 + mem[_5211]]
                                require mem[_5211 + mem[_5211]] <= test266151307()
                                require (32 * mem[_5211 + mem[_5211]]) + 32 >= 0 and _5211 + ceil32(return_data.size) + (32 * mem[_5211 + mem[_5211]]) + 32 <= test266151307()
                                mem[64] = _5211 + ceil32(return_data.size) + (32 * mem[_5211 + mem[_5211]]) + 32
                                mem[_5211 + ceil32(return_data.size)] = _5327
                                require return_data.size >= _5265 + (32 * _5327) + 32
                                mem[_5211 + ceil32(return_data.size) + 32 len 32 * _5327] = mem[_5211 + _5265 + 32 len 32 * _5327]
                                require _5327 - 1 < _5327
                                if not mem[(32 * _5327 - 1) + _5211 + ceil32(return_data.size) + 32]:
                                    return 0
                                if profitFactor * mem[(32 * _5327 - 1) + _5211 + ceil32(return_data.size) + 32] / mem[(32 * _5327 - 1) + _5211 + ceil32(return_data.size) + 32] != profitFactor:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[mem[64]] = profitFactor * mem[(32 * _5327 - 1) + _5211 + ceil32(return_data.size) + 32] < 0
                        else:
                            if t * mem[_3010] / mem[_3010] != t:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not mem[_3010]:
                                _3239 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3239] = 26
                                mem[_3239 + 32] = 'SafeMath: division by zero'
                                if not -1 * t * _3021 / 10^18:
                                    _3354 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3354] = 26
                                    mem[_3354 + 32] = 'SafeMath: division by zero'
                                    if 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83 == wantAddress:
                                        if not arg1:
                                            return 0
                                        if profitFactor * arg1 / arg1 != profitFactor:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        return (profitFactor * arg1 < 0)
                                    if wantToEthOracleAddress:
                                        mem[mem[64] + 4] = arg1
                                        require ext_code.size(wantToEthOracleAddress)
                                        staticcall wantToEthOracleAddress.0x780022a0 with:
                                                gas gas_remaining wei
                                               args arg1
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _3733 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if not mem[_3733]:
                                            return 0
                                        if profitFactor * mem[_3733] / mem[_3733] != profitFactor:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        mem[mem[64]] = profitFactor * mem[_3733] < 0
                                    else:
                                        _3471 = mem[64]
                                        mem[mem[64]] = 2
                                        mem[64] = mem[64] + 96
                                        require 0 < mem[_3471]
                                        mem[_3471 + 32] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                        require 1 < mem[_3471]
                                        mem[_3471 + 64] = wantAddress
                                        mem[_3471 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                        mem[_3471 + 100] = arg1
                                        mem[_3471 + 132] = 64
                                        mem[_3471 + 164] = mem[_3471]
                                        idx = 0
                                        s = _3471 + 196
                                        t = _3471 + 32
                                        while idx < mem[_3471]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        require ext_code.size(0xf491e7b69e4244ad4002bc14e878a34207e38c29)
                                        staticcall 0xf491e7b69e4244ad4002bc14e878a34207e38c29.mem[mem[64] len 4] with:
                                                gas gas_remaining wei
                                               args mem[mem[64] + 4 len _3471 + (32 * mem[_3471]) + -mem[64] + 192]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5210 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _5264 = mem[_5210]
                                        require mem[_5210] <= test266151307()
                                        require _5210 + return_data.size > _5210 + mem[_5210] + 31
                                        _5326 = mem[_5210 + mem[_5210]]
                                        require mem[_5210 + mem[_5210]] <= test266151307()
                                        require (32 * mem[_5210 + mem[_5210]]) + 32 >= 0 and _5210 + ceil32(return_data.size) + (32 * mem[_5210 + mem[_5210]]) + 32 <= test266151307()
                                        mem[64] = _5210 + ceil32(return_data.size) + (32 * mem[_5210 + mem[_5210]]) + 32
                                        mem[_5210 + ceil32(return_data.size)] = _5326
                                        require return_data.size >= _5264 + (32 * _5326) + 32
                                        mem[_5210 + ceil32(return_data.size) + 32 len 32 * _5326] = mem[_5210 + _5264 + 32 len 32 * _5326]
                                        require _5326 - 1 < _5326
                                        if not mem[(32 * _5326 - 1) + _5210 + ceil32(return_data.size) + 32]:
                                            return 0
                                        if profitFactor * mem[(32 * _5326 - 1) + _5210 + ceil32(return_data.size) + 32] / mem[(32 * _5326 - 1) + _5210 + ceil32(return_data.size) + 32] != profitFactor:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        mem[mem[64]] = profitFactor * mem[(32 * _5326 - 1) + _5210 + ceil32(return_data.size) + 32] < 0
                                else:
                                    if maxReportDelay * -1 * t * _3021 / 10^18 / -1 * t * _3021 / 10^18 != maxReportDelay:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _3379 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3379] = 26
                                    mem[_3379 + 32] = 'SafeMath: division by zero'
                                    if 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83 == wantAddress:
                                        if not arg1:
                                            return (0 < maxReportDelay * -1 * t * _3021 / 10^18 / 31556952)
                                        if profitFactor * arg1 / arg1 != profitFactor:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        return (profitFactor * arg1 < maxReportDelay * -1 * t * _3021 / 10^18 / 31556952)
                                    if wantToEthOracleAddress:
                                        mem[mem[64] + 4] = arg1
                                        require ext_code.size(wantToEthOracleAddress)
                                        staticcall wantToEthOracleAddress.0x780022a0 with:
                                                gas gas_remaining wei
                                               args arg1
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _3792 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if not mem[_3792]:
                                            return (0 < maxReportDelay * -1 * t * _3021 / 10^18 / 31556952)
                                        if profitFactor * mem[_3792] / mem[_3792] != profitFactor:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        mem[mem[64]] = profitFactor * mem[_3792] < maxReportDelay * -1 * t * _3021 / 10^18 / 31556952
                                    else:
                                        _3544 = mem[64]
                                        mem[mem[64]] = 2
                                        mem[64] = mem[64] + 96
                                        require 0 < mem[_3544]
                                        mem[_3544 + 32] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                        require 1 < mem[_3544]
                                        mem[_3544 + 64] = wantAddress
                                        mem[_3544 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                        mem[_3544 + 100] = arg1
                                        mem[_3544 + 132] = 64
                                        mem[_3544 + 164] = mem[_3544]
                                        idx = 0
                                        s = _3544 + 196
                                        u = _3544 + 32
                                        while idx < mem[_3544]:
                                            mem[s] = mem[u + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            u = u + 32
                                            continue 
                                        require ext_code.size(0xf491e7b69e4244ad4002bc14e878a34207e38c29)
                                        staticcall 0xf491e7b69e4244ad4002bc14e878a34207e38c29.mem[mem[64] len 4] with:
                                                gas gas_remaining wei
                                               args mem[mem[64] + 4 len _3544 + (32 * mem[_3544]) + -mem[64] + 192]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5209 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _5263 = mem[_5209]
                                        require mem[_5209] <= test266151307()
                                        require _5209 + return_data.size > _5209 + mem[_5209] + 31
                                        _5325 = mem[_5209 + mem[_5209]]
                                        require mem[_5209 + mem[_5209]] <= test266151307()
                                        require (32 * mem[_5209 + mem[_5209]]) + 32 >= 0 and _5209 + ceil32(return_data.size) + (32 * mem[_5209 + mem[_5209]]) + 32 <= test266151307()
                                        mem[64] = _5209 + ceil32(return_data.size) + (32 * mem[_5209 + mem[_5209]]) + 32
                                        mem[_5209 + ceil32(return_data.size)] = _5325
                                        require return_data.size >= _5263 + (32 * _5325) + 32
                                        mem[_5209 + ceil32(return_data.size) + 32 len 32 * _5325] = mem[_5209 + _5263 + 32 len 32 * _5325]
                                        require _5325 - 1 < _5325
                                        if not mem[(32 * _5325 - 1) + _5209 + ceil32(return_data.size) + 32]:
                                            return (0 < maxReportDelay * -1 * t * _3021 / 10^18 / 31556952)
                                        if profitFactor * mem[(32 * _5325 - 1) + _5209 + ceil32(return_data.size) + 32] / mem[(32 * _5325 - 1) + _5209 + ceil32(return_data.size) + 32] != profitFactor:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        mem[mem[64]] = profitFactor * mem[(32 * _5325 - 1) + _5209 + ceil32(return_data.size) + 32] < maxReportDelay * -1 * t * _3021 / 10^18 / 31556952
                            else:
                                if _2912 * mem[_3010] / mem[_3010] != _2912:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _3275 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3275] = 26
                                mem[_3275 + 32] = 'SafeMath: division by zero'
                                if not (_2912 * _3021) - (t * _3021) / 10^18:
                                    _3378 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3378] = 26
                                    mem[_3378 + 32] = 'SafeMath: division by zero'
                                    if 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83 == wantAddress:
                                        if not arg1:
                                            return 0
                                        if profitFactor * arg1 / arg1 != profitFactor:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        return (profitFactor * arg1 < 0)
                                    if wantToEthOracleAddress:
                                        mem[mem[64] + 4] = arg1
                                        require ext_code.size(wantToEthOracleAddress)
                                        staticcall wantToEthOracleAddress.0x780022a0 with:
                                                gas gas_remaining wei
                                               args arg1
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _3791 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if not mem[_3791]:
                                            return 0
                                        if profitFactor * mem[_3791] / mem[_3791] != profitFactor:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        mem[mem[64]] = profitFactor * mem[_3791] < 0
                                    else:
                                        _3541 = mem[64]
                                        mem[mem[64]] = 2
                                        mem[64] = mem[64] + 96
                                        require 0 < mem[_3541]
                                        mem[_3541 + 32] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                        require 1 < mem[_3541]
                                        mem[_3541 + 64] = wantAddress
                                        mem[_3541 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                        mem[_3541 + 100] = arg1
                                        mem[_3541 + 132] = 64
                                        mem[_3541 + 164] = mem[_3541]
                                        idx = 0
                                        s = _3541 + 196
                                        t = _3541 + 32
                                        while idx < mem[_3541]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        require ext_code.size(0xf491e7b69e4244ad4002bc14e878a34207e38c29)
                                        staticcall 0xf491e7b69e4244ad4002bc14e878a34207e38c29.mem[mem[64] len 4] with:
                                                gas gas_remaining wei
                                               args mem[mem[64] + 4 len _3541 + (32 * mem[_3541]) + -mem[64] + 192]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5208 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _5262 = mem[_5208]
                                        require mem[_5208] <= test266151307()
                                        require _5208 + return_data.size > _5208 + mem[_5208] + 31
                                        _5324 = mem[_5208 + mem[_5208]]
                                        require mem[_5208 + mem[_5208]] <= test266151307()
                                        require (32 * mem[_5208 + mem[_5208]]) + 32 >= 0 and _5208 + ceil32(return_data.size) + (32 * mem[_5208 + mem[_5208]]) + 32 <= test266151307()
                                        mem[64] = _5208 + ceil32(return_data.size) + (32 * mem[_5208 + mem[_5208]]) + 32
                                        mem[_5208 + ceil32(return_data.size)] = _5324
                                        require return_data.size >= _5262 + (32 * _5324) + 32
                                        mem[_5208 + ceil32(return_data.size) + 32 len 32 * _5324] = mem[_5208 + _5262 + 32 len 32 * _5324]
                                        require _5324 - 1 < _5324
                                        if not mem[(32 * _5324 - 1) + _5208 + ceil32(return_data.size) + 32]:
                                            return 0
                                        if profitFactor * mem[(32 * _5324 - 1) + _5208 + ceil32(return_data.size) + 32] / mem[(32 * _5324 - 1) + _5208 + ceil32(return_data.size) + 32] != profitFactor:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        mem[mem[64]] = profitFactor * mem[(32 * _5324 - 1) + _5208 + ceil32(return_data.size) + 32] < 0
                                else:
                                    if maxReportDelay * (_2912 * _3021) - (t * _3021) / 10^18 / (_2912 * _3021) - (t * _3021) / 10^18 != maxReportDelay:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _3397 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3397] = 26
                                    mem[_3397 + 32] = 'SafeMath: division by zero'
                                    if 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83 == wantAddress:
                                        if not arg1:
                                            return (0 < maxReportDelay * (_2912 * _3021) - (t * _3021) / 10^18 / 31556952)
                                        if profitFactor * arg1 / arg1 != profitFactor:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        return (profitFactor * arg1 < maxReportDelay * (_2912 * _3021) - (t * _3021) / 10^18 / 31556952)
                                    if wantToEthOracleAddress:
                                        mem[mem[64] + 4] = arg1
                                        require ext_code.size(wantToEthOracleAddress)
                                        staticcall wantToEthOracleAddress.0x780022a0 with:
                                                gas gas_remaining wei
                                               args arg1
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _3863 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if not mem[_3863]:
                                            return (0 < maxReportDelay * (_2912 * _3021) - (t * _3021) / 10^18 / 31556952)
                                        if profitFactor * mem[_3863] / mem[_3863] != profitFactor:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        mem[mem[64]] = profitFactor * mem[_3863] < maxReportDelay * (_2912 * _3021) - (t * _3021) / 10^18 / 31556952
                                    else:
                                        _3608 = mem[64]
                                        mem[mem[64]] = 2
                                        mem[64] = mem[64] + 96
                                        require 0 < mem[_3608]
                                        mem[_3608 + 32] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                        require 1 < mem[_3608]
                                        mem[_3608 + 64] = wantAddress
                                        mem[_3608 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                        mem[_3608 + 100] = arg1
                                        mem[_3608 + 132] = 64
                                        mem[_3608 + 164] = mem[_3608]
                                        idx = 0
                                        s = _3608 + 196
                                        u = _3608 + 32
                                        while idx < mem[_3608]:
                                            mem[s] = mem[u + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            u = u + 32
                                            continue 
                                        require ext_code.size(0xf491e7b69e4244ad4002bc14e878a34207e38c29)
                                        staticcall 0xf491e7b69e4244ad4002bc14e878a34207e38c29.mem[mem[64] len 4] with:
                                                gas gas_remaining wei
                                               args mem[mem[64] + 4 len _3608 + (32 * mem[_3608]) + -mem[64] + 192]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5207 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _5261 = mem[_5207]
                                        require mem[_5207] <= test266151307()
                                        require _5207 + return_data.size > _5207 + mem[_5207] + 31
                                        _5323 = mem[_5207 + mem[_5207]]
                                        require mem[_5207 + mem[_5207]] <= test266151307()
                                        require (32 * mem[_5207 + mem[_5207]]) + 32 >= 0 and _5207 + ceil32(return_data.size) + (32 * mem[_5207 + mem[_5207]]) + 32 <= test266151307()
                                        mem[64] = _5207 + ceil32(return_data.size) + (32 * mem[_5207 + mem[_5207]]) + 32
                                        mem[_5207 + ceil32(return_data.size)] = _5323
                                        require return_data.size >= _5261 + (32 * _5323) + 32
                                        mem[_5207 + ceil32(return_data.size) + 32 len 32 * _5323] = mem[_5207 + _5261 + 32 len 32 * _5323]
                                        require _5323 - 1 < _5323
                                        if not mem[(32 * _5323 - 1) + _5207 + ceil32(return_data.size) + 32]:
                                            return (0 < maxReportDelay * (_2912 * _3021) - (t * _3021) / 10^18 / 31556952)
                                        if profitFactor * mem[(32 * _5323 - 1) + _5207 + ceil32(return_data.size) + 32] / mem[(32 * _5323 - 1) + _5207 + ceil32(return_data.size) + 32] != profitFactor:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        mem[mem[64]] = profitFactor * mem[(32 * _5323 - 1) + _5207 + ceil32(return_data.size) + 32] < maxReportDelay * (_2912 * _3021) - (t * _3021) / 10^18 / 31556952
                    else:
                        if arg1 * profitFactor / profitFactor != arg1:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg1 * profitFactor < _819 + (_806 * lenders.length) - _877 + mem[_925]:
                            return 0
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(wantAddress)
                        staticcall wantAddress.balanceOf(address arg1) with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1029 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _1046 = mem[_1029]
                        idx = 0
                        s = 0
                        t = -1
                        while idx < lenders.length:
                            mem[0] = 13
                            require ext_code.size(lenders[idx])
                            staticcall lenders[idx].hasAssets() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _1474 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_1474] == bool(mem[_1474])
                            if not mem[_1474]:
                                idx = idx + 1
                                s = s
                                t = t
                                continue 
                            require idx < lenders.length
                            mem[0] = 13
                            require ext_code.size(lenders[idx])
                            staticcall lenders[idx].apr() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _1611 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _1635 = mem[_1611]
                            if mem[_1611] >= t:
                                idx = idx + 1
                                s = s
                                t = t
                                continue 
                            require idx < lenders.length
                            mem[0] = 13
                            require ext_code.size(lenders[idx])
                            staticcall lenders[idx].nav() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _1675 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            idx = idx + 1
                            s = mem[_1675]
                            t = _1635
                            continue 
                        if _1046 + s < s:
                            revert with 0, 'SafeMath: addition overflow'
                        idx = 0
                        u = 0
                        while idx < lenders.length:
                            mem[0] = 13
                            mem[mem[64] + 4] = _1046
                            require ext_code.size(lenders[idx])
                            staticcall lenders[idx].aprAfterDeposit(uint256 arg1) with:
                                    gas gas_remaining wei
                                   args _1046
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2870 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if mem[_2870] <= u:
                                idx = idx + 1
                                u = u
                                continue 
                            idx = idx + 1
                            u = mem[_2870]
                            continue 
                        require 0 < lenders.length
                        mem[0] = 13
                        mem[mem[64] + 4] = _1046 + s
                        require ext_code.size(lenders)
                        staticcall lenders.aprAfterDeposit(uint256 arg1) with:
                                gas gas_remaining wei
                               args (_1046 + s)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2869 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _2910 = mem[_2869]
                        if mem[_2869] <= t:
                            return 0
                        require 0 < lenders.length
                        mem[0] = 13
                        require ext_code.size(lenders)
                        staticcall lenders.nav() with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3008 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _3020 = mem[_3008]
                        if not mem[_3008]:
                            _3198 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3198] = 26
                            mem[_3198 + 32] = 'SafeMath: division by zero'
                            _3334 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3334] = 26
                            mem[_3334 + 32] = 'SafeMath: division by zero'
                            if 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83 == wantAddress:
                                if not arg1:
                                    return 0
                                if profitFactor * arg1 / arg1 != profitFactor:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                return (profitFactor * arg1 < 0)
                            if wantToEthOracleAddress:
                                mem[mem[64] + 4] = arg1
                                require ext_code.size(wantToEthOracleAddress)
                                staticcall wantToEthOracleAddress.0x780022a0 with:
                                        gas gas_remaining wei
                                       args arg1
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _3667 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if not mem[_3667]:
                                    return 0
                                if profitFactor * mem[_3667] / mem[_3667] != profitFactor:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[mem[64]] = profitFactor * mem[_3667] < 0
                            else:
                                _3434 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                require 0 < mem[_3434]
                                mem[_3434 + 32] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                require 1 < mem[_3434]
                                mem[_3434 + 64] = wantAddress
                                mem[_3434 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[_3434 + 100] = arg1
                                mem[_3434 + 132] = 64
                                mem[_3434 + 164] = mem[_3434]
                                idx = 0
                                s = _3434 + 196
                                t = _3434 + 32
                                while idx < mem[_3434]:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(0xf491e7b69e4244ad4002bc14e878a34207e38c29)
                                staticcall 0xf491e7b69e4244ad4002bc14e878a34207e38c29.mem[mem[64] len 4] with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len _3434 + (32 * mem[_3434]) + -mem[64] + 192]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _5206 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _5260 = mem[_5206]
                                require mem[_5206] <= test266151307()
                                require _5206 + return_data.size > _5206 + mem[_5206] + 31
                                _5322 = mem[_5206 + mem[_5206]]
                                require mem[_5206 + mem[_5206]] <= test266151307()
                                require (32 * mem[_5206 + mem[_5206]]) + 32 >= 0 and _5206 + ceil32(return_data.size) + (32 * mem[_5206 + mem[_5206]]) + 32 <= test266151307()
                                mem[64] = _5206 + ceil32(return_data.size) + (32 * mem[_5206 + mem[_5206]]) + 32
                                mem[_5206 + ceil32(return_data.size)] = _5322
                                require return_data.size >= _5260 + (32 * _5322) + 32
                                mem[_5206 + ceil32(return_data.size) + 32 len 32 * _5322] = mem[_5206 + _5260 + 32 len 32 * _5322]
                                require _5322 - 1 < _5322
                                if not mem[(32 * _5322 - 1) + _5206 + ceil32(return_data.size) + 32]:
                                    return 0
                                if profitFactor * mem[(32 * _5322 - 1) + _5206 + ceil32(return_data.size) + 32] / mem[(32 * _5322 - 1) + _5206 + ceil32(return_data.size) + 32] != profitFactor:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[mem[64]] = profitFactor * mem[(32 * _5322 - 1) + _5206 + ceil32(return_data.size) + 32] < 0
                        else:
                            if t * mem[_3008] / mem[_3008] != t:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not mem[_3008]:
                                _3238 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3238] = 26
                                mem[_3238 + 32] = 'SafeMath: division by zero'
                                if not -1 * t * _3020 / 10^18:
                                    _3352 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3352] = 26
                                    mem[_3352 + 32] = 'SafeMath: division by zero'
                                    if 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83 == wantAddress:
                                        if not arg1:
                                            return 0
                                        if profitFactor * arg1 / arg1 != profitFactor:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        return (profitFactor * arg1 < 0)
                                    if wantToEthOracleAddress:
                                        mem[mem[64] + 4] = arg1
                                        require ext_code.size(wantToEthOracleAddress)
                                        staticcall wantToEthOracleAddress.0x780022a0 with:
                                                gas gas_remaining wei
                                               args arg1
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _3726 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if not mem[_3726]:
                                            return 0
                                        if profitFactor * mem[_3726] / mem[_3726] != profitFactor:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        mem[mem[64]] = profitFactor * mem[_3726] < 0
                                    else:
                                        _3467 = mem[64]
                                        mem[mem[64]] = 2
                                        mem[64] = mem[64] + 96
                                        require 0 < mem[_3467]
                                        mem[_3467 + 32] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                        require 1 < mem[_3467]
                                        mem[_3467 + 64] = wantAddress
                                        mem[_3467 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                        mem[_3467 + 100] = arg1
                                        mem[_3467 + 132] = 64
                                        mem[_3467 + 164] = mem[_3467]
                                        idx = 0
                                        s = _3467 + 196
                                        t = _3467 + 32
                                        while idx < mem[_3467]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        require ext_code.size(0xf491e7b69e4244ad4002bc14e878a34207e38c29)
                                        staticcall 0xf491e7b69e4244ad4002bc14e878a34207e38c29.mem[mem[64] len 4] with:
                                                gas gas_remaining wei
                                               args mem[mem[64] + 4 len _3467 + (32 * mem[_3467]) + -mem[64] + 192]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5205 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _5259 = mem[_5205]
                                        require mem[_5205] <= test266151307()
                                        require _5205 + return_data.size > _5205 + mem[_5205] + 31
                                        _5321 = mem[_5205 + mem[_5205]]
                                        require mem[_5205 + mem[_5205]] <= test266151307()
                                        require (32 * mem[_5205 + mem[_5205]]) + 32 >= 0 and _5205 + ceil32(return_data.size) + (32 * mem[_5205 + mem[_5205]]) + 32 <= test266151307()
                                        mem[64] = _5205 + ceil32(return_data.size) + (32 * mem[_5205 + mem[_5205]]) + 32
                                        mem[_5205 + ceil32(return_data.size)] = _5321
                                        require return_data.size >= _5259 + (32 * _5321) + 32
                                        mem[_5205 + ceil32(return_data.size) + 32 len 32 * _5321] = mem[_5205 + _5259 + 32 len 32 * _5321]
                                        require _5321 - 1 < _5321
                                        if not mem[(32 * _5321 - 1) + _5205 + ceil32(return_data.size) + 32]:
                                            return 0
                                        if profitFactor * mem[(32 * _5321 - 1) + _5205 + ceil32(return_data.size) + 32] / mem[(32 * _5321 - 1) + _5205 + ceil32(return_data.size) + 32] != profitFactor:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        mem[mem[64]] = profitFactor * mem[(32 * _5321 - 1) + _5205 + ceil32(return_data.size) + 32] < 0
                                else:
                                    if maxReportDelay * -1 * t * _3020 / 10^18 / -1 * t * _3020 / 10^18 != maxReportDelay:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _3376 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3376] = 26
                                    mem[_3376 + 32] = 'SafeMath: division by zero'
                                    if 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83 == wantAddress:
                                        if not arg1:
                                            return (0 < maxReportDelay * -1 * t * _3020 / 10^18 / 31556952)
                                        if profitFactor * arg1 / arg1 != profitFactor:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        return (profitFactor * arg1 < maxReportDelay * -1 * t * _3020 / 10^18 / 31556952)
                                    if wantToEthOracleAddress:
                                        mem[mem[64] + 4] = arg1
                                        require ext_code.size(wantToEthOracleAddress)
                                        staticcall wantToEthOracleAddress.0x780022a0 with:
                                                gas gas_remaining wei
                                               args arg1
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _3785 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if not mem[_3785]:
                                            return (0 < maxReportDelay * -1 * t * _3020 / 10^18 / 31556952)
                                        if profitFactor * mem[_3785] / mem[_3785] != profitFactor:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        mem[mem[64]] = profitFactor * mem[_3785] < maxReportDelay * -1 * t * _3020 / 10^18 / 31556952
                                    else:
                                        _3535 = mem[64]
                                        mem[mem[64]] = 2
                                        mem[64] = mem[64] + 96
                                        require 0 < mem[_3535]
                                        mem[_3535 + 32] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                        require 1 < mem[_3535]
                                        mem[_3535 + 64] = wantAddress
                                        mem[_3535 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                        mem[_3535 + 100] = arg1
                                        mem[_3535 + 132] = 64
                                        mem[_3535 + 164] = mem[_3535]
                                        idx = 0
                                        s = _3535 + 196
                                        u = _3535 + 32
                                        while idx < mem[_3535]:
                                            mem[s] = mem[u + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            u = u + 32
                                            continue 
                                        require ext_code.size(0xf491e7b69e4244ad4002bc14e878a34207e38c29)
                                        staticcall 0xf491e7b69e4244ad4002bc14e878a34207e38c29.mem[mem[64] len 4] with:
                                                gas gas_remaining wei
                                               args mem[mem[64] + 4 len _3535 + (32 * mem[_3535]) + -mem[64] + 192]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5204 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _5258 = mem[_5204]
                                        require mem[_5204] <= test266151307()
                                        require _5204 + return_data.size > _5204 + mem[_5204] + 31
                                        _5320 = mem[_5204 + mem[_5204]]
                                        require mem[_5204 + mem[_5204]] <= test266151307()
                                        require (32 * mem[_5204 + mem[_5204]]) + 32 >= 0 and _5204 + ceil32(return_data.size) + (32 * mem[_5204 + mem[_5204]]) + 32 <= test266151307()
                                        mem[64] = _5204 + ceil32(return_data.size) + (32 * mem[_5204 + mem[_5204]]) + 32
                                        mem[_5204 + ceil32(return_data.size)] = _5320
                                        require return_data.size >= _5258 + (32 * _5320) + 32
                                        mem[_5204 + ceil32(return_data.size) + 32 len 32 * _5320] = mem[_5204 + _5258 + 32 len 32 * _5320]
                                        require _5320 - 1 < _5320
                                        if not mem[(32 * _5320 - 1) + _5204 + ceil32(return_data.size) + 32]:
                                            return (0 < maxReportDelay * -1 * t * _3020 / 10^18 / 31556952)
                                        if profitFactor * mem[(32 * _5320 - 1) + _5204 + ceil32(return_data.size) + 32] / mem[(32 * _5320 - 1) + _5204 + ceil32(return_data.size) + 32] != profitFactor:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        mem[mem[64]] = profitFactor * mem[(32 * _5320 - 1) + _5204 + ceil32(return_data.size) + 32] < maxReportDelay * -1 * t * _3020 / 10^18 / 31556952
                            else:
                                if _2910 * mem[_3008] / mem[_3008] != _2910:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _3273 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3273] = 26
                                mem[_3273 + 32] = 'SafeMath: division by zero'
                                if not (_2910 * _3020) - (t * _3020) / 10^18:
                                    _3375 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3375] = 26
                                    mem[_3375 + 32] = 'SafeMath: division by zero'
                                    if 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83 == wantAddress:
                                        if not arg1:
                                            return 0
                                        if profitFactor * arg1 / arg1 != profitFactor:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        return (profitFactor * arg1 < 0)
                                    if wantToEthOracleAddress:
                                        mem[mem[64] + 4] = arg1
                                        require ext_code.size(wantToEthOracleAddress)
                                        staticcall wantToEthOracleAddress.0x780022a0 with:
                                                gas gas_remaining wei
                                               args arg1
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _3784 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if not mem[_3784]:
                                            return 0
                                        if profitFactor * mem[_3784] / mem[_3784] != profitFactor:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        mem[mem[64]] = profitFactor * mem[_3784] < 0
                                    else:
                                        _3532 = mem[64]
                                        mem[mem[64]] = 2
                                        mem[64] = mem[64] + 96
                                        require 0 < mem[_3532]
                                        mem[_3532 + 32] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                        require 1 < mem[_3532]
                                        mem[_3532 + 64] = wantAddress
                                        mem[_3532 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                        mem[_3532 + 100] = arg1
                                        mem[_3532 + 132] = 64
                                        mem[_3532 + 164] = mem[_3532]
                                        idx = 0
                                        s = _3532 + 196
                                        t = _3532 + 32
                                        while idx < mem[_3532]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        require ext_code.size(0xf491e7b69e4244ad4002bc14e878a34207e38c29)
                                        staticcall 0xf491e7b69e4244ad4002bc14e878a34207e38c29.mem[mem[64] len 4] with:
                                                gas gas_remaining wei
                                               args mem[mem[64] + 4 len _3532 + (32 * mem[_3532]) + -mem[64] + 192]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5203 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _5257 = mem[_5203]
                                        require mem[_5203] <= test266151307()
                                        require _5203 + return_data.size > _5203 + mem[_5203] + 31
                                        _5319 = mem[_5203 + mem[_5203]]
                                        require mem[_5203 + mem[_5203]] <= test266151307()
                                        require (32 * mem[_5203 + mem[_5203]]) + 32 >= 0 and _5203 + ceil32(return_data.size) + (32 * mem[_5203 + mem[_5203]]) + 32 <= test266151307()
                                        mem[64] = _5203 + ceil32(return_data.size) + (32 * mem[_5203 + mem[_5203]]) + 32
                                        mem[_5203 + ceil32(return_data.size)] = _5319
                                        require return_data.size >= _5257 + (32 * _5319) + 32
                                        mem[_5203 + ceil32(return_data.size) + 32 len 32 * _5319] = mem[_5203 + _5257 + 32 len 32 * _5319]
                                        require _5319 - 1 < _5319
                                        if not mem[(32 * _5319 - 1) + _5203 + ceil32(return_data.size) + 32]:
                                            return 0
                                        if profitFactor * mem[(32 * _5319 - 1) + _5203 + ceil32(return_data.size) + 32] / mem[(32 * _5319 - 1) + _5203 + ceil32(return_data.size) + 32] != profitFactor:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        mem[mem[64]] = profitFactor * mem[(32 * _5319 - 1) + _5203 + ceil32(return_data.size) + 32] < 0
                                else:
                                    if maxReportDelay * (_2910 * _3020) - (t * _3020) / 10^18 / (_2910 * _3020) - (t * _3020) / 10^18 != maxReportDelay:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _3395 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3395] = 26
                                    mem[_3395 + 32] = 'SafeMath: division by zero'
                                    if 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83 == wantAddress:
                                        if not arg1:
                                            return (0 < maxReportDelay * (_2910 * _3020) - (t * _3020) / 10^18 / 31556952)
                                        if profitFactor * arg1 / arg1 != profitFactor:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        return (profitFactor * arg1 < maxReportDelay * (_2910 * _3020) - (t * _3020) / 10^18 / 31556952)
                                    if wantToEthOracleAddress:
                                        mem[mem[64] + 4] = arg1
                                        require ext_code.size(wantToEthOracleAddress)
                                        staticcall wantToEthOracleAddress.0x780022a0 with:
                                                gas gas_remaining wei
                                               args arg1
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _3854 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if not mem[_3854]:
                                            return (0 < maxReportDelay * (_2910 * _3020) - (t * _3020) / 10^18 / 31556952)
                                        if profitFactor * mem[_3854] / mem[_3854] != profitFactor:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        mem[mem[64]] = profitFactor * mem[_3854] < maxReportDelay * (_2910 * _3020) - (t * _3020) / 10^18 / 31556952
                                    else:
                                        _3600 = mem[64]
                                        mem[mem[64]] = 2
                                        mem[64] = mem[64] + 96
                                        require 0 < mem[_3600]
                                        mem[_3600 + 32] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                        require 1 < mem[_3600]
                                        mem[_3600 + 64] = wantAddress
                                        mem[_3600 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                        mem[_3600 + 100] = arg1
                                        mem[_3600 + 132] = 64
                                        mem[_3600 + 164] = mem[_3600]
                                        idx = 0
                                        s = _3600 + 196
                                        u = _3600 + 32
                                        while idx < mem[_3600]:
                                            mem[s] = mem[u + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            u = u + 32
                                            continue 
                                        require ext_code.size(0xf491e7b69e4244ad4002bc14e878a34207e38c29)
                                        staticcall 0xf491e7b69e4244ad4002bc14e878a34207e38c29.mem[mem[64] len 4] with:
                                                gas gas_remaining wei
                                               args mem[mem[64] + 4 len _3600 + (32 * mem[_3600]) + -mem[64] + 192]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5202 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _5256 = mem[_5202]
                                        require mem[_5202] <= test266151307()
                                        require _5202 + return_data.size > _5202 + mem[_5202] + 31
                                        _5318 = mem[_5202 + mem[_5202]]
                                        require mem[_5202 + mem[_5202]] <= test266151307()
                                        require (32 * mem[_5202 + mem[_5202]]) + 32 >= 0 and _5202 + ceil32(return_data.size) + (32 * mem[_5202 + mem[_5202]]) + 32 <= test266151307()
                                        mem[64] = _5202 + ceil32(return_data.size) + (32 * mem[_5202 + mem[_5202]]) + 32
                                        mem[_5202 + ceil32(return_data.size)] = _5318
                                        require return_data.size >= _5256 + (32 * _5318) + 32
                                        mem[_5202 + ceil32(return_data.size) + 32 len 32 * _5318] = mem[_5202 + _5256 + 32 len 32 * _5318]
                                        require _5318 - 1 < _5318
                                        if not mem[(32 * _5318 - 1) + _5202 + ceil32(return_data.size) + 32]:
                                            return (0 < maxReportDelay * (_2910 * _3020) - (t * _3020) / 10^18 / 31556952)
                                        if profitFactor * mem[(32 * _5318 - 1) + _5202 + ceil32(return_data.size) + 32] / mem[(32 * _5318 - 1) + _5202 + ceil32(return_data.size) + 32] != profitFactor:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        mem[mem[64]] = profitFactor * mem[(32 * _5318 - 1) + _5202 + ceil32(return_data.size) + 32] < maxReportDelay * (_2910 * _3020) - (t * _3020) / 10^18 / 31556952
    else:
        if wantToEthOracleAddress:
            mem[100] = arg1
            require ext_code.size(wantToEthOracleAddress)
            staticcall wantToEthOracleAddress.0x780022a0 with:
                    gas gas_remaining wei
                   args arg1
            mem[96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            mem[ceil32(return_data.size) + 96] = 0
            mem[ceil32(return_data.size) + 128] = 0
            mem[ceil32(return_data.size) + 160] = 0
            mem[ceil32(return_data.size) + 192] = 0
            mem[ceil32(return_data.size) + 224] = 0
            mem[ceil32(return_data.size) + 256] = 0
            mem[ceil32(return_data.size) + 288] = 0
            mem[ceil32(return_data.size) + 320] = 0
            mem[ceil32(return_data.size) + 352] = 0
            require ext_code.size(vaultAddress)
            staticcall vaultAddress.strategies(address arg1) with:
                    gas gas_remaining wei
                   args this.address
            mem[ceil32(return_data.size) + 384 len 288] = ext_call.return_data[0 len 288]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 288
            require bool((2 * ceil32(return_data.size)) + 672 <= test266151307())
            mem[(2 * ceil32(return_data.size)) + 384] = ext_call.return_data[0]
            mem[(2 * ceil32(return_data.size)) + 416] = ext_call.return_data[32]
            mem[(2 * ceil32(return_data.size)) + 448] = ext_call.return_data[64]
            mem[(2 * ceil32(return_data.size)) + 480] = ext_call.return_data[96]
            mem[(2 * ceil32(return_data.size)) + 512] = ext_call.return_data[128]
            mem[(2 * ceil32(return_data.size)) + 544] = ext_call.return_data[160]
            mem[(2 * ceil32(return_data.size)) + 576] = ext_call.return_data[192]
            mem[(2 * ceil32(return_data.size)) + 608] = ext_call.return_data[224]
            mem[(2 * ceil32(return_data.size)) + 640] = ext_call.return_data[256]
            if 0 == ext_call.return_data[32]:
                mem[(2 * ceil32(return_data.size)) + 676] = this.address
                require ext_code.size(wantAddress)
                staticcall wantAddress.balanceOf(address arg1) with:
                        gas gas_remaining wei
                       args this.address
                mem[(2 * ceil32(return_data.size)) + 672] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[64] = (4 * ceil32(return_data.size)) + 672
                require return_data.size >= 32
                idx = 0
                s = 0
                t = -1
                while idx < lenders.length:
                    mem[0] = 13
                    require ext_code.size(lenders[idx])
                    staticcall lenders[idx].hasAssets() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _783 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_783] == bool(mem[_783])
                    if not mem[_783]:
                        idx = idx + 1
                        s = s
                        t = t
                        continue 
                    require idx < lenders.length
                    mem[0] = 13
                    require ext_code.size(lenders[idx])
                    staticcall lenders[idx].apr() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _856 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _862 = mem[_856]
                    if mem[_856] >= t:
                        idx = idx + 1
                        s = s
                        t = t
                        continue 
                    require idx < lenders.length
                    mem[0] = 13
                    require ext_code.size(lenders[idx])
                    staticcall lenders[idx].nav() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _898 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    idx = idx + 1
                    s = mem[_898]
                    t = _862
                    continue 
                if ext_call.return_data[0] + s < s:
                    revert with 0, 'SafeMath: addition overflow'
                idx = 0
                u = 0
                while idx < lenders.length:
                    mem[0] = 13
                    mem[mem[64] + 4] = ext_call.return_data[0]
                    require ext_code.size(lenders[idx])
                    staticcall lenders[idx].aprAfterDeposit(uint256 arg1) with:
                            gas gas_remaining wei
                           args ext_call.return_data[0]
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1501 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if mem[_1501] <= u:
                        idx = idx + 1
                        u = u
                        continue 
                    idx = idx + 1
                    u = mem[_1501]
                    continue 
                require 0 < lenders.length
                mem[0] = 13
                mem[mem[64] + 4] = ext_call.return_data[0] + s
                require ext_code.size(lenders)
                staticcall lenders.aprAfterDeposit(uint256 arg1) with:
                        gas gas_remaining wei
                       args (ext_call.return_data[0] + s)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1500 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _1529 = mem[_1500]
                if mem[_1500] <= t:
                    return 0
                require 0 < lenders.length
                mem[0] = 13
                require ext_code.size(lenders)
                staticcall lenders.nav() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1608 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _1632 = mem[_1608]
                if not mem[_1608]:
                    _1701 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1701] = 26
                    mem[_1701 + 32] = 'SafeMath: division by zero'
                    _1747 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1747] = 26
                    mem[_1747 + 32] = 'SafeMath: division by zero'
                    if 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83 == wantAddress:
                        if not arg1:
                            return 0
                        if profitFactor * arg1 / arg1 != profitFactor:
                            revert with 0, 'SafeMath: multiplication overflow'
                        return (profitFactor * arg1 < 0)
                    if wantToEthOracleAddress:
                        mem[mem[64] + 4] = arg1
                        require ext_code.size(wantToEthOracleAddress)
                        staticcall wantToEthOracleAddress.0x780022a0 with:
                                gas gas_remaining wei
                               args arg1
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1927 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if not mem[_1927]:
                            return 0
                        if profitFactor * mem[_1927] / mem[_1927] != profitFactor:
                            revert with 0, 'SafeMath: multiplication overflow'
                        mem[mem[64]] = profitFactor * mem[_1927] < 0
                    else:
                        _1810 = mem[64]
                        mem[mem[64]] = 2
                        mem[64] = mem[64] + 96
                        require 0 < mem[_1810]
                        mem[_1810 + 32] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                        require 1 < mem[_1810]
                        mem[_1810 + 64] = wantAddress
                        mem[_1810 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                        mem[_1810 + 100] = arg1
                        mem[_1810 + 132] = 64
                        mem[_1810 + 164] = mem[_1810]
                        idx = 0
                        s = _1810 + 196
                        t = _1810 + 32
                        while idx < mem[_1810]:
                            mem[s] = mem[t + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        require ext_code.size(0xf491e7b69e4244ad4002bc14e878a34207e38c29)
                        staticcall 0xf491e7b69e4244ad4002bc14e878a34207e38c29.mem[mem[64] len 4] with:
                                gas gas_remaining wei
                               args mem[mem[64] + 4 len _1810 + (32 * mem[_1810]) + -mem[64] + 192]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2818 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _2864 = mem[_2818]
                        require mem[_2818] <= test266151307()
                        require _2818 + return_data.size > _2818 + mem[_2818] + 31
                        _2905 = mem[_2818 + mem[_2818]]
                        require mem[_2818 + mem[_2818]] <= test266151307()
                        require (32 * mem[_2818 + mem[_2818]]) + 32 >= 0 and _2818 + ceil32(return_data.size) + (32 * mem[_2818 + mem[_2818]]) + 32 <= test266151307()
                        mem[64] = _2818 + ceil32(return_data.size) + (32 * mem[_2818 + mem[_2818]]) + 32
                        mem[_2818 + ceil32(return_data.size)] = _2905
                        require return_data.size >= _2864 + (32 * _2905) + 32
                        mem[_2818 + ceil32(return_data.size) + 32 len 32 * _2905] = mem[_2818 + _2864 + 32 len 32 * _2905]
                        require _2905 - 1 < _2905
                        if not mem[(32 * _2905 - 1) + _2818 + ceil32(return_data.size) + 32]:
                            return 0
                        if profitFactor * mem[(32 * _2905 - 1) + _2818 + ceil32(return_data.size) + 32] / mem[(32 * _2905 - 1) + _2818 + ceil32(return_data.size) + 32] != profitFactor:
                            revert with 0, 'SafeMath: multiplication overflow'
                        mem[mem[64]] = profitFactor * mem[(32 * _2905 - 1) + _2818 + ceil32(return_data.size) + 32] < 0
                else:
                    if t * mem[_1608] / mem[_1608] != t:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not mem[_1608]:
                        _1709 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1709] = 26
                        mem[_1709 + 32] = 'SafeMath: division by zero'
                        if not -1 * t * _1632 / 10^18:
                            _1758 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1758] = 26
                            mem[_1758 + 32] = 'SafeMath: division by zero'
                            if 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83 == wantAddress:
                                if not arg1:
                                    return 0
                                if profitFactor * arg1 / arg1 != profitFactor:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                return (profitFactor * arg1 < 0)
                            if wantToEthOracleAddress:
                                mem[mem[64] + 4] = arg1
                                require ext_code.size(wantToEthOracleAddress)
                                staticcall wantToEthOracleAddress.0x780022a0 with:
                                        gas gas_remaining wei
                                       args arg1
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _1956 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if not mem[_1956]:
                                    return 0
                                if profitFactor * mem[_1956] / mem[_1956] != profitFactor:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[mem[64]] = profitFactor * mem[_1956] < 0
                            else:
                                _1824 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                require 0 < mem[_1824]
                                mem[_1824 + 32] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                require 1 < mem[_1824]
                                mem[_1824 + 64] = wantAddress
                                mem[_1824 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[_1824 + 100] = arg1
                                mem[_1824 + 132] = 64
                                mem[_1824 + 164] = mem[_1824]
                                idx = 0
                                s = _1824 + 196
                                t = _1824 + 32
                                while idx < mem[_1824]:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(0xf491e7b69e4244ad4002bc14e878a34207e38c29)
                                staticcall 0xf491e7b69e4244ad4002bc14e878a34207e38c29.mem[mem[64] len 4] with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len _1824 + (32 * mem[_1824]) + -mem[64] + 192]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _2817 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _2863 = mem[_2817]
                                require mem[_2817] <= test266151307()
                                require _2817 + return_data.size > _2817 + mem[_2817] + 31
                                _2904 = mem[_2817 + mem[_2817]]
                                require mem[_2817 + mem[_2817]] <= test266151307()
                                require (32 * mem[_2817 + mem[_2817]]) + 32 >= 0 and _2817 + ceil32(return_data.size) + (32 * mem[_2817 + mem[_2817]]) + 32 <= test266151307()
                                mem[64] = _2817 + ceil32(return_data.size) + (32 * mem[_2817 + mem[_2817]]) + 32
                                mem[_2817 + ceil32(return_data.size)] = _2904
                                require return_data.size >= _2863 + (32 * _2904) + 32
                                mem[_2817 + ceil32(return_data.size) + 32 len 32 * _2904] = mem[_2817 + _2863 + 32 len 32 * _2904]
                                require _2904 - 1 < _2904
                                if not mem[(32 * _2904 - 1) + _2817 + ceil32(return_data.size) + 32]:
                                    return 0
                                if profitFactor * mem[(32 * _2904 - 1) + _2817 + ceil32(return_data.size) + 32] / mem[(32 * _2904 - 1) + _2817 + ceil32(return_data.size) + 32] != profitFactor:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[mem[64]] = profitFactor * mem[(32 * _2904 - 1) + _2817 + ceil32(return_data.size) + 32] < 0
                        else:
                            if maxReportDelay * -1 * t * _1632 / 10^18 / -1 * t * _1632 / 10^18 != maxReportDelay:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _1769 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1769] = 26
                            mem[_1769 + 32] = 'SafeMath: division by zero'
                            if 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83 == wantAddress:
                                if not arg1:
                                    return (0 < maxReportDelay * -1 * t * _1632 / 10^18 / 31556952)
                                if profitFactor * arg1 / arg1 != profitFactor:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                return (profitFactor * arg1 < maxReportDelay * -1 * t * _1632 / 10^18 / 31556952)
                            if wantToEthOracleAddress:
                                mem[mem[64] + 4] = arg1
                                require ext_code.size(wantToEthOracleAddress)
                                staticcall wantToEthOracleAddress.0x780022a0 with:
                                        gas gas_remaining wei
                                       args arg1
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _1983 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if not mem[_1983]:
                                    return (0 < maxReportDelay * -1 * t * _1632 / 10^18 / 31556952)
                                if profitFactor * mem[_1983] / mem[_1983] != profitFactor:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[mem[64]] = profitFactor * mem[_1983] < maxReportDelay * -1 * t * _1632 / 10^18 / 31556952
                            else:
                                _1850 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                require 0 < mem[_1850]
                                mem[_1850 + 32] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                require 1 < mem[_1850]
                                mem[_1850 + 64] = wantAddress
                                mem[_1850 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[_1850 + 100] = arg1
                                mem[_1850 + 132] = 64
                                mem[_1850 + 164] = mem[_1850]
                                idx = 0
                                s = _1850 + 196
                                u = _1850 + 32
                                while idx < mem[_1850]:
                                    mem[s] = mem[u + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    u = u + 32
                                    continue 
                                require ext_code.size(0xf491e7b69e4244ad4002bc14e878a34207e38c29)
                                staticcall 0xf491e7b69e4244ad4002bc14e878a34207e38c29.mem[mem[64] len 4] with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len _1850 + (32 * mem[_1850]) + -mem[64] + 192]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _2816 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _2862 = mem[_2816]
                                require mem[_2816] <= test266151307()
                                require _2816 + return_data.size > _2816 + mem[_2816] + 31
                                _2903 = mem[_2816 + mem[_2816]]
                                require mem[_2816 + mem[_2816]] <= test266151307()
                                require (32 * mem[_2816 + mem[_2816]]) + 32 >= 0 and _2816 + ceil32(return_data.size) + (32 * mem[_2816 + mem[_2816]]) + 32 <= test266151307()
                                mem[64] = _2816 + ceil32(return_data.size) + (32 * mem[_2816 + mem[_2816]]) + 32
                                mem[_2816 + ceil32(return_data.size)] = _2903
                                require return_data.size >= _2862 + (32 * _2903) + 32
                                mem[_2816 + ceil32(return_data.size) + 32 len 32 * _2903] = mem[_2816 + _2862 + 32 len 32 * _2903]
                                require _2903 - 1 < _2903
                                if not mem[(32 * _2903 - 1) + _2816 + ceil32(return_data.size) + 32]:
                                    return (0 < maxReportDelay * -1 * t * _1632 / 10^18 / 31556952)
                                if profitFactor * mem[(32 * _2903 - 1) + _2816 + ceil32(return_data.size) + 32] / mem[(32 * _2903 - 1) + _2816 + ceil32(return_data.size) + 32] != profitFactor:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[mem[64]] = profitFactor * mem[(32 * _2903 - 1) + _2816 + ceil32(return_data.size) + 32] < maxReportDelay * -1 * t * _1632 / 10^18 / 31556952
                    else:
                        if _1529 * mem[_1608] / mem[_1608] != _1529:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _1715 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1715] = 26
                        mem[_1715 + 32] = 'SafeMath: division by zero'
                        if not (_1529 * _1632) - (t * _1632) / 10^18:
                            _1768 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1768] = 26
                            mem[_1768 + 32] = 'SafeMath: division by zero'
                            if 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83 == wantAddress:
                                if not arg1:
                                    return 0
                                if profitFactor * arg1 / arg1 != profitFactor:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                return (profitFactor * arg1 < 0)
                            if wantToEthOracleAddress:
                                mem[mem[64] + 4] = arg1
                                require ext_code.size(wantToEthOracleAddress)
                                staticcall wantToEthOracleAddress.0x780022a0 with:
                                        gas gas_remaining wei
                                       args arg1
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _1982 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if not mem[_1982]:
                                    return 0
                                if profitFactor * mem[_1982] / mem[_1982] != profitFactor:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[mem[64]] = profitFactor * mem[_1982] < 0
                            else:
                                _1847 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                require 0 < mem[_1847]
                                mem[_1847 + 32] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                require 1 < mem[_1847]
                                mem[_1847 + 64] = wantAddress
                                mem[_1847 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[_1847 + 100] = arg1
                                mem[_1847 + 132] = 64
                                mem[_1847 + 164] = mem[_1847]
                                idx = 0
                                s = _1847 + 196
                                t = _1847 + 32
                                while idx < mem[_1847]:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(0xf491e7b69e4244ad4002bc14e878a34207e38c29)
                                staticcall 0xf491e7b69e4244ad4002bc14e878a34207e38c29.mem[mem[64] len 4] with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len _1847 + (32 * mem[_1847]) + -mem[64] + 192]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _2815 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _2861 = mem[_2815]
                                require mem[_2815] <= test266151307()
                                require _2815 + return_data.size > _2815 + mem[_2815] + 31
                                _2902 = mem[_2815 + mem[_2815]]
                                require mem[_2815 + mem[_2815]] <= test266151307()
                                require (32 * mem[_2815 + mem[_2815]]) + 32 >= 0 and _2815 + ceil32(return_data.size) + (32 * mem[_2815 + mem[_2815]]) + 32 <= test266151307()
                                mem[64] = _2815 + ceil32(return_data.size) + (32 * mem[_2815 + mem[_2815]]) + 32
                                mem[_2815 + ceil32(return_data.size)] = _2902
                                require return_data.size >= _2861 + (32 * _2902) + 32
                                mem[_2815 + ceil32(return_data.size) + 32 len 32 * _2902] = mem[_2815 + _2861 + 32 len 32 * _2902]
                                require _2902 - 1 < _2902
                                if not mem[(32 * _2902 - 1) + _2815 + ceil32(return_data.size) + 32]:
                                    return 0
                                if profitFactor * mem[(32 * _2902 - 1) + _2815 + ceil32(return_data.size) + 32] / mem[(32 * _2902 - 1) + _2815 + ceil32(return_data.size) + 32] != profitFactor:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[mem[64]] = profitFactor * mem[(32 * _2902 - 1) + _2815 + ceil32(return_data.size) + 32] < 0
                        else:
                            if maxReportDelay * (_1529 * _1632) - (t * _1632) / 10^18 / (_1529 * _1632) - (t * _1632) / 10^18 != maxReportDelay:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _1780 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1780] = 26
                            mem[_1780 + 32] = 'SafeMath: division by zero'
                            if 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83 == wantAddress:
                                if not arg1:
                                    return (0 < maxReportDelay * (_1529 * _1632) - (t * _1632) / 10^18 / 31556952)
                                if profitFactor * arg1 / arg1 != profitFactor:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                return (profitFactor * arg1 < maxReportDelay * (_1529 * _1632) - (t * _1632) / 10^18 / 31556952)
                            if wantToEthOracleAddress:
                                mem[mem[64] + 4] = arg1
                                require ext_code.size(wantToEthOracleAddress)
                                staticcall wantToEthOracleAddress.0x780022a0 with:
                                        gas gas_remaining wei
                                       args arg1
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _2014 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if not mem[_2014]:
                                    return (0 < maxReportDelay * (_1529 * _1632) - (t * _1632) / 10^18 / 31556952)
                                if profitFactor * mem[_2014] / mem[_2014] != profitFactor:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[mem[64]] = profitFactor * mem[_2014] < maxReportDelay * (_1529 * _1632) - (t * _1632) / 10^18 / 31556952
                            else:
                                _1886 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                require 0 < mem[_1886]
                                mem[_1886 + 32] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                require 1 < mem[_1886]
                                mem[_1886 + 64] = wantAddress
                                mem[_1886 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[_1886 + 100] = arg1
                                mem[_1886 + 132] = 64
                                mem[_1886 + 164] = mem[_1886]
                                idx = 0
                                s = _1886 + 196
                                u = _1886 + 32
                                while idx < mem[_1886]:
                                    mem[s] = mem[u + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    u = u + 32
                                    continue 
                                require ext_code.size(0xf491e7b69e4244ad4002bc14e878a34207e38c29)
                                staticcall 0xf491e7b69e4244ad4002bc14e878a34207e38c29.mem[mem[64] len 4] with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len _1886 + (32 * mem[_1886]) + -mem[64] + 192]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _2814 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _2860 = mem[_2814]
                                require mem[_2814] <= test266151307()
                                require _2814 + return_data.size > _2814 + mem[_2814] + 31
                                _2901 = mem[_2814 + mem[_2814]]
                                require mem[_2814 + mem[_2814]] <= test266151307()
                                require (32 * mem[_2814 + mem[_2814]]) + 32 >= 0 and _2814 + ceil32(return_data.size) + (32 * mem[_2814 + mem[_2814]]) + 32 <= test266151307()
                                mem[64] = _2814 + ceil32(return_data.size) + (32 * mem[_2814 + mem[_2814]]) + 32
                                mem[_2814 + ceil32(return_data.size)] = _2901
                                require return_data.size >= _2860 + (32 * _2901) + 32
                                mem[_2814 + ceil32(return_data.size) + 32 len 32 * _2901] = mem[_2814 + _2860 + 32 len 32 * _2901]
                                require _2901 - 1 < _2901
                                if not mem[(32 * _2901 - 1) + _2814 + ceil32(return_data.size) + 32]:
                                    return (0 < maxReportDelay * (_1529 * _1632) - (t * _1632) / 10^18 / 31556952)
                                if profitFactor * mem[(32 * _2901 - 1) + _2814 + ceil32(return_data.size) + 32] / mem[(32 * _2901 - 1) + _2814 + ceil32(return_data.size) + 32] != profitFactor:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[mem[64]] = profitFactor * mem[(32 * _2901 - 1) + _2814 + ceil32(return_data.size) + 32] < maxReportDelay * (_1529 * _1632) - (t * _1632) / 10^18 / 31556952
            else:
                mem[(2 * ceil32(return_data.size)) + 672] = 30
                mem[(2 * ceil32(return_data.size)) + 704] = 'SafeMath: subtraction overflow'
                if ext_call.return_data[160] > block.timestamp:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if block.timestamp - ext_call.return_data[160] < minReportDelay:
                    mem[(2 * ceil32(return_data.size)) + 740] = this.address
                    require ext_code.size(wantAddress)
                    staticcall wantAddress.balanceOf(address arg1) with:
                            gas gas_remaining wei
                           args this.address
                    mem[(2 * ceil32(return_data.size)) + 736] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = (4 * ceil32(return_data.size)) + 736
                    require return_data.size >= 32
                    idx = 0
                    s = 0
                    t = -1
                    while idx < lenders.length:
                        mem[0] = 13
                        require ext_code.size(lenders[idx])
                        staticcall lenders[idx].hasAssets() with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _782 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_782] == bool(mem[_782])
                        if not mem[_782]:
                            idx = idx + 1
                            s = s
                            t = t
                            continue 
                        require idx < lenders.length
                        mem[0] = 13
                        require ext_code.size(lenders[idx])
                        staticcall lenders[idx].apr() with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _855 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _861 = mem[_855]
                        if mem[_855] >= t:
                            idx = idx + 1
                            s = s
                            t = t
                            continue 
                        require idx < lenders.length
                        mem[0] = 13
                        require ext_code.size(lenders[idx])
                        staticcall lenders[idx].nav() with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _897 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        idx = idx + 1
                        s = mem[_897]
                        t = _861
                        continue 
                    if ext_call.return_data[0] + s < s:
                        revert with 0, 'SafeMath: addition overflow'
                    idx = 0
                    u = 0
                    while idx < lenders.length:
                        mem[0] = 13
                        mem[mem[64] + 4] = ext_call.return_data[0]
                        require ext_code.size(lenders[idx])
                        staticcall lenders[idx].aprAfterDeposit(uint256 arg1) with:
                                gas gas_remaining wei
                               args ext_call.return_data[0]
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1499 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if mem[_1499] <= u:
                            idx = idx + 1
                            u = u
                            continue 
                        idx = idx + 1
                        u = mem[_1499]
                        continue 
                    require 0 < lenders.length
                    mem[0] = 13
                    mem[mem[64] + 4] = ext_call.return_data[0] + s
                    require ext_code.size(lenders)
                    staticcall lenders.aprAfterDeposit(uint256 arg1) with:
                            gas gas_remaining wei
                           args (ext_call.return_data[0] + s)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1498 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _1527 = mem[_1498]
                    if mem[_1498] <= t:
                        return 0
                    require 0 < lenders.length
                    mem[0] = 13
                    require ext_code.size(lenders)
                    staticcall lenders.nav() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1606 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _1631 = mem[_1606]
                    if not mem[_1606]:
                        _1699 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1699] = 26
                        mem[_1699 + 32] = 'SafeMath: division by zero'
                        _1745 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1745] = 26
                        mem[_1745 + 32] = 'SafeMath: division by zero'
                        if 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83 == wantAddress:
                            if not arg1:
                                return 0
                            if profitFactor * arg1 / arg1 != profitFactor:
                                revert with 0, 'SafeMath: multiplication overflow'
                            return (profitFactor * arg1 < 0)
                        if wantToEthOracleAddress:
                            mem[mem[64] + 4] = arg1
                            require ext_code.size(wantToEthOracleAddress)
                            staticcall wantToEthOracleAddress.0x780022a0 with:
                                    gas gas_remaining wei
                                   args arg1
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _1920 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if not mem[_1920]:
                                return 0
                            if profitFactor * mem[_1920] / mem[_1920] != profitFactor:
                                revert with 0, 'SafeMath: multiplication overflow'
                            mem[mem[64]] = profitFactor * mem[_1920] < 0
                        else:
                            _1807 = mem[64]
                            mem[mem[64]] = 2
                            mem[64] = mem[64] + 96
                            require 0 < mem[_1807]
                            mem[_1807 + 32] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                            require 1 < mem[_1807]
                            mem[_1807 + 64] = wantAddress
                            mem[_1807 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                            mem[_1807 + 100] = arg1
                            mem[_1807 + 132] = 64
                            mem[_1807 + 164] = mem[_1807]
                            idx = 0
                            s = _1807 + 196
                            t = _1807 + 32
                            while idx < mem[_1807]:
                                mem[s] = mem[t + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            require ext_code.size(0xf491e7b69e4244ad4002bc14e878a34207e38c29)
                            staticcall 0xf491e7b69e4244ad4002bc14e878a34207e38c29.mem[mem[64] len 4] with:
                                    gas gas_remaining wei
                                   args mem[mem[64] + 4 len _1807 + (32 * mem[_1807]) + -mem[64] + 192]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2813 = mem[64]
                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _2859 = mem[_2813]
                            require mem[_2813] <= test266151307()
                            require _2813 + return_data.size > _2813 + mem[_2813] + 31
                            _2900 = mem[_2813 + mem[_2813]]
                            require mem[_2813 + mem[_2813]] <= test266151307()
                            require (32 * mem[_2813 + mem[_2813]]) + 32 >= 0 and _2813 + ceil32(return_data.size) + (32 * mem[_2813 + mem[_2813]]) + 32 <= test266151307()
                            mem[64] = _2813 + ceil32(return_data.size) + (32 * mem[_2813 + mem[_2813]]) + 32
                            mem[_2813 + ceil32(return_data.size)] = _2900
                            require return_data.size >= _2859 + (32 * _2900) + 32
                            mem[_2813 + ceil32(return_data.size) + 32 len 32 * _2900] = mem[_2813 + _2859 + 32 len 32 * _2900]
                            require _2900 - 1 < _2900
                            if not mem[(32 * _2900 - 1) + _2813 + ceil32(return_data.size) + 32]:
                                return 0
                            if profitFactor * mem[(32 * _2900 - 1) + _2813 + ceil32(return_data.size) + 32] / mem[(32 * _2900 - 1) + _2813 + ceil32(return_data.size) + 32] != profitFactor:
                                revert with 0, 'SafeMath: multiplication overflow'
                            mem[mem[64]] = profitFactor * mem[(32 * _2900 - 1) + _2813 + ceil32(return_data.size) + 32] < 0
                    else:
                        if t * mem[_1606] / mem[_1606] != t:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not mem[_1606]:
                            _1708 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1708] = 26
                            mem[_1708 + 32] = 'SafeMath: division by zero'
                            if not -1 * t * _1631 / 10^18:
                                _1756 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1756] = 26
                                mem[_1756 + 32] = 'SafeMath: division by zero'
                                if 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83 == wantAddress:
                                    if not arg1:
                                        return 0
                                    if profitFactor * arg1 / arg1 != profitFactor:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    return (profitFactor * arg1 < 0)
                                if wantToEthOracleAddress:
                                    mem[mem[64] + 4] = arg1
                                    require ext_code.size(wantToEthOracleAddress)
                                    staticcall wantToEthOracleAddress.0x780022a0 with:
                                            gas gas_remaining wei
                                           args arg1
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _1949 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if not mem[_1949]:
                                        return 0
                                    if profitFactor * mem[_1949] / mem[_1949] != profitFactor:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[mem[64]] = profitFactor * mem[_1949] < 0
                                else:
                                    _1820 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    require 0 < mem[_1820]
                                    mem[_1820 + 32] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    require 1 < mem[_1820]
                                    mem[_1820 + 64] = wantAddress
                                    mem[_1820 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                    mem[_1820 + 100] = arg1
                                    mem[_1820 + 132] = 64
                                    mem[_1820 + 164] = mem[_1820]
                                    idx = 0
                                    s = _1820 + 196
                                    t = _1820 + 32
                                    while idx < mem[_1820]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(0xf491e7b69e4244ad4002bc14e878a34207e38c29)
                                    staticcall 0xf491e7b69e4244ad4002bc14e878a34207e38c29.mem[mem[64] len 4] with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4 len _1820 + (32 * mem[_1820]) + -mem[64] + 192]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _2812 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _2858 = mem[_2812]
                                    require mem[_2812] <= test266151307()
                                    require _2812 + return_data.size > _2812 + mem[_2812] + 31
                                    _2899 = mem[_2812 + mem[_2812]]
                                    require mem[_2812 + mem[_2812]] <= test266151307()
                                    require (32 * mem[_2812 + mem[_2812]]) + 32 >= 0 and _2812 + ceil32(return_data.size) + (32 * mem[_2812 + mem[_2812]]) + 32 <= test266151307()
                                    mem[64] = _2812 + ceil32(return_data.size) + (32 * mem[_2812 + mem[_2812]]) + 32
                                    mem[_2812 + ceil32(return_data.size)] = _2899
                                    require return_data.size >= _2858 + (32 * _2899) + 32
                                    mem[_2812 + ceil32(return_data.size) + 32 len 32 * _2899] = mem[_2812 + _2858 + 32 len 32 * _2899]
                                    require _2899 - 1 < _2899
                                    if not mem[(32 * _2899 - 1) + _2812 + ceil32(return_data.size) + 32]:
                                        return 0
                                    if profitFactor * mem[(32 * _2899 - 1) + _2812 + ceil32(return_data.size) + 32] / mem[(32 * _2899 - 1) + _2812 + ceil32(return_data.size) + 32] != profitFactor:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[mem[64]] = profitFactor * mem[(32 * _2899 - 1) + _2812 + ceil32(return_data.size) + 32] < 0
                            else:
                                if maxReportDelay * -1 * t * _1631 / 10^18 / -1 * t * _1631 / 10^18 != maxReportDelay:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _1766 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1766] = 26
                                mem[_1766 + 32] = 'SafeMath: division by zero'
                                if 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83 == wantAddress:
                                    if not arg1:
                                        return (0 < maxReportDelay * -1 * t * _1631 / 10^18 / 31556952)
                                    if profitFactor * arg1 / arg1 != profitFactor:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    return (profitFactor * arg1 < maxReportDelay * -1 * t * _1631 / 10^18 / 31556952)
                                if wantToEthOracleAddress:
                                    mem[mem[64] + 4] = arg1
                                    require ext_code.size(wantToEthOracleAddress)
                                    staticcall wantToEthOracleAddress.0x780022a0 with:
                                            gas gas_remaining wei
                                           args arg1
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _1976 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if not mem[_1976]:
                                        return (0 < maxReportDelay * -1 * t * _1631 / 10^18 / 31556952)
                                    if profitFactor * mem[_1976] / mem[_1976] != profitFactor:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[mem[64]] = profitFactor * mem[_1976] < maxReportDelay * -1 * t * _1631 / 10^18 / 31556952
                                else:
                                    _1841 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    require 0 < mem[_1841]
                                    mem[_1841 + 32] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    require 1 < mem[_1841]
                                    mem[_1841 + 64] = wantAddress
                                    mem[_1841 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                    mem[_1841 + 100] = arg1
                                    mem[_1841 + 132] = 64
                                    mem[_1841 + 164] = mem[_1841]
                                    idx = 0
                                    s = _1841 + 196
                                    u = _1841 + 32
                                    while idx < mem[_1841]:
                                        mem[s] = mem[u + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        u = u + 32
                                        continue 
                                    require ext_code.size(0xf491e7b69e4244ad4002bc14e878a34207e38c29)
                                    staticcall 0xf491e7b69e4244ad4002bc14e878a34207e38c29.mem[mem[64] len 4] with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4 len _1841 + (32 * mem[_1841]) + -mem[64] + 192]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _2811 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _2857 = mem[_2811]
                                    require mem[_2811] <= test266151307()
                                    require _2811 + return_data.size > _2811 + mem[_2811] + 31
                                    _2898 = mem[_2811 + mem[_2811]]
                                    require mem[_2811 + mem[_2811]] <= test266151307()
                                    require (32 * mem[_2811 + mem[_2811]]) + 32 >= 0 and _2811 + ceil32(return_data.size) + (32 * mem[_2811 + mem[_2811]]) + 32 <= test266151307()
                                    mem[64] = _2811 + ceil32(return_data.size) + (32 * mem[_2811 + mem[_2811]]) + 32
                                    mem[_2811 + ceil32(return_data.size)] = _2898
                                    require return_data.size >= _2857 + (32 * _2898) + 32
                                    mem[_2811 + ceil32(return_data.size) + 32 len 32 * _2898] = mem[_2811 + _2857 + 32 len 32 * _2898]
                                    require _2898 - 1 < _2898
                                    if not mem[(32 * _2898 - 1) + _2811 + ceil32(return_data.size) + 32]:
                                        return (0 < maxReportDelay * -1 * t * _1631 / 10^18 / 31556952)
                                    if profitFactor * mem[(32 * _2898 - 1) + _2811 + ceil32(return_data.size) + 32] / mem[(32 * _2898 - 1) + _2811 + ceil32(return_data.size) + 32] != profitFactor:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[mem[64]] = profitFactor * mem[(32 * _2898 - 1) + _2811 + ceil32(return_data.size) + 32] < maxReportDelay * -1 * t * _1631 / 10^18 / 31556952
                        else:
                            if _1527 * mem[_1606] / mem[_1606] != _1527:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _1713 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1713] = 26
                            mem[_1713 + 32] = 'SafeMath: division by zero'
                            if not (_1527 * _1631) - (t * _1631) / 10^18:
                                _1765 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1765] = 26
                                mem[_1765 + 32] = 'SafeMath: division by zero'
                                if 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83 == wantAddress:
                                    if not arg1:
                                        return 0
                                    if profitFactor * arg1 / arg1 != profitFactor:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    return (profitFactor * arg1 < 0)
                                if wantToEthOracleAddress:
                                    mem[mem[64] + 4] = arg1
                                    require ext_code.size(wantToEthOracleAddress)
                                    staticcall wantToEthOracleAddress.0x780022a0 with:
                                            gas gas_remaining wei
                                           args arg1
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _1975 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if not mem[_1975]:
                                        return 0
                                    if profitFactor * mem[_1975] / mem[_1975] != profitFactor:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[mem[64]] = profitFactor * mem[_1975] < 0
                                else:
                                    _1838 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    require 0 < mem[_1838]
                                    mem[_1838 + 32] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    require 1 < mem[_1838]
                                    mem[_1838 + 64] = wantAddress
                                    mem[_1838 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                    mem[_1838 + 100] = arg1
                                    mem[_1838 + 132] = 64
                                    mem[_1838 + 164] = mem[_1838]
                                    idx = 0
                                    s = _1838 + 196
                                    t = _1838 + 32
                                    while idx < mem[_1838]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(0xf491e7b69e4244ad4002bc14e878a34207e38c29)
                                    staticcall 0xf491e7b69e4244ad4002bc14e878a34207e38c29.mem[mem[64] len 4] with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4 len _1838 + (32 * mem[_1838]) + -mem[64] + 192]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _2810 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _2856 = mem[_2810]
                                    require mem[_2810] <= test266151307()
                                    require _2810 + return_data.size > _2810 + mem[_2810] + 31
                                    _2897 = mem[_2810 + mem[_2810]]
                                    require mem[_2810 + mem[_2810]] <= test266151307()
                                    require (32 * mem[_2810 + mem[_2810]]) + 32 >= 0 and _2810 + ceil32(return_data.size) + (32 * mem[_2810 + mem[_2810]]) + 32 <= test266151307()
                                    mem[64] = _2810 + ceil32(return_data.size) + (32 * mem[_2810 + mem[_2810]]) + 32
                                    mem[_2810 + ceil32(return_data.size)] = _2897
                                    require return_data.size >= _2856 + (32 * _2897) + 32
                                    mem[_2810 + ceil32(return_data.size) + 32 len 32 * _2897] = mem[_2810 + _2856 + 32 len 32 * _2897]
                                    require _2897 - 1 < _2897
                                    if not mem[(32 * _2897 - 1) + _2810 + ceil32(return_data.size) + 32]:
                                        return 0
                                    if profitFactor * mem[(32 * _2897 - 1) + _2810 + ceil32(return_data.size) + 32] / mem[(32 * _2897 - 1) + _2810 + ceil32(return_data.size) + 32] != profitFactor:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[mem[64]] = profitFactor * mem[(32 * _2897 - 1) + _2810 + ceil32(return_data.size) + 32] < 0
                            else:
                                if maxReportDelay * (_1527 * _1631) - (t * _1631) / 10^18 / (_1527 * _1631) - (t * _1631) / 10^18 != maxReportDelay:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _1778 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1778] = 26
                                mem[_1778 + 32] = 'SafeMath: division by zero'
                                if 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83 == wantAddress:
                                    if not arg1:
                                        return (0 < maxReportDelay * (_1527 * _1631) - (t * _1631) / 10^18 / 31556952)
                                    if profitFactor * arg1 / arg1 != profitFactor:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    return (profitFactor * arg1 < maxReportDelay * (_1527 * _1631) - (t * _1631) / 10^18 / 31556952)
                                if wantToEthOracleAddress:
                                    mem[mem[64] + 4] = arg1
                                    require ext_code.size(wantToEthOracleAddress)
                                    staticcall wantToEthOracleAddress.0x780022a0 with:
                                            gas gas_remaining wei
                                           args arg1
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _2005 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if not mem[_2005]:
                                        return (0 < maxReportDelay * (_1527 * _1631) - (t * _1631) / 10^18 / 31556952)
                                    if profitFactor * mem[_2005] / mem[_2005] != profitFactor:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[mem[64]] = profitFactor * mem[_2005] < maxReportDelay * (_1527 * _1631) - (t * _1631) / 10^18 / 31556952
                                else:
                                    _1878 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    require 0 < mem[_1878]
                                    mem[_1878 + 32] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    require 1 < mem[_1878]
                                    mem[_1878 + 64] = wantAddress
                                    mem[_1878 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                    mem[_1878 + 100] = arg1
                                    mem[_1878 + 132] = 64
                                    mem[_1878 + 164] = mem[_1878]
                                    idx = 0
                                    s = _1878 + 196
                                    u = _1878 + 32
                                    while idx < mem[_1878]:
                                        mem[s] = mem[u + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        u = u + 32
                                        continue 
                                    require ext_code.size(0xf491e7b69e4244ad4002bc14e878a34207e38c29)
                                    staticcall 0xf491e7b69e4244ad4002bc14e878a34207e38c29.mem[mem[64] len 4] with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4 len _1878 + (32 * mem[_1878]) + -mem[64] + 192]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _2809 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _2855 = mem[_2809]
                                    require mem[_2809] <= test266151307()
                                    require _2809 + return_data.size > _2809 + mem[_2809] + 31
                                    _2896 = mem[_2809 + mem[_2809]]
                                    require mem[_2809 + mem[_2809]] <= test266151307()
                                    require (32 * mem[_2809 + mem[_2809]]) + 32 >= 0 and _2809 + ceil32(return_data.size) + (32 * mem[_2809 + mem[_2809]]) + 32 <= test266151307()
                                    mem[64] = _2809 + ceil32(return_data.size) + (32 * mem[_2809 + mem[_2809]]) + 32
                                    mem[_2809 + ceil32(return_data.size)] = _2896
                                    require return_data.size >= _2855 + (32 * _2896) + 32
                                    mem[_2809 + ceil32(return_data.size) + 32 len 32 * _2896] = mem[_2809 + _2855 + 32 len 32 * _2896]
                                    require _2896 - 1 < _2896
                                    if not mem[(32 * _2896 - 1) + _2809 + ceil32(return_data.size) + 32]:
                                        return (0 < maxReportDelay * (_1527 * _1631) - (t * _1631) / 10^18 / 31556952)
                                    if profitFactor * mem[(32 * _2896 - 1) + _2809 + ceil32(return_data.size) + 32] / mem[(32 * _2896 - 1) + _2809 + ceil32(return_data.size) + 32] != profitFactor:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[mem[64]] = profitFactor * mem[(32 * _2896 - 1) + _2809 + ceil32(return_data.size) + 32] < maxReportDelay * (_1527 * _1631) - (t * _1631) / 10^18 / 31556952
                else:
                    mem[(2 * ceil32(return_data.size)) + 736] = 30
                    mem[(2 * ceil32(return_data.size)) + 768] = 'SafeMath: subtraction overflow'
                    if ext_call.return_data[160] > block.timestamp:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if block.timestamp - ext_call.return_data[160] >= maxReportDelay:
                        return 0
                    require ext_code.size(vaultAddress)
                    staticcall vaultAddress.debtOutstanding() with:
                            gas gas_remaining wei
                    mem[(2 * ceil32(return_data.size)) + 800] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = (4 * ceil32(return_data.size)) + 800
                    require return_data.size >= 32
                    if ext_call.return_data[0] > debtThreshold:
                        return 0
                    idx = 0
                    s = 0
                    while idx < lenders.length:
                        mem[0] = 13
                        require ext_code.size(lenders[idx])
                        staticcall lenders[idx].nav() with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _781 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if mem[_781] + s < s:
                            revert with 0, 'SafeMath: addition overflow'
                        idx = idx + 1
                        s = mem[_781] + s
                        continue 
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(wantAddress)
                    staticcall wantAddress.balanceOf(address arg1) with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _801 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _818 = mem[_801]
                    if mem[_801] + (_802 * lenders.length) < _802 * lenders.length:
                        revert with 0, 'SafeMath: addition overflow'
                    if debtThreshold < 0:
                        revert with 0, 'SafeMath: addition overflow'
                    if debtThreshold + mem[_801] + (_802 * lenders.length) < mem[(2 * ceil32(return_data.size)) + 576]:
                        return 0
                    if mem[_801] + (_802 * lenders.length) <= mem[(2 * ceil32(return_data.size)) + 576]:
                        require ext_code.size(vaultAddress)
                        staticcall vaultAddress.creditAvailable() with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _893 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if mem[_893] < mem[_893]:
                            revert with 0, 'SafeMath: addition overflow'
                        if not profitFactor:
                            if 0 < mem[_893]:
                                return 0
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(wantAddress)
                            staticcall wantAddress.balanceOf(address arg1) with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _975 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _985 = mem[_975]
                            idx = 0
                            s = 0
                            t = -1
                            while idx < lenders.length:
                                mem[0] = 13
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].hasAssets() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _1465 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_1465] == bool(mem[_1465])
                                if not mem[_1465]:
                                    idx = idx + 1
                                    s = s
                                    t = t
                                    continue 
                                require idx < lenders.length
                                mem[0] = 13
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].apr() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _1602 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _1628 = mem[_1602]
                                if mem[_1602] >= t:
                                    idx = idx + 1
                                    s = s
                                    t = t
                                    continue 
                                require idx < lenders.length
                                mem[0] = 13
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].nav() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _1668 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                idx = idx + 1
                                s = mem[_1668]
                                t = _1628
                                continue 
                            if _985 + s < s:
                                revert with 0, 'SafeMath: addition overflow'
                            idx = 0
                            u = 0
                            while idx < lenders.length:
                                mem[0] = 13
                                mem[mem[64] + 4] = _985
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].aprAfterDeposit(uint256 arg1) with:
                                        gas gas_remaining wei
                                       args _985
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _2850 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if mem[_2850] <= u:
                                    idx = idx + 1
                                    u = u
                                    continue 
                                idx = idx + 1
                                u = mem[_2850]
                                continue 
                            require 0 < lenders.length
                            mem[0] = 13
                            mem[mem[64] + 4] = _985 + s
                            require ext_code.size(lenders)
                            staticcall lenders.aprAfterDeposit(uint256 arg1) with:
                                    gas gas_remaining wei
                                   args (_985 + s)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2849 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _2890 = mem[_2849]
                            if mem[_2849] <= t:
                                return 0
                            require 0 < lenders.length
                            mem[0] = 13
                            require ext_code.size(lenders)
                            staticcall lenders.nav() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2998 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _3015 = mem[_2998]
                            if not mem[_2998]:
                                _3168 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3168] = 26
                                mem[_3168 + 32] = 'SafeMath: division by zero'
                                _3324 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3324] = 26
                                mem[_3324 + 32] = 'SafeMath: division by zero'
                                if 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83 == wantAddress:
                                    if not arg1:
                                        return 0
                                    if profitFactor * arg1 / arg1 != profitFactor:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    return (profitFactor * arg1 < 0)
                                if wantToEthOracleAddress:
                                    mem[mem[64] + 4] = arg1
                                    require ext_code.size(wantToEthOracleAddress)
                                    staticcall wantToEthOracleAddress.0x780022a0 with:
                                            gas gas_remaining wei
                                           args arg1
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _3632 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if not mem[_3632]:
                                        return 0
                                    if profitFactor * mem[_3632] / mem[_3632] != profitFactor:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[mem[64]] = profitFactor * mem[_3632] < 0
                                else:
                                    _3419 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    require 0 < mem[_3419]
                                    mem[_3419 + 32] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    require 1 < mem[_3419]
                                    mem[_3419 + 64] = wantAddress
                                    mem[_3419 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                    mem[_3419 + 100] = arg1
                                    mem[_3419 + 132] = 64
                                    mem[_3419 + 164] = mem[_3419]
                                    idx = 0
                                    s = _3419 + 196
                                    t = _3419 + 32
                                    while idx < mem[_3419]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(0xf491e7b69e4244ad4002bc14e878a34207e38c29)
                                    staticcall 0xf491e7b69e4244ad4002bc14e878a34207e38c29.mem[mem[64] len 4] with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4 len _3419 + (32 * mem[_3419]) + -mem[64] + 192]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5181 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _5235 = mem[_5181]
                                    require mem[_5181] <= test266151307()
                                    require _5181 + return_data.size > _5181 + mem[_5181] + 31
                                    _5287 = mem[_5181 + mem[_5181]]
                                    require mem[_5181 + mem[_5181]] <= test266151307()
                                    require (32 * mem[_5181 + mem[_5181]]) + 32 >= 0 and _5181 + ceil32(return_data.size) + (32 * mem[_5181 + mem[_5181]]) + 32 <= test266151307()
                                    mem[64] = _5181 + ceil32(return_data.size) + (32 * mem[_5181 + mem[_5181]]) + 32
                                    mem[_5181 + ceil32(return_data.size)] = _5287
                                    require return_data.size >= _5235 + (32 * _5287) + 32
                                    mem[_5181 + ceil32(return_data.size) + 32 len 32 * _5287] = mem[_5181 + _5235 + 32 len 32 * _5287]
                                    require _5287 - 1 < _5287
                                    if not mem[(32 * _5287 - 1) + _5181 + ceil32(return_data.size) + 32]:
                                        return 0
                                    if profitFactor * mem[(32 * _5287 - 1) + _5181 + ceil32(return_data.size) + 32] / mem[(32 * _5287 - 1) + _5181 + ceil32(return_data.size) + 32] != profitFactor:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[mem[64]] = profitFactor * mem[(32 * _5287 - 1) + _5181 + ceil32(return_data.size) + 32] < 0
                            else:
                                if t * mem[_2998] / mem[_2998] != t:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not mem[_2998]:
                                    _3223 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3223] = 26
                                    mem[_3223 + 32] = 'SafeMath: division by zero'
                                    if not -1 * t * _3015 / 10^18:
                                        _3342 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3342] = 26
                                        mem[_3342 + 32] = 'SafeMath: division by zero'
                                        if 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83 == wantAddress:
                                            if not arg1:
                                                return 0
                                            if profitFactor * arg1 / arg1 != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            return (profitFactor * arg1 < 0)
                                        if wantToEthOracleAddress:
                                            mem[mem[64] + 4] = arg1
                                            require ext_code.size(wantToEthOracleAddress)
                                            staticcall wantToEthOracleAddress.0x780022a0 with:
                                                    gas gas_remaining wei
                                                   args arg1
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _3691 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if not mem[_3691]:
                                                return 0
                                            if profitFactor * mem[_3691] / mem[_3691] != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[mem[64]] = profitFactor * mem[_3691] < 0
                                        else:
                                            _3447 = mem[64]
                                            mem[mem[64]] = 2
                                            mem[64] = mem[64] + 96
                                            require 0 < mem[_3447]
                                            mem[_3447 + 32] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                            require 1 < mem[_3447]
                                            mem[_3447 + 64] = wantAddress
                                            mem[_3447 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[_3447 + 100] = arg1
                                            mem[_3447 + 132] = 64
                                            mem[_3447 + 164] = mem[_3447]
                                            idx = 0
                                            s = _3447 + 196
                                            t = _3447 + 32
                                            while idx < mem[_3447]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            require ext_code.size(0xf491e7b69e4244ad4002bc14e878a34207e38c29)
                                            staticcall 0xf491e7b69e4244ad4002bc14e878a34207e38c29.mem[mem[64] len 4] with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4 len _3447 + (32 * mem[_3447]) + -mem[64] + 192]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5180 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _5234 = mem[_5180]
                                            require mem[_5180] <= test266151307()
                                            require _5180 + return_data.size > _5180 + mem[_5180] + 31
                                            _5286 = mem[_5180 + mem[_5180]]
                                            require mem[_5180 + mem[_5180]] <= test266151307()
                                            require (32 * mem[_5180 + mem[_5180]]) + 32 >= 0 and _5180 + ceil32(return_data.size) + (32 * mem[_5180 + mem[_5180]]) + 32 <= test266151307()
                                            mem[64] = _5180 + ceil32(return_data.size) + (32 * mem[_5180 + mem[_5180]]) + 32
                                            mem[_5180 + ceil32(return_data.size)] = _5286
                                            require return_data.size >= _5234 + (32 * _5286) + 32
                                            mem[_5180 + ceil32(return_data.size) + 32 len 32 * _5286] = mem[_5180 + _5234 + 32 len 32 * _5286]
                                            require _5286 - 1 < _5286
                                            if not mem[(32 * _5286 - 1) + _5180 + ceil32(return_data.size) + 32]:
                                                return 0
                                            if profitFactor * mem[(32 * _5286 - 1) + _5180 + ceil32(return_data.size) + 32] / mem[(32 * _5286 - 1) + _5180 + ceil32(return_data.size) + 32] != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[mem[64]] = profitFactor * mem[(32 * _5286 - 1) + _5180 + ceil32(return_data.size) + 32] < 0
                                    else:
                                        if maxReportDelay * -1 * t * _3015 / 10^18 / -1 * t * _3015 / 10^18 != maxReportDelay:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _3361 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3361] = 26
                                        mem[_3361 + 32] = 'SafeMath: division by zero'
                                        if 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83 == wantAddress:
                                            if not arg1:
                                                return (0 < maxReportDelay * -1 * t * _3015 / 10^18 / 31556952)
                                            if profitFactor * arg1 / arg1 != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            return (profitFactor * arg1 < maxReportDelay * -1 * t * _3015 / 10^18 / 31556952)
                                        if wantToEthOracleAddress:
                                            mem[mem[64] + 4] = arg1
                                            require ext_code.size(wantToEthOracleAddress)
                                            staticcall wantToEthOracleAddress.0x780022a0 with:
                                                    gas gas_remaining wei
                                                   args arg1
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _3750 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if not mem[_3750]:
                                                return (0 < maxReportDelay * -1 * t * _3015 / 10^18 / 31556952)
                                            if profitFactor * mem[_3750] / mem[_3750] != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[mem[64]] = profitFactor * mem[_3750] < maxReportDelay * -1 * t * _3015 / 10^18 / 31556952
                                        else:
                                            _3490 = mem[64]
                                            mem[mem[64]] = 2
                                            mem[64] = mem[64] + 96
                                            require 0 < mem[_3490]
                                            mem[_3490 + 32] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                            require 1 < mem[_3490]
                                            mem[_3490 + 64] = wantAddress
                                            mem[_3490 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[_3490 + 100] = arg1
                                            mem[_3490 + 132] = 64
                                            mem[_3490 + 164] = mem[_3490]
                                            idx = 0
                                            s = _3490 + 196
                                            u = _3490 + 32
                                            while idx < mem[_3490]:
                                                mem[s] = mem[u + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                u = u + 32
                                                continue 
                                            require ext_code.size(0xf491e7b69e4244ad4002bc14e878a34207e38c29)
                                            staticcall 0xf491e7b69e4244ad4002bc14e878a34207e38c29.mem[mem[64] len 4] with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4 len _3490 + (32 * mem[_3490]) + -mem[64] + 192]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5179 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _5233 = mem[_5179]
                                            require mem[_5179] <= test266151307()
                                            require _5179 + return_data.size > _5179 + mem[_5179] + 31
                                            _5285 = mem[_5179 + mem[_5179]]
                                            require mem[_5179 + mem[_5179]] <= test266151307()
                                            require (32 * mem[_5179 + mem[_5179]]) + 32 >= 0 and _5179 + ceil32(return_data.size) + (32 * mem[_5179 + mem[_5179]]) + 32 <= test266151307()
                                            mem[64] = _5179 + ceil32(return_data.size) + (32 * mem[_5179 + mem[_5179]]) + 32
                                            mem[_5179 + ceil32(return_data.size)] = _5285
                                            require return_data.size >= _5233 + (32 * _5285) + 32
                                            mem[_5179 + ceil32(return_data.size) + 32 len 32 * _5285] = mem[_5179 + _5233 + 32 len 32 * _5285]
                                            require _5285 - 1 < _5285
                                            if not mem[(32 * _5285 - 1) + _5179 + ceil32(return_data.size) + 32]:
                                                return (0 < maxReportDelay * -1 * t * _3015 / 10^18 / 31556952)
                                            if profitFactor * mem[(32 * _5285 - 1) + _5179 + ceil32(return_data.size) + 32] / mem[(32 * _5285 - 1) + _5179 + ceil32(return_data.size) + 32] != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[mem[64]] = profitFactor * mem[(32 * _5285 - 1) + _5179 + ceil32(return_data.size) + 32] < maxReportDelay * -1 * t * _3015 / 10^18 / 31556952
                                else:
                                    if _2890 * mem[_2998] / mem[_2998] != _2890:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _3253 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3253] = 26
                                    mem[_3253 + 32] = 'SafeMath: division by zero'
                                    if not (_2890 * _3015) - (t * _3015) / 10^18:
                                        _3360 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3360] = 26
                                        mem[_3360 + 32] = 'SafeMath: division by zero'
                                        if 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83 == wantAddress:
                                            if not arg1:
                                                return 0
                                            if profitFactor * arg1 / arg1 != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            return (profitFactor * arg1 < 0)
                                        if wantToEthOracleAddress:
                                            mem[mem[64] + 4] = arg1
                                            require ext_code.size(wantToEthOracleAddress)
                                            staticcall wantToEthOracleAddress.0x780022a0 with:
                                                    gas gas_remaining wei
                                                   args arg1
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _3749 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if not mem[_3749]:
                                                return 0
                                            if profitFactor * mem[_3749] / mem[_3749] != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[mem[64]] = profitFactor * mem[_3749] < 0
                                        else:
                                            _3487 = mem[64]
                                            mem[mem[64]] = 2
                                            mem[64] = mem[64] + 96
                                            require 0 < mem[_3487]
                                            mem[_3487 + 32] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                            require 1 < mem[_3487]
                                            mem[_3487 + 64] = wantAddress
                                            mem[_3487 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[_3487 + 100] = arg1
                                            mem[_3487 + 132] = 64
                                            mem[_3487 + 164] = mem[_3487]
                                            idx = 0
                                            s = _3487 + 196
                                            t = _3487 + 32
                                            while idx < mem[_3487]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            require ext_code.size(0xf491e7b69e4244ad4002bc14e878a34207e38c29)
                                            staticcall 0xf491e7b69e4244ad4002bc14e878a34207e38c29.mem[mem[64] len 4] with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4 len _3487 + (32 * mem[_3487]) + -mem[64] + 192]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5178 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _5232 = mem[_5178]
                                            require mem[_5178] <= test266151307()
                                            require _5178 + return_data.size > _5178 + mem[_5178] + 31
                                            _5284 = mem[_5178 + mem[_5178]]
                                            require mem[_5178 + mem[_5178]] <= test266151307()
                                            require (32 * mem[_5178 + mem[_5178]]) + 32 >= 0 and _5178 + ceil32(return_data.size) + (32 * mem[_5178 + mem[_5178]]) + 32 <= test266151307()
                                            mem[64] = _5178 + ceil32(return_data.size) + (32 * mem[_5178 + mem[_5178]]) + 32
                                            mem[_5178 + ceil32(return_data.size)] = _5284
                                            require return_data.size >= _5232 + (32 * _5284) + 32
                                            mem[_5178 + ceil32(return_data.size) + 32 len 32 * _5284] = mem[_5178 + _5232 + 32 len 32 * _5284]
                                            require _5284 - 1 < _5284
                                            if not mem[(32 * _5284 - 1) + _5178 + ceil32(return_data.size) + 32]:
                                                return 0
                                            if profitFactor * mem[(32 * _5284 - 1) + _5178 + ceil32(return_data.size) + 32] / mem[(32 * _5284 - 1) + _5178 + ceil32(return_data.size) + 32] != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[mem[64]] = profitFactor * mem[(32 * _5284 - 1) + _5178 + ceil32(return_data.size) + 32] < 0
                                    else:
                                        if maxReportDelay * (_2890 * _3015) - (t * _3015) / 10^18 / (_2890 * _3015) - (t * _3015) / 10^18 != maxReportDelay:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _3385 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3385] = 26
                                        mem[_3385 + 32] = 'SafeMath: division by zero'
                                        if 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83 == wantAddress:
                                            if not arg1:
                                                return (0 < maxReportDelay * (_2890 * _3015) - (t * _3015) / 10^18 / 31556952)
                                            if profitFactor * arg1 / arg1 != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            return (profitFactor * arg1 < maxReportDelay * (_2890 * _3015) - (t * _3015) / 10^18 / 31556952)
                                        if wantToEthOracleAddress:
                                            mem[mem[64] + 4] = arg1
                                            require ext_code.size(wantToEthOracleAddress)
                                            staticcall wantToEthOracleAddress.0x780022a0 with:
                                                    gas gas_remaining wei
                                                   args arg1
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _3809 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if not mem[_3809]:
                                                return (0 < maxReportDelay * (_2890 * _3015) - (t * _3015) / 10^18 / 31556952)
                                            if profitFactor * mem[_3809] / mem[_3809] != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[mem[64]] = profitFactor * mem[_3809] < maxReportDelay * (_2890 * _3015) - (t * _3015) / 10^18 / 31556952
                                        else:
                                            _3560 = mem[64]
                                            mem[mem[64]] = 2
                                            mem[64] = mem[64] + 96
                                            require 0 < mem[_3560]
                                            mem[_3560 + 32] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                            require 1 < mem[_3560]
                                            mem[_3560 + 64] = wantAddress
                                            mem[_3560 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[_3560 + 100] = arg1
                                            mem[_3560 + 132] = 64
                                            mem[_3560 + 164] = mem[_3560]
                                            idx = 0
                                            s = _3560 + 196
                                            u = _3560 + 32
                                            while idx < mem[_3560]:
                                                mem[s] = mem[u + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                u = u + 32
                                                continue 
                                            require ext_code.size(0xf491e7b69e4244ad4002bc14e878a34207e38c29)
                                            staticcall 0xf491e7b69e4244ad4002bc14e878a34207e38c29.mem[mem[64] len 4] with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4 len _3560 + (32 * mem[_3560]) + -mem[64] + 192]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5177 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _5231 = mem[_5177]
                                            require mem[_5177] <= test266151307()
                                            require _5177 + return_data.size > _5177 + mem[_5177] + 31
                                            _5283 = mem[_5177 + mem[_5177]]
                                            require mem[_5177 + mem[_5177]] <= test266151307()
                                            require (32 * mem[_5177 + mem[_5177]]) + 32 >= 0 and _5177 + ceil32(return_data.size) + (32 * mem[_5177 + mem[_5177]]) + 32 <= test266151307()
                                            mem[64] = _5177 + ceil32(return_data.size) + (32 * mem[_5177 + mem[_5177]]) + 32
                                            mem[_5177 + ceil32(return_data.size)] = _5283
                                            require return_data.size >= _5231 + (32 * _5283) + 32
                                            mem[_5177 + ceil32(return_data.size) + 32 len 32 * _5283] = mem[_5177 + _5231 + 32 len 32 * _5283]
                                            require _5283 - 1 < _5283
                                            if not mem[(32 * _5283 - 1) + _5177 + ceil32(return_data.size) + 32]:
                                                return (0 < maxReportDelay * (_2890 * _3015) - (t * _3015) / 10^18 / 31556952)
                                            if profitFactor * mem[(32 * _5283 - 1) + _5177 + ceil32(return_data.size) + 32] / mem[(32 * _5283 - 1) + _5177 + ceil32(return_data.size) + 32] != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[mem[64]] = profitFactor * mem[(32 * _5283 - 1) + _5177 + ceil32(return_data.size) + 32] < maxReportDelay * (_2890 * _3015) - (t * _3015) / 10^18 / 31556952
                        else:
                            if ext_call.return_data[0] * profitFactor / profitFactor != ext_call.return_data[0]:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if ext_call.return_data[0] * profitFactor < mem[_893]:
                                return 0
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(wantAddress)
                            staticcall wantAddress.balanceOf(address arg1) with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _979 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _990 = mem[_979]
                            idx = 0
                            s = 0
                            t = -1
                            while idx < lenders.length:
                                mem[0] = 13
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].hasAssets() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _1464 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_1464] == bool(mem[_1464])
                                if not mem[_1464]:
                                    idx = idx + 1
                                    s = s
                                    t = t
                                    continue 
                                require idx < lenders.length
                                mem[0] = 13
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].apr() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _1601 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _1627 = mem[_1601]
                                if mem[_1601] >= t:
                                    idx = idx + 1
                                    s = s
                                    t = t
                                    continue 
                                require idx < lenders.length
                                mem[0] = 13
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].nav() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _1667 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                idx = idx + 1
                                s = mem[_1667]
                                t = _1627
                                continue 
                            if _990 + s < s:
                                revert with 0, 'SafeMath: addition overflow'
                            idx = 0
                            u = 0
                            while idx < lenders.length:
                                mem[0] = 13
                                mem[mem[64] + 4] = _990
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].aprAfterDeposit(uint256 arg1) with:
                                        gas gas_remaining wei
                                       args _990
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _2848 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if mem[_2848] <= u:
                                    idx = idx + 1
                                    u = u
                                    continue 
                                idx = idx + 1
                                u = mem[_2848]
                                continue 
                            require 0 < lenders.length
                            mem[0] = 13
                            mem[mem[64] + 4] = _990 + s
                            require ext_code.size(lenders)
                            staticcall lenders.aprAfterDeposit(uint256 arg1) with:
                                    gas gas_remaining wei
                                   args (_990 + s)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2847 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _2888 = mem[_2847]
                            if mem[_2847] <= t:
                                return 0
                            require 0 < lenders.length
                            mem[0] = 13
                            require ext_code.size(lenders)
                            staticcall lenders.nav() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2996 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _3014 = mem[_2996]
                            if not mem[_2996]:
                                _3166 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3166] = 26
                                mem[_3166 + 32] = 'SafeMath: division by zero'
                                _3322 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3322] = 26
                                mem[_3322 + 32] = 'SafeMath: division by zero'
                                if 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83 == wantAddress:
                                    if not arg1:
                                        return 0
                                    if profitFactor * arg1 / arg1 != profitFactor:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    return (profitFactor * arg1 < 0)
                                if wantToEthOracleAddress:
                                    mem[mem[64] + 4] = arg1
                                    require ext_code.size(wantToEthOracleAddress)
                                    staticcall wantToEthOracleAddress.0x780022a0 with:
                                            gas gas_remaining wei
                                           args arg1
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _3625 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if not mem[_3625]:
                                        return 0
                                    if profitFactor * mem[_3625] / mem[_3625] != profitFactor:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[mem[64]] = profitFactor * mem[_3625] < 0
                                else:
                                    _3416 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    require 0 < mem[_3416]
                                    mem[_3416 + 32] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    require 1 < mem[_3416]
                                    mem[_3416 + 64] = wantAddress
                                    mem[_3416 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                    mem[_3416 + 100] = arg1
                                    mem[_3416 + 132] = 64
                                    mem[_3416 + 164] = mem[_3416]
                                    idx = 0
                                    s = _3416 + 196
                                    t = _3416 + 32
                                    while idx < mem[_3416]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(0xf491e7b69e4244ad4002bc14e878a34207e38c29)
                                    staticcall 0xf491e7b69e4244ad4002bc14e878a34207e38c29.mem[mem[64] len 4] with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4 len _3416 + (32 * mem[_3416]) + -mem[64] + 192]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5176 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _5230 = mem[_5176]
                                    require mem[_5176] <= test266151307()
                                    require _5176 + return_data.size > _5176 + mem[_5176] + 31
                                    _5282 = mem[_5176 + mem[_5176]]
                                    require mem[_5176 + mem[_5176]] <= test266151307()
                                    require (32 * mem[_5176 + mem[_5176]]) + 32 >= 0 and _5176 + ceil32(return_data.size) + (32 * mem[_5176 + mem[_5176]]) + 32 <= test266151307()
                                    mem[64] = _5176 + ceil32(return_data.size) + (32 * mem[_5176 + mem[_5176]]) + 32
                                    mem[_5176 + ceil32(return_data.size)] = _5282
                                    require return_data.size >= _5230 + (32 * _5282) + 32
                                    mem[_5176 + ceil32(return_data.size) + 32 len 32 * _5282] = mem[_5176 + _5230 + 32 len 32 * _5282]
                                    require _5282 - 1 < _5282
                                    if not mem[(32 * _5282 - 1) + _5176 + ceil32(return_data.size) + 32]:
                                        return 0
                                    if profitFactor * mem[(32 * _5282 - 1) + _5176 + ceil32(return_data.size) + 32] / mem[(32 * _5282 - 1) + _5176 + ceil32(return_data.size) + 32] != profitFactor:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[mem[64]] = profitFactor * mem[(32 * _5282 - 1) + _5176 + ceil32(return_data.size) + 32] < 0
                            else:
                                if t * mem[_2996] / mem[_2996] != t:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not mem[_2996]:
                                    _3222 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3222] = 26
                                    mem[_3222 + 32] = 'SafeMath: division by zero'
                                    if not -1 * t * _3014 / 10^18:
                                        _3340 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3340] = 26
                                        mem[_3340 + 32] = 'SafeMath: division by zero'
                                        if 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83 == wantAddress:
                                            if not arg1:
                                                return 0
                                            if profitFactor * arg1 / arg1 != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            return (profitFactor * arg1 < 0)
                                        if wantToEthOracleAddress:
                                            mem[mem[64] + 4] = arg1
                                            require ext_code.size(wantToEthOracleAddress)
                                            staticcall wantToEthOracleAddress.0x780022a0 with:
                                                    gas gas_remaining wei
                                                   args arg1
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _3684 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if not mem[_3684]:
                                                return 0
                                            if profitFactor * mem[_3684] / mem[_3684] != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[mem[64]] = profitFactor * mem[_3684] < 0
                                        else:
                                            _3443 = mem[64]
                                            mem[mem[64]] = 2
                                            mem[64] = mem[64] + 96
                                            require 0 < mem[_3443]
                                            mem[_3443 + 32] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                            require 1 < mem[_3443]
                                            mem[_3443 + 64] = wantAddress
                                            mem[_3443 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[_3443 + 100] = arg1
                                            mem[_3443 + 132] = 64
                                            mem[_3443 + 164] = mem[_3443]
                                            idx = 0
                                            s = _3443 + 196
                                            t = _3443 + 32
                                            while idx < mem[_3443]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            require ext_code.size(0xf491e7b69e4244ad4002bc14e878a34207e38c29)
                                            staticcall 0xf491e7b69e4244ad4002bc14e878a34207e38c29.mem[mem[64] len 4] with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4 len _3443 + (32 * mem[_3443]) + -mem[64] + 192]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5175 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _5229 = mem[_5175]
                                            require mem[_5175] <= test266151307()
                                            require _5175 + return_data.size > _5175 + mem[_5175] + 31
                                            _5281 = mem[_5175 + mem[_5175]]
                                            require mem[_5175 + mem[_5175]] <= test266151307()
                                            require (32 * mem[_5175 + mem[_5175]]) + 32 >= 0 and _5175 + ceil32(return_data.size) + (32 * mem[_5175 + mem[_5175]]) + 32 <= test266151307()
                                            mem[64] = _5175 + ceil32(return_data.size) + (32 * mem[_5175 + mem[_5175]]) + 32
                                            mem[_5175 + ceil32(return_data.size)] = _5281
                                            require return_data.size >= _5229 + (32 * _5281) + 32
                                            mem[_5175 + ceil32(return_data.size) + 32 len 32 * _5281] = mem[_5175 + _5229 + 32 len 32 * _5281]
                                            require _5281 - 1 < _5281
                                            if not mem[(32 * _5281 - 1) + _5175 + ceil32(return_data.size) + 32]:
                                                return 0
                                            if profitFactor * mem[(32 * _5281 - 1) + _5175 + ceil32(return_data.size) + 32] / mem[(32 * _5281 - 1) + _5175 + ceil32(return_data.size) + 32] != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[mem[64]] = profitFactor * mem[(32 * _5281 - 1) + _5175 + ceil32(return_data.size) + 32] < 0
                                    else:
                                        if maxReportDelay * -1 * t * _3014 / 10^18 / -1 * t * _3014 / 10^18 != maxReportDelay:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _3358 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3358] = 26
                                        mem[_3358 + 32] = 'SafeMath: division by zero'
                                        if 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83 == wantAddress:
                                            if not arg1:
                                                return (0 < maxReportDelay * -1 * t * _3014 / 10^18 / 31556952)
                                            if profitFactor * arg1 / arg1 != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            return (profitFactor * arg1 < maxReportDelay * -1 * t * _3014 / 10^18 / 31556952)
                                        if wantToEthOracleAddress:
                                            mem[mem[64] + 4] = arg1
                                            require ext_code.size(wantToEthOracleAddress)
                                            staticcall wantToEthOracleAddress.0x780022a0 with:
                                                    gas gas_remaining wei
                                                   args arg1
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _3743 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if not mem[_3743]:
                                                return (0 < maxReportDelay * -1 * t * _3014 / 10^18 / 31556952)
                                            if profitFactor * mem[_3743] / mem[_3743] != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[mem[64]] = profitFactor * mem[_3743] < maxReportDelay * -1 * t * _3014 / 10^18 / 31556952
                                        else:
                                            _3481 = mem[64]
                                            mem[mem[64]] = 2
                                            mem[64] = mem[64] + 96
                                            require 0 < mem[_3481]
                                            mem[_3481 + 32] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                            require 1 < mem[_3481]
                                            mem[_3481 + 64] = wantAddress
                                            mem[_3481 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[_3481 + 100] = arg1
                                            mem[_3481 + 132] = 64
                                            mem[_3481 + 164] = mem[_3481]
                                            idx = 0
                                            s = _3481 + 196
                                            u = _3481 + 32
                                            while idx < mem[_3481]:
                                                mem[s] = mem[u + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                u = u + 32
                                                continue 
                                            require ext_code.size(0xf491e7b69e4244ad4002bc14e878a34207e38c29)
                                            staticcall 0xf491e7b69e4244ad4002bc14e878a34207e38c29.mem[mem[64] len 4] with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4 len _3481 + (32 * mem[_3481]) + -mem[64] + 192]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5174 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _5228 = mem[_5174]
                                            require mem[_5174] <= test266151307()
                                            require _5174 + return_data.size > _5174 + mem[_5174] + 31
                                            _5280 = mem[_5174 + mem[_5174]]
                                            require mem[_5174 + mem[_5174]] <= test266151307()
                                            require (32 * mem[_5174 + mem[_5174]]) + 32 >= 0 and _5174 + ceil32(return_data.size) + (32 * mem[_5174 + mem[_5174]]) + 32 <= test266151307()
                                            mem[64] = _5174 + ceil32(return_data.size) + (32 * mem[_5174 + mem[_5174]]) + 32
                                            mem[_5174 + ceil32(return_data.size)] = _5280
                                            require return_data.size >= _5228 + (32 * _5280) + 32
                                            mem[_5174 + ceil32(return_data.size) + 32 len 32 * _5280] = mem[_5174 + _5228 + 32 len 32 * _5280]
                                            require _5280 - 1 < _5280
                                            if not mem[(32 * _5280 - 1) + _5174 + ceil32(return_data.size) + 32]:
                                                return (0 < maxReportDelay * -1 * t * _3014 / 10^18 / 31556952)
                                            if profitFactor * mem[(32 * _5280 - 1) + _5174 + ceil32(return_data.size) + 32] / mem[(32 * _5280 - 1) + _5174 + ceil32(return_data.size) + 32] != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[mem[64]] = profitFactor * mem[(32 * _5280 - 1) + _5174 + ceil32(return_data.size) + 32] < maxReportDelay * -1 * t * _3014 / 10^18 / 31556952
                                else:
                                    if _2888 * mem[_2996] / mem[_2996] != _2888:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _3251 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3251] = 26
                                    mem[_3251 + 32] = 'SafeMath: division by zero'
                                    if not (_2888 * _3014) - (t * _3014) / 10^18:
                                        _3357 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3357] = 26
                                        mem[_3357 + 32] = 'SafeMath: division by zero'
                                        if 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83 == wantAddress:
                                            if not arg1:
                                                return 0
                                            if profitFactor * arg1 / arg1 != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            return (profitFactor * arg1 < 0)
                                        if wantToEthOracleAddress:
                                            mem[mem[64] + 4] = arg1
                                            require ext_code.size(wantToEthOracleAddress)
                                            staticcall wantToEthOracleAddress.0x780022a0 with:
                                                    gas gas_remaining wei
                                                   args arg1
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _3742 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if not mem[_3742]:
                                                return 0
                                            if profitFactor * mem[_3742] / mem[_3742] != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[mem[64]] = profitFactor * mem[_3742] < 0
                                        else:
                                            _3478 = mem[64]
                                            mem[mem[64]] = 2
                                            mem[64] = mem[64] + 96
                                            require 0 < mem[_3478]
                                            mem[_3478 + 32] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                            require 1 < mem[_3478]
                                            mem[_3478 + 64] = wantAddress
                                            mem[_3478 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[_3478 + 100] = arg1
                                            mem[_3478 + 132] = 64
                                            mem[_3478 + 164] = mem[_3478]
                                            idx = 0
                                            s = _3478 + 196
                                            t = _3478 + 32
                                            while idx < mem[_3478]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            require ext_code.size(0xf491e7b69e4244ad4002bc14e878a34207e38c29)
                                            staticcall 0xf491e7b69e4244ad4002bc14e878a34207e38c29.mem[mem[64] len 4] with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4 len _3478 + (32 * mem[_3478]) + -mem[64] + 192]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5173 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _5227 = mem[_5173]
                                            require mem[_5173] <= test266151307()
                                            require _5173 + return_data.size > _5173 + mem[_5173] + 31
                                            _5279 = mem[_5173 + mem[_5173]]
                                            require mem[_5173 + mem[_5173]] <= test266151307()
                                            require (32 * mem[_5173 + mem[_5173]]) + 32 >= 0 and _5173 + ceil32(return_data.size) + (32 * mem[_5173 + mem[_5173]]) + 32 <= test266151307()
                                            mem[64] = _5173 + ceil32(return_data.size) + (32 * mem[_5173 + mem[_5173]]) + 32
                                            mem[_5173 + ceil32(return_data.size)] = _5279
                                            require return_data.size >= _5227 + (32 * _5279) + 32
                                            mem[_5173 + ceil32(return_data.size) + 32 len 32 * _5279] = mem[_5173 + _5227 + 32 len 32 * _5279]
                                            require _5279 - 1 < _5279
                                            if not mem[(32 * _5279 - 1) + _5173 + ceil32(return_data.size) + 32]:
                                                return 0
                                            if profitFactor * mem[(32 * _5279 - 1) + _5173 + ceil32(return_data.size) + 32] / mem[(32 * _5279 - 1) + _5173 + ceil32(return_data.size) + 32] != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[mem[64]] = profitFactor * mem[(32 * _5279 - 1) + _5173 + ceil32(return_data.size) + 32] < 0
                                    else:
                                        if maxReportDelay * (_2888 * _3014) - (t * _3014) / 10^18 / (_2888 * _3014) - (t * _3014) / 10^18 != maxReportDelay:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _3383 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3383] = 26
                                        mem[_3383 + 32] = 'SafeMath: division by zero'
                                        if 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83 == wantAddress:
                                            if not arg1:
                                                return (0 < maxReportDelay * (_2888 * _3014) - (t * _3014) / 10^18 / 31556952)
                                            if profitFactor * arg1 / arg1 != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            return (profitFactor * arg1 < maxReportDelay * (_2888 * _3014) - (t * _3014) / 10^18 / 31556952)
                                        if wantToEthOracleAddress:
                                            mem[mem[64] + 4] = arg1
                                            require ext_code.size(wantToEthOracleAddress)
                                            staticcall wantToEthOracleAddress.0x780022a0 with:
                                                    gas gas_remaining wei
                                                   args arg1
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _3800 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if not mem[_3800]:
                                                return (0 < maxReportDelay * (_2888 * _3014) - (t * _3014) / 10^18 / 31556952)
                                            if profitFactor * mem[_3800] / mem[_3800] != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[mem[64]] = profitFactor * mem[_3800] < maxReportDelay * (_2888 * _3014) - (t * _3014) / 10^18 / 31556952
                                        else:
                                            _3552 = mem[64]
                                            mem[mem[64]] = 2
                                            mem[64] = mem[64] + 96
                                            require 0 < mem[_3552]
                                            mem[_3552 + 32] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                            require 1 < mem[_3552]
                                            mem[_3552 + 64] = wantAddress
                                            mem[_3552 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[_3552 + 100] = arg1
                                            mem[_3552 + 132] = 64
                                            mem[_3552 + 164] = mem[_3552]
                                            idx = 0
                                            s = _3552 + 196
                                            u = _3552 + 32
                                            while idx < mem[_3552]:
                                                mem[s] = mem[u + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                u = u + 32
                                                continue 
                                            require ext_code.size(0xf491e7b69e4244ad4002bc14e878a34207e38c29)
                                            staticcall 0xf491e7b69e4244ad4002bc14e878a34207e38c29.mem[mem[64] len 4] with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4 len _3552 + (32 * mem[_3552]) + -mem[64] + 192]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5172 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _5226 = mem[_5172]
                                            require mem[_5172] <= test266151307()
                                            require _5172 + return_data.size > _5172 + mem[_5172] + 31
                                            _5278 = mem[_5172 + mem[_5172]]
                                            require mem[_5172 + mem[_5172]] <= test266151307()
                                            require (32 * mem[_5172 + mem[_5172]]) + 32 >= 0 and _5172 + ceil32(return_data.size) + (32 * mem[_5172 + mem[_5172]]) + 32 <= test266151307()
                                            mem[64] = _5172 + ceil32(return_data.size) + (32 * mem[_5172 + mem[_5172]]) + 32
                                            mem[_5172 + ceil32(return_data.size)] = _5278
                                            require return_data.size >= _5226 + (32 * _5278) + 32
                                            mem[_5172 + ceil32(return_data.size) + 32 len 32 * _5278] = mem[_5172 + _5226 + 32 len 32 * _5278]
                                            require _5278 - 1 < _5278
                                            if not mem[(32 * _5278 - 1) + _5172 + ceil32(return_data.size) + 32]:
                                                return (0 < maxReportDelay * (_2888 * _3014) - (t * _3014) / 10^18 / 31556952)
                                            if profitFactor * mem[(32 * _5278 - 1) + _5172 + ceil32(return_data.size) + 32] / mem[(32 * _5278 - 1) + _5172 + ceil32(return_data.size) + 32] != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[mem[64]] = profitFactor * mem[(32 * _5278 - 1) + _5172 + ceil32(return_data.size) + 32] < maxReportDelay * (_2888 * _3014) - (t * _3014) / 10^18 / 31556952
                    else:
                        _874 = mem[(2 * ceil32(return_data.size)) + 576]
                        _879 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_879] = 30
                        mem[_879 + 32] = 'SafeMath: subtraction overflow'
                        if _874 > _818 + (_802 * lenders.length):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        require ext_code.size(vaultAddress)
                        staticcall vaultAddress.creditAvailable() with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _923 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if _818 + (_802 * lenders.length) - _874 + mem[_923] < mem[_923]:
                            revert with 0, 'SafeMath: addition overflow'
                        if not profitFactor:
                            if 0 < _818 + (_802 * lenders.length) - _874 + mem[_923]:
                                return 0
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(wantAddress)
                            staticcall wantAddress.balanceOf(address arg1) with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _1013 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _1037 = mem[_1013]
                            idx = 0
                            s = 0
                            t = -1
                            while idx < lenders.length:
                                mem[0] = 13
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].hasAssets() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _1467 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_1467] == bool(mem[_1467])
                                if not mem[_1467]:
                                    idx = idx + 1
                                    s = s
                                    t = t
                                    continue 
                                require idx < lenders.length
                                mem[0] = 13
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].apr() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _1604 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _1630 = mem[_1604]
                                if mem[_1604] >= t:
                                    idx = idx + 1
                                    s = s
                                    t = t
                                    continue 
                                require idx < lenders.length
                                mem[0] = 13
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].nav() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _1670 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                idx = idx + 1
                                s = mem[_1670]
                                t = _1630
                                continue 
                            if _1037 + s < s:
                                revert with 0, 'SafeMath: addition overflow'
                            idx = 0
                            u = 0
                            while idx < lenders.length:
                                mem[0] = 13
                                mem[mem[64] + 4] = _1037
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].aprAfterDeposit(uint256 arg1) with:
                                        gas gas_remaining wei
                                       args _1037
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _2854 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if mem[_2854] <= u:
                                    idx = idx + 1
                                    u = u
                                    continue 
                                idx = idx + 1
                                u = mem[_2854]
                                continue 
                            require 0 < lenders.length
                            mem[0] = 13
                            mem[mem[64] + 4] = _1037 + s
                            require ext_code.size(lenders)
                            staticcall lenders.aprAfterDeposit(uint256 arg1) with:
                                    gas gas_remaining wei
                                   args (_1037 + s)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2853 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _2894 = mem[_2853]
                            if mem[_2853] <= t:
                                return 0
                            require 0 < lenders.length
                            mem[0] = 13
                            require ext_code.size(lenders)
                            staticcall lenders.nav() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3002 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _3017 = mem[_3002]
                            if not mem[_3002]:
                                _3172 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3172] = 26
                                mem[_3172 + 32] = 'SafeMath: division by zero'
                                _3328 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3328] = 26
                                mem[_3328 + 32] = 'SafeMath: division by zero'
                                if 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83 == wantAddress:
                                    if not arg1:
                                        return 0
                                    if profitFactor * arg1 / arg1 != profitFactor:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    return (profitFactor * arg1 < 0)
                                if wantToEthOracleAddress:
                                    mem[mem[64] + 4] = arg1
                                    require ext_code.size(wantToEthOracleAddress)
                                    staticcall wantToEthOracleAddress.0x780022a0 with:
                                            gas gas_remaining wei
                                           args arg1
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _3646 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if not mem[_3646]:
                                        return 0
                                    if profitFactor * mem[_3646] / mem[_3646] != profitFactor:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[mem[64]] = profitFactor * mem[_3646] < 0
                                else:
                                    _3425 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    require 0 < mem[_3425]
                                    mem[_3425 + 32] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    require 1 < mem[_3425]
                                    mem[_3425 + 64] = wantAddress
                                    mem[_3425 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                    mem[_3425 + 100] = arg1
                                    mem[_3425 + 132] = 64
                                    mem[_3425 + 164] = mem[_3425]
                                    idx = 0
                                    s = _3425 + 196
                                    t = _3425 + 32
                                    while idx < mem[_3425]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(0xf491e7b69e4244ad4002bc14e878a34207e38c29)
                                    staticcall 0xf491e7b69e4244ad4002bc14e878a34207e38c29.mem[mem[64] len 4] with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4 len _3425 + (32 * mem[_3425]) + -mem[64] + 192]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5191 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _5245 = mem[_5191]
                                    require mem[_5191] <= test266151307()
                                    require _5191 + return_data.size > _5191 + mem[_5191] + 31
                                    _5297 = mem[_5191 + mem[_5191]]
                                    require mem[_5191 + mem[_5191]] <= test266151307()
                                    require (32 * mem[_5191 + mem[_5191]]) + 32 >= 0 and _5191 + ceil32(return_data.size) + (32 * mem[_5191 + mem[_5191]]) + 32 <= test266151307()
                                    mem[64] = _5191 + ceil32(return_data.size) + (32 * mem[_5191 + mem[_5191]]) + 32
                                    mem[_5191 + ceil32(return_data.size)] = _5297
                                    require return_data.size >= _5245 + (32 * _5297) + 32
                                    mem[_5191 + ceil32(return_data.size) + 32 len 32 * _5297] = mem[_5191 + _5245 + 32 len 32 * _5297]
                                    require _5297 - 1 < _5297
                                    if not mem[(32 * _5297 - 1) + _5191 + ceil32(return_data.size) + 32]:
                                        return 0
                                    if profitFactor * mem[(32 * _5297 - 1) + _5191 + ceil32(return_data.size) + 32] / mem[(32 * _5297 - 1) + _5191 + ceil32(return_data.size) + 32] != profitFactor:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[mem[64]] = profitFactor * mem[(32 * _5297 - 1) + _5191 + ceil32(return_data.size) + 32] < 0
                            else:
                                if t * mem[_3002] / mem[_3002] != t:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not mem[_3002]:
                                    _3225 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3225] = 26
                                    mem[_3225 + 32] = 'SafeMath: division by zero'
                                    if not -1 * t * _3017 / 10^18:
                                        _3346 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3346] = 26
                                        mem[_3346 + 32] = 'SafeMath: division by zero'
                                        if 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83 == wantAddress:
                                            if not arg1:
                                                return 0
                                            if profitFactor * arg1 / arg1 != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            return (profitFactor * arg1 < 0)
                                        if wantToEthOracleAddress:
                                            mem[mem[64] + 4] = arg1
                                            require ext_code.size(wantToEthOracleAddress)
                                            staticcall wantToEthOracleAddress.0x780022a0 with:
                                                    gas gas_remaining wei
                                                   args arg1
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _3705 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if not mem[_3705]:
                                                return 0
                                            if profitFactor * mem[_3705] / mem[_3705] != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[mem[64]] = profitFactor * mem[_3705] < 0
                                        else:
                                            _3455 = mem[64]
                                            mem[mem[64]] = 2
                                            mem[64] = mem[64] + 96
                                            require 0 < mem[_3455]
                                            mem[_3455 + 32] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                            require 1 < mem[_3455]
                                            mem[_3455 + 64] = wantAddress
                                            mem[_3455 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[_3455 + 100] = arg1
                                            mem[_3455 + 132] = 64
                                            mem[_3455 + 164] = mem[_3455]
                                            idx = 0
                                            s = _3455 + 196
                                            t = _3455 + 32
                                            while idx < mem[_3455]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            require ext_code.size(0xf491e7b69e4244ad4002bc14e878a34207e38c29)
                                            staticcall 0xf491e7b69e4244ad4002bc14e878a34207e38c29.mem[mem[64] len 4] with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4 len _3455 + (32 * mem[_3455]) + -mem[64] + 192]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5190 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _5244 = mem[_5190]
                                            require mem[_5190] <= test266151307()
                                            require _5190 + return_data.size > _5190 + mem[_5190] + 31
                                            _5296 = mem[_5190 + mem[_5190]]
                                            require mem[_5190 + mem[_5190]] <= test266151307()
                                            require (32 * mem[_5190 + mem[_5190]]) + 32 >= 0 and _5190 + ceil32(return_data.size) + (32 * mem[_5190 + mem[_5190]]) + 32 <= test266151307()
                                            mem[64] = _5190 + ceil32(return_data.size) + (32 * mem[_5190 + mem[_5190]]) + 32
                                            mem[_5190 + ceil32(return_data.size)] = _5296
                                            require return_data.size >= _5244 + (32 * _5296) + 32
                                            mem[_5190 + ceil32(return_data.size) + 32 len 32 * _5296] = mem[_5190 + _5244 + 32 len 32 * _5296]
                                            require _5296 - 1 < _5296
                                            if not mem[(32 * _5296 - 1) + _5190 + ceil32(return_data.size) + 32]:
                                                return 0
                                            if profitFactor * mem[(32 * _5296 - 1) + _5190 + ceil32(return_data.size) + 32] / mem[(32 * _5296 - 1) + _5190 + ceil32(return_data.size) + 32] != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[mem[64]] = profitFactor * mem[(32 * _5296 - 1) + _5190 + ceil32(return_data.size) + 32] < 0
                                    else:
                                        if maxReportDelay * -1 * t * _3017 / 10^18 / -1 * t * _3017 / 10^18 != maxReportDelay:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _3367 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3367] = 26
                                        mem[_3367 + 32] = 'SafeMath: division by zero'
                                        if 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83 == wantAddress:
                                            if not arg1:
                                                return (0 < maxReportDelay * -1 * t * _3017 / 10^18 / 31556952)
                                            if profitFactor * arg1 / arg1 != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            return (profitFactor * arg1 < maxReportDelay * -1 * t * _3017 / 10^18 / 31556952)
                                        if wantToEthOracleAddress:
                                            mem[mem[64] + 4] = arg1
                                            require ext_code.size(wantToEthOracleAddress)
                                            staticcall wantToEthOracleAddress.0x780022a0 with:
                                                    gas gas_remaining wei
                                                   args arg1
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _3764 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if not mem[_3764]:
                                                return (0 < maxReportDelay * -1 * t * _3017 / 10^18 / 31556952)
                                            if profitFactor * mem[_3764] / mem[_3764] != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[mem[64]] = profitFactor * mem[_3764] < maxReportDelay * -1 * t * _3017 / 10^18 / 31556952
                                        else:
                                            _3508 = mem[64]
                                            mem[mem[64]] = 2
                                            mem[64] = mem[64] + 96
                                            require 0 < mem[_3508]
                                            mem[_3508 + 32] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                            require 1 < mem[_3508]
                                            mem[_3508 + 64] = wantAddress
                                            mem[_3508 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[_3508 + 100] = arg1
                                            mem[_3508 + 132] = 64
                                            mem[_3508 + 164] = mem[_3508]
                                            idx = 0
                                            s = _3508 + 196
                                            u = _3508 + 32
                                            while idx < mem[_3508]:
                                                mem[s] = mem[u + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                u = u + 32
                                                continue 
                                            require ext_code.size(0xf491e7b69e4244ad4002bc14e878a34207e38c29)
                                            staticcall 0xf491e7b69e4244ad4002bc14e878a34207e38c29.mem[mem[64] len 4] with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4 len _3508 + (32 * mem[_3508]) + -mem[64] + 192]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5189 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _5243 = mem[_5189]
                                            require mem[_5189] <= test266151307()
                                            require _5189 + return_data.size > _5189 + mem[_5189] + 31
                                            _5295 = mem[_5189 + mem[_5189]]
                                            require mem[_5189 + mem[_5189]] <= test266151307()
                                            require (32 * mem[_5189 + mem[_5189]]) + 32 >= 0 and _5189 + ceil32(return_data.size) + (32 * mem[_5189 + mem[_5189]]) + 32 <= test266151307()
                                            mem[64] = _5189 + ceil32(return_data.size) + (32 * mem[_5189 + mem[_5189]]) + 32
                                            mem[_5189 + ceil32(return_data.size)] = _5295
                                            require return_data.size >= _5243 + (32 * _5295) + 32
                                            mem[_5189 + ceil32(return_data.size) + 32 len 32 * _5295] = mem[_5189 + _5243 + 32 len 32 * _5295]
                                            require _5295 - 1 < _5295
                                            if not mem[(32 * _5295 - 1) + _5189 + ceil32(return_data.size) + 32]:
                                                return (0 < maxReportDelay * -1 * t * _3017 / 10^18 / 31556952)
                                            if profitFactor * mem[(32 * _5295 - 1) + _5189 + ceil32(return_data.size) + 32] / mem[(32 * _5295 - 1) + _5189 + ceil32(return_data.size) + 32] != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[mem[64]] = profitFactor * mem[(32 * _5295 - 1) + _5189 + ceil32(return_data.size) + 32] < maxReportDelay * -1 * t * _3017 / 10^18 / 31556952
                                else:
                                    if _2894 * mem[_3002] / mem[_3002] != _2894:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _3257 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3257] = 26
                                    mem[_3257 + 32] = 'SafeMath: division by zero'
                                    if not (_2894 * _3017) - (t * _3017) / 10^18:
                                        _3366 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3366] = 26
                                        mem[_3366 + 32] = 'SafeMath: division by zero'
                                        if 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83 == wantAddress:
                                            if not arg1:
                                                return 0
                                            if profitFactor * arg1 / arg1 != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            return (profitFactor * arg1 < 0)
                                        if wantToEthOracleAddress:
                                            mem[mem[64] + 4] = arg1
                                            require ext_code.size(wantToEthOracleAddress)
                                            staticcall wantToEthOracleAddress.0x780022a0 with:
                                                    gas gas_remaining wei
                                                   args arg1
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _3763 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if not mem[_3763]:
                                                return 0
                                            if profitFactor * mem[_3763] / mem[_3763] != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[mem[64]] = profitFactor * mem[_3763] < 0
                                        else:
                                            _3505 = mem[64]
                                            mem[mem[64]] = 2
                                            mem[64] = mem[64] + 96
                                            require 0 < mem[_3505]
                                            mem[_3505 + 32] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                            require 1 < mem[_3505]
                                            mem[_3505 + 64] = wantAddress
                                            mem[_3505 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[_3505 + 100] = arg1
                                            mem[_3505 + 132] = 64
                                            mem[_3505 + 164] = mem[_3505]
                                            idx = 0
                                            s = _3505 + 196
                                            t = _3505 + 32
                                            while idx < mem[_3505]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            require ext_code.size(0xf491e7b69e4244ad4002bc14e878a34207e38c29)
                                            staticcall 0xf491e7b69e4244ad4002bc14e878a34207e38c29.mem[mem[64] len 4] with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4 len _3505 + (32 * mem[_3505]) + -mem[64] + 192]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5188 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _5242 = mem[_5188]
                                            require mem[_5188] <= test266151307()
                                            require _5188 + return_data.size > _5188 + mem[_5188] + 31
                                            _5294 = mem[_5188 + mem[_5188]]
                                            require mem[_5188 + mem[_5188]] <= test266151307()
                                            require (32 * mem[_5188 + mem[_5188]]) + 32 >= 0 and _5188 + ceil32(return_data.size) + (32 * mem[_5188 + mem[_5188]]) + 32 <= test266151307()
                                            mem[64] = _5188 + ceil32(return_data.size) + (32 * mem[_5188 + mem[_5188]]) + 32
                                            mem[_5188 + ceil32(return_data.size)] = _5294
                                            require return_data.size >= _5242 + (32 * _5294) + 32
                                            mem[_5188 + ceil32(return_data.size) + 32 len 32 * _5294] = mem[_5188 + _5242 + 32 len 32 * _5294]
                                            require _5294 - 1 < _5294
                                            if not mem[(32 * _5294 - 1) + _5188 + ceil32(return_data.size) + 32]:
                                                return 0
                                            if profitFactor * mem[(32 * _5294 - 1) + _5188 + ceil32(return_data.size) + 32] / mem[(32 * _5294 - 1) + _5188 + ceil32(return_data.size) + 32] != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[mem[64]] = profitFactor * mem[(32 * _5294 - 1) + _5188 + ceil32(return_data.size) + 32] < 0
                                    else:
                                        if maxReportDelay * (_2894 * _3017) - (t * _3017) / 10^18 / (_2894 * _3017) - (t * _3017) / 10^18 != maxReportDelay:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _3389 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3389] = 26
                                        mem[_3389 + 32] = 'SafeMath: division by zero'
                                        if 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83 == wantAddress:
                                            if not arg1:
                                                return (0 < maxReportDelay * (_2894 * _3017) - (t * _3017) / 10^18 / 31556952)
                                            if profitFactor * arg1 / arg1 != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            return (profitFactor * arg1 < maxReportDelay * (_2894 * _3017) - (t * _3017) / 10^18 / 31556952)
                                        if wantToEthOracleAddress:
                                            mem[mem[64] + 4] = arg1
                                            require ext_code.size(wantToEthOracleAddress)
                                            staticcall wantToEthOracleAddress.0x780022a0 with:
                                                    gas gas_remaining wei
                                                   args arg1
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _3827 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if not mem[_3827]:
                                                return (0 < maxReportDelay * (_2894 * _3017) - (t * _3017) / 10^18 / 31556952)
                                            if profitFactor * mem[_3827] / mem[_3827] != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[mem[64]] = profitFactor * mem[_3827] < maxReportDelay * (_2894 * _3017) - (t * _3017) / 10^18 / 31556952
                                        else:
                                            _3576 = mem[64]
                                            mem[mem[64]] = 2
                                            mem[64] = mem[64] + 96
                                            require 0 < mem[_3576]
                                            mem[_3576 + 32] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                            require 1 < mem[_3576]
                                            mem[_3576 + 64] = wantAddress
                                            mem[_3576 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[_3576 + 100] = arg1
                                            mem[_3576 + 132] = 64
                                            mem[_3576 + 164] = mem[_3576]
                                            idx = 0
                                            s = _3576 + 196
                                            u = _3576 + 32
                                            while idx < mem[_3576]:
                                                mem[s] = mem[u + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                u = u + 32
                                                continue 
                                            require ext_code.size(0xf491e7b69e4244ad4002bc14e878a34207e38c29)
                                            staticcall 0xf491e7b69e4244ad4002bc14e878a34207e38c29.mem[mem[64] len 4] with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4 len _3576 + (32 * mem[_3576]) + -mem[64] + 192]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5187 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _5241 = mem[_5187]
                                            require mem[_5187] <= test266151307()
                                            require _5187 + return_data.size > _5187 + mem[_5187] + 31
                                            _5293 = mem[_5187 + mem[_5187]]
                                            require mem[_5187 + mem[_5187]] <= test266151307()
                                            require (32 * mem[_5187 + mem[_5187]]) + 32 >= 0 and _5187 + ceil32(return_data.size) + (32 * mem[_5187 + mem[_5187]]) + 32 <= test266151307()
                                            mem[64] = _5187 + ceil32(return_data.size) + (32 * mem[_5187 + mem[_5187]]) + 32
                                            mem[_5187 + ceil32(return_data.size)] = _5293
                                            require return_data.size >= _5241 + (32 * _5293) + 32
                                            mem[_5187 + ceil32(return_data.size) + 32 len 32 * _5293] = mem[_5187 + _5241 + 32 len 32 * _5293]
                                            require _5293 - 1 < _5293
                                            if not mem[(32 * _5293 - 1) + _5187 + ceil32(return_data.size) + 32]:
                                                return (0 < maxReportDelay * (_2894 * _3017) - (t * _3017) / 10^18 / 31556952)
                                            if profitFactor * mem[(32 * _5293 - 1) + _5187 + ceil32(return_data.size) + 32] / mem[(32 * _5293 - 1) + _5187 + ceil32(return_data.size) + 32] != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[mem[64]] = profitFactor * mem[(32 * _5293 - 1) + _5187 + ceil32(return_data.size) + 32] < maxReportDelay * (_2894 * _3017) - (t * _3017) / 10^18 / 31556952
                        else:
                            if ext_call.return_data[0] * profitFactor / profitFactor != ext_call.return_data[0]:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if ext_call.return_data[0] * profitFactor < _818 + (_802 * lenders.length) - _874 + mem[_923]:
                                return 0
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(wantAddress)
                            staticcall wantAddress.balanceOf(address arg1) with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _1024 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _1043 = mem[_1024]
                            idx = 0
                            s = 0
                            t = -1
                            while idx < lenders.length:
                                mem[0] = 13
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].hasAssets() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _1466 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_1466] == bool(mem[_1466])
                                if not mem[_1466]:
                                    idx = idx + 1
                                    s = s
                                    t = t
                                    continue 
                                require idx < lenders.length
                                mem[0] = 13
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].apr() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _1603 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _1629 = mem[_1603]
                                if mem[_1603] >= t:
                                    idx = idx + 1
                                    s = s
                                    t = t
                                    continue 
                                require idx < lenders.length
                                mem[0] = 13
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].nav() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _1669 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                idx = idx + 1
                                s = mem[_1669]
                                t = _1629
                                continue 
                            if _1043 + s < s:
                                revert with 0, 'SafeMath: addition overflow'
                            idx = 0
                            u = 0
                            while idx < lenders.length:
                                mem[0] = 13
                                mem[mem[64] + 4] = _1043
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].aprAfterDeposit(uint256 arg1) with:
                                        gas gas_remaining wei
                                       args _1043
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _2852 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if mem[_2852] <= u:
                                    idx = idx + 1
                                    u = u
                                    continue 
                                idx = idx + 1
                                u = mem[_2852]
                                continue 
                            require 0 < lenders.length
                            mem[0] = 13
                            mem[mem[64] + 4] = _1043 + s
                            require ext_code.size(lenders)
                            staticcall lenders.aprAfterDeposit(uint256 arg1) with:
                                    gas gas_remaining wei
                                   args (_1043 + s)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2851 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _2892 = mem[_2851]
                            if mem[_2851] <= t:
                                return 0
                            require 0 < lenders.length
                            mem[0] = 13
                            require ext_code.size(lenders)
                            staticcall lenders.nav() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3000 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _3016 = mem[_3000]
                            if not mem[_3000]:
                                _3170 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3170] = 26
                                mem[_3170 + 32] = 'SafeMath: division by zero'
                                _3326 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3326] = 26
                                mem[_3326 + 32] = 'SafeMath: division by zero'
                                if 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83 == wantAddress:
                                    if not arg1:
                                        return 0
                                    if profitFactor * arg1 / arg1 != profitFactor:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    return (profitFactor * arg1 < 0)
                                if wantToEthOracleAddress:
                                    mem[mem[64] + 4] = arg1
                                    require ext_code.size(wantToEthOracleAddress)
                                    staticcall wantToEthOracleAddress.0x780022a0 with:
                                            gas gas_remaining wei
                                           args arg1
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _3639 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if not mem[_3639]:
                                        return 0
                                    if profitFactor * mem[_3639] / mem[_3639] != profitFactor:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[mem[64]] = profitFactor * mem[_3639] < 0
                                else:
                                    _3422 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    require 0 < mem[_3422]
                                    mem[_3422 + 32] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    require 1 < mem[_3422]
                                    mem[_3422 + 64] = wantAddress
                                    mem[_3422 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                    mem[_3422 + 100] = arg1
                                    mem[_3422 + 132] = 64
                                    mem[_3422 + 164] = mem[_3422]
                                    idx = 0
                                    s = _3422 + 196
                                    t = _3422 + 32
                                    while idx < mem[_3422]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(0xf491e7b69e4244ad4002bc14e878a34207e38c29)
                                    staticcall 0xf491e7b69e4244ad4002bc14e878a34207e38c29.mem[mem[64] len 4] with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4 len _3422 + (32 * mem[_3422]) + -mem[64] + 192]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5186 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _5240 = mem[_5186]
                                    require mem[_5186] <= test266151307()
                                    require _5186 + return_data.size > _5186 + mem[_5186] + 31
                                    _5292 = mem[_5186 + mem[_5186]]
                                    require mem[_5186 + mem[_5186]] <= test266151307()
                                    require (32 * mem[_5186 + mem[_5186]]) + 32 >= 0 and _5186 + ceil32(return_data.size) + (32 * mem[_5186 + mem[_5186]]) + 32 <= test266151307()
                                    mem[64] = _5186 + ceil32(return_data.size) + (32 * mem[_5186 + mem[_5186]]) + 32
                                    mem[_5186 + ceil32(return_data.size)] = _5292
                                    require return_data.size >= _5240 + (32 * _5292) + 32
                                    mem[_5186 + ceil32(return_data.size) + 32 len 32 * _5292] = mem[_5186 + _5240 + 32 len 32 * _5292]
                                    require _5292 - 1 < _5292
                                    if not mem[(32 * _5292 - 1) + _5186 + ceil32(return_data.size) + 32]:
                                        return 0
                                    if profitFactor * mem[(32 * _5292 - 1) + _5186 + ceil32(return_data.size) + 32] / mem[(32 * _5292 - 1) + _5186 + ceil32(return_data.size) + 32] != profitFactor:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[mem[64]] = profitFactor * mem[(32 * _5292 - 1) + _5186 + ceil32(return_data.size) + 32] < 0
                            else:
                                if t * mem[_3000] / mem[_3000] != t:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not mem[_3000]:
                                    _3224 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3224] = 26
                                    mem[_3224 + 32] = 'SafeMath: division by zero'
                                    if not -1 * t * _3016 / 10^18:
                                        _3344 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3344] = 26
                                        mem[_3344 + 32] = 'SafeMath: division by zero'
                                        if 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83 == wantAddress:
                                            if not arg1:
                                                return 0
                                            if profitFactor * arg1 / arg1 != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            return (profitFactor * arg1 < 0)
                                        if wantToEthOracleAddress:
                                            mem[mem[64] + 4] = arg1
                                            require ext_code.size(wantToEthOracleAddress)
                                            staticcall wantToEthOracleAddress.0x780022a0 with:
                                                    gas gas_remaining wei
                                                   args arg1
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _3698 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if not mem[_3698]:
                                                return 0
                                            if profitFactor * mem[_3698] / mem[_3698] != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[mem[64]] = profitFactor * mem[_3698] < 0
                                        else:
                                            _3451 = mem[64]
                                            mem[mem[64]] = 2
                                            mem[64] = mem[64] + 96
                                            require 0 < mem[_3451]
                                            mem[_3451 + 32] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                            require 1 < mem[_3451]
                                            mem[_3451 + 64] = wantAddress
                                            mem[_3451 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[_3451 + 100] = arg1
                                            mem[_3451 + 132] = 64
                                            mem[_3451 + 164] = mem[_3451]
                                            idx = 0
                                            s = _3451 + 196
                                            t = _3451 + 32
                                            while idx < mem[_3451]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            require ext_code.size(0xf491e7b69e4244ad4002bc14e878a34207e38c29)
                                            staticcall 0xf491e7b69e4244ad4002bc14e878a34207e38c29.mem[mem[64] len 4] with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4 len _3451 + (32 * mem[_3451]) + -mem[64] + 192]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5185 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _5239 = mem[_5185]
                                            require mem[_5185] <= test266151307()
                                            require _5185 + return_data.size > _5185 + mem[_5185] + 31
                                            _5291 = mem[_5185 + mem[_5185]]
                                            require mem[_5185 + mem[_5185]] <= test266151307()
                                            require (32 * mem[_5185 + mem[_5185]]) + 32 >= 0 and _5185 + ceil32(return_data.size) + (32 * mem[_5185 + mem[_5185]]) + 32 <= test266151307()
                                            mem[64] = _5185 + ceil32(return_data.size) + (32 * mem[_5185 + mem[_5185]]) + 32
                                            mem[_5185 + ceil32(return_data.size)] = _5291
                                            require return_data.size >= _5239 + (32 * _5291) + 32
                                            mem[_5185 + ceil32(return_data.size) + 32 len 32 * _5291] = mem[_5185 + _5239 + 32 len 32 * _5291]
                                            require _5291 - 1 < _5291
                                            if not mem[(32 * _5291 - 1) + _5185 + ceil32(return_data.size) + 32]:
                                                return 0
                                            if profitFactor * mem[(32 * _5291 - 1) + _5185 + ceil32(return_data.size) + 32] / mem[(32 * _5291 - 1) + _5185 + ceil32(return_data.size) + 32] != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[mem[64]] = profitFactor * mem[(32 * _5291 - 1) + _5185 + ceil32(return_data.size) + 32] < 0
                                    else:
                                        if maxReportDelay * -1 * t * _3016 / 10^18 / -1 * t * _3016 / 10^18 != maxReportDelay:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _3364 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3364] = 26
                                        mem[_3364 + 32] = 'SafeMath: division by zero'
                                        if 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83 == wantAddress:
                                            if not arg1:
                                                return (0 < maxReportDelay * -1 * t * _3016 / 10^18 / 31556952)
                                            if profitFactor * arg1 / arg1 != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            return (profitFactor * arg1 < maxReportDelay * -1 * t * _3016 / 10^18 / 31556952)
                                        if wantToEthOracleAddress:
                                            mem[mem[64] + 4] = arg1
                                            require ext_code.size(wantToEthOracleAddress)
                                            staticcall wantToEthOracleAddress.0x780022a0 with:
                                                    gas gas_remaining wei
                                                   args arg1
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _3757 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if not mem[_3757]:
                                                return (0 < maxReportDelay * -1 * t * _3016 / 10^18 / 31556952)
                                            if profitFactor * mem[_3757] / mem[_3757] != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[mem[64]] = profitFactor * mem[_3757] < maxReportDelay * -1 * t * _3016 / 10^18 / 31556952
                                        else:
                                            _3499 = mem[64]
                                            mem[mem[64]] = 2
                                            mem[64] = mem[64] + 96
                                            require 0 < mem[_3499]
                                            mem[_3499 + 32] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                            require 1 < mem[_3499]
                                            mem[_3499 + 64] = wantAddress
                                            mem[_3499 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[_3499 + 100] = arg1
                                            mem[_3499 + 132] = 64
                                            mem[_3499 + 164] = mem[_3499]
                                            idx = 0
                                            s = _3499 + 196
                                            u = _3499 + 32
                                            while idx < mem[_3499]:
                                                mem[s] = mem[u + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                u = u + 32
                                                continue 
                                            require ext_code.size(0xf491e7b69e4244ad4002bc14e878a34207e38c29)
                                            staticcall 0xf491e7b69e4244ad4002bc14e878a34207e38c29.mem[mem[64] len 4] with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4 len _3499 + (32 * mem[_3499]) + -mem[64] + 192]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5184 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _5238 = mem[_5184]
                                            require mem[_5184] <= test266151307()
                                            require _5184 + return_data.size > _5184 + mem[_5184] + 31
                                            _5290 = mem[_5184 + mem[_5184]]
                                            require mem[_5184 + mem[_5184]] <= test266151307()
                                            require (32 * mem[_5184 + mem[_5184]]) + 32 >= 0 and _5184 + ceil32(return_data.size) + (32 * mem[_5184 + mem[_5184]]) + 32 <= test266151307()
                                            mem[64] = _5184 + ceil32(return_data.size) + (32 * mem[_5184 + mem[_5184]]) + 32
                                            mem[_5184 + ceil32(return_data.size)] = _5290
                                            require return_data.size >= _5238 + (32 * _5290) + 32
                                            mem[_5184 + ceil32(return_data.size) + 32 len 32 * _5290] = mem[_5184 + _5238 + 32 len 32 * _5290]
                                            require _5290 - 1 < _5290
                                            if not mem[(32 * _5290 - 1) + _5184 + ceil32(return_data.size) + 32]:
                                                return (0 < maxReportDelay * -1 * t * _3016 / 10^18 / 31556952)
                                            if profitFactor * mem[(32 * _5290 - 1) + _5184 + ceil32(return_data.size) + 32] / mem[(32 * _5290 - 1) + _5184 + ceil32(return_data.size) + 32] != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[mem[64]] = profitFactor * mem[(32 * _5290 - 1) + _5184 + ceil32(return_data.size) + 32] < maxReportDelay * -1 * t * _3016 / 10^18 / 31556952
                                else:
                                    if _2892 * mem[_3000] / mem[_3000] != _2892:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _3255 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3255] = 26
                                    mem[_3255 + 32] = 'SafeMath: division by zero'
                                    if not (_2892 * _3016) - (t * _3016) / 10^18:
                                        _3363 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3363] = 26
                                        mem[_3363 + 32] = 'SafeMath: division by zero'
                                        if 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83 == wantAddress:
                                            if not arg1:
                                                return 0
                                            if profitFactor * arg1 / arg1 != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            return (profitFactor * arg1 < 0)
                                        if wantToEthOracleAddress:
                                            mem[mem[64] + 4] = arg1
                                            require ext_code.size(wantToEthOracleAddress)
                                            staticcall wantToEthOracleAddress.0x780022a0 with:
                                                    gas gas_remaining wei
                                                   args arg1
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _3756 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if not mem[_3756]:
                                                return 0
                                            if profitFactor * mem[_3756] / mem[_3756] != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[mem[64]] = profitFactor * mem[_3756] < 0
                                        else:
                                            _3496 = mem[64]
                                            mem[mem[64]] = 2
                                            mem[64] = mem[64] + 96
                                            require 0 < mem[_3496]
                                            mem[_3496 + 32] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                            require 1 < mem[_3496]
                                            mem[_3496 + 64] = wantAddress
                                            mem[_3496 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[_3496 + 100] = arg1
                                            mem[_3496 + 132] = 64
                                            mem[_3496 + 164] = mem[_3496]
                                            idx = 0
                                            s = _3496 + 196
                                            t = _3496 + 32
                                            while idx < mem[_3496]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            require ext_code.size(0xf491e7b69e4244ad4002bc14e878a34207e38c29)
                                            staticcall 0xf491e7b69e4244ad4002bc14e878a34207e38c29.mem[mem[64] len 4] with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4 len _3496 + (32 * mem[_3496]) + -mem[64] + 192]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5183 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _5237 = mem[_5183]
                                            require mem[_5183] <= test266151307()
                                            require _5183 + return_data.size > _5183 + mem[_5183] + 31
                                            _5289 = mem[_5183 + mem[_5183]]
                                            require mem[_5183 + mem[_5183]] <= test266151307()
                                            require (32 * mem[_5183 + mem[_5183]]) + 32 >= 0 and _5183 + ceil32(return_data.size) + (32 * mem[_5183 + mem[_5183]]) + 32 <= test266151307()
                                            mem[64] = _5183 + ceil32(return_data.size) + (32 * mem[_5183 + mem[_5183]]) + 32
                                            mem[_5183 + ceil32(return_data.size)] = _5289
                                            require return_data.size >= _5237 + (32 * _5289) + 32
                                            mem[_5183 + ceil32(return_data.size) + 32 len 32 * _5289] = mem[_5183 + _5237 + 32 len 32 * _5289]
                                            require _5289 - 1 < _5289
                                            if not mem[(32 * _5289 - 1) + _5183 + ceil32(return_data.size) + 32]:
                                                return 0
                                            if profitFactor * mem[(32 * _5289 - 1) + _5183 + ceil32(return_data.size) + 32] / mem[(32 * _5289 - 1) + _5183 + ceil32(return_data.size) + 32] != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[mem[64]] = profitFactor * mem[(32 * _5289 - 1) + _5183 + ceil32(return_data.size) + 32] < 0
                                    else:
                                        if maxReportDelay * (_2892 * _3016) - (t * _3016) / 10^18 / (_2892 * _3016) - (t * _3016) / 10^18 != maxReportDelay:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _3387 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3387] = 26
                                        mem[_3387 + 32] = 'SafeMath: division by zero'
                                        if 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83 == wantAddress:
                                            if not arg1:
                                                return (0 < maxReportDelay * (_2892 * _3016) - (t * _3016) / 10^18 / 31556952)
                                            if profitFactor * arg1 / arg1 != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            return (profitFactor * arg1 < maxReportDelay * (_2892 * _3016) - (t * _3016) / 10^18 / 31556952)
                                        if wantToEthOracleAddress:
                                            mem[mem[64] + 4] = arg1
                                            require ext_code.size(wantToEthOracleAddress)
                                            staticcall wantToEthOracleAddress.0x780022a0 with:
                                                    gas gas_remaining wei
                                                   args arg1
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _3818 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if not mem[_3818]:
                                                return (0 < maxReportDelay * (_2892 * _3016) - (t * _3016) / 10^18 / 31556952)
                                            if profitFactor * mem[_3818] / mem[_3818] != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[mem[64]] = profitFactor * mem[_3818] < maxReportDelay * (_2892 * _3016) - (t * _3016) / 10^18 / 31556952
                                        else:
                                            _3568 = mem[64]
                                            mem[mem[64]] = 2
                                            mem[64] = mem[64] + 96
                                            require 0 < mem[_3568]
                                            mem[_3568 + 32] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                            require 1 < mem[_3568]
                                            mem[_3568 + 64] = wantAddress
                                            mem[_3568 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[_3568 + 100] = arg1
                                            mem[_3568 + 132] = 64
                                            mem[_3568 + 164] = mem[_3568]
                                            idx = 0
                                            s = _3568 + 196
                                            u = _3568 + 32
                                            while idx < mem[_3568]:
                                                mem[s] = mem[u + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                u = u + 32
                                                continue 
                                            require ext_code.size(0xf491e7b69e4244ad4002bc14e878a34207e38c29)
                                            staticcall 0xf491e7b69e4244ad4002bc14e878a34207e38c29.mem[mem[64] len 4] with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4 len _3568 + (32 * mem[_3568]) + -mem[64] + 192]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5182 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _5236 = mem[_5182]
                                            require mem[_5182] <= test266151307()
                                            require _5182 + return_data.size > _5182 + mem[_5182] + 31
                                            _5288 = mem[_5182 + mem[_5182]]
                                            require mem[_5182 + mem[_5182]] <= test266151307()
                                            require (32 * mem[_5182 + mem[_5182]]) + 32 >= 0 and _5182 + ceil32(return_data.size) + (32 * mem[_5182 + mem[_5182]]) + 32 <= test266151307()
                                            mem[64] = _5182 + ceil32(return_data.size) + (32 * mem[_5182 + mem[_5182]]) + 32
                                            mem[_5182 + ceil32(return_data.size)] = _5288
                                            require return_data.size >= _5236 + (32 * _5288) + 32
                                            mem[_5182 + ceil32(return_data.size) + 32 len 32 * _5288] = mem[_5182 + _5236 + 32 len 32 * _5288]
                                            require _5288 - 1 < _5288
                                            if not mem[(32 * _5288 - 1) + _5182 + ceil32(return_data.size) + 32]:
                                                return (0 < maxReportDelay * (_2892 * _3016) - (t * _3016) / 10^18 / 31556952)
                                            if profitFactor * mem[(32 * _5288 - 1) + _5182 + ceil32(return_data.size) + 32] / mem[(32 * _5288 - 1) + _5182 + ceil32(return_data.size) + 32] != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[mem[64]] = profitFactor * mem[(32 * _5288 - 1) + _5182 + ceil32(return_data.size) + 32] < maxReportDelay * (_2892 * _3016) - (t * _3016) / 10^18 / 31556952
        else:
            mem[96] = 2
            mem[128] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
            mem[160] = wantAddress
            mem[192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
            mem[196] = arg1
            mem[228] = 64
            mem[260] = 2
            idx = 0
            s = 292
            t = 128
            while idx < 2:
                mem[s] = mem[t + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            require ext_code.size(0xf491e7b69e4244ad4002bc14e878a34207e38c29)
            staticcall 0xf491e7b69e4244ad4002bc14e878a34207e38c29.getAmountsOut(uint256 arg1, address[] arg2) with:
                    gas gas_remaining wei
                   args arg1, Array(len=2, data=mem[292 len 64])
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[192 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(return_data.size) + 192
            require return_data.size >= 32
            _800 = mem[192 len 4], Mask(224, 32, arg1) >> 32
            require mem[192 len 4], Mask(224, 32, arg1) >> 32 <= test266151307()
            require return_data.size + 192 > mem[192 len 4], Mask(224, 32, arg1) >> 32 + 223
            _817 = mem[mem[192 len 4], Mask(224, 32, arg1) >> 32 + 192]
            require mem[mem[192 len 4], Mask(224, 32, arg1) >> 32 + 192] <= test266151307()
            require (32 * mem[mem[192 len 4], Mask(224, 32, arg1) >> 32 + 192]) + 32 >= 0 and ceil32(return_data.size) + (32 * mem[mem[192 len 4], Mask(224, 32, arg1) >> 32 + 192]) + 224 <= test266151307()
            mem[64] = ceil32(return_data.size) + (32 * mem[mem[192 len 4], Mask(224, 32, arg1) >> 32 + 192]) + 224
            mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg1) >> 32 + 192]
            require return_data.size >= _800 + (32 * _817) + 32
            mem[ceil32(return_data.size) + 224 len 32 * _817] = mem[_800 + 224 len 32 * _817]
            require _817 - 1 < _817
            _1455 = mem[(32 * _817 - 1) + ceil32(return_data.size) + 224]
            _1480 = mem[64]
            mem[64] = mem[64] + 288
            mem[_1480] = 0
            mem[_1480 + 32] = 0
            mem[_1480 + 64] = 0
            mem[_1480 + 96] = 0
            mem[_1480 + 128] = 0
            mem[_1480 + 160] = 0
            mem[_1480 + 192] = 0
            mem[_1480 + 224] = 0
            mem[_1480 + 256] = 0
            require ext_code.size(vaultAddress)
            staticcall vaultAddress.strategies(address arg1) with:
                    gas gas_remaining wei
                   args address(this.address)
            mem[mem[64] len 288] = ext_call.return_data[0 len 288]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1543 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 288
            _1592 = mem[64]
            require mem[64] + 288 >= mem[64] and mem[64] + 288 <= test266151307()
            mem[64] = mem[64] + 288
            mem[_1592] = mem[_1543]
            mem[_1592 + 32] = mem[_1543 + 32]
            mem[_1592 + 64] = mem[_1543 + 64]
            mem[_1592 + 96] = mem[_1543 + 96]
            mem[_1592 + 128] = mem[_1543 + 128]
            mem[_1592 + 160] = mem[_1543 + 160]
            mem[_1592 + 192] = mem[_1543 + 192]
            mem[_1592 + 224] = mem[_1543 + 224]
            mem[_1592 + 256] = mem[_1543 + 256]
            if 0 == mem[_1592 + 32]:
                mem[mem[64] + 4] = this.address
                require ext_code.size(wantAddress)
                staticcall wantAddress.balanceOf(address arg1) with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1696 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _1707 = mem[_1696]
                idx = 0
                s = 0
                t = -1
                while idx < lenders.length:
                    mem[0] = 13
                    require ext_code.size(lenders[idx])
                    staticcall lenders[idx].hasAssets() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2800 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_2800] == bool(mem[_2800])
                    if not mem[_2800]:
                        idx = idx + 1
                        s = s
                        t = t
                        continue 
                    require idx < lenders.length
                    mem[0] = 13
                    require ext_code.size(lenders[idx])
                    staticcall lenders[idx].apr() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2994 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _3013 = mem[_2994]
                    if mem[_2994] >= t:
                        idx = idx + 1
                        s = s
                        t = t
                        continue 
                    require idx < lenders.length
                    mem[0] = 13
                    require ext_code.size(lenders[idx])
                    staticcall lenders[idx].nav() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3117 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    idx = idx + 1
                    s = mem[_3117]
                    t = _3013
                    continue 
                if _1707 + s < s:
                    revert with 0, 'SafeMath: addition overflow'
                idx = 0
                u = 0
                while idx < lenders.length:
                    mem[0] = 13
                    mem[mem[64] + 4] = _1707
                    require ext_code.size(lenders[idx])
                    staticcall lenders[idx].aprAfterDeposit(uint256 arg1) with:
                            gas gas_remaining wei
                           args _1707
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _5225 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if mem[_5225] <= u:
                        idx = idx + 1
                        u = u
                        continue 
                    idx = idx + 1
                    u = mem[_5225]
                    continue 
                require 0 < lenders.length
                mem[0] = 13
                mem[mem[64] + 4] = _1707 + s
                require ext_code.size(lenders)
                staticcall lenders.aprAfterDeposit(uint256 arg1) with:
                        gas gas_remaining wei
                       args (_1707 + s)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _5224 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _5276 = mem[_5224]
                if mem[_5224] <= t:
                    return 0
                require 0 < lenders.length
                mem[0] = 13
                require ext_code.size(lenders)
                staticcall lenders.nav() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _5517 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _5523 = mem[_5517]
                if not mem[_5517]:
                    _5751 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5751] = 26
                    mem[_5751 + 32] = 'SafeMath: division by zero'
                    _5961 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5961] = 26
                    mem[_5961 + 32] = 'SafeMath: division by zero'
                    if 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83 == wantAddress:
                        if not arg1:
                            return 0
                        if profitFactor * arg1 / arg1 != profitFactor:
                            revert with 0, 'SafeMath: multiplication overflow'
                        return (profitFactor * arg1 < 0)
                    if wantToEthOracleAddress:
                        mem[mem[64] + 4] = arg1
                        require ext_code.size(wantToEthOracleAddress)
                        staticcall wantToEthOracleAddress.0x780022a0 with:
                                gas gas_remaining wei
                               args arg1
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _6037 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if not mem[_6037]:
                            return 0
                        if profitFactor * mem[_6037] / mem[_6037] != profitFactor:
                            revert with 0, 'SafeMath: multiplication overflow'
                        mem[mem[64]] = profitFactor * mem[_6037] < 0
                    else:
                        _5979 = mem[64]
                        mem[mem[64]] = 2
                        mem[64] = mem[64] + 96
                        require 0 < mem[_5979]
                        mem[_5979 + 32] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                        require 1 < mem[_5979]
                        mem[_5979 + 64] = wantAddress
                        mem[_5979 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                        mem[_5979 + 100] = arg1
                        mem[_5979 + 132] = 64
                        mem[_5979 + 164] = mem[_5979]
                        idx = 0
                        s = _5979 + 196
                        t = _5979 + 32
                        while idx < mem[_5979]:
                            mem[s] = mem[t + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        require ext_code.size(0xf491e7b69e4244ad4002bc14e878a34207e38c29)
                        staticcall 0xf491e7b69e4244ad4002bc14e878a34207e38c29.mem[mem[64] len 4] with:
                                gas gas_remaining wei
                               args mem[mem[64] + 4 len _5979 + (32 * mem[_5979]) + -mem[64] + 192]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _6559 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _6577 = mem[_6559]
                        require mem[_6559] <= test266151307()
                        require _6559 + return_data.size > _6559 + mem[_6559] + 31
                        _6595 = mem[_6559 + mem[_6559]]
                        require mem[_6559 + mem[_6559]] <= test266151307()
                        require (32 * mem[_6559 + mem[_6559]]) + 32 >= 0 and _6559 + ceil32(return_data.size) + (32 * mem[_6559 + mem[_6559]]) + 32 <= test266151307()
                        mem[64] = _6559 + ceil32(return_data.size) + (32 * mem[_6559 + mem[_6559]]) + 32
                        mem[_6559 + ceil32(return_data.size)] = _6595
                        require return_data.size >= _6577 + (32 * _6595) + 32
                        mem[_6559 + ceil32(return_data.size) + 32 len 32 * _6595] = mem[_6559 + _6577 + 32 len 32 * _6595]
                        require _6595 - 1 < _6595
                        if not mem[(32 * _6595 - 1) + _6559 + ceil32(return_data.size) + 32]:
                            return 0
                        if profitFactor * mem[(32 * _6595 - 1) + _6559 + ceil32(return_data.size) + 32] / mem[(32 * _6595 - 1) + _6559 + ceil32(return_data.size) + 32] != profitFactor:
                            revert with 0, 'SafeMath: multiplication overflow'
                        mem[mem[64]] = profitFactor * mem[(32 * _6595 - 1) + _6559 + ceil32(return_data.size) + 32] < 0
                else:
                    if t * mem[_5517] / mem[_5517] != t:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if mem[_5517]:
                        if _5276 * mem[_5517] / mem[_5517] != _5276:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _5876 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5876] = 26
                        mem[_5876 + 32] = 'SafeMath: division by zero'
                        if (_5276 * _5523) - (t * _5523) / 10^18:
                            if maxReportDelay * (_5276 * _5523) - (t * _5523) / 10^18 / (_5276 * _5523) - (t * _5523) / 10^18 != maxReportDelay:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _5974 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5974] = 26
                            mem[_5974 + 32] = 'SafeMath: division by zero'
                            if 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83 == wantAddress:
                                if not arg1:
                                    return (0 < maxReportDelay * (_5276 * _5523) - (t * _5523) / 10^18 / 31556952)
                                if profitFactor * arg1 / arg1 != profitFactor:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                return (profitFactor * arg1 < maxReportDelay * (_5276 * _5523) - (t * _5523) / 10^18 / 31556952)
                            if wantToEthOracleAddress:
                                mem[mem[64] + 4] = arg1
                                require ext_code.size(wantToEthOracleAddress)
                                staticcall wantToEthOracleAddress.0x780022a0 with:
                                        gas gas_remaining wei
                                       args arg1
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _6075 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if not mem[_6075]:
                                    return (0 < maxReportDelay * (_5276 * _5523) - (t * _5523) / 10^18 / 31556952)
                                if profitFactor * mem[_6075] / mem[_6075] != profitFactor:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[mem[64]] = profitFactor * mem[_6075] < maxReportDelay * (_5276 * _5523) - (t * _5523) / 10^18 / 31556952
                            else:
                                _6016 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                require 0 < mem[_6016]
                                mem[_6016 + 32] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                require 1 < mem[_6016]
                                mem[_6016 + 64] = wantAddress
                                mem[_6016 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[_6016 + 100] = arg1
                                mem[_6016 + 132] = 64
                                mem[_6016 + 164] = mem[_6016]
                                idx = 0
                                s = _6016 + 196
                                u = _6016 + 32
                                while idx < mem[_6016]:
                                    mem[s] = mem[u + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    u = u + 32
                                    continue 
                                require ext_code.size(0xf491e7b69e4244ad4002bc14e878a34207e38c29)
                                staticcall 0xf491e7b69e4244ad4002bc14e878a34207e38c29.mem[mem[64] len 4] with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len _6016 + (32 * mem[_6016]) + -mem[64] + 192]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _6555 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _6573 = mem[_6555]
                                require mem[_6555] <= test266151307()
                                require _6555 + return_data.size > _6555 + mem[_6555] + 31
                                _6591 = mem[_6555 + mem[_6555]]
                                require mem[_6555 + mem[_6555]] <= test266151307()
                                require (32 * mem[_6555 + mem[_6555]]) + 32 >= 0 and _6555 + ceil32(return_data.size) + (32 * mem[_6555 + mem[_6555]]) + 32 <= test266151307()
                                mem[64] = _6555 + ceil32(return_data.size) + (32 * mem[_6555 + mem[_6555]]) + 32
                                mem[_6555 + ceil32(return_data.size)] = _6591
                                require return_data.size >= _6573 + (32 * _6591) + 32
                                mem[_6555 + ceil32(return_data.size) + 32 len 32 * _6591] = mem[_6555 + _6573 + 32 len 32 * _6591]
                                require _6591 - 1 < _6591
                                if not mem[(32 * _6591 - 1) + _6555 + ceil32(return_data.size) + 32]:
                                    return (0 < maxReportDelay * (_5276 * _5523) - (t * _5523) / 10^18 / 31556952)
                                if profitFactor * mem[(32 * _6591 - 1) + _6555 + ceil32(return_data.size) + 32] / mem[(32 * _6591 - 1) + _6555 + ceil32(return_data.size) + 32] != profitFactor:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[mem[64]] = profitFactor * mem[(32 * _6591 - 1) + _6555 + ceil32(return_data.size) + 32] < maxReportDelay * (_5276 * _5523) - (t * _5523) / 10^18 / 31556952
                        else:
                            _5969 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5969] = 26
                            mem[_5969 + 32] = 'SafeMath: division by zero'
                            if 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83 == wantAddress:
                                if not arg1:
                                    return 0
                                if profitFactor * arg1 / arg1 != profitFactor:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                return (profitFactor * arg1 < 0)
                            if wantToEthOracleAddress:
                                mem[mem[64] + 4] = arg1
                                require ext_code.size(wantToEthOracleAddress)
                                staticcall wantToEthOracleAddress.0x780022a0 with:
                                        gas gas_remaining wei
                                       args arg1
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _6060 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if not mem[_6060]:
                                    return 0
                                if profitFactor * mem[_6060] / mem[_6060] != profitFactor:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[mem[64]] = profitFactor * mem[_6060] < 0
                            else:
                                _5999 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                require 0 < mem[_5999]
                                mem[_5999 + 32] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                require 1 < mem[_5999]
                                mem[_5999 + 64] = wantAddress
                                mem[_5999 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[_5999 + 100] = arg1
                                mem[_5999 + 132] = 64
                                mem[_5999 + 164] = mem[_5999]
                                idx = 0
                                s = _5999 + 196
                                t = _5999 + 32
                                while idx < mem[_5999]:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(0xf491e7b69e4244ad4002bc14e878a34207e38c29)
                                staticcall 0xf491e7b69e4244ad4002bc14e878a34207e38c29.mem[mem[64] len 4] with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len _5999 + (32 * mem[_5999]) + -mem[64] + 192]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _6556 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _6574 = mem[_6556]
                                require mem[_6556] <= test266151307()
                                require _6556 + return_data.size > _6556 + mem[_6556] + 31
                                _6592 = mem[_6556 + mem[_6556]]
                                require mem[_6556 + mem[_6556]] <= test266151307()
                                require (32 * mem[_6556 + mem[_6556]]) + 32 >= 0 and _6556 + ceil32(return_data.size) + (32 * mem[_6556 + mem[_6556]]) + 32 <= test266151307()
                                mem[64] = _6556 + ceil32(return_data.size) + (32 * mem[_6556 + mem[_6556]]) + 32
                                mem[_6556 + ceil32(return_data.size)] = _6592
                                require return_data.size >= _6574 + (32 * _6592) + 32
                                mem[_6556 + ceil32(return_data.size) + 32 len 32 * _6592] = mem[_6556 + _6574 + 32 len 32 * _6592]
                                var136001 = _6556 + _6574 + (32 * _6592) + 32
                                require _6592 - 1 < _6592
                                if not mem[(32 * _6592 - 1) + _6556 + ceil32(return_data.size) + 32]:
                                    return 0
                                if profitFactor * mem[(32 * _6592 - 1) + _6556 + ceil32(return_data.size) + 32] / mem[(32 * _6592 - 1) + _6556 + ceil32(return_data.size) + 32] != profitFactor:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[mem[64]] = profitFactor * mem[(32 * _6592 - 1) + _6556 + ceil32(return_data.size) + 32] < 0
                    else:
                        _5833 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5833] = 26
                        mem[_5833 + 32] = 'SafeMath: division by zero'
                        if not -1 * t * _5523 / 10^18:
                            _5965 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5965] = 26
                            mem[_5965 + 32] = 'SafeMath: division by zero'
                            if 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83 == wantAddress:
                                if not arg1:
                                    return 0
                                if profitFactor * arg1 / arg1 != profitFactor:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                return (profitFactor * arg1 < 0)
                            if wantToEthOracleAddress:
                                mem[mem[64] + 4] = arg1
                                require ext_code.size(wantToEthOracleAddress)
                                staticcall wantToEthOracleAddress.0x780022a0 with:
                                        gas gas_remaining wei
                                       args arg1
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _6049 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if not mem[_6049]:
                                    return 0
                                if profitFactor * mem[_6049] / mem[_6049] != profitFactor:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[mem[64]] = profitFactor * mem[_6049] < 0
                            else:
                                _5986 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                require 0 < mem[_5986]
                                mem[_5986 + 32] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                require 1 < mem[_5986]
                                mem[_5986 + 64] = wantAddress
                                mem[_5986 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[_5986 + 100] = arg1
                                mem[_5986 + 132] = 64
                                mem[_5986 + 164] = mem[_5986]
                                idx = 0
                                s = _5986 + 196
                                t = _5986 + 32
                                while idx < mem[_5986]:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(0xf491e7b69e4244ad4002bc14e878a34207e38c29)
                                staticcall 0xf491e7b69e4244ad4002bc14e878a34207e38c29.mem[mem[64] len 4] with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len _5986 + (32 * mem[_5986]) + -mem[64] + 192]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _6558 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _6576 = mem[_6558]
                                require mem[_6558] <= test266151307()
                                require _6558 + return_data.size > _6558 + mem[_6558] + 31
                                _6594 = mem[_6558 + mem[_6558]]
                                require mem[_6558 + mem[_6558]] <= test266151307()
                                require (32 * mem[_6558 + mem[_6558]]) + 32 >= 0 and _6558 + ceil32(return_data.size) + (32 * mem[_6558 + mem[_6558]]) + 32 <= test266151307()
                                mem[64] = _6558 + ceil32(return_data.size) + (32 * mem[_6558 + mem[_6558]]) + 32
                                mem[_6558 + ceil32(return_data.size)] = _6594
                                require return_data.size >= _6576 + (32 * _6594) + 32
                                mem[_6558 + ceil32(return_data.size) + 32 len 32 * _6594] = mem[_6558 + _6576 + 32 len 32 * _6594]
                                var135001 = _6558 + _6576 + (32 * _6594) + 32
                                require _6594 - 1 < _6594
                                if not mem[(32 * _6594 - 1) + _6558 + ceil32(return_data.size) + 32]:
                                    return 0
                                if profitFactor * mem[(32 * _6594 - 1) + _6558 + ceil32(return_data.size) + 32] / mem[(32 * _6594 - 1) + _6558 + ceil32(return_data.size) + 32] != profitFactor:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[mem[64]] = profitFactor * mem[(32 * _6594 - 1) + _6558 + ceil32(return_data.size) + 32] < 0
                        else:
                            if maxReportDelay * -1 * t * _5523 / 10^18 / -1 * t * _5523 / 10^18 != maxReportDelay:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _5970 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5970] = 26
                            mem[_5970 + 32] = 'SafeMath: division by zero'
                            if 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83 == wantAddress:
                                if not arg1:
                                    return (0 < maxReportDelay * -1 * t * _5523 / 10^18 / 31556952)
                                if profitFactor * arg1 / arg1 != profitFactor:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                return (profitFactor * arg1 < maxReportDelay * -1 * t * _5523 / 10^18 / 31556952)
                            if wantToEthOracleAddress:
                                mem[mem[64] + 4] = arg1
                                require ext_code.size(wantToEthOracleAddress)
                                staticcall wantToEthOracleAddress.0x780022a0 with:
                                        gas gas_remaining wei
                                       args arg1
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _6061 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if not mem[_6061]:
                                    return (0 < maxReportDelay * -1 * t * _5523 / 10^18 / 31556952)
                                if profitFactor * mem[_6061] / mem[_6061] != profitFactor:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[mem[64]] = profitFactor * mem[_6061] < maxReportDelay * -1 * t * _5523 / 10^18 / 31556952
                            else:
                                _6002 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                require 0 < mem[_6002]
                                mem[_6002 + 32] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                require 1 < mem[_6002]
                                mem[_6002 + 64] = wantAddress
                                mem[_6002 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[_6002 + 100] = arg1
                                mem[_6002 + 132] = 64
                                mem[_6002 + 164] = mem[_6002]
                                idx = 0
                                s = _6002 + 196
                                u = _6002 + 32
                                while idx < mem[_6002]:
                                    mem[s] = mem[u + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    u = u + 32
                                    continue 
                                require ext_code.size(0xf491e7b69e4244ad4002bc14e878a34207e38c29)
                                staticcall 0xf491e7b69e4244ad4002bc14e878a34207e38c29.mem[mem[64] len 4] with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len _6002 + (32 * mem[_6002]) + -mem[64] + 192]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _6557 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _6575 = mem[_6557]
                                require mem[_6557] <= test266151307()
                                require _6557 + return_data.size > _6557 + mem[_6557] + 31
                                _6593 = mem[_6557 + mem[_6557]]
                                require mem[_6557 + mem[_6557]] <= test266151307()
                                require (32 * mem[_6557 + mem[_6557]]) + 32 >= 0 and _6557 + ceil32(return_data.size) + (32 * mem[_6557 + mem[_6557]]) + 32 <= test266151307()
                                mem[64] = _6557 + ceil32(return_data.size) + (32 * mem[_6557 + mem[_6557]]) + 32
                                mem[_6557 + ceil32(return_data.size)] = _6593
                                require return_data.size >= _6575 + (32 * _6593) + 32
                                mem[_6557 + ceil32(return_data.size) + 32 len 32 * _6593] = mem[_6557 + _6575 + 32 len 32 * _6593]
                                var136001 = _6557 + _6575 + (32 * _6593) + 32
                                require _6593 - 1 < _6593
                                if not mem[(32 * _6593 - 1) + _6557 + ceil32(return_data.size) + 32]:
                                    return (0 < maxReportDelay * -1 * t * _5523 / 10^18 / 31556952)
                                if profitFactor * mem[(32 * _6593 - 1) + _6557 + ceil32(return_data.size) + 32] / mem[(32 * _6593 - 1) + _6557 + ceil32(return_data.size) + 32] != profitFactor:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[mem[64]] = profitFactor * mem[(32 * _6593 - 1) + _6557 + ceil32(return_data.size) + 32] < maxReportDelay * -1 * t * _5523 / 10^18 / 31556952
            else:
                _1639 = mem[_1592 + 160]
                _1640 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1640] = 30
                mem[_1640 + 32] = 'SafeMath: subtraction overflow'
                if _1639 > block.timestamp:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if block.timestamp - _1639 < minReportDelay:
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(wantAddress)
                    staticcall wantAddress.balanceOf(address arg1) with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1728 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _1734 = mem[_1728]
                    idx = 0
                    s = 0
                    t = -1
                    while idx < lenders.length:
                        mem[0] = 13
                        require ext_code.size(lenders[idx])
                        staticcall lenders[idx].hasAssets() with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2799 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_2799] == bool(mem[_2799])
                        if not mem[_2799]:
                            idx = idx + 1
                            s = s
                            t = t
                            continue 
                        require idx < lenders.length
                        mem[0] = 13
                        require ext_code.size(lenders[idx])
                        staticcall lenders[idx].apr() with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2993 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _3012 = mem[_2993]
                        if mem[_2993] >= t:
                            idx = idx + 1
                            s = s
                            t = t
                            continue 
                        require idx < lenders.length
                        mem[0] = 13
                        require ext_code.size(lenders[idx])
                        staticcall lenders[idx].nav() with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3116 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        idx = idx + 1
                        s = mem[_3116]
                        t = _3012
                        continue 
                    if _1734 + s < s:
                        revert with 0, 'SafeMath: addition overflow'
                    idx = 0
                    u = 0
                    while idx < lenders.length:
                        mem[0] = 13
                        mem[mem[64] + 4] = _1734
                        require ext_code.size(lenders[idx])
                        staticcall lenders[idx].aprAfterDeposit(uint256 arg1) with:
                                gas gas_remaining wei
                               args _1734
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _5223 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if mem[_5223] <= u:
                            idx = idx + 1
                            u = u
                            continue 
                        idx = idx + 1
                        u = mem[_5223]
                        continue 
                    require 0 < lenders.length
                    mem[0] = 13
                    mem[mem[64] + 4] = _1734 + s
                    require ext_code.size(lenders)
                    staticcall lenders.aprAfterDeposit(uint256 arg1) with:
                            gas gas_remaining wei
                           args (_1734 + s)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _5222 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _5274 = mem[_5222]
                    if mem[_5222] <= t:
                        return 0
                    require 0 < lenders.length
                    mem[0] = 13
                    require ext_code.size(lenders)
                    staticcall lenders.nav() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _5515 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _5522 = mem[_5515]
                    if not mem[_5515]:
                        _5749 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5749] = 26
                        mem[_5749 + 32] = 'SafeMath: division by zero'
                        _5959 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5959] = 26
                        mem[_5959 + 32] = 'SafeMath: division by zero'
                        if 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83 == wantAddress:
                            if not arg1:
                                return 0
                            if profitFactor * arg1 / arg1 != profitFactor:
                                revert with 0, 'SafeMath: multiplication overflow'
                            return (profitFactor * arg1 < 0)
                        if wantToEthOracleAddress:
                            mem[mem[64] + 4] = arg1
                            require ext_code.size(wantToEthOracleAddress)
                            staticcall wantToEthOracleAddress.0x780022a0 with:
                                    gas gas_remaining wei
                                   args arg1
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _6030 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if not mem[_6030]:
                                return 0
                            if profitFactor * mem[_6030] / mem[_6030] != profitFactor:
                                revert with 0, 'SafeMath: multiplication overflow'
                            mem[mem[64]] = profitFactor * mem[_6030] < 0
                        else:
                            _5976 = mem[64]
                            mem[mem[64]] = 2
                            mem[64] = mem[64] + 96
                            require 0 < mem[_5976]
                            mem[_5976 + 32] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                            require 1 < mem[_5976]
                            mem[_5976 + 64] = wantAddress
                            mem[_5976 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                            mem[_5976 + 100] = arg1
                            mem[_5976 + 132] = 64
                            mem[_5976 + 164] = mem[_5976]
                            idx = 0
                            s = _5976 + 196
                            t = _5976 + 32
                            while idx < mem[_5976]:
                                mem[s] = mem[t + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            require ext_code.size(0xf491e7b69e4244ad4002bc14e878a34207e38c29)
                            staticcall 0xf491e7b69e4244ad4002bc14e878a34207e38c29.mem[mem[64] len 4] with:
                                    gas gas_remaining wei
                                   args mem[mem[64] + 4 len _5976 + (32 * mem[_5976]) + -mem[64] + 192]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _6554 = mem[64]
                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _6572 = mem[_6554]
                            require mem[_6554] <= test266151307()
                            require _6554 + return_data.size > _6554 + mem[_6554] + 31
                            _6590 = mem[_6554 + mem[_6554]]
                            require mem[_6554 + mem[_6554]] <= test266151307()
                            require (32 * mem[_6554 + mem[_6554]]) + 32 >= 0 and _6554 + ceil32(return_data.size) + (32 * mem[_6554 + mem[_6554]]) + 32 <= test266151307()
                            mem[64] = _6554 + ceil32(return_data.size) + (32 * mem[_6554 + mem[_6554]]) + 32
                            mem[_6554 + ceil32(return_data.size)] = _6590
                            require return_data.size >= _6572 + (32 * _6590) + 32
                            mem[_6554 + ceil32(return_data.size) + 32 len 32 * _6590] = mem[_6554 + _6572 + 32 len 32 * _6590]
                            require _6590 - 1 < _6590
                            if not mem[(32 * _6590 - 1) + _6554 + ceil32(return_data.size) + 32]:
                                return 0
                            if profitFactor * mem[(32 * _6590 - 1) + _6554 + ceil32(return_data.size) + 32] / mem[(32 * _6590 - 1) + _6554 + ceil32(return_data.size) + 32] != profitFactor:
                                revert with 0, 'SafeMath: multiplication overflow'
                            mem[mem[64]] = profitFactor * mem[(32 * _6590 - 1) + _6554 + ceil32(return_data.size) + 32] < 0
                    else:
                        if t * mem[_5515] / mem[_5515] != t:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not mem[_5515]:
                            _5832 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5832] = 26
                            mem[_5832 + 32] = 'SafeMath: division by zero'
                            if not -1 * t * _5522 / 10^18:
                                _5963 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5963] = 26
                                mem[_5963 + 32] = 'SafeMath: division by zero'
                                if 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83 == wantAddress:
                                    if not arg1:
                                        return 0
                                    if profitFactor * arg1 / arg1 != profitFactor:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    return (profitFactor * arg1 < 0)
                                if wantToEthOracleAddress:
                                    mem[mem[64] + 4] = arg1
                                    require ext_code.size(wantToEthOracleAddress)
                                    staticcall wantToEthOracleAddress.0x780022a0 with:
                                            gas gas_remaining wei
                                           args arg1
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _6042 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if not mem[_6042]:
                                        return 0
                                    if profitFactor * mem[_6042] / mem[_6042] != profitFactor:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[mem[64]] = profitFactor * mem[_6042] < 0
                                else:
                                    _5982 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    require 0 < mem[_5982]
                                    mem[_5982 + 32] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    require 1 < mem[_5982]
                                    mem[_5982 + 64] = wantAddress
                                    mem[_5982 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                    mem[_5982 + 100] = arg1
                                    mem[_5982 + 132] = 64
                                    mem[_5982 + 164] = mem[_5982]
                                    idx = 0
                                    s = _5982 + 196
                                    t = _5982 + 32
                                    while idx < mem[_5982]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(0xf491e7b69e4244ad4002bc14e878a34207e38c29)
                                    staticcall 0xf491e7b69e4244ad4002bc14e878a34207e38c29.mem[mem[64] len 4] with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4 len _5982 + (32 * mem[_5982]) + -mem[64] + 192]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _6553 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _6571 = mem[_6553]
                                    require mem[_6553] <= test266151307()
                                    require _6553 + return_data.size > _6553 + mem[_6553] + 31
                                    _6589 = mem[_6553 + mem[_6553]]
                                    require mem[_6553 + mem[_6553]] <= test266151307()
                                    require (32 * mem[_6553 + mem[_6553]]) + 32 >= 0 and _6553 + ceil32(return_data.size) + (32 * mem[_6553 + mem[_6553]]) + 32 <= test266151307()
                                    mem[64] = _6553 + ceil32(return_data.size) + (32 * mem[_6553 + mem[_6553]]) + 32
                                    mem[_6553 + ceil32(return_data.size)] = _6589
                                    require return_data.size >= _6571 + (32 * _6589) + 32
                                    mem[_6553 + ceil32(return_data.size) + 32 len 32 * _6589] = mem[_6553 + _6571 + 32 len 32 * _6589]
                                    require _6589 - 1 < _6589
                                    if not mem[(32 * _6589 - 1) + _6553 + ceil32(return_data.size) + 32]:
                                        return 0
                                    if profitFactor * mem[(32 * _6589 - 1) + _6553 + ceil32(return_data.size) + 32] / mem[(32 * _6589 - 1) + _6553 + ceil32(return_data.size) + 32] != profitFactor:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[mem[64]] = profitFactor * mem[(32 * _6589 - 1) + _6553 + ceil32(return_data.size) + 32] < 0
                            else:
                                if maxReportDelay * -1 * t * _5522 / 10^18 / -1 * t * _5522 / 10^18 != maxReportDelay:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _5967 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5967] = 26
                                mem[_5967 + 32] = 'SafeMath: division by zero'
                                if 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83 == wantAddress:
                                    if not arg1:
                                        return (0 < maxReportDelay * -1 * t * _5522 / 10^18 / 31556952)
                                    if profitFactor * arg1 / arg1 != profitFactor:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    return (profitFactor * arg1 < maxReportDelay * -1 * t * _5522 / 10^18 / 31556952)
                                if wantToEthOracleAddress:
                                    mem[mem[64] + 4] = arg1
                                    require ext_code.size(wantToEthOracleAddress)
                                    staticcall wantToEthOracleAddress.0x780022a0 with:
                                            gas gas_remaining wei
                                           args arg1
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _6054 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if not mem[_6054]:
                                        return (0 < maxReportDelay * -1 * t * _5522 / 10^18 / 31556952)
                                    if profitFactor * mem[_6054] / mem[_6054] != profitFactor:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[mem[64]] = profitFactor * mem[_6054] < maxReportDelay * -1 * t * _5522 / 10^18 / 31556952
                                else:
                                    _5993 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    require 0 < mem[_5993]
                                    mem[_5993 + 32] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    require 1 < mem[_5993]
                                    mem[_5993 + 64] = wantAddress
                                    mem[_5993 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                    mem[_5993 + 100] = arg1
                                    mem[_5993 + 132] = 64
                                    mem[_5993 + 164] = mem[_5993]
                                    idx = 0
                                    s = _5993 + 196
                                    u = _5993 + 32
                                    while idx < mem[_5993]:
                                        mem[s] = mem[u + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        u = u + 32
                                        continue 
                                    require ext_code.size(0xf491e7b69e4244ad4002bc14e878a34207e38c29)
                                    staticcall 0xf491e7b69e4244ad4002bc14e878a34207e38c29.mem[mem[64] len 4] with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4 len _5993 + (32 * mem[_5993]) + -mem[64] + 192]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _6552 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _6570 = mem[_6552]
                                    require mem[_6552] <= test266151307()
                                    require _6552 + return_data.size > _6552 + mem[_6552] + 31
                                    _6588 = mem[_6552 + mem[_6552]]
                                    require mem[_6552 + mem[_6552]] <= test266151307()
                                    require (32 * mem[_6552 + mem[_6552]]) + 32 >= 0 and _6552 + ceil32(return_data.size) + (32 * mem[_6552 + mem[_6552]]) + 32 <= test266151307()
                                    mem[64] = _6552 + ceil32(return_data.size) + (32 * mem[_6552 + mem[_6552]]) + 32
                                    mem[_6552 + ceil32(return_data.size)] = _6588
                                    require return_data.size >= _6570 + (32 * _6588) + 32
                                    mem[_6552 + ceil32(return_data.size) + 32 len 32 * _6588] = mem[_6552 + _6570 + 32 len 32 * _6588]
                                    require _6588 - 1 < _6588
                                    if not mem[(32 * _6588 - 1) + _6552 + ceil32(return_data.size) + 32]:
                                        return (0 < maxReportDelay * -1 * t * _5522 / 10^18 / 31556952)
                                    if profitFactor * mem[(32 * _6588 - 1) + _6552 + ceil32(return_data.size) + 32] / mem[(32 * _6588 - 1) + _6552 + ceil32(return_data.size) + 32] != profitFactor:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[mem[64]] = profitFactor * mem[(32 * _6588 - 1) + _6552 + ceil32(return_data.size) + 32] < maxReportDelay * -1 * t * _5522 / 10^18 / 31556952
                        else:
                            if _5274 * mem[_5515] / mem[_5515] != _5274:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _5874 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5874] = 26
                            mem[_5874 + 32] = 'SafeMath: division by zero'
                            if not (_5274 * _5522) - (t * _5522) / 10^18:
                                _5966 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5966] = 26
                                mem[_5966 + 32] = 'SafeMath: division by zero'
                                if 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83 == wantAddress:
                                    if not arg1:
                                        return 0
                                    if profitFactor * arg1 / arg1 != profitFactor:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    return (profitFactor * arg1 < 0)
                                if wantToEthOracleAddress:
                                    mem[mem[64] + 4] = arg1
                                    require ext_code.size(wantToEthOracleAddress)
                                    staticcall wantToEthOracleAddress.0x780022a0 with:
                                            gas gas_remaining wei
                                           args arg1
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _6053 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if not mem[_6053]:
                                        return 0
                                    if profitFactor * mem[_6053] / mem[_6053] != profitFactor:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[mem[64]] = profitFactor * mem[_6053] < 0
                                else:
                                    _5990 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    require 0 < mem[_5990]
                                    mem[_5990 + 32] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    require 1 < mem[_5990]
                                    mem[_5990 + 64] = wantAddress
                                    mem[_5990 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                    mem[_5990 + 100] = arg1
                                    mem[_5990 + 132] = 64
                                    mem[_5990 + 164] = mem[_5990]
                                    idx = 0
                                    s = _5990 + 196
                                    t = _5990 + 32
                                    while idx < mem[_5990]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(0xf491e7b69e4244ad4002bc14e878a34207e38c29)
                                    staticcall 0xf491e7b69e4244ad4002bc14e878a34207e38c29.mem[mem[64] len 4] with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4 len _5990 + (32 * mem[_5990]) + -mem[64] + 192]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _6551 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _6569 = mem[_6551]
                                    require mem[_6551] <= test266151307()
                                    require _6551 + return_data.size > _6551 + mem[_6551] + 31
                                    _6587 = mem[_6551 + mem[_6551]]
                                    require mem[_6551 + mem[_6551]] <= test266151307()
                                    require (32 * mem[_6551 + mem[_6551]]) + 32 >= 0 and _6551 + ceil32(return_data.size) + (32 * mem[_6551 + mem[_6551]]) + 32 <= test266151307()
                                    mem[64] = _6551 + ceil32(return_data.size) + (32 * mem[_6551 + mem[_6551]]) + 32
                                    mem[_6551 + ceil32(return_data.size)] = _6587
                                    require return_data.size >= _6569 + (32 * _6587) + 32
                                    mem[_6551 + ceil32(return_data.size) + 32 len 32 * _6587] = mem[_6551 + _6569 + 32 len 32 * _6587]
                                    require _6587 - 1 < _6587
                                    if not mem[(32 * _6587 - 1) + _6551 + ceil32(return_data.size) + 32]:
                                        return 0
                                    if profitFactor * mem[(32 * _6587 - 1) + _6551 + ceil32(return_data.size) + 32] / mem[(32 * _6587 - 1) + _6551 + ceil32(return_data.size) + 32] != profitFactor:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[mem[64]] = profitFactor * mem[(32 * _6587 - 1) + _6551 + ceil32(return_data.size) + 32] < 0
                            else:
                                if maxReportDelay * (_5274 * _5522) - (t * _5522) / 10^18 / (_5274 * _5522) - (t * _5522) / 10^18 != maxReportDelay:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _5972 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5972] = 26
                                mem[_5972 + 32] = 'SafeMath: division by zero'
                                if 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83 == wantAddress:
                                    if not arg1:
                                        return (0 < maxReportDelay * (_5274 * _5522) - (t * _5522) / 10^18 / 31556952)
                                    if profitFactor * arg1 / arg1 != profitFactor:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    return (profitFactor * arg1 < maxReportDelay * (_5274 * _5522) - (t * _5522) / 10^18 / 31556952)
                                if wantToEthOracleAddress:
                                    mem[mem[64] + 4] = arg1
                                    require ext_code.size(wantToEthOracleAddress)
                                    staticcall wantToEthOracleAddress.0x780022a0 with:
                                            gas gas_remaining wei
                                           args arg1
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _6066 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if not mem[_6066]:
                                        return (0 < maxReportDelay * (_5274 * _5522) - (t * _5522) / 10^18 / 31556952)
                                    if profitFactor * mem[_6066] / mem[_6066] != profitFactor:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[mem[64]] = profitFactor * mem[_6066] < maxReportDelay * (_5274 * _5522) - (t * _5522) / 10^18 / 31556952
                                else:
                                    _6008 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    require 0 < mem[_6008]
                                    mem[_6008 + 32] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    require 1 < mem[_6008]
                                    mem[_6008 + 64] = wantAddress
                                    mem[_6008 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                    mem[_6008 + 100] = arg1
                                    mem[_6008 + 132] = 64
                                    mem[_6008 + 164] = mem[_6008]
                                    idx = 0
                                    s = _6008 + 196
                                    u = _6008 + 32
                                    while idx < mem[_6008]:
                                        mem[s] = mem[u + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        u = u + 32
                                        continue 
                                    require ext_code.size(0xf491e7b69e4244ad4002bc14e878a34207e38c29)
                                    staticcall 0xf491e7b69e4244ad4002bc14e878a34207e38c29.mem[mem[64] len 4] with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4 len _6008 + (32 * mem[_6008]) + -mem[64] + 192]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _6550 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _6568 = mem[_6550]
                                    require mem[_6550] <= test266151307()
                                    require _6550 + return_data.size > _6550 + mem[_6550] + 31
                                    _6586 = mem[_6550 + mem[_6550]]
                                    require mem[_6550 + mem[_6550]] <= test266151307()
                                    require (32 * mem[_6550 + mem[_6550]]) + 32 >= 0 and _6550 + ceil32(return_data.size) + (32 * mem[_6550 + mem[_6550]]) + 32 <= test266151307()
                                    mem[64] = _6550 + ceil32(return_data.size) + (32 * mem[_6550 + mem[_6550]]) + 32
                                    mem[_6550 + ceil32(return_data.size)] = _6586
                                    require return_data.size >= _6568 + (32 * _6586) + 32
                                    mem[_6550 + ceil32(return_data.size) + 32 len 32 * _6586] = mem[_6550 + _6568 + 32 len 32 * _6586]
                                    require _6586 - 1 < _6586
                                    if not mem[(32 * _6586 - 1) + _6550 + ceil32(return_data.size) + 32]:
                                        return (0 < maxReportDelay * (_5274 * _5522) - (t * _5522) / 10^18 / 31556952)
                                    if profitFactor * mem[(32 * _6586 - 1) + _6550 + ceil32(return_data.size) + 32] / mem[(32 * _6586 - 1) + _6550 + ceil32(return_data.size) + 32] != profitFactor:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[mem[64]] = profitFactor * mem[(32 * _6586 - 1) + _6550 + ceil32(return_data.size) + 32] < maxReportDelay * (_5274 * _5522) - (t * _5522) / 10^18 / 31556952
                else:
                    _1680 = mem[_1592 + 160]
                    _1694 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1694] = 30
                    mem[_1694 + 32] = 'SafeMath: subtraction overflow'
                    if _1680 > block.timestamp:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if block.timestamp - _1680 >= maxReportDelay:
                        return 0
                    require ext_code.size(vaultAddress)
                    staticcall vaultAddress.debtOutstanding() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1726 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if mem[_1726] > debtThreshold:
                        return 0
                    idx = 0
                    s = 0
                    while idx < lenders.length:
                        mem[0] = 13
                        require ext_code.size(lenders[idx])
                        staticcall lenders[idx].nav() with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2798 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _2844 = mem[_2798]
                        if mem[_2798] + s < s:
                            revert with 0, 'SafeMath: addition overflow'
                        idx = idx + 1
                        s = mem[_2798] + s
                        continue 
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(wantAddress)
                    staticcall wantAddress.balanceOf(address arg1) with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2843 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2887 = mem[_2843]
                    if mem[_2843] + (_2844 * lenders.length) < _2844 * lenders.length:
                        revert with 0, 'SafeMath: addition overflow'
                    if debtThreshold < 0:
                        revert with 0, 'SafeMath: addition overflow'
                    if debtThreshold + mem[_2843] + (_2844 * lenders.length) < mem[_1592 + 192]:
                        return 0
                    if mem[_2843] + (_2844 * lenders.length) <= mem[_1592 + 192]:
                        require ext_code.size(vaultAddress)
                        staticcall vaultAddress.creditAvailable() with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3114 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if mem[_3114] < mem[_3114]:
                            revert with 0, 'SafeMath: addition overflow'
                        if not profitFactor:
                            if 0 < mem[_3114]:
                                return 0
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(wantAddress)
                            staticcall wantAddress.balanceOf(address arg1) with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3338 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _3381 = mem[_3338]
                            idx = 0
                            s = 0
                            t = -1
                            while idx < lenders.length:
                                mem[0] = 13
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].hasAssets() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _5165 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_5165] == bool(mem[_5165])
                                if not mem[_5165]:
                                    idx = idx + 1
                                    s = s
                                    t = t
                                    continue 
                                require idx < lenders.length
                                mem[0] = 13
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].apr() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _5511 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _5519 = mem[_5511]
                                if mem[_5511] >= t:
                                    idx = idx + 1
                                    s = s
                                    t = t
                                    continue 
                                require idx < lenders.length
                                mem[0] = 13
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].nav() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _5697 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                idx = idx + 1
                                s = mem[_5697]
                                t = _5519
                                continue 
                            if _3381 + s < s:
                                revert with 0, 'SafeMath: addition overflow'
                            idx = 0
                            u = 0
                            while idx < lenders.length:
                                mem[0] = 13
                                mem[mem[64] + 4] = _3381
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].aprAfterDeposit(uint256 arg1) with:
                                        gas gas_remaining wei
                                       args _3381
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _6563 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if mem[_6563] <= u:
                                    idx = idx + 1
                                    u = u
                                    continue 
                                idx = idx + 1
                                u = mem[_6563]
                                continue 
                            require 0 < lenders.length
                            mem[0] = 13
                            mem[mem[64] + 4] = _3381 + s
                            require ext_code.size(lenders)
                            staticcall lenders.aprAfterDeposit(uint256 arg1) with:
                                    gas gas_remaining wei
                                   args (_3381 + s)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _6562 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _6580 = mem[_6562]
                            if mem[_6562] <= t:
                                return 0
                            require 0 < lenders.length
                            mem[0] = 13
                            require ext_code.size(lenders)
                            staticcall lenders.nav() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _6865 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _6871 = mem[_6865]
                            if not mem[_6865]:
                                _6935 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6935] = 26
                                mem[_6935 + 32] = 'SafeMath: division by zero'
                                _7005 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_7005] = 26
                                mem[_7005 + 32] = 'SafeMath: division by zero'
                                if 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83 == wantAddress:
                                    if not arg1:
                                        return 0
                                    if profitFactor * arg1 / arg1 != profitFactor:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    return (profitFactor * arg1 < 0)
                                if wantToEthOracleAddress:
                                    mem[mem[64] + 4] = arg1
                                    require ext_code.size(wantToEthOracleAddress)
                                    staticcall wantToEthOracleAddress.0x780022a0 with:
                                            gas gas_remaining wei
                                           args arg1
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7147 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if not mem[_7147]:
                                        return 0
                                    if profitFactor * mem[_7147] / mem[_7147] != profitFactor:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[mem[64]] = profitFactor * mem[_7147] < 0
                                else:
                                    _7041 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    require 0 < mem[_7041]
                                    mem[_7041 + 32] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    require 1 < mem[_7041]
                                    mem[_7041 + 64] = wantAddress
                                    mem[_7041 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                    mem[_7041 + 100] = arg1
                                    mem[_7041 + 132] = 64
                                    mem[_7041 + 164] = mem[_7041]
                                    idx = 0
                                    s = _7041 + 196
                                    t = _7041 + 32
                                    while idx < mem[_7041]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(0xf491e7b69e4244ad4002bc14e878a34207e38c29)
                                    staticcall 0xf491e7b69e4244ad4002bc14e878a34207e38c29.mem[mem[64] len 4] with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4 len _7041 + (32 * mem[_7041]) + -mem[64] + 192]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7867 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _7887 = mem[_7867]
                                    require mem[_7867] <= test266151307()
                                    require _7867 + return_data.size > _7867 + mem[_7867] + 31
                                    _7907 = mem[_7867 + mem[_7867]]
                                    require mem[_7867 + mem[_7867]] <= test266151307()
                                    require (32 * mem[_7867 + mem[_7867]]) + 32 >= 0 and _7867 + ceil32(return_data.size) + (32 * mem[_7867 + mem[_7867]]) + 32 <= test266151307()
                                    mem[64] = _7867 + ceil32(return_data.size) + (32 * mem[_7867 + mem[_7867]]) + 32
                                    mem[_7867 + ceil32(return_data.size)] = _7907
                                    require return_data.size >= _7887 + (32 * _7907) + 32
                                    mem[_7867 + ceil32(return_data.size) + 32 len 32 * _7907] = mem[_7867 + _7887 + 32 len 32 * _7907]
                                    require _7907 - 1 < _7907
                                    if not mem[(32 * _7907 - 1) + _7867 + ceil32(return_data.size) + 32]:
                                        return 0
                                    if profitFactor * mem[(32 * _7907 - 1) + _7867 + ceil32(return_data.size) + 32] / mem[(32 * _7907 - 1) + _7867 + ceil32(return_data.size) + 32] != profitFactor:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[mem[64]] = profitFactor * mem[(32 * _7907 - 1) + _7867 + ceil32(return_data.size) + 32] < 0
                            else:
                                if t * mem[_6865] / mem[_6865] != t:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not mem[_6865]:
                                    _6961 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6961] = 26
                                    mem[_6961 + 32] = 'SafeMath: division by zero'
                                    if not -1 * t * _6871 / 10^18:
                                        _7013 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7013] = 26
                                        mem[_7013 + 32] = 'SafeMath: division by zero'
                                        if 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83 == wantAddress:
                                            if not arg1:
                                                return 0
                                            if profitFactor * arg1 / arg1 != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            return (profitFactor * arg1 < 0)
                                        if wantToEthOracleAddress:
                                            mem[mem[64] + 4] = arg1
                                            require ext_code.size(wantToEthOracleAddress)
                                            staticcall wantToEthOracleAddress.0x780022a0 with:
                                                    gas gas_remaining wei
                                                   args arg1
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7173 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if not mem[_7173]:
                                                return 0
                                            if profitFactor * mem[_7173] / mem[_7173] != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[mem[64]] = profitFactor * mem[_7173] < 0
                                        else:
                                            _7054 = mem[64]
                                            mem[mem[64]] = 2
                                            mem[64] = mem[64] + 96
                                            require 0 < mem[_7054]
                                            mem[_7054 + 32] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                            require 1 < mem[_7054]
                                            mem[_7054 + 64] = wantAddress
                                            mem[_7054 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[_7054 + 100] = arg1
                                            mem[_7054 + 132] = 64
                                            mem[_7054 + 164] = mem[_7054]
                                            idx = 0
                                            s = _7054 + 196
                                            t = _7054 + 32
                                            while idx < mem[_7054]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            require ext_code.size(0xf491e7b69e4244ad4002bc14e878a34207e38c29)
                                            staticcall 0xf491e7b69e4244ad4002bc14e878a34207e38c29.mem[mem[64] len 4] with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4 len _7054 + (32 * mem[_7054]) + -mem[64] + 192]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7866 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7886 = mem[_7866]
                                            require mem[_7866] <= test266151307()
                                            require _7866 + return_data.size > _7866 + mem[_7866] + 31
                                            _7906 = mem[_7866 + mem[_7866]]
                                            require mem[_7866 + mem[_7866]] <= test266151307()
                                            require (32 * mem[_7866 + mem[_7866]]) + 32 >= 0 and _7866 + ceil32(return_data.size) + (32 * mem[_7866 + mem[_7866]]) + 32 <= test266151307()
                                            mem[64] = _7866 + ceil32(return_data.size) + (32 * mem[_7866 + mem[_7866]]) + 32
                                            mem[_7866 + ceil32(return_data.size)] = _7906
                                            require return_data.size >= _7886 + (32 * _7906) + 32
                                            mem[_7866 + ceil32(return_data.size) + 32 len 32 * _7906] = mem[_7866 + _7886 + 32 len 32 * _7906]
                                            require _7906 - 1 < _7906
                                            if not mem[(32 * _7906 - 1) + _7866 + ceil32(return_data.size) + 32]:
                                                return 0
                                            if profitFactor * mem[(32 * _7906 - 1) + _7866 + ceil32(return_data.size) + 32] / mem[(32 * _7906 - 1) + _7866 + ceil32(return_data.size) + 32] != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[mem[64]] = profitFactor * mem[(32 * _7906 - 1) + _7866 + ceil32(return_data.size) + 32] < 0
                                    else:
                                        if maxReportDelay * -1 * t * _6871 / 10^18 / -1 * t * _6871 / 10^18 != maxReportDelay:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _7022 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7022] = 26
                                        mem[_7022 + 32] = 'SafeMath: division by zero'
                                        if 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83 == wantAddress:
                                            if not arg1:
                                                return (0 < maxReportDelay * -1 * t * _6871 / 10^18 / 31556952)
                                            if profitFactor * arg1 / arg1 != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            return (profitFactor * arg1 < maxReportDelay * -1 * t * _6871 / 10^18 / 31556952)
                                        if wantToEthOracleAddress:
                                            mem[mem[64] + 4] = arg1
                                            require ext_code.size(wantToEthOracleAddress)
                                            staticcall wantToEthOracleAddress.0x780022a0 with:
                                                    gas gas_remaining wei
                                                   args arg1
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7199 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if not mem[_7199]:
                                                return (0 < maxReportDelay * -1 * t * _6871 / 10^18 / 31556952)
                                            if profitFactor * mem[_7199] / mem[_7199] != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[mem[64]] = profitFactor * mem[_7199] < maxReportDelay * -1 * t * _6871 / 10^18 / 31556952
                                        else:
                                            _7078 = mem[64]
                                            mem[mem[64]] = 2
                                            mem[64] = mem[64] + 96
                                            require 0 < mem[_7078]
                                            mem[_7078 + 32] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                            require 1 < mem[_7078]
                                            mem[_7078 + 64] = wantAddress
                                            mem[_7078 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[_7078 + 100] = arg1
                                            mem[_7078 + 132] = 64
                                            mem[_7078 + 164] = mem[_7078]
                                            idx = 0
                                            s = _7078 + 196
                                            u = _7078 + 32
                                            while idx < mem[_7078]:
                                                mem[s] = mem[u + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                u = u + 32
                                                continue 
                                            require ext_code.size(0xf491e7b69e4244ad4002bc14e878a34207e38c29)
                                            staticcall 0xf491e7b69e4244ad4002bc14e878a34207e38c29.mem[mem[64] len 4] with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4 len _7078 + (32 * mem[_7078]) + -mem[64] + 192]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7865 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7885 = mem[_7865]
                                            require mem[_7865] <= test266151307()
                                            require _7865 + return_data.size > _7865 + mem[_7865] + 31
                                            _7905 = mem[_7865 + mem[_7865]]
                                            require mem[_7865 + mem[_7865]] <= test266151307()
                                            require (32 * mem[_7865 + mem[_7865]]) + 32 >= 0 and _7865 + ceil32(return_data.size) + (32 * mem[_7865 + mem[_7865]]) + 32 <= test266151307()
                                            mem[64] = _7865 + ceil32(return_data.size) + (32 * mem[_7865 + mem[_7865]]) + 32
                                            mem[_7865 + ceil32(return_data.size)] = _7905
                                            require return_data.size >= _7885 + (32 * _7905) + 32
                                            mem[_7865 + ceil32(return_data.size) + 32 len 32 * _7905] = mem[_7865 + _7885 + 32 len 32 * _7905]
                                            require _7905 - 1 < _7905
                                            if not mem[(32 * _7905 - 1) + _7865 + ceil32(return_data.size) + 32]:
                                                return (0 < maxReportDelay * -1 * t * _6871 / 10^18 / 31556952)
                                            if profitFactor * mem[(32 * _7905 - 1) + _7865 + ceil32(return_data.size) + 32] / mem[(32 * _7905 - 1) + _7865 + ceil32(return_data.size) + 32] != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[mem[64]] = profitFactor * mem[(32 * _7905 - 1) + _7865 + ceil32(return_data.size) + 32] < maxReportDelay * -1 * t * _6871 / 10^18 / 31556952
                                else:
                                    if _6580 * mem[_6865] / mem[_6865] != _6580:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _6976 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6976] = 26
                                    mem[_6976 + 32] = 'SafeMath: division by zero'
                                    if not (_6580 * _6871) - (t * _6871) / 10^18:
                                        _7021 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7021] = 26
                                        mem[_7021 + 32] = 'SafeMath: division by zero'
                                        if 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83 == wantAddress:
                                            if not arg1:
                                                return 0
                                            if profitFactor * arg1 / arg1 != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            return (profitFactor * arg1 < 0)
                                        if wantToEthOracleAddress:
                                            mem[mem[64] + 4] = arg1
                                            require ext_code.size(wantToEthOracleAddress)
                                            staticcall wantToEthOracleAddress.0x780022a0 with:
                                                    gas gas_remaining wei
                                                   args arg1
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7198 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if not mem[_7198]:
                                                return 0
                                            if profitFactor * mem[_7198] / mem[_7198] != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[mem[64]] = profitFactor * mem[_7198] < 0
                                        else:
                                            _7075 = mem[64]
                                            mem[mem[64]] = 2
                                            mem[64] = mem[64] + 96
                                            require 0 < mem[_7075]
                                            mem[_7075 + 32] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                            require 1 < mem[_7075]
                                            mem[_7075 + 64] = wantAddress
                                            mem[_7075 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[_7075 + 100] = arg1
                                            mem[_7075 + 132] = 64
                                            mem[_7075 + 164] = mem[_7075]
                                            idx = 0
                                            s = _7075 + 196
                                            t = _7075 + 32
                                            while idx < mem[_7075]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            require ext_code.size(0xf491e7b69e4244ad4002bc14e878a34207e38c29)
                                            staticcall 0xf491e7b69e4244ad4002bc14e878a34207e38c29.mem[mem[64] len 4] with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4 len _7075 + (32 * mem[_7075]) + -mem[64] + 192]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7864 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7884 = mem[_7864]
                                            require mem[_7864] <= test266151307()
                                            require _7864 + return_data.size > _7864 + mem[_7864] + 31
                                            _7904 = mem[_7864 + mem[_7864]]
                                            require mem[_7864 + mem[_7864]] <= test266151307()
                                            require (32 * mem[_7864 + mem[_7864]]) + 32 >= 0 and _7864 + ceil32(return_data.size) + (32 * mem[_7864 + mem[_7864]]) + 32 <= test266151307()
                                            mem[64] = _7864 + ceil32(return_data.size) + (32 * mem[_7864 + mem[_7864]]) + 32
                                            mem[_7864 + ceil32(return_data.size)] = _7904
                                            require return_data.size >= _7884 + (32 * _7904) + 32
                                            mem[_7864 + ceil32(return_data.size) + 32 len 32 * _7904] = mem[_7864 + _7884 + 32 len 32 * _7904]
                                            require _7904 - 1 < _7904
                                            if not mem[(32 * _7904 - 1) + _7864 + ceil32(return_data.size) + 32]:
                                                return 0
                                            if profitFactor * mem[(32 * _7904 - 1) + _7864 + ceil32(return_data.size) + 32] / mem[(32 * _7904 - 1) + _7864 + ceil32(return_data.size) + 32] != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[mem[64]] = profitFactor * mem[(32 * _7904 - 1) + _7864 + ceil32(return_data.size) + 32] < 0
                                    else:
                                        if maxReportDelay * (_6580 * _6871) - (t * _6871) / 10^18 / (_6580 * _6871) - (t * _6871) / 10^18 != maxReportDelay:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _7032 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7032] = 26
                                        mem[_7032 + 32] = 'SafeMath: division by zero'
                                        if 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83 == wantAddress:
                                            if not arg1:
                                                return (0 < maxReportDelay * (_6580 * _6871) - (t * _6871) / 10^18 / 31556952)
                                            if profitFactor * arg1 / arg1 != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            return (profitFactor * arg1 < maxReportDelay * (_6580 * _6871) - (t * _6871) / 10^18 / 31556952)
                                        if wantToEthOracleAddress:
                                            mem[mem[64] + 4] = arg1
                                            require ext_code.size(wantToEthOracleAddress)
                                            staticcall wantToEthOracleAddress.0x780022a0 with:
                                                    gas gas_remaining wei
                                                   args arg1
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7227 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if not mem[_7227]:
                                                return (0 < maxReportDelay * (_6580 * _6871) - (t * _6871) / 10^18 / 31556952)
                                            if profitFactor * mem[_7227] / mem[_7227] != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[mem[64]] = profitFactor * mem[_7227] < maxReportDelay * (_6580 * _6871) - (t * _6871) / 10^18 / 31556952
                                        else:
                                            _7110 = mem[64]
                                            mem[mem[64]] = 2
                                            mem[64] = mem[64] + 96
                                            require 0 < mem[_7110]
                                            mem[_7110 + 32] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                            require 1 < mem[_7110]
                                            mem[_7110 + 64] = wantAddress
                                            mem[_7110 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[_7110 + 100] = arg1
                                            mem[_7110 + 132] = 64
                                            mem[_7110 + 164] = mem[_7110]
                                            idx = 0
                                            s = _7110 + 196
                                            u = _7110 + 32
                                            while idx < mem[_7110]:
                                                mem[s] = mem[u + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                u = u + 32
                                                continue 
                                            require ext_code.size(0xf491e7b69e4244ad4002bc14e878a34207e38c29)
                                            staticcall 0xf491e7b69e4244ad4002bc14e878a34207e38c29.mem[mem[64] len 4] with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4 len _7110 + (32 * mem[_7110]) + -mem[64] + 192]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7863 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7883 = mem[_7863]
                                            require mem[_7863] <= test266151307()
                                            require _7863 + return_data.size > _7863 + mem[_7863] + 31
                                            _7903 = mem[_7863 + mem[_7863]]
                                            require mem[_7863 + mem[_7863]] <= test266151307()
                                            require (32 * mem[_7863 + mem[_7863]]) + 32 >= 0 and _7863 + ceil32(return_data.size) + (32 * mem[_7863 + mem[_7863]]) + 32 <= test266151307()
                                            mem[64] = _7863 + ceil32(return_data.size) + (32 * mem[_7863 + mem[_7863]]) + 32
                                            mem[_7863 + ceil32(return_data.size)] = _7903
                                            require return_data.size >= _7883 + (32 * _7903) + 32
                                            mem[_7863 + ceil32(return_data.size) + 32 len 32 * _7903] = mem[_7863 + _7883 + 32 len 32 * _7903]
                                            require _7903 - 1 < _7903
                                            if not mem[(32 * _7903 - 1) + _7863 + ceil32(return_data.size) + 32]:
                                                return (0 < maxReportDelay * (_6580 * _6871) - (t * _6871) / 10^18 / 31556952)
                                            if profitFactor * mem[(32 * _7903 - 1) + _7863 + ceil32(return_data.size) + 32] / mem[(32 * _7903 - 1) + _7863 + ceil32(return_data.size) + 32] != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[mem[64]] = profitFactor * mem[(32 * _7903 - 1) + _7863 + ceil32(return_data.size) + 32] < maxReportDelay * (_6580 * _6871) - (t * _6871) / 10^18 / 31556952
                        else:
                            if _1455 * profitFactor / profitFactor != _1455:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if _1455 * profitFactor < mem[_3114]:
                                return 0
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(wantAddress)
                            staticcall wantAddress.balanceOf(address arg1) with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3355 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _3399 = mem[_3355]
                            idx = 0
                            s = 0
                            t = -1
                            while idx < lenders.length:
                                mem[0] = 13
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].hasAssets() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _5164 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_5164] == bool(mem[_5164])
                                if not mem[_5164]:
                                    idx = idx + 1
                                    s = s
                                    t = t
                                    continue 
                                require idx < lenders.length
                                mem[0] = 13
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].apr() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _5510 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _5518 = mem[_5510]
                                if mem[_5510] >= t:
                                    idx = idx + 1
                                    s = s
                                    t = t
                                    continue 
                                require idx < lenders.length
                                mem[0] = 13
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].nav() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _5696 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                idx = idx + 1
                                s = mem[_5696]
                                t = _5518
                                continue 
                            if _3399 + s < s:
                                revert with 0, 'SafeMath: addition overflow'
                            idx = 0
                            u = 0
                            while idx < lenders.length:
                                mem[0] = 13
                                mem[mem[64] + 4] = _3399
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].aprAfterDeposit(uint256 arg1) with:
                                        gas gas_remaining wei
                                       args _3399
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _6561 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if mem[_6561] <= u:
                                    idx = idx + 1
                                    u = u
                                    continue 
                                idx = idx + 1
                                u = mem[_6561]
                                continue 
                            require 0 < lenders.length
                            mem[0] = 13
                            mem[mem[64] + 4] = _3399 + s
                            require ext_code.size(lenders)
                            staticcall lenders.aprAfterDeposit(uint256 arg1) with:
                                    gas gas_remaining wei
                                   args (_3399 + s)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _6560 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _6578 = mem[_6560]
                            if mem[_6560] <= t:
                                return 0
                            require 0 < lenders.length
                            mem[0] = 13
                            require ext_code.size(lenders)
                            staticcall lenders.nav() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _6863 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _6870 = mem[_6863]
                            if not mem[_6863]:
                                _6933 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6933] = 26
                                mem[_6933 + 32] = 'SafeMath: division by zero'
                                _7003 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_7003] = 26
                                mem[_7003 + 32] = 'SafeMath: division by zero'
                                if 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83 == wantAddress:
                                    if not arg1:
                                        return 0
                                    if profitFactor * arg1 / arg1 != profitFactor:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    return (profitFactor * arg1 < 0)
                                if wantToEthOracleAddress:
                                    mem[mem[64] + 4] = arg1
                                    require ext_code.size(wantToEthOracleAddress)
                                    staticcall wantToEthOracleAddress.0x780022a0 with:
                                            gas gas_remaining wei
                                           args arg1
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7140 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if not mem[_7140]:
                                        return 0
                                    if profitFactor * mem[_7140] / mem[_7140] != profitFactor:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[mem[64]] = profitFactor * mem[_7140] < 0
                                else:
                                    _7038 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    require 0 < mem[_7038]
                                    mem[_7038 + 32] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    require 1 < mem[_7038]
                                    mem[_7038 + 64] = wantAddress
                                    mem[_7038 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                    mem[_7038 + 100] = arg1
                                    mem[_7038 + 132] = 64
                                    mem[_7038 + 164] = mem[_7038]
                                    idx = 0
                                    s = _7038 + 196
                                    t = _7038 + 32
                                    while idx < mem[_7038]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(0xf491e7b69e4244ad4002bc14e878a34207e38c29)
                                    staticcall 0xf491e7b69e4244ad4002bc14e878a34207e38c29.mem[mem[64] len 4] with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4 len _7038 + (32 * mem[_7038]) + -mem[64] + 192]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7862 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _7882 = mem[_7862]
                                    require mem[_7862] <= test266151307()
                                    require _7862 + return_data.size > _7862 + mem[_7862] + 31
                                    _7902 = mem[_7862 + mem[_7862]]
                                    require mem[_7862 + mem[_7862]] <= test266151307()
                                    require (32 * mem[_7862 + mem[_7862]]) + 32 >= 0 and _7862 + ceil32(return_data.size) + (32 * mem[_7862 + mem[_7862]]) + 32 <= test266151307()
                                    mem[64] = _7862 + ceil32(return_data.size) + (32 * mem[_7862 + mem[_7862]]) + 32
                                    mem[_7862 + ceil32(return_data.size)] = _7902
                                    require return_data.size >= _7882 + (32 * _7902) + 32
                                    mem[_7862 + ceil32(return_data.size) + 32 len 32 * _7902] = mem[_7862 + _7882 + 32 len 32 * _7902]
                                    require _7902 - 1 < _7902
                                    if not mem[(32 * _7902 - 1) + _7862 + ceil32(return_data.size) + 32]:
                                        return 0
                                    if profitFactor * mem[(32 * _7902 - 1) + _7862 + ceil32(return_data.size) + 32] / mem[(32 * _7902 - 1) + _7862 + ceil32(return_data.size) + 32] != profitFactor:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[mem[64]] = profitFactor * mem[(32 * _7902 - 1) + _7862 + ceil32(return_data.size) + 32] < 0
                            else:
                                if t * mem[_6863] / mem[_6863] != t:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not mem[_6863]:
                                    _6960 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6960] = 26
                                    mem[_6960 + 32] = 'SafeMath: division by zero'
                                    if not -1 * t * _6870 / 10^18:
                                        _7011 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7011] = 26
                                        mem[_7011 + 32] = 'SafeMath: division by zero'
                                        if 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83 == wantAddress:
                                            if not arg1:
                                                return 0
                                            if profitFactor * arg1 / arg1 != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            return (profitFactor * arg1 < 0)
                                        if wantToEthOracleAddress:
                                            mem[mem[64] + 4] = arg1
                                            require ext_code.size(wantToEthOracleAddress)
                                            staticcall wantToEthOracleAddress.0x780022a0 with:
                                                    gas gas_remaining wei
                                                   args arg1
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7166 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if not mem[_7166]:
                                                return 0
                                            if profitFactor * mem[_7166] / mem[_7166] != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[mem[64]] = profitFactor * mem[_7166] < 0
                                        else:
                                            _7050 = mem[64]
                                            mem[mem[64]] = 2
                                            mem[64] = mem[64] + 96
                                            require 0 < mem[_7050]
                                            mem[_7050 + 32] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                            require 1 < mem[_7050]
                                            mem[_7050 + 64] = wantAddress
                                            mem[_7050 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[_7050 + 100] = arg1
                                            mem[_7050 + 132] = 64
                                            mem[_7050 + 164] = mem[_7050]
                                            idx = 0
                                            s = _7050 + 196
                                            t = _7050 + 32
                                            while idx < mem[_7050]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            require ext_code.size(0xf491e7b69e4244ad4002bc14e878a34207e38c29)
                                            staticcall 0xf491e7b69e4244ad4002bc14e878a34207e38c29.mem[mem[64] len 4] with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4 len _7050 + (32 * mem[_7050]) + -mem[64] + 192]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7861 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7881 = mem[_7861]
                                            require mem[_7861] <= test266151307()
                                            require _7861 + return_data.size > _7861 + mem[_7861] + 31
                                            _7901 = mem[_7861 + mem[_7861]]
                                            require mem[_7861 + mem[_7861]] <= test266151307()
                                            require (32 * mem[_7861 + mem[_7861]]) + 32 >= 0 and _7861 + ceil32(return_data.size) + (32 * mem[_7861 + mem[_7861]]) + 32 <= test266151307()
                                            mem[64] = _7861 + ceil32(return_data.size) + (32 * mem[_7861 + mem[_7861]]) + 32
                                            mem[_7861 + ceil32(return_data.size)] = _7901
                                            require return_data.size >= _7881 + (32 * _7901) + 32
                                            mem[_7861 + ceil32(return_data.size) + 32 len 32 * _7901] = mem[_7861 + _7881 + 32 len 32 * _7901]
                                            require _7901 - 1 < _7901
                                            if not mem[(32 * _7901 - 1) + _7861 + ceil32(return_data.size) + 32]:
                                                return 0
                                            if profitFactor * mem[(32 * _7901 - 1) + _7861 + ceil32(return_data.size) + 32] / mem[(32 * _7901 - 1) + _7861 + ceil32(return_data.size) + 32] != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[mem[64]] = profitFactor * mem[(32 * _7901 - 1) + _7861 + ceil32(return_data.size) + 32] < 0
                                    else:
                                        if maxReportDelay * -1 * t * _6870 / 10^18 / -1 * t * _6870 / 10^18 != maxReportDelay:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _7019 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7019] = 26
                                        mem[_7019 + 32] = 'SafeMath: division by zero'
                                        if 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83 == wantAddress:
                                            if not arg1:
                                                return (0 < maxReportDelay * -1 * t * _6870 / 10^18 / 31556952)
                                            if profitFactor * arg1 / arg1 != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            return (profitFactor * arg1 < maxReportDelay * -1 * t * _6870 / 10^18 / 31556952)
                                        if wantToEthOracleAddress:
                                            mem[mem[64] + 4] = arg1
                                            require ext_code.size(wantToEthOracleAddress)
                                            staticcall wantToEthOracleAddress.0x780022a0 with:
                                                    gas gas_remaining wei
                                                   args arg1
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7192 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if not mem[_7192]:
                                                return (0 < maxReportDelay * -1 * t * _6870 / 10^18 / 31556952)
                                            if profitFactor * mem[_7192] / mem[_7192] != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[mem[64]] = profitFactor * mem[_7192] < maxReportDelay * -1 * t * _6870 / 10^18 / 31556952
                                        else:
                                            _7069 = mem[64]
                                            mem[mem[64]] = 2
                                            mem[64] = mem[64] + 96
                                            require 0 < mem[_7069]
                                            mem[_7069 + 32] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                            require 1 < mem[_7069]
                                            mem[_7069 + 64] = wantAddress
                                            mem[_7069 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[_7069 + 100] = arg1
                                            mem[_7069 + 132] = 64
                                            mem[_7069 + 164] = mem[_7069]
                                            idx = 0
                                            s = _7069 + 196
                                            u = _7069 + 32
                                            while idx < mem[_7069]:
                                                mem[s] = mem[u + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                u = u + 32
                                                continue 
                                            require ext_code.size(0xf491e7b69e4244ad4002bc14e878a34207e38c29)
                                            staticcall 0xf491e7b69e4244ad4002bc14e878a34207e38c29.mem[mem[64] len 4] with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4 len _7069 + (32 * mem[_7069]) + -mem[64] + 192]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7860 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7880 = mem[_7860]
                                            require mem[_7860] <= test266151307()
                                            require _7860 + return_data.size > _7860 + mem[_7860] + 31
                                            _7900 = mem[_7860 + mem[_7860]]
                                            require mem[_7860 + mem[_7860]] <= test266151307()
                                            require (32 * mem[_7860 + mem[_7860]]) + 32 >= 0 and _7860 + ceil32(return_data.size) + (32 * mem[_7860 + mem[_7860]]) + 32 <= test266151307()
                                            mem[64] = _7860 + ceil32(return_data.size) + (32 * mem[_7860 + mem[_7860]]) + 32
                                            mem[_7860 + ceil32(return_data.size)] = _7900
                                            require return_data.size >= _7880 + (32 * _7900) + 32
                                            mem[_7860 + ceil32(return_data.size) + 32 len 32 * _7900] = mem[_7860 + _7880 + 32 len 32 * _7900]
                                            require _7900 - 1 < _7900
                                            if not mem[(32 * _7900 - 1) + _7860 + ceil32(return_data.size) + 32]:
                                                return (0 < maxReportDelay * -1 * t * _6870 / 10^18 / 31556952)
                                            if profitFactor * mem[(32 * _7900 - 1) + _7860 + ceil32(return_data.size) + 32] / mem[(32 * _7900 - 1) + _7860 + ceil32(return_data.size) + 32] != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[mem[64]] = profitFactor * mem[(32 * _7900 - 1) + _7860 + ceil32(return_data.size) + 32] < maxReportDelay * -1 * t * _6870 / 10^18 / 31556952
                                else:
                                    if _6578 * mem[_6863] / mem[_6863] != _6578:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _6974 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6974] = 26
                                    mem[_6974 + 32] = 'SafeMath: division by zero'
                                    if not (_6578 * _6870) - (t * _6870) / 10^18:
                                        _7018 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7018] = 26
                                        mem[_7018 + 32] = 'SafeMath: division by zero'
                                        if 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83 == wantAddress:
                                            if not arg1:
                                                return 0
                                            if profitFactor * arg1 / arg1 != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            return (profitFactor * arg1 < 0)
                                        if wantToEthOracleAddress:
                                            mem[mem[64] + 4] = arg1
                                            require ext_code.size(wantToEthOracleAddress)
                                            staticcall wantToEthOracleAddress.0x780022a0 with:
                                                    gas gas_remaining wei
                                                   args arg1
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7191 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if not mem[_7191]:
                                                return 0
                                            if profitFactor * mem[_7191] / mem[_7191] != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[mem[64]] = profitFactor * mem[_7191] < 0
                                        else:
                                            _7066 = mem[64]
                                            mem[mem[64]] = 2
                                            mem[64] = mem[64] + 96
                                            require 0 < mem[_7066]
                                            mem[_7066 + 32] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                            require 1 < mem[_7066]
                                            mem[_7066 + 64] = wantAddress
                                            mem[_7066 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[_7066 + 100] = arg1
                                            mem[_7066 + 132] = 64
                                            mem[_7066 + 164] = mem[_7066]
                                            idx = 0
                                            s = _7066 + 196
                                            t = _7066 + 32
                                            while idx < mem[_7066]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            require ext_code.size(0xf491e7b69e4244ad4002bc14e878a34207e38c29)
                                            staticcall 0xf491e7b69e4244ad4002bc14e878a34207e38c29.mem[mem[64] len 4] with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4 len _7066 + (32 * mem[_7066]) + -mem[64] + 192]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7859 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7879 = mem[_7859]
                                            require mem[_7859] <= test266151307()
                                            require _7859 + return_data.size > _7859 + mem[_7859] + 31
                                            _7899 = mem[_7859 + mem[_7859]]
                                            require mem[_7859 + mem[_7859]] <= test266151307()
                                            require (32 * mem[_7859 + mem[_7859]]) + 32 >= 0 and _7859 + ceil32(return_data.size) + (32 * mem[_7859 + mem[_7859]]) + 32 <= test266151307()
                                            mem[64] = _7859 + ceil32(return_data.size) + (32 * mem[_7859 + mem[_7859]]) + 32
                                            mem[_7859 + ceil32(return_data.size)] = _7899
                                            require return_data.size >= _7879 + (32 * _7899) + 32
                                            mem[_7859 + ceil32(return_data.size) + 32 len 32 * _7899] = mem[_7859 + _7879 + 32 len 32 * _7899]
                                            require _7899 - 1 < _7899
                                            if not mem[(32 * _7899 - 1) + _7859 + ceil32(return_data.size) + 32]:
                                                return 0
                                            if profitFactor * mem[(32 * _7899 - 1) + _7859 + ceil32(return_data.size) + 32] / mem[(32 * _7899 - 1) + _7859 + ceil32(return_data.size) + 32] != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[mem[64]] = profitFactor * mem[(32 * _7899 - 1) + _7859 + ceil32(return_data.size) + 32] < 0
                                    else:
                                        if maxReportDelay * (_6578 * _6870) - (t * _6870) / 10^18 / (_6578 * _6870) - (t * _6870) / 10^18 != maxReportDelay:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _7030 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7030] = 26
                                        mem[_7030 + 32] = 'SafeMath: division by zero'
                                        if 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83 == wantAddress:
                                            if not arg1:
                                                return (0 < maxReportDelay * (_6578 * _6870) - (t * _6870) / 10^18 / 31556952)
                                            if profitFactor * arg1 / arg1 != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            return (profitFactor * arg1 < maxReportDelay * (_6578 * _6870) - (t * _6870) / 10^18 / 31556952)
                                        if wantToEthOracleAddress:
                                            mem[mem[64] + 4] = arg1
                                            require ext_code.size(wantToEthOracleAddress)
                                            staticcall wantToEthOracleAddress.0x780022a0 with:
                                                    gas gas_remaining wei
                                                   args arg1
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7218 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if not mem[_7218]:
                                                return (0 < maxReportDelay * (_6578 * _6870) - (t * _6870) / 10^18 / 31556952)
                                            if profitFactor * mem[_7218] / mem[_7218] != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[mem[64]] = profitFactor * mem[_7218] < maxReportDelay * (_6578 * _6870) - (t * _6870) / 10^18 / 31556952
                                        else:
                                            _7102 = mem[64]
                                            mem[mem[64]] = 2
                                            mem[64] = mem[64] + 96
                                            require 0 < mem[_7102]
                                            mem[_7102 + 32] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                            require 1 < mem[_7102]
                                            mem[_7102 + 64] = wantAddress
                                            mem[_7102 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[_7102 + 100] = arg1
                                            mem[_7102 + 132] = 64
                                            mem[_7102 + 164] = mem[_7102]
                                            idx = 0
                                            s = _7102 + 196
                                            u = _7102 + 32
                                            while idx < mem[_7102]:
                                                mem[s] = mem[u + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                u = u + 32
                                                continue 
                                            require ext_code.size(0xf491e7b69e4244ad4002bc14e878a34207e38c29)
                                            staticcall 0xf491e7b69e4244ad4002bc14e878a34207e38c29.mem[mem[64] len 4] with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4 len _7102 + (32 * mem[_7102]) + -mem[64] + 192]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7858 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7878 = mem[_7858]
                                            require mem[_7858] <= test266151307()
                                            require _7858 + return_data.size > _7858 + mem[_7858] + 31
                                            _7898 = mem[_7858 + mem[_7858]]
                                            require mem[_7858 + mem[_7858]] <= test266151307()
                                            require (32 * mem[_7858 + mem[_7858]]) + 32 >= 0 and _7858 + ceil32(return_data.size) + (32 * mem[_7858 + mem[_7858]]) + 32 <= test266151307()
                                            mem[64] = _7858 + ceil32(return_data.size) + (32 * mem[_7858 + mem[_7858]]) + 32
                                            mem[_7858 + ceil32(return_data.size)] = _7898
                                            require return_data.size >= _7878 + (32 * _7898) + 32
                                            mem[_7858 + ceil32(return_data.size) + 32 len 32 * _7898] = mem[_7858 + _7878 + 32 len 32 * _7898]
                                            require _7898 - 1 < _7898
                                            if not mem[(32 * _7898 - 1) + _7858 + ceil32(return_data.size) + 32]:
                                                return (0 < maxReportDelay * (_6578 * _6870) - (t * _6870) / 10^18 / 31556952)
                                            if profitFactor * mem[(32 * _7898 - 1) + _7858 + ceil32(return_data.size) + 32] / mem[(32 * _7898 - 1) + _7858 + ceil32(return_data.size) + 32] != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[mem[64]] = profitFactor * mem[(32 * _7898 - 1) + _7858 + ceil32(return_data.size) + 32] < maxReportDelay * (_6578 * _6870) - (t * _6870) / 10^18 / 31556952
                    else:
                        _3046 = mem[_1592 + 192]
                        _3087 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3087] = 30
                        mem[_3087 + 32] = 'SafeMath: subtraction overflow'
                        if _3046 > _2887 + (_2844 * lenders.length):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        require ext_code.size(vaultAddress)
                        staticcall vaultAddress.creditAvailable() with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3163 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if _2887 + (_2844 * lenders.length) - _3046 + mem[_3163] < mem[_3163]:
                            revert with 0, 'SafeMath: addition overflow'
                        if not profitFactor:
                            if 0 < _2887 + (_2844 * lenders.length) - _3046 + mem[_3163]:
                                return 0
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(wantAddress)
                            staticcall wantAddress.balanceOf(address arg1) with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3410 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _3442 = mem[_3410]
                            idx = 0
                            s = 0
                            t = -1
                            while idx < lenders.length:
                                mem[0] = 13
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].hasAssets() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _5167 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_5167] == bool(mem[_5167])
                                if not mem[_5167]:
                                    idx = idx + 1
                                    s = s
                                    t = t
                                    continue 
                                require idx < lenders.length
                                mem[0] = 13
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].apr() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _5513 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _5521 = mem[_5513]
                                if mem[_5513] >= t:
                                    idx = idx + 1
                                    s = s
                                    t = t
                                    continue 
                                require idx < lenders.length
                                mem[0] = 13
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].nav() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _5699 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                idx = idx + 1
                                s = mem[_5699]
                                t = _5521
                                continue 
                            if _3442 + s < s:
                                revert with 0, 'SafeMath: addition overflow'
                            idx = 0
                            u = 0
                            while idx < lenders.length:
                                mem[0] = 13
                                mem[mem[64] + 4] = _3442
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].aprAfterDeposit(uint256 arg1) with:
                                        gas gas_remaining wei
                                       args _3442
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _6567 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if mem[_6567] <= u:
                                    idx = idx + 1
                                    u = u
                                    continue 
                                idx = idx + 1
                                u = mem[_6567]
                                continue 
                            require 0 < lenders.length
                            mem[0] = 13
                            mem[mem[64] + 4] = _3442 + s
                            require ext_code.size(lenders)
                            staticcall lenders.aprAfterDeposit(uint256 arg1) with:
                                    gas gas_remaining wei
                                   args (_3442 + s)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _6566 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _6584 = mem[_6566]
                            if mem[_6566] <= t:
                                return 0
                            require 0 < lenders.length
                            mem[0] = 13
                            require ext_code.size(lenders)
                            staticcall lenders.nav() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _6869 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _6873 = mem[_6869]
                            if not mem[_6869]:
                                _6939 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6939] = 26
                                mem[_6939 + 32] = 'SafeMath: division by zero'
                                _7009 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_7009] = 26
                                mem[_7009 + 32] = 'SafeMath: division by zero'
                                if 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83 == wantAddress:
                                    if not arg1:
                                        return 0
                                    if profitFactor * arg1 / arg1 != profitFactor:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    return (profitFactor * arg1 < 0)
                                if wantToEthOracleAddress:
                                    mem[mem[64] + 4] = arg1
                                    require ext_code.size(wantToEthOracleAddress)
                                    staticcall wantToEthOracleAddress.0x780022a0 with:
                                            gas gas_remaining wei
                                           args arg1
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7161 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if not mem[_7161]:
                                        return 0
                                    if profitFactor * mem[_7161] / mem[_7161] != profitFactor:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[mem[64]] = profitFactor * mem[_7161] < 0
                                else:
                                    _7047 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    require 0 < mem[_7047]
                                    mem[_7047 + 32] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    require 1 < mem[_7047]
                                    mem[_7047 + 64] = wantAddress
                                    mem[_7047 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                    mem[_7047 + 100] = arg1
                                    mem[_7047 + 132] = 64
                                    mem[_7047 + 164] = mem[_7047]
                                    idx = 0
                                    s = _7047 + 196
                                    t = _7047 + 32
                                    while idx < mem[_7047]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(0xf491e7b69e4244ad4002bc14e878a34207e38c29)
                                    staticcall 0xf491e7b69e4244ad4002bc14e878a34207e38c29.mem[mem[64] len 4] with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4 len _7047 + (32 * mem[_7047]) + -mem[64] + 192]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7877 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _7897 = mem[_7877]
                                    require mem[_7877] <= test266151307()
                                    require _7877 + return_data.size > _7877 + mem[_7877] + 31
                                    _7917 = mem[_7877 + mem[_7877]]
                                    require mem[_7877 + mem[_7877]] <= test266151307()
                                    require (32 * mem[_7877 + mem[_7877]]) + 32 >= 0 and _7877 + ceil32(return_data.size) + (32 * mem[_7877 + mem[_7877]]) + 32 <= test266151307()
                                    mem[64] = _7877 + ceil32(return_data.size) + (32 * mem[_7877 + mem[_7877]]) + 32
                                    mem[_7877 + ceil32(return_data.size)] = _7917
                                    require return_data.size >= _7897 + (32 * _7917) + 32
                                    mem[_7877 + ceil32(return_data.size) + 32 len 32 * _7917] = mem[_7877 + _7897 + 32 len 32 * _7917]
                                    require _7917 - 1 < _7917
                                    if not mem[(32 * _7917 - 1) + _7877 + ceil32(return_data.size) + 32]:
                                        return 0
                                    if profitFactor * mem[(32 * _7917 - 1) + _7877 + ceil32(return_data.size) + 32] / mem[(32 * _7917 - 1) + _7877 + ceil32(return_data.size) + 32] != profitFactor:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[mem[64]] = profitFactor * mem[(32 * _7917 - 1) + _7877 + ceil32(return_data.size) + 32] < 0
                            else:
                                if t * mem[_6869] / mem[_6869] != t:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not mem[_6869]:
                                    _6963 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6963] = 26
                                    mem[_6963 + 32] = 'SafeMath: division by zero'
                                    if not -1 * t * _6873 / 10^18:
                                        _7017 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7017] = 26
                                        mem[_7017 + 32] = 'SafeMath: division by zero'
                                        if 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83 == wantAddress:
                                            if not arg1:
                                                return 0
                                            if profitFactor * arg1 / arg1 != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            return (profitFactor * arg1 < 0)
                                        if wantToEthOracleAddress:
                                            mem[mem[64] + 4] = arg1
                                            require ext_code.size(wantToEthOracleAddress)
                                            staticcall wantToEthOracleAddress.0x780022a0 with:
                                                    gas gas_remaining wei
                                                   args arg1
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7187 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if not mem[_7187]:
                                                return 0
                                            if profitFactor * mem[_7187] / mem[_7187] != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[mem[64]] = profitFactor * mem[_7187] < 0
                                        else:
                                            _7062 = mem[64]
                                            mem[mem[64]] = 2
                                            mem[64] = mem[64] + 96
                                            require 0 < mem[_7062]
                                            mem[_7062 + 32] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                            require 1 < mem[_7062]
                                            mem[_7062 + 64] = wantAddress
                                            mem[_7062 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[_7062 + 100] = arg1
                                            mem[_7062 + 132] = 64
                                            mem[_7062 + 164] = mem[_7062]
                                            idx = 0
                                            s = _7062 + 196
                                            t = _7062 + 32
                                            while idx < mem[_7062]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            require ext_code.size(0xf491e7b69e4244ad4002bc14e878a34207e38c29)
                                            staticcall 0xf491e7b69e4244ad4002bc14e878a34207e38c29.mem[mem[64] len 4] with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4 len _7062 + (32 * mem[_7062]) + -mem[64] + 192]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7876 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7896 = mem[_7876]
                                            require mem[_7876] <= test266151307()
                                            require _7876 + return_data.size > _7876 + mem[_7876] + 31
                                            _7916 = mem[_7876 + mem[_7876]]
                                            require mem[_7876 + mem[_7876]] <= test266151307()
                                            require (32 * mem[_7876 + mem[_7876]]) + 32 >= 0 and _7876 + ceil32(return_data.size) + (32 * mem[_7876 + mem[_7876]]) + 32 <= test266151307()
                                            mem[64] = _7876 + ceil32(return_data.size) + (32 * mem[_7876 + mem[_7876]]) + 32
                                            mem[_7876 + ceil32(return_data.size)] = _7916
                                            require return_data.size >= _7896 + (32 * _7916) + 32
                                            mem[_7876 + ceil32(return_data.size) + 32 len 32 * _7916] = mem[_7876 + _7896 + 32 len 32 * _7916]
                                            require _7916 - 1 < _7916
                                            if not mem[(32 * _7916 - 1) + _7876 + ceil32(return_data.size) + 32]:
                                                return 0
                                            if profitFactor * mem[(32 * _7916 - 1) + _7876 + ceil32(return_data.size) + 32] / mem[(32 * _7916 - 1) + _7876 + ceil32(return_data.size) + 32] != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[mem[64]] = profitFactor * mem[(32 * _7916 - 1) + _7876 + ceil32(return_data.size) + 32] < 0
                                    else:
                                        if maxReportDelay * -1 * t * _6873 / 10^18 / -1 * t * _6873 / 10^18 != maxReportDelay:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _7028 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7028] = 26
                                        mem[_7028 + 32] = 'SafeMath: division by zero'
                                        if 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83 == wantAddress:
                                            if not arg1:
                                                return (0 < maxReportDelay * -1 * t * _6873 / 10^18 / 31556952)
                                            if profitFactor * arg1 / arg1 != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            return (profitFactor * arg1 < maxReportDelay * -1 * t * _6873 / 10^18 / 31556952)
                                        if wantToEthOracleAddress:
                                            mem[mem[64] + 4] = arg1
                                            require ext_code.size(wantToEthOracleAddress)
                                            staticcall wantToEthOracleAddress.0x780022a0 with:
                                                    gas gas_remaining wei
                                                   args arg1
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7213 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if not mem[_7213]:
                                                return (0 < maxReportDelay * -1 * t * _6873 / 10^18 / 31556952)
                                            if profitFactor * mem[_7213] / mem[_7213] != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[mem[64]] = profitFactor * mem[_7213] < maxReportDelay * -1 * t * _6873 / 10^18 / 31556952
                                        else:
                                            _7096 = mem[64]
                                            mem[mem[64]] = 2
                                            mem[64] = mem[64] + 96
                                            require 0 < mem[_7096]
                                            mem[_7096 + 32] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                            require 1 < mem[_7096]
                                            mem[_7096 + 64] = wantAddress
                                            mem[_7096 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[_7096 + 100] = arg1
                                            mem[_7096 + 132] = 64
                                            mem[_7096 + 164] = mem[_7096]
                                            idx = 0
                                            s = _7096 + 196
                                            u = _7096 + 32
                                            while idx < mem[_7096]:
                                                mem[s] = mem[u + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                u = u + 32
                                                continue 
                                            require ext_code.size(0xf491e7b69e4244ad4002bc14e878a34207e38c29)
                                            staticcall 0xf491e7b69e4244ad4002bc14e878a34207e38c29.mem[mem[64] len 4] with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4 len _7096 + (32 * mem[_7096]) + -mem[64] + 192]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7875 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7895 = mem[_7875]
                                            require mem[_7875] <= test266151307()
                                            require _7875 + return_data.size > _7875 + mem[_7875] + 31
                                            _7915 = mem[_7875 + mem[_7875]]
                                            require mem[_7875 + mem[_7875]] <= test266151307()
                                            require (32 * mem[_7875 + mem[_7875]]) + 32 >= 0 and _7875 + ceil32(return_data.size) + (32 * mem[_7875 + mem[_7875]]) + 32 <= test266151307()
                                            mem[64] = _7875 + ceil32(return_data.size) + (32 * mem[_7875 + mem[_7875]]) + 32
                                            mem[_7875 + ceil32(return_data.size)] = _7915
                                            require return_data.size >= _7895 + (32 * _7915) + 32
                                            mem[_7875 + ceil32(return_data.size) + 32 len 32 * _7915] = mem[_7875 + _7895 + 32 len 32 * _7915]
                                            require _7915 - 1 < _7915
                                            if not mem[(32 * _7915 - 1) + _7875 + ceil32(return_data.size) + 32]:
                                                return (0 < maxReportDelay * -1 * t * _6873 / 10^18 / 31556952)
                                            if profitFactor * mem[(32 * _7915 - 1) + _7875 + ceil32(return_data.size) + 32] / mem[(32 * _7915 - 1) + _7875 + ceil32(return_data.size) + 32] != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[mem[64]] = profitFactor * mem[(32 * _7915 - 1) + _7875 + ceil32(return_data.size) + 32] < maxReportDelay * -1 * t * _6873 / 10^18 / 31556952
                                else:
                                    if _6584 * mem[_6869] / mem[_6869] != _6584:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _6980 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6980] = 26
                                    mem[_6980 + 32] = 'SafeMath: division by zero'
                                    if not (_6584 * _6873) - (t * _6873) / 10^18:
                                        _7027 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7027] = 26
                                        mem[_7027 + 32] = 'SafeMath: division by zero'
                                        if 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83 == wantAddress:
                                            if not arg1:
                                                return 0
                                            if profitFactor * arg1 / arg1 != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            return (profitFactor * arg1 < 0)
                                        if wantToEthOracleAddress:
                                            mem[mem[64] + 4] = arg1
                                            require ext_code.size(wantToEthOracleAddress)
                                            staticcall wantToEthOracleAddress.0x780022a0 with:
                                                    gas gas_remaining wei
                                                   args arg1
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7212 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if not mem[_7212]:
                                                return 0
                                            if profitFactor * mem[_7212] / mem[_7212] != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[mem[64]] = profitFactor * mem[_7212] < 0
                                        else:
                                            _7093 = mem[64]
                                            mem[mem[64]] = 2
                                            mem[64] = mem[64] + 96
                                            require 0 < mem[_7093]
                                            mem[_7093 + 32] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                            require 1 < mem[_7093]
                                            mem[_7093 + 64] = wantAddress
                                            mem[_7093 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[_7093 + 100] = arg1
                                            mem[_7093 + 132] = 64
                                            mem[_7093 + 164] = mem[_7093]
                                            idx = 0
                                            s = _7093 + 196
                                            t = _7093 + 32
                                            while idx < mem[_7093]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            require ext_code.size(0xf491e7b69e4244ad4002bc14e878a34207e38c29)
                                            staticcall 0xf491e7b69e4244ad4002bc14e878a34207e38c29.mem[mem[64] len 4] with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4 len _7093 + (32 * mem[_7093]) + -mem[64] + 192]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7874 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7894 = mem[_7874]
                                            require mem[_7874] <= test266151307()
                                            require _7874 + return_data.size > _7874 + mem[_7874] + 31
                                            _7914 = mem[_7874 + mem[_7874]]
                                            require mem[_7874 + mem[_7874]] <= test266151307()
                                            require (32 * mem[_7874 + mem[_7874]]) + 32 >= 0 and _7874 + ceil32(return_data.size) + (32 * mem[_7874 + mem[_7874]]) + 32 <= test266151307()
                                            mem[64] = _7874 + ceil32(return_data.size) + (32 * mem[_7874 + mem[_7874]]) + 32
                                            mem[_7874 + ceil32(return_data.size)] = _7914
                                            require return_data.size >= _7894 + (32 * _7914) + 32
                                            mem[_7874 + ceil32(return_data.size) + 32 len 32 * _7914] = mem[_7874 + _7894 + 32 len 32 * _7914]
                                            require _7914 - 1 < _7914
                                            if not mem[(32 * _7914 - 1) + _7874 + ceil32(return_data.size) + 32]:
                                                return 0
                                            if profitFactor * mem[(32 * _7914 - 1) + _7874 + ceil32(return_data.size) + 32] / mem[(32 * _7914 - 1) + _7874 + ceil32(return_data.size) + 32] != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[mem[64]] = profitFactor * mem[(32 * _7914 - 1) + _7874 + ceil32(return_data.size) + 32] < 0
                                    else:
                                        if maxReportDelay * (_6584 * _6873) - (t * _6873) / 10^18 / (_6584 * _6873) - (t * _6873) / 10^18 != maxReportDelay:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _7036 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7036] = 26
                                        mem[_7036 + 32] = 'SafeMath: division by zero'
                                        if 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83 == wantAddress:
                                            if not arg1:
                                                return (0 < maxReportDelay * (_6584 * _6873) - (t * _6873) / 10^18 / 31556952)
                                            if profitFactor * arg1 / arg1 != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            return (profitFactor * arg1 < maxReportDelay * (_6584 * _6873) - (t * _6873) / 10^18 / 31556952)
                                        if wantToEthOracleAddress:
                                            mem[mem[64] + 4] = arg1
                                            require ext_code.size(wantToEthOracleAddress)
                                            staticcall wantToEthOracleAddress.0x780022a0 with:
                                                    gas gas_remaining wei
                                                   args arg1
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7245 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if not mem[_7245]:
                                                return (0 < maxReportDelay * (_6584 * _6873) - (t * _6873) / 10^18 / 31556952)
                                            if profitFactor * mem[_7245] / mem[_7245] != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[mem[64]] = profitFactor * mem[_7245] < maxReportDelay * (_6584 * _6873) - (t * _6873) / 10^18 / 31556952
                                        else:
                                            _7126 = mem[64]
                                            mem[mem[64]] = 2
                                            mem[64] = mem[64] + 96
                                            require 0 < mem[_7126]
                                            mem[_7126 + 32] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                            require 1 < mem[_7126]
                                            mem[_7126 + 64] = wantAddress
                                            mem[_7126 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[_7126 + 100] = arg1
                                            mem[_7126 + 132] = 64
                                            mem[_7126 + 164] = mem[_7126]
                                            idx = 0
                                            s = _7126 + 196
                                            u = _7126 + 32
                                            while idx < mem[_7126]:
                                                mem[s] = mem[u + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                u = u + 32
                                                continue 
                                            require ext_code.size(0xf491e7b69e4244ad4002bc14e878a34207e38c29)
                                            staticcall 0xf491e7b69e4244ad4002bc14e878a34207e38c29.mem[mem[64] len 4] with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4 len _7126 + (32 * mem[_7126]) + -mem[64] + 192]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7873 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7893 = mem[_7873]
                                            require mem[_7873] <= test266151307()
                                            require _7873 + return_data.size > _7873 + mem[_7873] + 31
                                            _7913 = mem[_7873 + mem[_7873]]
                                            require mem[_7873 + mem[_7873]] <= test266151307()
                                            require (32 * mem[_7873 + mem[_7873]]) + 32 >= 0 and _7873 + ceil32(return_data.size) + (32 * mem[_7873 + mem[_7873]]) + 32 <= test266151307()
                                            mem[64] = _7873 + ceil32(return_data.size) + (32 * mem[_7873 + mem[_7873]]) + 32
                                            mem[_7873 + ceil32(return_data.size)] = _7913
                                            require return_data.size >= _7893 + (32 * _7913) + 32
                                            mem[_7873 + ceil32(return_data.size) + 32 len 32 * _7913] = mem[_7873 + _7893 + 32 len 32 * _7913]
                                            require _7913 - 1 < _7913
                                            if not mem[(32 * _7913 - 1) + _7873 + ceil32(return_data.size) + 32]:
                                                return (0 < maxReportDelay * (_6584 * _6873) - (t * _6873) / 10^18 / 31556952)
                                            if profitFactor * mem[(32 * _7913 - 1) + _7873 + ceil32(return_data.size) + 32] / mem[(32 * _7913 - 1) + _7873 + ceil32(return_data.size) + 32] != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[mem[64]] = profitFactor * mem[(32 * _7913 - 1) + _7873 + ceil32(return_data.size) + 32] < maxReportDelay * (_6584 * _6873) - (t * _6873) / 10^18 / 31556952
                        else:
                            if _1455 * profitFactor / profitFactor != _1455:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if _1455 * profitFactor < _2887 + (_2844 * lenders.length) - _3046 + mem[_3163]:
                                return 0
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(wantAddress)
                            staticcall wantAddress.balanceOf(address arg1) with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3415 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _3477 = mem[_3415]
                            idx = 0
                            s = 0
                            t = -1
                            while idx < lenders.length:
                                mem[0] = 13
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].hasAssets() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _5166 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_5166] == bool(mem[_5166])
                                if not mem[_5166]:
                                    idx = idx + 1
                                    s = s
                                    t = t
                                    continue 
                                require idx < lenders.length
                                mem[0] = 13
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].apr() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _5512 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _5520 = mem[_5512]
                                if mem[_5512] >= t:
                                    idx = idx + 1
                                    s = s
                                    t = t
                                    continue 
                                require idx < lenders.length
                                mem[0] = 13
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].nav() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _5698 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                idx = idx + 1
                                s = mem[_5698]
                                t = _5520
                                continue 
                            if _3477 + s < s:
                                revert with 0, 'SafeMath: addition overflow'
                            idx = 0
                            u = 0
                            while idx < lenders.length:
                                mem[0] = 13
                                mem[mem[64] + 4] = _3477
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].aprAfterDeposit(uint256 arg1) with:
                                        gas gas_remaining wei
                                       args _3477
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _6565 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if mem[_6565] <= u:
                                    idx = idx + 1
                                    u = u
                                    continue 
                                idx = idx + 1
                                u = mem[_6565]
                                continue 
                            require 0 < lenders.length
                            mem[0] = 13
                            mem[mem[64] + 4] = _3477 + s
                            require ext_code.size(lenders)
                            staticcall lenders.aprAfterDeposit(uint256 arg1) with:
                                    gas gas_remaining wei
                                   args (_3477 + s)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _6564 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _6582 = mem[_6564]
                            if mem[_6564] <= t:
                                return 0
                            require 0 < lenders.length
                            mem[0] = 13
                            require ext_code.size(lenders)
                            staticcall lenders.nav() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _6867 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _6872 = mem[_6867]
                            if not mem[_6867]:
                                _6937 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6937] = 26
                                mem[_6937 + 32] = 'SafeMath: division by zero'
                                _7007 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_7007] = 26
                                mem[_7007 + 32] = 'SafeMath: division by zero'
                                if 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83 == wantAddress:
                                    if not arg1:
                                        return 0
                                    if profitFactor * arg1 / arg1 != profitFactor:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    return (profitFactor * arg1 < 0)
                                if wantToEthOracleAddress:
                                    mem[mem[64] + 4] = arg1
                                    require ext_code.size(wantToEthOracleAddress)
                                    staticcall wantToEthOracleAddress.0x780022a0 with:
                                            gas gas_remaining wei
                                           args arg1
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7154 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if not mem[_7154]:
                                        return 0
                                    if profitFactor * mem[_7154] / mem[_7154] != profitFactor:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[mem[64]] = profitFactor * mem[_7154] < 0
                                else:
                                    _7044 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    require 0 < mem[_7044]
                                    mem[_7044 + 32] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    require 1 < mem[_7044]
                                    mem[_7044 + 64] = wantAddress
                                    mem[_7044 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                    mem[_7044 + 100] = arg1
                                    mem[_7044 + 132] = 64
                                    mem[_7044 + 164] = mem[_7044]
                                    idx = 0
                                    s = _7044 + 196
                                    t = _7044 + 32
                                    while idx < mem[_7044]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(0xf491e7b69e4244ad4002bc14e878a34207e38c29)
                                    staticcall 0xf491e7b69e4244ad4002bc14e878a34207e38c29.mem[mem[64] len 4] with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4 len _7044 + (32 * mem[_7044]) + -mem[64] + 192]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7872 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _7892 = mem[_7872]
                                    require mem[_7872] <= test266151307()
                                    require _7872 + return_data.size > _7872 + mem[_7872] + 31
                                    _7912 = mem[_7872 + mem[_7872]]
                                    require mem[_7872 + mem[_7872]] <= test266151307()
                                    require (32 * mem[_7872 + mem[_7872]]) + 32 >= 0 and _7872 + ceil32(return_data.size) + (32 * mem[_7872 + mem[_7872]]) + 32 <= test266151307()
                                    mem[64] = _7872 + ceil32(return_data.size) + (32 * mem[_7872 + mem[_7872]]) + 32
                                    mem[_7872 + ceil32(return_data.size)] = _7912
                                    require return_data.size >= _7892 + (32 * _7912) + 32
                                    mem[_7872 + ceil32(return_data.size) + 32 len 32 * _7912] = mem[_7872 + _7892 + 32 len 32 * _7912]
                                    require _7912 - 1 < _7912
                                    if not mem[(32 * _7912 - 1) + _7872 + ceil32(return_data.size) + 32]:
                                        return 0
                                    if profitFactor * mem[(32 * _7912 - 1) + _7872 + ceil32(return_data.size) + 32] / mem[(32 * _7912 - 1) + _7872 + ceil32(return_data.size) + 32] != profitFactor:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[mem[64]] = profitFactor * mem[(32 * _7912 - 1) + _7872 + ceil32(return_data.size) + 32] < 0
                            else:
                                if t * mem[_6867] / mem[_6867] != t:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not mem[_6867]:
                                    _6962 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6962] = 26
                                    mem[_6962 + 32] = 'SafeMath: division by zero'
                                    if not -1 * t * _6872 / 10^18:
                                        _7015 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7015] = 26
                                        mem[_7015 + 32] = 'SafeMath: division by zero'
                                        if 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83 == wantAddress:
                                            if not arg1:
                                                return 0
                                            if profitFactor * arg1 / arg1 != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            return (profitFactor * arg1 < 0)
                                        if wantToEthOracleAddress:
                                            mem[mem[64] + 4] = arg1
                                            require ext_code.size(wantToEthOracleAddress)
                                            staticcall wantToEthOracleAddress.0x780022a0 with:
                                                    gas gas_remaining wei
                                                   args arg1
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7180 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if not mem[_7180]:
                                                return 0
                                            if profitFactor * mem[_7180] / mem[_7180] != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[mem[64]] = profitFactor * mem[_7180] < 0
                                        else:
                                            _7058 = mem[64]
                                            mem[mem[64]] = 2
                                            mem[64] = mem[64] + 96
                                            require 0 < mem[_7058]
                                            mem[_7058 + 32] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                            require 1 < mem[_7058]
                                            mem[_7058 + 64] = wantAddress
                                            mem[_7058 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[_7058 + 100] = arg1
                                            mem[_7058 + 132] = 64
                                            mem[_7058 + 164] = mem[_7058]
                                            idx = 0
                                            s = _7058 + 196
                                            t = _7058 + 32
                                            while idx < mem[_7058]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            require ext_code.size(0xf491e7b69e4244ad4002bc14e878a34207e38c29)
                                            staticcall 0xf491e7b69e4244ad4002bc14e878a34207e38c29.mem[mem[64] len 4] with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4 len _7058 + (32 * mem[_7058]) + -mem[64] + 192]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7871 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7891 = mem[_7871]
                                            require mem[_7871] <= test266151307()
                                            require _7871 + return_data.size > _7871 + mem[_7871] + 31
                                            _7911 = mem[_7871 + mem[_7871]]
                                            require mem[_7871 + mem[_7871]] <= test266151307()
                                            require (32 * mem[_7871 + mem[_7871]]) + 32 >= 0 and _7871 + ceil32(return_data.size) + (32 * mem[_7871 + mem[_7871]]) + 32 <= test266151307()
                                            mem[64] = _7871 + ceil32(return_data.size) + (32 * mem[_7871 + mem[_7871]]) + 32
                                            mem[_7871 + ceil32(return_data.size)] = _7911
                                            require return_data.size >= _7891 + (32 * _7911) + 32
                                            mem[_7871 + ceil32(return_data.size) + 32 len 32 * _7911] = mem[_7871 + _7891 + 32 len 32 * _7911]
                                            require _7911 - 1 < _7911
                                            if not mem[(32 * _7911 - 1) + _7871 + ceil32(return_data.size) + 32]:
                                                return 0
                                            if profitFactor * mem[(32 * _7911 - 1) + _7871 + ceil32(return_data.size) + 32] / mem[(32 * _7911 - 1) + _7871 + ceil32(return_data.size) + 32] != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[mem[64]] = profitFactor * mem[(32 * _7911 - 1) + _7871 + ceil32(return_data.size) + 32] < 0
                                    else:
                                        if maxReportDelay * -1 * t * _6872 / 10^18 / -1 * t * _6872 / 10^18 != maxReportDelay:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _7025 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7025] = 26
                                        mem[_7025 + 32] = 'SafeMath: division by zero'
                                        if 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83 == wantAddress:
                                            if not arg1:
                                                return (0 < maxReportDelay * -1 * t * _6872 / 10^18 / 31556952)
                                            if profitFactor * arg1 / arg1 != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            return (profitFactor * arg1 < maxReportDelay * -1 * t * _6872 / 10^18 / 31556952)
                                        if wantToEthOracleAddress:
                                            mem[mem[64] + 4] = arg1
                                            require ext_code.size(wantToEthOracleAddress)
                                            staticcall wantToEthOracleAddress.0x780022a0 with:
                                                    gas gas_remaining wei
                                                   args arg1
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7206 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if not mem[_7206]:
                                                return (0 < maxReportDelay * -1 * t * _6872 / 10^18 / 31556952)
                                            if profitFactor * mem[_7206] / mem[_7206] != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[mem[64]] = profitFactor * mem[_7206] < maxReportDelay * -1 * t * _6872 / 10^18 / 31556952
                                        else:
                                            _7087 = mem[64]
                                            mem[mem[64]] = 2
                                            mem[64] = mem[64] + 96
                                            require 0 < mem[_7087]
                                            mem[_7087 + 32] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                            require 1 < mem[_7087]
                                            mem[_7087 + 64] = wantAddress
                                            mem[_7087 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[_7087 + 100] = arg1
                                            mem[_7087 + 132] = 64
                                            mem[_7087 + 164] = mem[_7087]
                                            idx = 0
                                            s = _7087 + 196
                                            u = _7087 + 32
                                            while idx < mem[_7087]:
                                                mem[s] = mem[u + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                u = u + 32
                                                continue 
                                            require ext_code.size(0xf491e7b69e4244ad4002bc14e878a34207e38c29)
                                            staticcall 0xf491e7b69e4244ad4002bc14e878a34207e38c29.mem[mem[64] len 4] with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4 len _7087 + (32 * mem[_7087]) + -mem[64] + 192]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7870 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7890 = mem[_7870]
                                            require mem[_7870] <= test266151307()
                                            require _7870 + return_data.size > _7870 + mem[_7870] + 31
                                            _7910 = mem[_7870 + mem[_7870]]
                                            require mem[_7870 + mem[_7870]] <= test266151307()
                                            require (32 * mem[_7870 + mem[_7870]]) + 32 >= 0 and _7870 + ceil32(return_data.size) + (32 * mem[_7870 + mem[_7870]]) + 32 <= test266151307()
                                            mem[64] = _7870 + ceil32(return_data.size) + (32 * mem[_7870 + mem[_7870]]) + 32
                                            mem[_7870 + ceil32(return_data.size)] = _7910
                                            require return_data.size >= _7890 + (32 * _7910) + 32
                                            mem[_7870 + ceil32(return_data.size) + 32 len 32 * _7910] = mem[_7870 + _7890 + 32 len 32 * _7910]
                                            require _7910 - 1 < _7910
                                            if not mem[(32 * _7910 - 1) + _7870 + ceil32(return_data.size) + 32]:
                                                return (0 < maxReportDelay * -1 * t * _6872 / 10^18 / 31556952)
                                            if profitFactor * mem[(32 * _7910 - 1) + _7870 + ceil32(return_data.size) + 32] / mem[(32 * _7910 - 1) + _7870 + ceil32(return_data.size) + 32] != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[mem[64]] = profitFactor * mem[(32 * _7910 - 1) + _7870 + ceil32(return_data.size) + 32] < maxReportDelay * -1 * t * _6872 / 10^18 / 31556952
                                else:
                                    if _6582 * mem[_6867] / mem[_6867] != _6582:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _6978 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6978] = 26
                                    mem[_6978 + 32] = 'SafeMath: division by zero'
                                    if not (_6582 * _6872) - (t * _6872) / 10^18:
                                        _7024 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7024] = 26
                                        mem[_7024 + 32] = 'SafeMath: division by zero'
                                        if 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83 == wantAddress:
                                            if not arg1:
                                                return 0
                                            if profitFactor * arg1 / arg1 != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            return (profitFactor * arg1 < 0)
                                        if wantToEthOracleAddress:
                                            mem[mem[64] + 4] = arg1
                                            require ext_code.size(wantToEthOracleAddress)
                                            staticcall wantToEthOracleAddress.0x780022a0 with:
                                                    gas gas_remaining wei
                                                   args arg1
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7205 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if not mem[_7205]:
                                                return 0
                                            if profitFactor * mem[_7205] / mem[_7205] != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[mem[64]] = profitFactor * mem[_7205] < 0
                                        else:
                                            _7084 = mem[64]
                                            mem[mem[64]] = 2
                                            mem[64] = mem[64] + 96
                                            require 0 < mem[_7084]
                                            mem[_7084 + 32] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                            require 1 < mem[_7084]
                                            mem[_7084 + 64] = wantAddress
                                            mem[_7084 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[_7084 + 100] = arg1
                                            mem[_7084 + 132] = 64
                                            mem[_7084 + 164] = mem[_7084]
                                            idx = 0
                                            s = _7084 + 196
                                            t = _7084 + 32
                                            while idx < mem[_7084]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            require ext_code.size(0xf491e7b69e4244ad4002bc14e878a34207e38c29)
                                            staticcall 0xf491e7b69e4244ad4002bc14e878a34207e38c29.mem[mem[64] len 4] with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4 len _7084 + (32 * mem[_7084]) + -mem[64] + 192]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7869 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7889 = mem[_7869]
                                            require mem[_7869] <= test266151307()
                                            require _7869 + return_data.size > _7869 + mem[_7869] + 31
                                            _7909 = mem[_7869 + mem[_7869]]
                                            require mem[_7869 + mem[_7869]] <= test266151307()
                                            require (32 * mem[_7869 + mem[_7869]]) + 32 >= 0 and _7869 + ceil32(return_data.size) + (32 * mem[_7869 + mem[_7869]]) + 32 <= test266151307()
                                            mem[64] = _7869 + ceil32(return_data.size) + (32 * mem[_7869 + mem[_7869]]) + 32
                                            mem[_7869 + ceil32(return_data.size)] = _7909
                                            require return_data.size >= _7889 + (32 * _7909) + 32
                                            mem[_7869 + ceil32(return_data.size) + 32 len 32 * _7909] = mem[_7869 + _7889 + 32 len 32 * _7909]
                                            require _7909 - 1 < _7909
                                            if not mem[(32 * _7909 - 1) + _7869 + ceil32(return_data.size) + 32]:
                                                return 0
                                            if profitFactor * mem[(32 * _7909 - 1) + _7869 + ceil32(return_data.size) + 32] / mem[(32 * _7909 - 1) + _7869 + ceil32(return_data.size) + 32] != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[mem[64]] = profitFactor * mem[(32 * _7909 - 1) + _7869 + ceil32(return_data.size) + 32] < 0
                                    else:
                                        if maxReportDelay * (_6582 * _6872) - (t * _6872) / 10^18 / (_6582 * _6872) - (t * _6872) / 10^18 != maxReportDelay:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _7034 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7034] = 26
                                        mem[_7034 + 32] = 'SafeMath: division by zero'
                                        if 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83 == wantAddress:
                                            if not arg1:
                                                return (0 < maxReportDelay * (_6582 * _6872) - (t * _6872) / 10^18 / 31556952)
                                            if profitFactor * arg1 / arg1 != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            return (profitFactor * arg1 < maxReportDelay * (_6582 * _6872) - (t * _6872) / 10^18 / 31556952)
                                        if wantToEthOracleAddress:
                                            mem[mem[64] + 4] = arg1
                                            require ext_code.size(wantToEthOracleAddress)
                                            staticcall wantToEthOracleAddress.0x780022a0 with:
                                                    gas gas_remaining wei
                                                   args arg1
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7236 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if not mem[_7236]:
                                                return (0 < maxReportDelay * (_6582 * _6872) - (t * _6872) / 10^18 / 31556952)
                                            if profitFactor * mem[_7236] / mem[_7236] != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[mem[64]] = profitFactor * mem[_7236] < maxReportDelay * (_6582 * _6872) - (t * _6872) / 10^18 / 31556952
                                        else:
                                            _7118 = mem[64]
                                            mem[mem[64]] = 2
                                            mem[64] = mem[64] + 96
                                            require 0 < mem[_7118]
                                            mem[_7118 + 32] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                            require 1 < mem[_7118]
                                            mem[_7118 + 64] = wantAddress
                                            mem[_7118 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[_7118 + 100] = arg1
                                            mem[_7118 + 132] = 64
                                            mem[_7118 + 164] = mem[_7118]
                                            idx = 0
                                            s = _7118 + 196
                                            u = _7118 + 32
                                            while idx < mem[_7118]:
                                                mem[s] = mem[u + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                u = u + 32
                                                continue 
                                            require ext_code.size(0xf491e7b69e4244ad4002bc14e878a34207e38c29)
                                            staticcall 0xf491e7b69e4244ad4002bc14e878a34207e38c29.mem[mem[64] len 4] with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4 len _7118 + (32 * mem[_7118]) + -mem[64] + 192]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7868 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7888 = mem[_7868]
                                            require mem[_7868] <= test266151307()
                                            require _7868 + return_data.size > _7868 + mem[_7868] + 31
                                            _7908 = mem[_7868 + mem[_7868]]
                                            require mem[_7868 + mem[_7868]] <= test266151307()
                                            require (32 * mem[_7868 + mem[_7868]]) + 32 >= 0 and _7868 + ceil32(return_data.size) + (32 * mem[_7868 + mem[_7868]]) + 32 <= test266151307()
                                            mem[64] = _7868 + ceil32(return_data.size) + (32 * mem[_7868 + mem[_7868]]) + 32
                                            mem[_7868 + ceil32(return_data.size)] = _7908
                                            require return_data.size >= _7888 + (32 * _7908) + 32
                                            mem[_7868 + ceil32(return_data.size) + 32 len 32 * _7908] = mem[_7868 + _7888 + 32 len 32 * _7908]
                                            require _7908 - 1 < _7908
                                            if not mem[(32 * _7908 - 1) + _7868 + ceil32(return_data.size) + 32]:
                                                return (0 < maxReportDelay * (_6582 * _6872) - (t * _6872) / 10^18 / 31556952)
                                            if profitFactor * mem[(32 * _7908 - 1) + _7868 + ceil32(return_data.size) + 32] / mem[(32 * _7908 - 1) + _7868 + ceil32(return_data.size) + 32] != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[mem[64]] = profitFactor * mem[(32 * _7908 - 1) + _7868 + ceil32(return_data.size) + 32] < maxReportDelay * (_6582 * _6872) - (t * _6872) / 10^18 / 31556952
    return memory
      from mem[64]
       len 32
}



}
