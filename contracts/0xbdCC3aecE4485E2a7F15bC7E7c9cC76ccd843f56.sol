contract main {




// =====================  Runtime code  =====================


#
#  - sub_06b64c3a(?)
#  - unstakeAll()
#  - sub_6055537b(?)
#  - sub_71d28e2e(?)
#  - sub_80fcd3a3(?)
#  - harvestAll()
#  - sub_aa3419da(?)
#  - sub_b37f105b(?)
#  - sub_d2a9c181(?)
#  - harvest(uint256 arg1)
#  - sub_f02b0e64(?)
#  - _fallback()
#
const sub_2aedba85(?) = 0


address owner;
mapping of struct stor1;
array of uint256 stor2;
mapping of uint256 stor3;
array of uint256 stor4;
array of struct stor5;
array of uint256 stor6;
uint256 stor8;
array of address stor9;
array of struct stor10;
address stor11;
address stor13;
array of address stor1546678032441257452667456735582814959992782782816731922691272282333561699760;
array of address stor1546678032441257452667456735582814959992782782816731922691272282333561699761;

function owner() {
    return owner
}

function renounceOwnership() {
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    owner = 0
    emit OwnershipTransferred(owner, 0);
}

function sub_1ad7ddcb(?) {
    require calldata.size - 4 >= 64
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if arg2 >= 3:
        revert with 0, 50
    stor6[arg2] = arg1
}

function sub_d9873603(?) {
    require calldata.size - 4 >= 64
    require arg2 == address(arg2)
    if not stor1[arg1][3][address(arg2)].field_0:
        revert with 0, 'No bonus NFT of this type staked'
    return (stor1[arg1][3][address(arg2)].field_0 - 1)
}

function sub_17e4f906(?) {
    require calldata.size - 4 >= 32
    if block.timestamp < stor1[arg1].field_0:
        revert with 0, 17
    if block.timestamp - stor1[arg1].field_0 <= 24 * 3600:
        return (block.timestamp - stor1[arg1].field_0)
    return (24 * 3600)
}

function transferOwnership(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Ownable: new owner is the zero address'
    owner = arg1
    emit OwnershipTransferred(owner, arg1);
}

function sub_c1700844(?) {
    if stor2.length > test266151307():
        revert with 0, 65
    if stor2.length:
        mem[128 len 32 * stor2.length] = call.data[calldata.size len 32 * stor2.length]
    idx = 0
    while idx < stor2.length:
        mem[0] = 2
        if idx >= stor2.length:
            revert with 0, 50
        mem[(32 * idx) + 128] = stor2[idx]
        if idx == -1:
            revert with 0, 17
        idx = idx + 1
        continue 
    return Array(len=stor2.length, data=mem[128 len 32 * stor2.length])
}

function onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) {
    require calldata.size - 4 >= 128
    require arg1 == arg1
    require arg2 == arg2
    require arg4 <= test266151307()
    require calldata.size > arg4 + 35
    if arg4.length > test266151307():
        revert with 0, 65
    if ceil32(ceil32(arg4.length)) + 97 < 96 or ceil32(ceil32(arg4.length)) + 97 > test266151307():
        revert with 0, 65
    require arg4 + arg4.length + 36 <= calldata.size
    return 0x150b7a0200000000000000000000000000000000000000000000000000000000
}

function sub_4bd3692a(?) {
    require calldata.size - 4 >= 32
    require ext_code.size(stor11)
    staticcall stor11.0xe908c717 with:
            gas gas_remaining wei
           args arg1
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[31 len 1]
    if ext_call.return_data[31 len 1] > 6:
        revert with 0, 33
    if ext_call.return_data[31 len 1] >= 7:
        revert with 0, 33
    return ext_call.return_data[31 len 1]
}

function sub_a6db553b(?) {
    require calldata.size - 4 >= 128
    require arg1 == address(arg1)
    require arg2 == address(arg2)
    require arg4 == uint8(arg4)
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if not uint8(arg4):
        if arg3 >= stor5.length:
            revert with 0, 50
        address(stor5[arg3].field_0) = address(arg1)
        address(stor5[arg3].field_256) = address(arg2)
    else:
        if 1 == uint8(arg4):
            stor5.length++
            stor36B6[stor5.length] = address(arg1)
            stor36B6[stor5.length] = address(arg2)
}

function sub_6ffbb5dc(?) {
    require calldata.size - 4 >= 96
    require arg1 == address(arg1)
    require arg3 == uint8(arg3)
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if not uint8(arg3):
        if arg2 >= stor9.length:
            revert with 0, 50
        address(stor9[arg2].field_0) = address(arg1)
    else:
        if 1 == uint8(arg3):
            stor9.length++
            address(stor9[stor9.length].field_0) = address(arg1)
        else:
            if 2 == uint8(arg3):
                if not stor9.length:
                    revert with 0, 49
                address(stor9[stor9.length].field_0) = 0
                stor9.length--
}

function sub_5f56a31a(?) {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    if stor4[address(arg1)] > test266151307():
        revert with 0, 65
    if stor4[address(arg1)]:
        mem[128 len 32 * stor4[address(arg1)]] = call.data[calldata.size len 32 * stor4[address(arg1)]]
    idx = 0
    while idx < stor4[address(arg1)]:
        mem[32] = 4
        if idx >= stor4[address(arg1)]:
            revert with 0, 50
        mem[0] = sha3(address(arg1), 4)
        if idx >= stor4[address(arg1)]:
            revert with 0, 50
        mem[(32 * idx) + 128] = stor4[address(arg1)][idx]
        if idx == -1:
            revert with 0, 17
        idx = idx + 1
        continue 
    return Array(len=stor4[address(arg1)], data=mem[128 len 32 * stor4[address(arg1)]])
}

function sub_78e1a01e(?) {
    require calldata.size - 4 >= 32
    require ext_code.size(stor13)
    call stor13.0x42842e0e with:
         gas gas_remaining wei
        args msg.sender, address(this.address), arg1
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    if not stor1[arg1].field_512:
        stor1[arg1].field_512 = sha3(arg1, stor6.length)
    if not stor3[arg1]:
        stor2.length++
        stor2[stor2.length] = arg1
        stor3[arg1] = stor2.length
    if not stor4[msg.sender][1][arg1]:
        stor4[msg.sender]++
        stor4[msg.sender][stor4[msg.sender]] = arg1
        stor4[msg.sender][1][arg1] = stor4[msg.sender]
    stor1[arg1].field_256 = msg.sender or Mask(96, 160, stor1[arg1].field_256)
    stor1[arg1].field_0 = block.timestamp
}

function sub_85e53e27(?) {
    require calldata.size - 4 >= 32
    mem[96] = 0x85e53e2700000000000000000000000000000000000000000000000000000000
    mem[100] = arg1
    require ext_code.size(stor11)
    staticcall stor11.0x85e53e27 with:
            gas gas_remaining wei
           args arg1
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    mem[96 len return_data.size] = ext_call.return_data[0 len return_data.size]
    mem[64] = ceil32(return_data.size) + 96
    require return_data.size >= 32
    _4 = mem[96 len 4], Mask(224, 32, arg1) >> 32
    require mem[96 len 4], Mask(224, 32, arg1) >> 32 <= test266151307()
    require return_data.size + 96 > mem[96 len 4], Mask(224, 32, arg1) >> 32 + 127
    _5 = mem[mem[96 len 4], Mask(224, 32, arg1) >> 32 + 96]
    if mem[mem[96 len 4], Mask(224, 32, arg1) >> 32 + 96] > test266151307():
        revert with 0, 65
    if ceil32(ceil32(mem[mem[96 len 4], Mask(224, 32, arg1) >> 32 + 96])) + 1 < 0 or ceil32(return_data.size) + ceil32(ceil32(mem[mem[96 len 4], Mask(224, 32, arg1) >> 32 + 96])) + 97 > test266151307():
        revert with 0, 65
    mem[64] = ceil32(return_data.size) + ceil32(ceil32(mem[mem[96 len 4], Mask(224, 32, arg1) >> 32 + 96])) + 97
    mem[ceil32(return_data.size) + 96] = _5
    require _4 + _5 + 32 <= return_data.size
    mem[ceil32(return_data.size) + 128 len ceil32(_5)] = mem[_4 + 128 len ceil32(_5)]
    if ceil32(_5) <= _5:
        _19 = mem[64]
        mem[mem[64]] = 32
        mem[mem[64] + 32] = _5
        mem[mem[64] + 64 len ceil32(_5)] = mem[ceil32(return_data.size) + 128 len ceil32(_5)]
        if ceil32(_5) <= _5:
            return Array(len=_5, data=mem[mem[64] + 64 len ceil32(_5)])
        mem[_5 + mem[64] + 64] = 0
        return memory
          from mem[64]
           len ceil32(_5) + _19 + -mem[64] + 64
    mem[_5 + ceil32(return_data.size) + 128] = 0
    _20 = mem[64]
    mem[mem[64]] = 32
    mem[mem[64] + 32] = _5
    mem[mem[64] + 64 len ceil32(_5)] = mem[ceil32(return_data.size) + 128 len ceil32(_5)]
    if ceil32(_5) <= _5:
        return Array(len=_5, data=mem[mem[64] + 64 len ceil32(_5)])
    mem[_5 + mem[64] + 64] = 0
    return memory
      from mem[64]
       len ceil32(_5) + _20 + -mem[64] + 64
}

function sub_4949a3f6(?) {
    require calldata.size - 4 >= 32
    idx = 0
    s = 0
    while idx < stor5.length:
        mem[0] = address(stor5[idx].field_0)
        mem[32] = sha3(arg1, 1) + 3
        if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = s
            continue 
        if s == -1:
            revert with 0, 17
        if idx == -1:
            revert with 0, 17
        idx = idx + 1
        s = s + 1
        continue 
    if s > test266151307():
        revert with 0, 65
    mem[96] = s
    if s:
        mem[128 len 32 * s] = call.data[calldata.size len 32 * s]
    if s > test266151307():
        revert with 0, 65
    mem[(32 * s) + 128] = s
    mem[64] = (64 * s) + 160
    if s:
        mem[(32 * s) + 160 len 32 * s] = call.data[calldata.size len 32 * s]
    idx = 0
    t = 0
    while idx < stor5.length:
        mem[0] = address(stor5[idx].field_0)
        mem[32] = sha3(arg1, 1) + 3
        if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            t = t
            continue 
        if idx >= stor5.length:
            revert with 0, 50
        mem[0] = 5
        if t == -1:
            revert with 0, 17
        if t >= s:
            revert with 0, 50
        mem[(32 * t) + 128] = address(stor5[idx].field_0)
        if idx == -1:
            revert with 0, 17
        idx = idx + 1
        t = t + 1
        continue 
    t = 0
    while t < s:
        if t >= s:
            revert with 0, 50
        mem[0] = mem[(32 * t) + 140 len 20]
        mem[32] = sha3(arg1, 1) + 3
        if stor1[arg1][3][mem[(32 * t) + 140 len 20]].field_0 < 1:
            revert with 0, 17
        if t >= mem[(32 * s) + 128]:
            revert with 0, 50
        mem[(32 * t) + (32 * s) + 160] = stor1[arg1][3][mem[(32 * t) + 140 len 20]].field_0 - 1
        if t == -1:
            revert with 0, 17
        t = t + 1
        continue 
    mem[(64 * s) + 160] = 64
    mem[(64 * s) + 224] = s
    t = 0
    u = 128
    v = mem[64] + 96
    while t < s:
        mem[v] = mem[u + 12 len 20]
        t = t + 1
        u = u + 32
        v = v + 32
        continue 
    mem[(64 * s) + 192] = (32 * s) + 96
    mem[(98 * s) + 256] = mem[(32 * s) + 128]
    mem[(98 * s) + 288 len 32 * mem[(32 * s) + 128]] = mem[(32 * s) + 160 len 32 * mem[(32 * s) + 128]]
    return memory
      from mem[64]
       len (98 * s) + (32 * mem[(32 * s) + 128]) + -mem[64] + 288
}

function sub_5f9e80d0(?) {
    require calldata.size - 4 >= 64
    require arg2 < stor5.length
    mem[96] = address(stor5[arg2].field_0)
    mem[128] = address(stor5[arg2].field_256)
    mem[0] = address(stor5[arg2].field_0)
    mem[32] = sha3(arg1, 1) + 3
    if not stor1[arg1][3][address(stor5[arg2].field_0)].field_0:
        return 64, 96, 0, 0
    mem[160] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
    mem[164] = arg1
    mem[196] = stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1
    require ext_code.size(address(stor5[arg2].field_256))
    staticcall address(stor5[arg2].field_256).0x5f9e80d0 with:
            gas gas_remaining wei
           args arg1, stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    mem[160 len return_data.size] = ext_call.return_data[0 len return_data.size]
    mem[64] = ceil32(return_data.size) + 160
    require return_data.size >= 64
    _14 = mem[160 len 4], Mask(224, 32, arg1) >> 32
    require mem[160 len 4], Mask(224, 32, arg1) >> 32 <= test266151307()
    require mem[160 len 4], Mask(224, 32, arg1) >> 32 + 191 < return_data.size + 160
    _16 = mem[mem[160 len 4], Mask(224, 32, arg1) >> 32 + 160]
    if mem[mem[160 len 4], Mask(224, 32, arg1) >> 32 + 160] > test266151307():
        revert with 0, 65
    if ceil32(32 * mem[mem[160 len 4], Mask(224, 32, arg1) >> 32 + 160]) + 1 < 0 or ceil32(return_data.size) + ceil32(32 * mem[mem[160 len 4], Mask(224, 32, arg1) >> 32 + 160]) + 161 > test266151307():
        revert with 0, 65
    mem[64] = ceil32(return_data.size) + ceil32(32 * mem[mem[160 len 4], Mask(224, 32, arg1) >> 32 + 160]) + 161
    mem[ceil32(return_data.size) + 160] = mem[mem[160 len 4], Mask(224, 32, arg1) >> 32 + 160]
    require _14 + (32 * _16) + 32 <= return_data.size
    mem[ceil32(return_data.size) + 192 len 32 * _16] = mem[_14 + 192 len 32 * _16]
    require uint32(arg1), Mask(224, 32, stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1) >> 32 <= test266151307()
    require uint32(arg1), Mask(224, 32, stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1) >> 32 + 191 < return_data.size + 160
    _35 = mem[uint32(arg1), Mask(224, 32, stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1) >> 32 + 160]
    if mem[uint32(arg1), Mask(224, 32, stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1) >> 32 + 160] > test266151307():
        revert with 0, 65
    _38 = mem[64]
    if mem[64] + ceil32(32 * mem[uint32(arg1), Mask(224, 32, stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1) >> 32 + 160]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[uint32(arg1), Mask(224, 32, stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1) >> 32 + 160]) + 1 > test266151307():
        revert with 0, 65
    mem[64] = mem[64] + ceil32(32 * mem[uint32(arg1), Mask(224, 32, stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1) >> 32 + 160]) + 1
    mem[_38] = mem[uint32(arg1), Mask(224, 32, stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1) >> 32 + 160]
    require uint32(arg1), Mask(224, 32, stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1) >> 32 + (32 * _35) + 32 <= return_data.size
    mem[_38 + 32 len 32 * _35] = mem[uint32(arg1), Mask(224, 32, stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1) >> 32 + 192 len 32 * _35]
    _49 = mem[64]
    mem[mem[64]] = 64
    _50 = mem[ceil32(return_data.size) + 160]
    mem[mem[64] + 64] = mem[ceil32(return_data.size) + 160]
    mem[mem[64] + 96 len 32 * _50] = mem[ceil32(return_data.size) + 192 len 32 * _50]
    mem[mem[64] + 32] = (32 * _50) + 96
    _56 = mem[_38]
    mem[_49 + (32 * _50) + 96] = mem[_38]
    mem[_49 + (32 * _50) + 128 len 32 * _56] = mem[_38 + 32 len 32 * _56]
    return memory
      from mem[64]
       len _49 + (32 * _50) + (32 * _56) + -mem[64] + 128
}

function sub_d9fe3288(?) {
    require calldata.size - 4 >= 128
    require cd[4] == uint8(cd[4])
    require cd[36] <= test266151307()
    require cd[36] + 35 < calldata.size
    if ('cd', 36).length > test266151307():
        revert with 0, 65
    if ceil32(32 * ('cd', 36).length) + 97 < 96 or ceil32(32 * ('cd', 36).length) + 97 > test266151307():
        revert with 0, 65
    mem[96] = ('cd', 36).length
    require cd[36] + (32 * ('cd', 36).length) + 36 <= calldata.size
    idx = 0
    s = cd[36] + 36
    t = 128
    while idx < ('cd', 36).length:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[68] <= test266151307()
    require cd[68] + 35 < calldata.size
    if ('cd', 68).length > test266151307():
        revert with 0, 65
    if ceil32(32 * ('cd', 68).length) + 98 < 97 or ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 98 > test266151307():
        revert with 0, 65
    mem[ceil32(32 * ('cd', 36).length) + 97] = ('cd', 68).length
    require cd[68] + (32 * ('cd', 68).length) + 36 <= calldata.size
    idx = 0
    s = cd[68] + 36
    t = ceil32(32 * ('cd', 36).length) + 129
    while idx < ('cd', 68).length:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    if ('cd', 100).length > test266151307():
        revert with 0, 65
    if ceil32(32 * ('cd', 100).length) + 99 < 98 or ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + ceil32(32 * ('cd', 100).length) + 99 > test266151307():
        revert with 0, 65
    mem[ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 98] = ('cd', 100).length
    require cd[100] + (32 * ('cd', 100).length) + 36 <= calldata.size
    idx = 0
    s = cd[100] + 36
    t = ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 130
    while idx < ('cd', 100).length:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    mem[ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + ceil32(32 * ('cd', 100).length) + 99] = 96
    mem[ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + ceil32(32 * ('cd', 100).length) + 131] = ceil32(32 * ('cd', 36).length) + 97
    if uint8(cd[4]) > 6:
        revert with 0, 33
    stor10[cd[4] << 248].field_0 = ('cd', 36).length
    if not ('cd', 36).length:
        idx = 0
        while stor10[cd[4] << 248].field_0 > idx:
            stor10[cd[4] << 248][idx].field_0 = 0
            idx = idx + 1
            continue 
    else:
        s = 0
        idx = 128
        while (32 * ('cd', 36).length) + 128 > idx:
            stor10[cd[4] << 248][s].field_0 = mem[idx]
            s = s + 1
            idx = idx + 32
            continue 
        idx = Mask(251, 0, (32 * ('cd', 36).length) + 31) >> 5
        while stor10[cd[4] << 248].field_0 > idx:
            stor10[cd[4] << 248][idx].field_0 = 0
            idx = idx + 1
            continue 
    stor10[cd[4] << 248].field_256 = ('cd', 68).length
    if not ('cd', 68).length:
        idx = 0
        while stor10[cd[4] << 248].field_256 > idx:
            stor10[cd[4] << 248][idx + 1].field_0 = 0
            idx = idx + 1
            continue 
    else:
        s = 0
        idx = ceil32(32 * ('cd', 36).length) + 129
        while ceil32(32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 129 > idx:
            stor10[cd[4] << 248][s + 1].field_0 = mem[idx]
            s = s + 1
            idx = idx + 32
            continue 
        idx = Mask(251, 0, (32 * ('cd', 68).length) + 31) >> 5
        while stor10[cd[4] << 248].field_256 > idx:
            stor10[cd[4] << 248][idx + 1].field_0 = 0
            idx = idx + 1
            continue 
    stor10[cd[4] << 248].field_512 = ('cd', 100).length
    if not ('cd', 100).length:
        idx = 0
        while stor10[cd[4] << 248].field_512 > idx:
            stor10[cd[4] << 248][idx + 2].field_0 = 0
            idx = idx + 1
            continue 
    else:
        s = 0
        idx = ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 130
        while ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + (32 * ('cd', 100).length) + 130 > idx:
            stor10[cd[4] << 248][s + 2].field_0 = mem[idx]
            s = s + 1
            idx = idx + 32
            continue 
        idx = Mask(251, 0, (32 * ('cd', 100).length) + 31) >> 5
        while stor10[cd[4] << 248].field_512 > idx:
            stor10[cd[4] << 248][idx + 2].field_0 = 0
            idx = idx + 1
            continue 
}

function sub_28140527(?) {
    require calldata.size - 4 >= 96
    require cd[4] <= test266151307()
    require cd[4] + 35 < calldata.size
    mem[64] = 320
    require cd[4] + 228 <= calldata.size
    idx = 0
    s = cd[4] + 4
    t = 96
    while idx < 7:
        require cd[s] <= test266151307()
        require cd[4] + cd[s] + 35 < calldata.size
        if cd[(cd[4] + cd[s] + 4)] > test266151307():
            revert with 0, 65
        _4 = mem[64]
        if mem[64] + ceil32(32 * cd[(cd[4] + cd[s] + 4)]) + 1 < mem[64] or mem[64] + ceil32(32 * cd[(cd[4] + cd[s] + 4)]) + 1 > test266151307():
            revert with 0, 65
        mem[64] = mem[64] + ceil32(32 * cd[(cd[4] + cd[s] + 4)]) + 1
        mem[_4] = cd[(cd[4] + cd[s] + 4)]
        require cd[4] + cd[s] + (32 * cd[(cd[4] + cd[s] + 4)]) + 36 <= calldata.size
        u = 0
        v = cd[4] + cd[s] + 36
        w = _4 + 32
        while u < cd[(cd[4] + cd[s] + 4)]:
            mem[w] = cd[v]
            u = u + 1
            v = v + 32
            w = w + 32
            continue 
        mem[t] = _4
        u = u + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[36] <= test266151307()
    require cd[36] + 35 < calldata.size
    _3 = mem[64]
    if mem[64] + 224 > test266151307() or mem[64] + 224 < mem[64]:
        revert with 0, 65
    mem[64] = mem[64] + 224
    require cd[36] + 228 <= calldata.size
    idx = 0
    s = cd[36] + 4
    t = _3
    while idx < 7:
        require cd[s] <= test266151307()
        require cd[36] + cd[s] + 35 < calldata.size
        if cd[(cd[36] + cd[s] + 4)] > test266151307():
            revert with 0, 65
        _7 = mem[64]
        if mem[64] + ceil32(32 * cd[(cd[36] + cd[s] + 4)]) + 1 < mem[64] or mem[64] + ceil32(32 * cd[(cd[36] + cd[s] + 4)]) + 1 > test266151307():
            revert with 0, 65
        mem[64] = mem[64] + ceil32(32 * cd[(cd[36] + cd[s] + 4)]) + 1
        mem[_7] = cd[(cd[36] + cd[s] + 4)]
        require cd[36] + cd[s] + (32 * cd[(cd[36] + cd[s] + 4)]) + 36 <= calldata.size
        u = 0
        v = cd[36] + cd[s] + 36
        w = _7 + 32
        while u < cd[(cd[36] + cd[s] + 4)]:
            mem[w] = cd[v]
            u = u + 1
            v = v + 32
            w = w + 32
            continue 
        mem[t] = _7
        u = u + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[68] <= test266151307()
    require cd[68] + 35 < calldata.size
    _6 = mem[64]
    if mem[64] + 224 > test266151307() or mem[64] + 224 < mem[64]:
        revert with 0, 65
    mem[64] = mem[64] + 224
    require cd[68] + 228 <= calldata.size
    idx = 0
    s = cd[68] + 4
    t = _6
    while idx < 7:
        require cd[s] <= test266151307()
        require cd[68] + cd[s] + 35 < calldata.size
        if cd[(cd[68] + cd[s] + 4)] > test266151307():
            revert with 0, 65
        _12 = mem[64]
        if mem[64] + ceil32(32 * cd[(cd[68] + cd[s] + 4)]) + 1 < mem[64] or mem[64] + ceil32(32 * cd[(cd[68] + cd[s] + 4)]) + 1 > test266151307():
            revert with 0, 65
        mem[64] = mem[64] + ceil32(32 * cd[(cd[68] + cd[s] + 4)]) + 1
        mem[_12] = cd[(cd[68] + cd[s] + 4)]
        require cd[68] + cd[s] + (32 * cd[(cd[68] + cd[s] + 4)]) + 36 <= calldata.size
        u = 0
        v = cd[68] + cd[s] + 36
        w = _12 + 32
        while u < cd[(cd[68] + cd[s] + 4)]:
            mem[w] = cd[v]
            u = u + 1
            v = v + 32
            w = w + 32
            continue 
        mem[t] = _12
        u = u + 1
        s = s + 32
        t = t + 32
        continue 
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    idx = 0
    while idx < 7:
        _53 = mem[(32 * idx) + 96]
        _54 = mem[(32 * idx) + _3]
        _55 = mem[(32 * idx) + _6]
        if mem[mem[(32 * idx) + 96]] != mem[mem[(32 * idx) + _3]]:
            revert with 0, 'Length mismatch'
        if mem[mem[(32 * idx) + 96]] != mem[mem[(32 * idx) + _6]]:
            revert with 0, 'Length mismatch'
        _62 = mem[64]
        mem[64] = mem[64] + 96
        mem[_62] = mem[(32 * idx) + 96]
        mem[_62 + 32] = _54
        mem[_62 + 64] = _55
        if idx > 6:
            revert with 0, 33
        mem[0] = idx
        mem[32] = 10
        _67 = mem[_53]
        stor10[idx].field_0 = mem[_53]
        mem[0] = sha3(idx, 10)
        if not _67:
            s = sha3(sha3(idx, 10))
            while sha3(sha3(idx, 10)) + stor10[idx].field_0 > s:
                stor[s] = 0
                s = s + 1
                continue 
            _96 = mem[_54]
            stor10[idx].field_256 = mem[_54]
            mem[0] = sha3(idx, 10) + 1
            if not _96:
                s = sha3(sha3(idx, 10) + 1)
                while sha3(sha3(idx, 10) + 1) + stor10[idx].field_256 > s:
                    stor[s] = 0
                    s = s + 1
                    continue 
                _121 = mem[_55]
                stor10[idx].field_512 = mem[_55]
                mem[0] = sha3(idx, 10) + 2
                if not _121:
                    s = sha3(sha3(idx, 10) + 2)
                    while sha3(sha3(idx, 10) + 2) + stor10[idx].field_512 > s:
                        stor[s] = 0
                        s = s + 1
                        continue 
                else:
                    t = sha3(sha3(idx, 10) + 2)
                    s = _55 + 32
                    while _55 + (32 * _121) + 32 > s:
                        stor[t] = mem[s]
                        t = t + 1
                        s = s + 32
                        continue 
                    s = sha3(sha3(idx, 10) + 2) + (Mask(251, 0, (32 * _121) + 31) >> 5)
                    while sha3(sha3(idx, 10) + 2) + stor10[idx].field_512 > s:
                        stor[s] = 0
                        s = s + 1
                        continue 
            else:
                t = sha3(sha3(idx, 10) + 1)
                s = _54 + 32
                while _54 + (32 * _96) + 32 > s:
                    stor[t] = mem[s]
                    t = t + 1
                    s = s + 32
                    continue 
                s = sha3(sha3(idx, 10) + 1) + (Mask(251, 0, (32 * _96) + 31) >> 5)
                while sha3(sha3(idx, 10) + 1) + stor10[idx].field_256 > s:
                    stor[s] = 0
                    s = s + 1
                    continue 
                _143 = mem[_55]
                stor10[idx].field_512 = mem[_55]
                mem[0] = sha3(idx, 10) + 2
                if not _143:
                    s = sha3(sha3(idx, 10) + 2)
                    while sha3(sha3(idx, 10) + 2) + stor10[idx].field_512 > s:
                        stor[s] = 0
                        s = s + 1
                        continue 
                else:
                    t = sha3(sha3(idx, 10) + 2)
                    s = _55 + 32
                    while _55 + (32 * _143) + 32 > s:
                        stor[t] = mem[s]
                        t = t + 1
                        s = s + 32
                        continue 
                    s = sha3(sha3(idx, 10) + 2) + (Mask(251, 0, (32 * _143) + 31) >> 5)
                    while sha3(sha3(idx, 10) + 2) + stor10[idx].field_512 > s:
                        stor[s] = 0
                        s = s + 1
                        continue 
        else:
            t = sha3(sha3(idx, 10))
            s = _53 + 32
            while _53 + (32 * _67) + 32 > s:
                stor[t] = mem[s]
                t = t + 1
                s = s + 32
                continue 
            s = sha3(sha3(idx, 10)) + (Mask(251, 0, (32 * _67) + 31) >> 5)
            while sha3(sha3(idx, 10)) + stor10[idx].field_0 > s:
                stor[s] = 0
                s = s + 1
                continue 
            _123 = mem[_54]
            stor10[idx].field_256 = mem[_54]
            mem[0] = sha3(idx, 10) + 1
            if not _123:
                s = sha3(sha3(idx, 10) + 1)
                while sha3(sha3(idx, 10) + 1) + stor10[idx].field_256 > s:
                    stor[s] = 0
                    s = s + 1
                    continue 
                _145 = mem[_55]
                stor10[idx].field_512 = mem[_55]
                mem[0] = sha3(idx, 10) + 2
                if not _145:
                    s = sha3(sha3(idx, 10) + 2)
                    while sha3(sha3(idx, 10) + 2) + stor10[idx].field_512 > s:
                        stor[s] = 0
                        s = s + 1
                        continue 
                else:
                    t = sha3(sha3(idx, 10) + 2)
                    s = _55 + 32
                    while _55 + (32 * _145) + 32 > s:
                        stor[t] = mem[s]
                        t = t + 1
                        s = s + 32
                        continue 
                    s = sha3(sha3(idx, 10) + 2) + (Mask(251, 0, (32 * _145) + 31) >> 5)
                    while sha3(sha3(idx, 10) + 2) + stor10[idx].field_512 > s:
                        stor[s] = 0
                        s = s + 1
                        continue 
            else:
                t = sha3(sha3(idx, 10) + 1)
                s = _54 + 32
                while _54 + (32 * _123) + 32 > s:
                    stor[t] = mem[s]
                    t = t + 1
                    s = s + 32
                    continue 
                s = sha3(sha3(idx, 10) + 1) + (Mask(251, 0, (32 * _123) + 31) >> 5)
                while sha3(sha3(idx, 10) + 1) + stor10[idx].field_256 > s:
                    stor[s] = 0
                    s = s + 1
                    continue 
                _157 = mem[_55]
                stor10[idx].field_512 = mem[_55]
                mem[0] = sha3(idx, 10) + 2
                if not _157:
                    s = sha3(sha3(idx, 10) + 2)
                    while sha3(sha3(idx, 10) + 2) + stor10[idx].field_512 > s:
                        stor[s] = 0
                        s = s + 1
                        continue 
                else:
                    t = sha3(sha3(idx, 10) + 2)
                    s = _55 + 32
                    while _55 + (32 * _157) + 32 > s:
                        stor[t] = mem[s]
                        t = t + 1
                        s = s + 32
                        continue 
                    s = sha3(sha3(idx, 10) + 2) + (Mask(251, 0, (32 * _157) + 31) >> 5)
                    while sha3(sha3(idx, 10) + 2) + stor10[idx].field_512 > s:
                        stor[s] = 0
                        s = s + 1
                        continue 
        if idx == -1:
            revert with 0, 17
        idx = idx + 1
        continue 
}

function stakeAll() {
    mem[100] = msg.sender
    require ext_code.size(stor13)
    staticcall stor13.0x70a08231 with:
            gas gas_remaining wei
           args msg.sender
    mem[96] = ext_call.return_data[0]
    if ext_call.success:
        mem[64] = ceil32(return_data.size) + 96
        require return_data.size >= 32
        if ext_call.return_data[0] < 1:
            revert with 0, 17
        mem[ceil32(return_data.size) + 96] = 0x2f745c5900000000000000000000000000000000000000000000000000000000
        mem[ceil32(return_data.size) + 100] = msg.sender
        mem[ceil32(return_data.size) + 132] = var42001
        require ext_code.size(stor13)
        staticcall stor13.mem[var44003 len 4] with:
                gas gas_remaining wei
               args mem[var44003 + 4 len var44004 - 4]
        mem[var44005] = ext_call.return_data[0]
        if ext_call.success:
            mem[64] = (2 * ceil32(return_data.size)) + 96
            require var48002 - var48001 >= 32
            _288 = mem[var50002]
            mem[(2 * ceil32(return_data.size)) + 96] = 0x42842e0e00000000000000000000000000000000000000000000000000000000
            mem[(2 * ceil32(return_data.size)) + 100] = msg.sender
            mem[(2 * ceil32(return_data.size)) + 132] = this.address
            mem[(2 * ceil32(return_data.size)) + 164] = _288
            require ext_code.size(stor13)
            call stor13.0x42842e0e with:
                 gas gas_remaining wei
                args msg.sender, address(this.address), _288
            s = _288
            t = var50006
            while ext_call.success:
                mem[0] = s
                mem[32] = 1
                if stor1[s].field_512:
                    if stor3[s]:
                        if stor4[msg.sender][1][s]:
                            mem[0] = s
                            mem[32] = 1
                            stor1[s].field_256 = msg.sender or Mask(96, 160, stor1[s].field_256)
                            stor1[s].field_0 = block.timestamp
                            if not t:
                            mem[mem[64] + 4] = msg.sender
                            mem[mem[64] + 36] = t - 1
                            require ext_code.size(stor13)
                            staticcall stor13.0x2f745c59 with:
                                    gas gas_remaining wei
                                   args msg.sender, t - 1
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _413 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _421 = mem[_413]
                            mem[mem[64]] = 0x42842e0e00000000000000000000000000000000000000000000000000000000
                            mem[(2 * ceil32(return_data.size)) + 100] = msg.sender
                            mem[(2 * ceil32(return_data.size)) + 132] = this.address
                            mem[(2 * ceil32(return_data.size)) + 164] = _421
                            require ext_code.size(stor13)
                            call stor13.0x42842e0e with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len (2 * ceil32(return_data.size)) + -mem[64] + 192]
                            s = _421
                            t = t - 1
                            continue 
                        stor4[msg.sender]++
                        stor4[msg.sender][stor4[msg.sender]] = s
                        stor4[msg.sender][1][s] = stor4[msg.sender]
                        mem[0] = s
                        mem[32] = 1
                        stor1[s].field_256 = msg.sender or Mask(96, 160, stor1[s].field_256)
                        stor1[s].field_0 = block.timestamp
                        if not t:
                        mem[mem[64] + 4] = msg.sender
                        mem[mem[64] + 36] = t - 1
                        require ext_code.size(stor13)
                        staticcall stor13.0x2f745c59 with:
                                gas gas_remaining wei
                               args msg.sender, t - 1
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _414 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _422 = mem[_414]
                        mem[mem[64]] = 0x42842e0e00000000000000000000000000000000000000000000000000000000
                        mem[(2 * ceil32(return_data.size)) + 100] = msg.sender
                        mem[(2 * ceil32(return_data.size)) + 132] = this.address
                        mem[(2 * ceil32(return_data.size)) + 164] = _422
                        require ext_code.size(stor13)
                        call stor13.0x42842e0e with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len (2 * ceil32(return_data.size)) + -mem[64] + 192]
                        s = _422
                        t = t - 1
                        continue 
                    stor2.length++
                    stor2[stor2.length] = s
                    stor3[s] = stor2.length
                    if stor4[msg.sender][1][s]:
                        mem[0] = s
                        mem[32] = 1
                        stor1[s].field_256 = msg.sender or Mask(96, 160, stor1[s].field_256)
                        stor1[s].field_0 = block.timestamp
                        if not t:
                        mem[mem[64] + 4] = msg.sender
                        mem[mem[64] + 36] = t - 1
                        require ext_code.size(stor13)
                        staticcall stor13.0x2f745c59 with:
                                gas gas_remaining wei
                               args msg.sender, t - 1
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _415 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _423 = mem[_415]
                        mem[mem[64]] = 0x42842e0e00000000000000000000000000000000000000000000000000000000
                        mem[(2 * ceil32(return_data.size)) + 100] = msg.sender
                        mem[(2 * ceil32(return_data.size)) + 132] = this.address
                        mem[(2 * ceil32(return_data.size)) + 164] = _423
                        require ext_code.size(stor13)
                        call stor13.0x42842e0e with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len (2 * ceil32(return_data.size)) + -mem[64] + 192]
                        s = _423
                        t = t - 1
                        continue 
                    stor4[msg.sender]++
                    stor4[msg.sender][stor4[msg.sender]] = s
                    stor4[msg.sender][1][s] = stor4[msg.sender]
                    mem[0] = s
                    mem[32] = 1
                    stor1[s].field_256 = msg.sender or Mask(96, 160, stor1[s].field_256)
                    stor1[s].field_0 = block.timestamp
                    if not t:
                    mem[mem[64] + 4] = msg.sender
                    mem[mem[64] + 36] = t - 1
                    require ext_code.size(stor13)
                    staticcall stor13.0x2f745c59 with:
                            gas gas_remaining wei
                           args msg.sender, t - 1
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _416 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _424 = mem[_416]
                    mem[mem[64]] = 0x42842e0e00000000000000000000000000000000000000000000000000000000
                    mem[(2 * ceil32(return_data.size)) + 100] = msg.sender
                    mem[(2 * ceil32(return_data.size)) + 132] = this.address
                    mem[(2 * ceil32(return_data.size)) + 164] = _424
                    require ext_code.size(stor13)
                    call stor13.0x42842e0e with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len (2 * ceil32(return_data.size)) + -mem[64] + 192]
                    s = _424
                    t = t - 1
                    continue 
                _362 = mem[64]
                mem[mem[64] + 32] = s
                mem[mem[64] + 64] = stor6.length
                _363 = mem[64]
                mem[mem[64]] = 64
                mem[64] = mem[64] + 96
                stor1[s].field_512 = sha3(mem[_363 + 32 len mem[_363]])
                if not stor3[s]:
                    stor2.length++
                    stor2[stor2.length] = s
                    stor3[s] = stor2.length
                if not stor4[msg.sender][1][s]:
                    stor4[msg.sender]++
                    stor4[msg.sender][stor4[msg.sender]] = s
                    stor4[msg.sender][1][s] = stor4[msg.sender]
                mem[0] = s
                mem[32] = 1
                stor1[s].field_256 = msg.sender or Mask(96, 160, stor1[s].field_256)
                stor1[s].field_0 = block.timestamp
                if not t:
                mem[_362 + 100] = msg.sender
                mem[_362 + 132] = t - 1
                require ext_code.size(stor13)
                staticcall stor13.0x2f745c59 with:
                        gas gas_remaining wei
                       args msg.sender, t - 1
                mem[_362 + 96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[64] = _362 + ceil32(return_data.size) + 96
                require return_data.size >= 32
                mem[_362 + ceil32(return_data.size) + 96] = 0x42842e0e00000000000000000000000000000000000000000000000000000000
                mem[(2 * ceil32(return_data.size)) + 100] = msg.sender
                mem[(2 * ceil32(return_data.size)) + 132] = this.address
                mem[(2 * ceil32(return_data.size)) + 164] = ext_call.return_data[0]
                require ext_code.size(stor13)
                call stor13.0x42842e0e with:
                     gas gas_remaining wei
                    args mem[_362 + ceil32(return_data.size) + 100 len (2 * ceil32(return_data.size)) + -_362 + 96]
                s = ext_call.return_data[0]
                t = t - 1
                continue 
    revert with ext_call.return_data[0 len return_data.size]
}

function sub_5400c9e8(?) {
    require calldata.size - 4 >= 32
    if not stor1[arg1].field_512:
        mem[96] = 0
        mem[128] = 0
        if 1 >= stor9.length:
            revert with 0, 50
        mem[0] = 9
        mem[160] = 0x15d2cfca00000000000000000000000000000000000000000000000000000000
        mem[164] = 64
        mem[228] = 0
        mem[260 len 0] = None
        mem[196] = arg1
        require ext_code.size(address(stor9.field_256))
        staticcall address(stor9.field_256).0x15d2cfca with:
                gas gas_remaining wei
               args 64, arg1, 0
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        mem[160 len return_data.size] = ext_call.return_data[0 len return_data.size]
        mem[64] = ceil32(return_data.size) + 160
        require return_data.size >= 32
        _145 = mem[160 len 4], 0
        require mem[160 len 4], 0 <= test266151307()
        require mem[160 len 4], 0 + 191 < return_data.size + 160
        _150 = mem[mem[160 len 4], 0 + 160]
        if mem[mem[160 len 4], 0 + 160] > test266151307():
            revert with 0, 65
        if ceil32(32 * mem[mem[160 len 4], 0 + 160]) + 1 < 0 or ceil32(return_data.size) + ceil32(32 * mem[mem[160 len 4], 0 + 160]) + 161 > test266151307():
            revert with 0, 65
        mem[64] = ceil32(return_data.size) + ceil32(32 * mem[mem[160 len 4], 0 + 160]) + 161
        mem[ceil32(return_data.size) + 160] = mem[mem[160 len 4], 0 + 160]
        require _145 + (32 * _150) + 32 <= return_data.size
        mem[ceil32(return_data.size) + 192 len 32 * _150] = mem[_145 + 192 len 32 * _150]
        mem[mem[64]] = 32
        mem[mem[64] + 32] = _150
        mem[mem[64] + 64 len 32 * _150] = mem[ceil32(return_data.size) + 192 len 32 * _150]
        return Array(len=_150, data=mem[mem[64] + 64 len 32 * _150])
    mem[100] = arg1
    require ext_code.size(stor11)
    staticcall stor11.0xe908c717 with:
            gas gas_remaining wei
           args arg1
    mem[96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[31 len 1]
    if ext_call.return_data[31 len 1] > 6:
        revert with 0, 33
    mem[0] = ext_call.return_data[31 len 1]
    mem[32] = 10
    mem[ceil32(return_data.size) + 192] = stor10[ext_call.return_data[31 len 1]].field_0
    if not stor10[ext_call.return_data[31 len 1]].field_0:
        mem[ceil32(return_data.size) + 96] = ceil32(return_data.size) + 192
        mem[ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + 224] = stor10[ext_call.return_data[31 len 1]].field_256
        if not stor10[ext_call.return_data[31 len 1]].field_256:
            mem[ceil32(return_data.size) + 128] = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + 224
            mem[64] = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + (32 * stor10[ext_call.return_data[31 len 1]].field_512) + 288
            mem[ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 256] = stor10[ext_call.return_data[31 len 1]].field_512
            if not stor10[ext_call.return_data[31 len 1]].field_512:
                mem[ceil32(return_data.size) + 160] = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 256
                idx = 0
                s = 0
                while idx < stor10[ext_call.return_data[31 len 1]].field_512:
                    mem[0] = arg1
                    mem[32] = 1
                    mem[mem[64] + 32] = idx
                    mem[mem[64] + 64] = stor1[arg1].field_512
                    mem[mem[64] + 96] = stor8
                    _129 = mem[64]
                    mem[mem[64]] = 96
                    mem[64] = mem[64] + 128
                    if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                        revert with 0, 50
                    if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        revert with 0, 18
                    if sha3(mem[_129 + 32 len mem[_129]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s
                        continue 
                    if s == -1:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + 1
                    continue 
                idx = 0
                t = 0
                while idx < stor5.length:
                    mem[0] = 5
                    _454 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_454] = address(stor5[idx].field_0)
                    mem[_454 + 32] = address(stor5[idx].field_256)
                    mem[0] = address(stor5[idx].field_0)
                    mem[32] = sha3(arg1, 1) + 3
                    if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                        _468 = mem[64]
                        mem[mem[64]] = 0
                        mem[mem[64] + 32] = 0
                        mem[64] = mem[64] + 64
                        if t > !mem[_468]:
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        t = t + mem[_468]
                        continue 
                    mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = arg1
                    mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    require ext_code.size(address(stor5[idx].field_256))
                    staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                            gas gas_remaining wei
                           args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _496 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 64
                    _508 = mem[_496]
                    require mem[_496] <= test266151307()
                    require _496 + mem[_496] + 31 < _496 + return_data.size
                    _557 = mem[_496 + mem[_496]]
                    if mem[_496 + mem[_496]] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[_496 + mem[_496]]) + 1 < 0 or _496 + ceil32(return_data.size) + ceil32(32 * mem[_496 + mem[_496]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = _496 + ceil32(return_data.size) + ceil32(32 * mem[_496 + mem[_496]]) + 1
                    mem[_496 + ceil32(return_data.size)] = _557
                    require _508 + (32 * _557) + 32 <= return_data.size
                    s = 0
                    u = _496 + _508 + 32
                    v = _496 + ceil32(return_data.size) + 32
                    while s < _557:
                        mem[v] = mem[u]
                        s = s + 1
                        u = u + 32
                        v = v + 32
                        continue 
                    _1072 = mem[_496 + 32]
                    require mem[_496 + 32] <= test266151307()
                    require _496 + mem[_496 + 32] + 31 < _496 + return_data.size
                    _1077 = mem[_496 + mem[_496 + 32]]
                    if mem[_496 + mem[_496 + 32]] > test266151307():
                        revert with 0, 65
                    _1163 = mem[64]
                    if mem[64] + ceil32(32 * mem[_496 + mem[_496 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_496 + mem[_496 + 32]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = mem[64] + ceil32(32 * mem[_496 + mem[_496 + 32]]) + 1
                    mem[_1163] = _1077
                    require _1072 + (32 * _1077) + 32 <= return_data.size
                    s = 0
                    u = _496 + _1072 + 32
                    v = _1163 + 32
                    while s < _1077:
                        mem[v] = mem[u]
                        s = s + 1
                        u = u + 32
                        v = v + 32
                        continue 
                    if t > !mem[_496 + ceil32(return_data.size)]:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    t = t + mem[_496 + ceil32(return_data.size)]
                    continue 
                if s > !t:
                    revert with 0, 17
                if s + t > test266151307():
                    revert with 0, 65
                _467 = mem[64]
                mem[mem[64]] = s + t
                if not s + t:
                    if s > !t:
                        revert with 0, 17
                    if s + t > test266151307():
                        revert with 0, 65
                    _495 = mem[64] + (32 * s + t) + 32
                    mem[mem[64] + (32 * s + t) + 32] = s + t
                    mem[64] = _495 + (32 * s + t) + 32
                    if not s + t:
                        _1004 = mem[mem[ceil32(return_data.size) + 160]]
                        idx = 0
                        u = 0
                        while idx < _1004:
                            mem[0] = arg1
                            mem[32] = 1
                            mem[mem[64] + 32] = idx
                            mem[mem[64] + 64] = stor1[arg1].field_512
                            mem[mem[64] + 96] = stor8
                            _1019 = mem[64]
                            mem[mem[64]] = 96
                            mem[64] = mem[64] + 128
                            if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                                revert with 0, 50
                            if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                                revert with 0, 18
                            if sha3(mem[_1019 + 32 len mem[_1019]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                u = u
                                continue 
                            if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                                revert with 0, 50
                            if u >= mem[_467]:
                                revert with 0, 50
                            mem[(32 * u) + _467 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                            if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                                revert with 0, 50
                            if u >= mem[_495]:
                                revert with 0, 50
                            mem[(32 * u) + _495 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                            if u == -1:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            u = u + 1
                            continue 
                        idx = 0
                        while idx < stor5.length:
                            mem[0] = 5
                            _2167 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2167] = address(stor5[idx].field_0)
                            mem[_2167 + 32] = address(stor5[idx].field_256)
                            mem[0] = address(stor5[idx].field_0)
                            mem[32] = sha3(arg1, 1) + 3
                            if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                                _2202 = mem[64]
                                mem[mem[64]] = 0
                                mem[mem[64] + 32] = 0
                                mem[64] = mem[64] + 64
                                _3447 = mem[_2202]
                                s = 0
                                t = u
                                while s < _3447:
                                    if s >= mem[_2202]:
                                        revert with 0, 50
                                    if t >= mem[_467]:
                                        revert with 0, 50
                                    mem[(32 * t) + _467 + 32] = mem[(32 * s) + _2202 + 32]
                                    if s >= mem[_2202 + 32]:
                                        revert with 0, 50
                                    if t >= mem[_495]:
                                        revert with 0, 50
                                    mem[(32 * t) + _495 + 32] = mem[(32 * s) + _2202 + 64]
                                    if t == -1:
                                        revert with 0, 17
                                    if s == -1:
                                        revert with 0, 17
                                    s = s + 1
                                    t = t + 1
                                    continue 
                            else:
                                mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = arg1
                                mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                                require ext_code.size(address(stor5[idx].field_256))
                                staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                                        gas gas_remaining wei
                                       args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _2278 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 64
                                _2316 = mem[_2278]
                                require mem[_2278] <= test266151307()
                                require _2278 + mem[_2278] + 31 < _2278 + return_data.size
                                _2435 = mem[_2278 + mem[_2278]]
                                if mem[_2278 + mem[_2278]] > test266151307():
                                    revert with 0, 65
                                if ceil32(32 * mem[_2278 + mem[_2278]]) + 1 < 0 or _2278 + ceil32(return_data.size) + ceil32(32 * mem[_2278 + mem[_2278]]) + 1 > test266151307():
                                    revert with 0, 65
                                mem[64] = _2278 + ceil32(return_data.size) + ceil32(32 * mem[_2278 + mem[_2278]]) + 1
                                mem[_2278 + ceil32(return_data.size)] = _2435
                                require _2316 + (32 * _2435) + 32 <= return_data.size
                                s = 0
                                t = _2278 + _2316 + 32
                                v = _2278 + ceil32(return_data.size) + 32
                                while s < _2435:
                                    mem[v] = mem[t]
                                    s = s + 1
                                    t = t + 32
                                    v = v + 32
                                    continue 
                                _3601 = mem[_2278 + 32]
                                require mem[_2278 + 32] <= test266151307()
                                require _2278 + mem[_2278 + 32] + 31 < _2278 + return_data.size
                                _3648 = mem[_2278 + mem[_2278 + 32]]
                                if mem[_2278 + mem[_2278 + 32]] > test266151307():
                                    revert with 0, 65
                                _3827 = mem[64]
                                if mem[64] + ceil32(32 * mem[_2278 + mem[_2278 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_2278 + mem[_2278 + 32]]) + 1 > test266151307():
                                    revert with 0, 65
                                mem[64] = mem[64] + ceil32(32 * mem[_2278 + mem[_2278 + 32]]) + 1
                                mem[_3827] = _3648
                                require _3601 + (32 * _3648) + 32 <= return_data.size
                                s = 0
                                t = _2278 + _3601 + 32
                                v = _3827 + 32
                                while s < _3648:
                                    mem[v] = mem[t]
                                    s = s + 1
                                    t = t + 32
                                    v = v + 32
                                    continue 
                                _6763 = mem[_2278 + ceil32(return_data.size)]
                                s = 0
                                t = u
                                while s < _6763:
                                    if s >= mem[_2278 + ceil32(return_data.size)]:
                                        revert with 0, 50
                                    if t >= mem[_467]:
                                        revert with 0, 50
                                    mem[(32 * t) + _467 + 32] = mem[(32 * s) + _2278 + ceil32(return_data.size) + 32]
                                    if s >= mem[_3827]:
                                        revert with 0, 50
                                    if t >= mem[_495]:
                                        revert with 0, 50
                                    mem[(32 * t) + _495 + 32] = mem[(32 * s) + _3827 + 32]
                                    if t == -1:
                                        revert with 0, 17
                                    if s == -1:
                                        revert with 0, 17
                                    _6763 = mem[_2278 + ceil32(return_data.size)]
                                    s = s + 1
                                    t = t + 1
                                    continue 
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            continue 
                        if s > !t:
                            revert with 0, 17
                        if u != s + t:
                            revert with 0, 1
                        if 1 >= stor9.length:
                            revert with 0, 50
                        mem[0] = 9
                        mem[mem[64]] = 0x15d2cfca00000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 64
                        _2268 = mem[_467]
                        mem[mem[64] + 68] = mem[_467]
                        mem[mem[64] + 100 len 32 * _2268] = mem[_467 + 32 len 32 * _2268]
                        mem[mem[64] + 36] = arg1
                        require ext_code.size(address(stor9.field_256))
                        staticcall address(stor9.field_256).0x15d2cfca with:
                                gas gas_remaining wei
                               args 64, arg1, mem[mem[64] + 68 len (32 * _2268) + 32]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3647 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _3757 = mem[_3647]
                        require mem[_3647] <= test266151307()
                        require _3647 + mem[_3647] + 31 < _3647 + return_data.size
                        _3885 = mem[_3647 + mem[_3647]]
                        if mem[_3647 + mem[_3647]] > test266151307():
                            revert with 0, 65
                        if ceil32(32 * mem[_3647 + mem[_3647]]) + 1 < 0 or _3647 + ceil32(return_data.size) + ceil32(32 * mem[_3647 + mem[_3647]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = _3647 + ceil32(return_data.size) + ceil32(32 * mem[_3647 + mem[_3647]]) + 1
                        mem[_3647 + ceil32(return_data.size)] = _3885
                        require _3757 + (32 * _3885) + 32 <= return_data.size
                        mem[_3647 + ceil32(return_data.size) + 32 len 32 * _3885] = mem[_3647 + _3757 + 32 len 32 * _3885]
                        mem[mem[64]] = 32
                        mem[mem[64] + 32] = _3885
                        mem[mem[64] + 64 len 32 * _3885] = mem[_3647 + ceil32(return_data.size) + 32 len 32 * _3885]
                        return Array(len=_3885, data=mem[mem[64] + 64 len 32 * _3885])
                    mem[_495 + 32 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
                    _1006 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = 0
                    u = 0
                    while idx < _1006:
                        mem[0] = arg1
                        mem[32] = 1
                        mem[mem[64] + 32] = idx
                        mem[mem[64] + 64] = stor1[arg1].field_512
                        mem[mem[64] + 96] = stor8
                        _1026 = mem[64]
                        mem[mem[64]] = 96
                        mem[64] = mem[64] + 128
                        if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                            revert with 0, 50
                        if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                            revert with 0, 18
                        if sha3(mem[_1026 + 32 len mem[_1026]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            u = u
                            continue 
                        if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                            revert with 0, 50
                        if u >= mem[_467]:
                            revert with 0, 50
                        mem[(32 * u) + _467 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                        if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                            revert with 0, 50
                        if u >= mem[_495]:
                            revert with 0, 50
                        mem[(32 * u) + _495 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                        if u == -1:
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        u = u + 1
                        continue 
                    idx = 0
                    while idx < stor5.length:
                        mem[0] = 5
                        _2172 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2172] = address(stor5[idx].field_0)
                        mem[_2172 + 32] = address(stor5[idx].field_256)
                        mem[0] = address(stor5[idx].field_0)
                        mem[32] = sha3(arg1, 1) + 3
                        if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                            _2203 = mem[64]
                            mem[mem[64]] = 0
                            mem[mem[64] + 32] = 0
                            mem[64] = mem[64] + 64
                            _3448 = mem[_2203]
                            s = 0
                            t = u
                            while s < _3448:
                                if s >= mem[_2203]:
                                    revert with 0, 50
                                if t >= mem[_467]:
                                    revert with 0, 50
                                mem[(32 * t) + _467 + 32] = mem[(32 * s) + _2203 + 32]
                                if s >= mem[_2203 + 32]:
                                    revert with 0, 50
                                if t >= mem[_495]:
                                    revert with 0, 50
                                mem[(32 * t) + _495 + 32] = mem[(32 * s) + _2203 + 64]
                                if t == -1:
                                    revert with 0, 17
                                if s == -1:
                                    revert with 0, 17
                                s = s + 1
                                t = t + 1
                                continue 
                        else:
                            mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = arg1
                            mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                            require ext_code.size(address(stor5[idx].field_256))
                            staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                                    gas gas_remaining wei
                                   args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2281 = mem[64]
                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 64
                            _2319 = mem[_2281]
                            require mem[_2281] <= test266151307()
                            require _2281 + mem[_2281] + 31 < _2281 + return_data.size
                            _2437 = mem[_2281 + mem[_2281]]
                            if mem[_2281 + mem[_2281]] > test266151307():
                                revert with 0, 65
                            if ceil32(32 * mem[_2281 + mem[_2281]]) + 1 < 0 or _2281 + ceil32(return_data.size) + ceil32(32 * mem[_2281 + mem[_2281]]) + 1 > test266151307():
                                revert with 0, 65
                            mem[64] = _2281 + ceil32(return_data.size) + ceil32(32 * mem[_2281 + mem[_2281]]) + 1
                            mem[_2281 + ceil32(return_data.size)] = _2437
                            require _2319 + (32 * _2437) + 32 <= return_data.size
                            s = 0
                            t = _2281 + _2319 + 32
                            v = _2281 + ceil32(return_data.size) + 32
                            while s < _2437:
                                mem[v] = mem[t]
                                s = s + 1
                                t = t + 32
                                v = v + 32
                                continue 
                            _3604 = mem[_2281 + 32]
                            require mem[_2281 + 32] <= test266151307()
                            require _2281 + mem[_2281 + 32] + 31 < _2281 + return_data.size
                            _3650 = mem[_2281 + mem[_2281 + 32]]
                            if mem[_2281 + mem[_2281 + 32]] > test266151307():
                                revert with 0, 65
                            _3828 = mem[64]
                            if mem[64] + ceil32(32 * mem[_2281 + mem[_2281 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_2281 + mem[_2281 + 32]]) + 1 > test266151307():
                                revert with 0, 65
                            mem[64] = mem[64] + ceil32(32 * mem[_2281 + mem[_2281 + 32]]) + 1
                            mem[_3828] = _3650
                            require _3604 + (32 * _3650) + 32 <= return_data.size
                            s = 0
                            t = _2281 + _3604 + 32
                            v = _3828 + 32
                            while s < _3650:
                                mem[v] = mem[t]
                                s = s + 1
                                t = t + 32
                                v = v + 32
                                continue 
                            _6764 = mem[_2281 + ceil32(return_data.size)]
                            s = 0
                            t = u
                            while s < _6764:
                                if s >= mem[_2281 + ceil32(return_data.size)]:
                                    revert with 0, 50
                                if t >= mem[_467]:
                                    revert with 0, 50
                                mem[(32 * t) + _467 + 32] = mem[(32 * s) + _2281 + ceil32(return_data.size) + 32]
                                if s >= mem[_3828]:
                                    revert with 0, 50
                                if t >= mem[_495]:
                                    revert with 0, 50
                                mem[(32 * t) + _495 + 32] = mem[(32 * s) + _3828 + 32]
                                if t == -1:
                                    revert with 0, 17
                                if s == -1:
                                    revert with 0, 17
                                _6764 = mem[_2281 + ceil32(return_data.size)]
                                s = s + 1
                                t = t + 1
                                continue 
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
                    if s > !t:
                        revert with 0, 17
                    if u != s + t:
                        revert with 0, 1
                    if 1 >= stor9.length:
                        revert with 0, 50
                    mem[0] = 9
                    mem[mem[64]] = 0x15d2cfca00000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 64
                    _2270 = mem[_467]
                    mem[mem[64] + 68] = mem[_467]
                    mem[mem[64] + 100 len 32 * _2270] = mem[_467 + 32 len 32 * _2270]
                    mem[mem[64] + 36] = arg1
                    require ext_code.size(address(stor9.field_256))
                    staticcall address(stor9.field_256).0x15d2cfca with:
                            gas gas_remaining wei
                           args 64, arg1, mem[mem[64] + 68 len (32 * _2270) + 32]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3649 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _3758 = mem[_3649]
                    require mem[_3649] <= test266151307()
                    require _3649 + mem[_3649] + 31 < _3649 + return_data.size
                    _3886 = mem[_3649 + mem[_3649]]
                    if mem[_3649 + mem[_3649]] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[_3649 + mem[_3649]]) + 1 < 0 or _3649 + ceil32(return_data.size) + ceil32(32 * mem[_3649 + mem[_3649]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = _3649 + ceil32(return_data.size) + ceil32(32 * mem[_3649 + mem[_3649]]) + 1
                    mem[_3649 + ceil32(return_data.size)] = _3886
                    require _3758 + (32 * _3886) + 32 <= return_data.size
                    mem[_3649 + ceil32(return_data.size) + 32 len 32 * _3886] = mem[_3649 + _3758 + 32 len 32 * _3886]
                    mem[mem[64]] = 32
                    mem[mem[64] + 32] = _3886
                    mem[mem[64] + 64 len 32 * _3886] = mem[_3649 + ceil32(return_data.size) + 32 len 32 * _3886]
                    return Array(len=_3886, data=mem[mem[64] + 64 len 32 * _3886])
                mem[mem[64] + 32 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
                if s > !t:
                    revert with 0, 17
                if s + t > test266151307():
                    revert with 0, 65
                mem[mem[64] + (32 * s + t) + 32] = s + t
                mem[64] = _467 + (64 * s + t) + 64
                if not s + t:
                    _1008 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = 0
                    u = 0
                    while idx < _1008:
                        mem[0] = arg1
                        mem[32] = 1
                        mem[mem[64] + 32] = idx
                        mem[mem[64] + 64] = stor1[arg1].field_512
                        mem[mem[64] + 96] = stor8
                        _1033 = mem[64]
                        mem[mem[64]] = 96
                        mem[64] = mem[64] + 128
                        if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                            revert with 0, 50
                        if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                            revert with 0, 18
                        if sha3(mem[_1033 + 32 len mem[_1033]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            u = u
                            continue 
                        if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                            revert with 0, 50
                        if u >= mem[_467]:
                            revert with 0, 50
                        mem[(32 * u) + _467 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                        if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                            revert with 0, 50
                        if u >= mem[_467 + (32 * s + t) + 32]:
                            revert with 0, 50
                        mem[(32 * u) + _467 + (32 * s + t) + 64] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                        if u == -1:
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        u = u + 1
                        continue 
                    idx = 0
                    while idx < stor5.length:
                        mem[0] = 5
                        _2177 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2177] = address(stor5[idx].field_0)
                        mem[_2177 + 32] = address(stor5[idx].field_256)
                        mem[0] = address(stor5[idx].field_0)
                        mem[32] = sha3(arg1, 1) + 3
                        if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                            _2204 = mem[64]
                            mem[mem[64]] = 0
                            mem[mem[64] + 32] = 0
                            mem[64] = mem[64] + 64
                            _3449 = mem[_2204]
                            v = 0
                            w = u
                            while v < _3449:
                                if v >= mem[_2204]:
                                    revert with 0, 50
                                if w >= mem[_467]:
                                    revert with 0, 50
                                mem[(32 * w) + _467 + 32] = mem[(32 * v) + _2204 + 32]
                                if v >= mem[_2204 + 32]:
                                    revert with 0, 50
                                if w >= mem[_467 + (32 * s + t) + 32]:
                                    revert with 0, 50
                                mem[(32 * w) + _467 + (32 * s + t) + 64] = mem[(32 * v) + _2204 + 64]
                                if w == -1:
                                    revert with 0, 17
                                if v == -1:
                                    revert with 0, 17
                                v = v + 1
                                w = w + 1
                                continue 
                        else:
                            mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = arg1
                            mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                            require ext_code.size(address(stor5[idx].field_256))
                            staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                                    gas gas_remaining wei
                                   args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2284 = mem[64]
                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 64
                            _2322 = mem[_2284]
                            require mem[_2284] <= test266151307()
                            require _2284 + mem[_2284] + 31 < _2284 + return_data.size
                            _2439 = mem[_2284 + mem[_2284]]
                            if mem[_2284 + mem[_2284]] > test266151307():
                                revert with 0, 65
                            if ceil32(32 * mem[_2284 + mem[_2284]]) + 1 < 0 or _2284 + ceil32(return_data.size) + ceil32(32 * mem[_2284 + mem[_2284]]) + 1 > test266151307():
                                revert with 0, 65
                            mem[64] = _2284 + ceil32(return_data.size) + ceil32(32 * mem[_2284 + mem[_2284]]) + 1
                            mem[_2284 + ceil32(return_data.size)] = _2439
                            require _2322 + (32 * _2439) + 32 <= return_data.size
                            v = 0
                            w = _2284 + _2322 + 32
                            x = _2284 + ceil32(return_data.size) + 32
                            while v < _2439:
                                mem[x] = mem[w]
                                v = v + 1
                                w = w + 32
                                x = x + 32
                                continue 
                            _3607 = mem[_2284 + 32]
                            require mem[_2284 + 32] <= test266151307()
                            require _2284 + mem[_2284 + 32] + 31 < _2284 + return_data.size
                            _3652 = mem[_2284 + mem[_2284 + 32]]
                            if mem[_2284 + mem[_2284 + 32]] > test266151307():
                                revert with 0, 65
                            _3829 = mem[64]
                            if mem[64] + ceil32(32 * mem[_2284 + mem[_2284 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_2284 + mem[_2284 + 32]]) + 1 > test266151307():
                                revert with 0, 65
                            mem[64] = mem[64] + ceil32(32 * mem[_2284 + mem[_2284 + 32]]) + 1
                            mem[_3829] = _3652
                            require _3607 + (32 * _3652) + 32 <= return_data.size
                            v = 0
                            w = _2284 + _3607 + 32
                            x = _3829 + 32
                            while v < _3652:
                                mem[x] = mem[w]
                                v = v + 1
                                w = w + 32
                                x = x + 32
                                continue 
                            _6765 = mem[_2284 + ceil32(return_data.size)]
                            v = 0
                            w = u
                            while v < _6765:
                                if v >= mem[_2284 + ceil32(return_data.size)]:
                                    revert with 0, 50
                                if w >= mem[_467]:
                                    revert with 0, 50
                                mem[(32 * w) + _467 + 32] = mem[(32 * v) + _2284 + ceil32(return_data.size) + 32]
                                if v >= mem[_3829]:
                                    revert with 0, 50
                                if w >= mem[_467 + (32 * s + t) + 32]:
                                    revert with 0, 50
                                mem[(32 * w) + _467 + (32 * s + t) + 64] = mem[(32 * v) + _3829 + 32]
                                if w == -1:
                                    revert with 0, 17
                                if v == -1:
                                    revert with 0, 17
                                _6765 = mem[_2284 + ceil32(return_data.size)]
                                v = v + 1
                                w = w + 1
                                continue 
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
                    if s > !t:
                        revert with 0, 17
                    if u != s + t:
                        revert with 0, 1
                    if 1 >= stor9.length:
                        revert with 0, 50
                    mem[0] = 9
                    mem[mem[64]] = 0x15d2cfca00000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 64
                    _2272 = mem[_467]
                    mem[mem[64] + 68] = mem[_467]
                    mem[mem[64] + 100 len 32 * _2272] = mem[_467 + 32 len 32 * _2272]
                    mem[mem[64] + 36] = arg1
                    require ext_code.size(address(stor9.field_256))
                    staticcall address(stor9.field_256).0x15d2cfca with:
                            gas gas_remaining wei
                           args 64, arg1, mem[mem[64] + 68 len (32 * _2272) + 32]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3651 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _3759 = mem[_3651]
                    require mem[_3651] <= test266151307()
                    require _3651 + mem[_3651] + 31 < _3651 + return_data.size
                    _3887 = mem[_3651 + mem[_3651]]
                    if mem[_3651 + mem[_3651]] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[_3651 + mem[_3651]]) + 1 < 0 or _3651 + ceil32(return_data.size) + ceil32(32 * mem[_3651 + mem[_3651]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = _3651 + ceil32(return_data.size) + ceil32(32 * mem[_3651 + mem[_3651]]) + 1
                    mem[_3651 + ceil32(return_data.size)] = _3887
                    require _3759 + (32 * _3887) + 32 <= return_data.size
                    mem[_3651 + ceil32(return_data.size) + 32 len 32 * _3887] = mem[_3651 + _3759 + 32 len 32 * _3887]
                    mem[mem[64]] = 32
                    mem[mem[64] + 32] = _3887
                    mem[mem[64] + 64 len 32 * _3887] = mem[_3651 + ceil32(return_data.size) + 32 len 32 * _3887]
                    return Array(len=_3887, data=mem[mem[64] + 64 len 32 * _3887])
                mem[_467 + (32 * s + t) + 64 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
                _1010 = mem[mem[ceil32(return_data.size) + 160]]
                idx = 0
                u = 0
                while idx < _1010:
                    mem[0] = arg1
                    mem[32] = 1
                    mem[mem[64] + 32] = idx
                    mem[mem[64] + 64] = stor1[arg1].field_512
                    mem[mem[64] + 96] = stor8
                    _1040 = mem[64]
                    mem[mem[64]] = 96
                    mem[64] = mem[64] + 128
                    if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                        revert with 0, 50
                    if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        revert with 0, 18
                    if sha3(mem[_1040 + 32 len mem[_1040]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        u = u
                        continue 
                    if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                        revert with 0, 50
                    if u >= mem[_467]:
                        revert with 0, 50
                    mem[(32 * u) + _467 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                    if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                        revert with 0, 50
                    if u >= mem[_467 + (32 * s + t) + 32]:
                        revert with 0, 50
                    mem[(32 * u) + _467 + (32 * s + t) + 64] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                    if u == -1:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    u = u + 1
                    continue 
                idx = 0
                while idx < stor5.length:
                    mem[0] = 5
                    _2182 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2182] = address(stor5[idx].field_0)
                    mem[_2182 + 32] = address(stor5[idx].field_256)
                    mem[0] = address(stor5[idx].field_0)
                    mem[32] = sha3(arg1, 1) + 3
                    if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                        _2205 = mem[64]
                        mem[mem[64]] = 0
                        mem[mem[64] + 32] = 0
                        mem[64] = mem[64] + 64
                        _3450 = mem[_2205]
                        v = 0
                        w = u
                        while v < _3450:
                            if v >= mem[_2205]:
                                revert with 0, 50
                            if w >= mem[_467]:
                                revert with 0, 50
                            mem[(32 * w) + _467 + 32] = mem[(32 * v) + _2205 + 32]
                            if v >= mem[_2205 + 32]:
                                revert with 0, 50
                            if w >= mem[_467 + (32 * s + t) + 32]:
                                revert with 0, 50
                            mem[(32 * w) + _467 + (32 * s + t) + 64] = mem[(32 * v) + _2205 + 64]
                            if w == -1:
                                revert with 0, 17
                            if v == -1:
                                revert with 0, 17
                            v = v + 1
                            w = w + 1
                            continue 
                    else:
                        mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = arg1
                        mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                        require ext_code.size(address(stor5[idx].field_256))
                        staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                                gas gas_remaining wei
                               args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2287 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 64
                        _2325 = mem[_2287]
                        require mem[_2287] <= test266151307()
                        require _2287 + mem[_2287] + 31 < _2287 + return_data.size
                        _2441 = mem[_2287 + mem[_2287]]
                        if mem[_2287 + mem[_2287]] > test266151307():
                            revert with 0, 65
                        if ceil32(32 * mem[_2287 + mem[_2287]]) + 1 < 0 or _2287 + ceil32(return_data.size) + ceil32(32 * mem[_2287 + mem[_2287]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = _2287 + ceil32(return_data.size) + ceil32(32 * mem[_2287 + mem[_2287]]) + 1
                        mem[_2287 + ceil32(return_data.size)] = _2441
                        require _2325 + (32 * _2441) + 32 <= return_data.size
                        v = 0
                        w = _2287 + _2325 + 32
                        x = _2287 + ceil32(return_data.size) + 32
                        while v < _2441:
                            mem[x] = mem[w]
                            v = v + 1
                            w = w + 32
                            x = x + 32
                            continue 
                        _3610 = mem[_2287 + 32]
                        require mem[_2287 + 32] <= test266151307()
                        require _2287 + mem[_2287 + 32] + 31 < _2287 + return_data.size
                        _3654 = mem[_2287 + mem[_2287 + 32]]
                        if mem[_2287 + mem[_2287 + 32]] > test266151307():
                            revert with 0, 65
                        _3830 = mem[64]
                        if mem[64] + ceil32(32 * mem[_2287 + mem[_2287 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_2287 + mem[_2287 + 32]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = mem[64] + ceil32(32 * mem[_2287 + mem[_2287 + 32]]) + 1
                        mem[_3830] = _3654
                        require _3610 + (32 * _3654) + 32 <= return_data.size
                        v = 0
                        w = _2287 + _3610 + 32
                        x = _3830 + 32
                        while v < _3654:
                            mem[x] = mem[w]
                            v = v + 1
                            w = w + 32
                            x = x + 32
                            continue 
                        _6766 = mem[_2287 + ceil32(return_data.size)]
                        v = 0
                        w = u
                        while v < _6766:
                            if v >= mem[_2287 + ceil32(return_data.size)]:
                                revert with 0, 50
                            if w >= mem[_467]:
                                revert with 0, 50
                            mem[(32 * w) + _467 + 32] = mem[(32 * v) + _2287 + ceil32(return_data.size) + 32]
                            if v >= mem[_3830]:
                                revert with 0, 50
                            if w >= mem[_467 + (32 * s + t) + 32]:
                                revert with 0, 50
                            mem[(32 * w) + _467 + (32 * s + t) + 64] = mem[(32 * v) + _3830 + 32]
                            if w == -1:
                                revert with 0, 17
                            if v == -1:
                                revert with 0, 17
                            _6766 = mem[_2287 + ceil32(return_data.size)]
                            v = v + 1
                            w = w + 1
                            continue 
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                if s > !t:
                    revert with 0, 17
                if u != s + t:
                    revert with 0, 1
                if 1 >= stor9.length:
                    revert with 0, 50
                mem[0] = 9
                mem[mem[64]] = 0x15d2cfca00000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 64
                _2274 = mem[_467]
                mem[mem[64] + 68] = mem[_467]
                mem[mem[64] + 100 len 32 * _2274] = mem[_467 + 32 len 32 * _2274]
                mem[mem[64] + 36] = arg1
                require ext_code.size(address(stor9.field_256))
                staticcall address(stor9.field_256).0x15d2cfca with:
                        gas gas_remaining wei
                       args 64, arg1, mem[mem[64] + 68 len (32 * _2274) + 32]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3653 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _3760 = mem[_3653]
                require mem[_3653] <= test266151307()
                require _3653 + mem[_3653] + 31 < _3653 + return_data.size
                _3888 = mem[_3653 + mem[_3653]]
                if mem[_3653 + mem[_3653]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_3653 + mem[_3653]]) + 1 < 0 or _3653 + ceil32(return_data.size) + ceil32(32 * mem[_3653 + mem[_3653]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _3653 + ceil32(return_data.size) + ceil32(32 * mem[_3653 + mem[_3653]]) + 1
                mem[_3653 + ceil32(return_data.size)] = _3888
                require _3760 + (32 * _3888) + 32 <= return_data.size
                mem[_3653 + ceil32(return_data.size) + 32 len 32 * _3888] = mem[_3653 + _3760 + 32 len 32 * _3888]
                mem[mem[64]] = 32
                mem[mem[64] + 32] = _3888
                mem[mem[64] + 64 len 32 * _3888] = mem[_3653 + ceil32(return_data.size) + 32 len 32 * _3888]
                return Array(len=_3888, data=mem[mem[64] + 64 len 32 * _3888])
            mem[0] = sha3(ext_call.return_data[31 len 1], 10) + 2
            mem[ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 288] = stor10[ext_call.return_data[31 len 1]][2].field_0
            idx = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 288
            s = 0
            while ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + (32 * stor10[ext_call.return_data[31 len 1]].field_512) + 256 > idx:
                mem[idx + 32] = stor10[ext_call.return_data[31 len 1]][s + 2].field_256
                idx = idx + 32
                s = s + 1
                continue 
            mem[ceil32(return_data.size) + 160] = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 256
            idx = 0
            s = 0
            while idx < stor10[ext_call.return_data[31 len 1]].field_512:
                mem[0] = arg1
                mem[32] = 1
                mem[mem[64] + 32] = idx
                mem[mem[64] + 64] = stor1[arg1].field_512
                mem[mem[64] + 96] = stor8
                _1048 = mem[64]
                mem[mem[64]] = 96
                mem[64] = mem[64] + 128
                if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                    revert with 0, 50
                if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    revert with 0, 18
                if sha3(mem[_1048 + 32 len mem[_1048]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s
                    continue 
                if s == -1:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s + 1
                continue 
            idx = 0
            t = 0
            while idx < stor5.length:
                mem[0] = 5
                _2187 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2187] = address(stor5[idx].field_0)
                mem[_2187 + 32] = address(stor5[idx].field_256)
                mem[0] = address(stor5[idx].field_0)
                mem[32] = sha3(arg1, 1) + 3
                if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                    _2208 = mem[64]
                    mem[mem[64]] = 0
                    mem[mem[64] + 32] = 0
                    mem[64] = mem[64] + 64
                    if t > !mem[_2208]:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    t = t + mem[_2208]
                    continue 
                mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = arg1
                mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                require ext_code.size(address(stor5[idx].field_256))
                staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                        gas gas_remaining wei
                       args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _2291 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 64
                _2330 = mem[_2291]
                require mem[_2291] <= test266151307()
                require _2291 + mem[_2291] + 31 < _2291 + return_data.size
                _2451 = mem[_2291 + mem[_2291]]
                if mem[_2291 + mem[_2291]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_2291 + mem[_2291]]) + 1 < 0 or _2291 + ceil32(return_data.size) + ceil32(32 * mem[_2291 + mem[_2291]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _2291 + ceil32(return_data.size) + ceil32(32 * mem[_2291 + mem[_2291]]) + 1
                mem[_2291 + ceil32(return_data.size)] = _2451
                require _2330 + (32 * _2451) + 32 <= return_data.size
                s = 0
                u = _2291 + _2330 + 32
                v = _2291 + ceil32(return_data.size) + 32
                while s < _2451:
                    mem[v] = mem[u]
                    s = s + 1
                    u = u + 32
                    v = v + 32
                    continue 
                _3617 = mem[_2291 + 32]
                require mem[_2291 + 32] <= test266151307()
                require _2291 + mem[_2291 + 32] + 31 < _2291 + return_data.size
                _3655 = mem[_2291 + mem[_2291 + 32]]
                if mem[_2291 + mem[_2291 + 32]] > test266151307():
                    revert with 0, 65
                _3847 = mem[64]
                if mem[64] + ceil32(32 * mem[_2291 + mem[_2291 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_2291 + mem[_2291 + 32]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = mem[64] + ceil32(32 * mem[_2291 + mem[_2291 + 32]]) + 1
                mem[_3847] = _3655
                require _3617 + (32 * _3655) + 32 <= return_data.size
                s = 0
                u = _2291 + _3617 + 32
                v = _3847 + 32
                while s < _3655:
                    mem[v] = mem[u]
                    s = s + 1
                    u = u + 32
                    v = v + 32
                    continue 
                if t > !mem[_2291 + ceil32(return_data.size)]:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                t = t + mem[_2291 + ceil32(return_data.size)]
                continue 
            if s > !t:
                revert with 0, 17
            if s + t > test266151307():
                revert with 0, 65
            _2207 = mem[64]
            mem[mem[64]] = s + t
            if not s + t:
                if s > !t:
                    revert with 0, 17
                if s + t > test266151307():
                    revert with 0, 65
                _2290 = mem[64] + (32 * s + t) + 32
                mem[mem[64] + (32 * s + t) + 32] = s + t
                mem[64] = _2290 + (32 * s + t) + 32
                if not s + t:
                    _3452 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = 0
                    u = 0
                    while idx < _3452:
                        mem[0] = arg1
                        mem[32] = 1
                        mem[mem[64] + 32] = idx
                        mem[mem[64] + 64] = stor1[arg1].field_512
                        mem[mem[64] + 96] = stor8
                        _3495 = mem[64]
                        mem[mem[64]] = 96
                        mem[64] = mem[64] + 128
                        if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                            revert with 0, 50
                        if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                            revert with 0, 18
                        if sha3(mem[_3495 + 32 len mem[_3495]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                            if idx == -1:
                                revert with 0, 17
                            _3452 = mem[mem[ceil32(return_data.size) + 160]]
                            idx = idx + 1
                            u = u
                            continue 
                        if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                            revert with 0, 50
                        if u >= mem[_2207]:
                            revert with 0, 50
                        mem[(32 * u) + _2207 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                        if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                            revert with 0, 50
                        if u >= mem[_2290]:
                            revert with 0, 50
                        mem[(32 * u) + _2290 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                        if u == -1:
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        _3452 = mem[mem[ceil32(return_data.size) + 160]]
                        idx = idx + 1
                        u = u + 1
                        continue 
                    idx = 0
                    while idx < stor5.length:
                        mem[0] = 5
                        _5246 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5246] = address(stor5[idx].field_0)
                        mem[_5246 + 32] = address(stor5[idx].field_256)
                        mem[0] = address(stor5[idx].field_0)
                        mem[32] = sha3(arg1, 1) + 3
                        if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                            _5320 = mem[64]
                            mem[mem[64]] = 0
                            mem[mem[64] + 32] = 0
                            mem[64] = mem[64] + 64
                            _6767 = mem[_5320]
                            s = 0
                            t = u
                            while s < _6767:
                                if s >= mem[_5320]:
                                    revert with 0, 50
                                if t >= mem[_2207]:
                                    revert with 0, 50
                                mem[(32 * t) + _2207 + 32] = mem[(32 * s) + _5320 + 32]
                                if s >= mem[_5320 + 32]:
                                    revert with 0, 50
                                if t >= mem[_2290]:
                                    revert with 0, 50
                                mem[(32 * t) + _2290 + 32] = mem[(32 * s) + _5320 + 64]
                                if t == -1:
                                    revert with 0, 17
                                if s == -1:
                                    revert with 0, 17
                                _6767 = mem[_5320]
                                s = s + 1
                                t = t + 1
                                continue 
                        else:
                            mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = arg1
                            mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                            require ext_code.size(address(stor5[idx].field_256))
                            staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                                    gas gas_remaining wei
                                   args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _5496 = mem[64]
                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 64
                            _5569 = mem[_5496]
                            require mem[_5496] <= test266151307()
                            require _5496 + mem[_5496] + 31 < _5496 + return_data.size
                            _5713 = mem[_5496 + mem[_5496]]
                            if mem[_5496 + mem[_5496]] > test266151307():
                                revert with 0, 65
                            if ceil32(32 * mem[_5496 + mem[_5496]]) + 1 < 0 or _5496 + ceil32(return_data.size) + ceil32(32 * mem[_5496 + mem[_5496]]) + 1 > test266151307():
                                revert with 0, 65
                            mem[64] = _5496 + ceil32(return_data.size) + ceil32(32 * mem[_5496 + mem[_5496]]) + 1
                            mem[_5496 + ceil32(return_data.size)] = _5713
                            require _5569 + (32 * _5713) + 32 <= return_data.size
                            s = 0
                            t = _5496 + _5569 + 32
                            v = _5496 + ceil32(return_data.size) + 32
                            while s < _5713:
                                mem[v] = mem[t]
                                s = s + 1
                                t = t + 32
                                v = v + 32
                                continue 
                            _6951 = mem[_5496 + 32]
                            require mem[_5496 + 32] <= test266151307()
                            require _5496 + mem[_5496 + 32] + 31 < _5496 + return_data.size
                            _7068 = mem[_5496 + mem[_5496 + 32]]
                            if mem[_5496 + mem[_5496 + 32]] > test266151307():
                                revert with 0, 65
                            _7257 = mem[64]
                            if mem[64] + ceil32(32 * mem[_5496 + mem[_5496 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_5496 + mem[_5496 + 32]]) + 1 > test266151307():
                                revert with 0, 65
                            mem[64] = mem[64] + ceil32(32 * mem[_5496 + mem[_5496 + 32]]) + 1
                            mem[_7257] = _7068
                            require _6951 + (32 * _7068) + 32 <= return_data.size
                            s = 0
                            t = _5496 + _6951 + 32
                            v = _7257 + 32
                            while s < _7068:
                                mem[v] = mem[t]
                                s = s + 1
                                t = t + 32
                                v = v + 32
                                continue 
                            _9227 = mem[_5496 + ceil32(return_data.size)]
                            s = 0
                            t = u
                            while s < _9227:
                                if s >= mem[_5496 + ceil32(return_data.size)]:
                                    revert with 0, 50
                                if t >= mem[_2207]:
                                    revert with 0, 50
                                mem[(32 * t) + _2207 + 32] = mem[(32 * s) + _5496 + ceil32(return_data.size) + 32]
                                if s >= mem[_7257]:
                                    revert with 0, 50
                                if t >= mem[_2290]:
                                    revert with 0, 50
                                mem[(32 * t) + _2290 + 32] = mem[(32 * s) + _7257 + 32]
                                if t == -1:
                                    revert with 0, 17
                                if s == -1:
                                    revert with 0, 17
                                _9227 = mem[_5496 + ceil32(return_data.size)]
                                s = s + 1
                                t = t + 1
                                continue 
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
                    if s > !t:
                        revert with 0, 17
                    if u != s + t:
                        revert with 0, 1
                    if 1 >= stor9.length:
                        revert with 0, 50
                    mem[0] = 9
                    mem[mem[64]] = 0x15d2cfca00000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 64
                    _5460 = mem[_2207]
                    mem[mem[64] + 68] = mem[_2207]
                    mem[mem[64] + 100 len 32 * _5460] = mem[_2207 + 32 len 32 * _5460]
                    idx = _5460
                    mem[mem[64] + 36] = arg1
                    require ext_code.size(address(stor9.field_256))
                    staticcall address(stor9.field_256).0x15d2cfca with:
                            gas gas_remaining wei
                           args 64, arg1, mem[mem[64] + 68 len (32 * _5460) + 32]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _7067 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _7183 = mem[_7067]
                    require mem[_7067] <= test266151307()
                    require _7067 + mem[_7067] + 31 < _7067 + return_data.size
                    _7321 = mem[_7067 + mem[_7067]]
                    if mem[_7067 + mem[_7067]] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[_7067 + mem[_7067]]) + 1 < 0 or _7067 + ceil32(return_data.size) + ceil32(32 * mem[_7067 + mem[_7067]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = _7067 + ceil32(return_data.size) + ceil32(32 * mem[_7067 + mem[_7067]]) + 1
                    mem[_7067 + ceil32(return_data.size)] = _7321
                    require _7183 + (32 * _7321) + 32 <= return_data.size
                    mem[_7067 + ceil32(return_data.size) + 32 len 32 * _7321] = mem[_7067 + _7183 + 32 len 32 * _7321]
                    mem[mem[64]] = 32
                    mem[mem[64] + 32] = _7321
                    mem[mem[64] + 64 len 32 * _7321] = mem[_7067 + ceil32(return_data.size) + 32 len 32 * _7321]
                    var88001 = _7321
                    var88002 = _7067 + ceil32(return_data.size) + (32 * _7321) + 32
                    return Array(len=_7321, data=mem[mem[64] + 64 len 32 * _7321])
                mem[_2290 + 32 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
                _3454 = mem[mem[ceil32(return_data.size) + 160]]
                idx = 0
                u = 0
                while idx < _3454:
                    mem[0] = arg1
                    mem[32] = 1
                    mem[mem[64] + 32] = idx
                    mem[mem[64] + 64] = stor1[arg1].field_512
                    mem[mem[64] + 96] = stor8
                    _3502 = mem[64]
                    mem[mem[64]] = 96
                    mem[64] = mem[64] + 128
                    if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                        revert with 0, 50
                    if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        revert with 0, 18
                    if sha3(mem[_3502 + 32 len mem[_3502]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        if idx == -1:
                            revert with 0, 17
                        _3454 = mem[mem[ceil32(return_data.size) + 160]]
                        idx = idx + 1
                        u = u
                        continue 
                    if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                        revert with 0, 50
                    if u >= mem[_2207]:
                        revert with 0, 50
                    mem[(32 * u) + _2207 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                    if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                        revert with 0, 50
                    if u >= mem[_2290]:
                        revert with 0, 50
                    mem[(32 * u) + _2290 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                    if u == -1:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _3454 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = idx + 1
                    u = u + 1
                    continue 
                idx = 0
                while idx < stor5.length:
                    mem[0] = 5
                    _5251 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5251] = address(stor5[idx].field_0)
                    mem[_5251 + 32] = address(stor5[idx].field_256)
                    mem[0] = address(stor5[idx].field_0)
                    mem[32] = sha3(arg1, 1) + 3
                    if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                        _5321 = mem[64]
                        mem[mem[64]] = 0
                        mem[mem[64] + 32] = 0
                        mem[64] = mem[64] + 64
                        _6768 = mem[_5321]
                        s = 0
                        t = u
                        while s < _6768:
                            if s >= mem[_5321]:
                                revert with 0, 50
                            if t >= mem[_2207]:
                                revert with 0, 50
                            mem[(32 * t) + _2207 + 32] = mem[(32 * s) + _5321 + 32]
                            if s >= mem[_5321 + 32]:
                                revert with 0, 50
                            if t >= mem[_2290]:
                                revert with 0, 50
                            mem[(32 * t) + _2290 + 32] = mem[(32 * s) + _5321 + 64]
                            if t == -1:
                                revert with 0, 17
                            if s == -1:
                                revert with 0, 17
                            _6768 = mem[_5321]
                            s = s + 1
                            t = t + 1
                            continue 
                    else:
                        mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = arg1
                        mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                        require ext_code.size(address(stor5[idx].field_256))
                        staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                                gas gas_remaining wei
                               args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _5499 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 64
                        _5572 = mem[_5499]
                        require mem[_5499] <= test266151307()
                        require _5499 + mem[_5499] + 31 < _5499 + return_data.size
                        _5715 = mem[_5499 + mem[_5499]]
                        if mem[_5499 + mem[_5499]] > test266151307():
                            revert with 0, 65
                        if ceil32(32 * mem[_5499 + mem[_5499]]) + 1 < 0 or _5499 + ceil32(return_data.size) + ceil32(32 * mem[_5499 + mem[_5499]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = _5499 + ceil32(return_data.size) + ceil32(32 * mem[_5499 + mem[_5499]]) + 1
                        mem[_5499 + ceil32(return_data.size)] = _5715
                        require _5572 + (32 * _5715) + 32 <= return_data.size
                        s = 0
                        t = _5499 + _5572 + 32
                        v = _5499 + ceil32(return_data.size) + 32
                        while s < _5715:
                            mem[v] = mem[t]
                            s = s + 1
                            t = t + 32
                            v = v + 32
                            continue 
                        _6954 = mem[_5499 + 32]
                        require mem[_5499 + 32] <= test266151307()
                        require _5499 + mem[_5499 + 32] + 31 < _5499 + return_data.size
                        _7070 = mem[_5499 + mem[_5499 + 32]]
                        if mem[_5499 + mem[_5499 + 32]] > test266151307():
                            revert with 0, 65
                        _7258 = mem[64]
                        if mem[64] + ceil32(32 * mem[_5499 + mem[_5499 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_5499 + mem[_5499 + 32]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = mem[64] + ceil32(32 * mem[_5499 + mem[_5499 + 32]]) + 1
                        mem[_7258] = _7070
                        require _6954 + (32 * _7070) + 32 <= return_data.size
                        s = 0
                        t = _5499 + _6954 + 32
                        v = _7258 + 32
                        while s < _7070:
                            mem[v] = mem[t]
                            s = s + 1
                            t = t + 32
                            v = v + 32
                            continue 
                        _9228 = mem[_5499 + ceil32(return_data.size)]
                        s = 0
                        t = u
                        while s < _9228:
                            if s >= mem[_5499 + ceil32(return_data.size)]:
                                revert with 0, 50
                            if t >= mem[_2207]:
                                revert with 0, 50
                            mem[(32 * t) + _2207 + 32] = mem[(32 * s) + _5499 + ceil32(return_data.size) + 32]
                            if s >= mem[_7258]:
                                revert with 0, 50
                            if t >= mem[_2290]:
                                revert with 0, 50
                            mem[(32 * t) + _2290 + 32] = mem[(32 * s) + _7258 + 32]
                            if t == -1:
                                revert with 0, 17
                            if s == -1:
                                revert with 0, 17
                            _9228 = mem[_5499 + ceil32(return_data.size)]
                            s = s + 1
                            t = t + 1
                            continue 
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                if s > !t:
                    revert with 0, 17
                if u != s + t:
                    revert with 0, 1
                if 1 >= stor9.length:
                    revert with 0, 50
                mem[0] = 9
                mem[mem[64]] = 0x15d2cfca00000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 64
                _5462 = mem[_2207]
                mem[mem[64] + 68] = mem[_2207]
                mem[mem[64] + 100 len 32 * _5462] = mem[_2207 + 32 len 32 * _5462]
                idx = _5462
                mem[mem[64] + 36] = arg1
                require ext_code.size(address(stor9.field_256))
                staticcall address(stor9.field_256).0x15d2cfca with:
                        gas gas_remaining wei
                       args 64, arg1, mem[mem[64] + 68 len (32 * _5462) + 32]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _7069 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _7184 = mem[_7069]
                require mem[_7069] <= test266151307()
                require _7069 + mem[_7069] + 31 < _7069 + return_data.size
                _7322 = mem[_7069 + mem[_7069]]
                if mem[_7069 + mem[_7069]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_7069 + mem[_7069]]) + 1 < 0 or _7069 + ceil32(return_data.size) + ceil32(32 * mem[_7069 + mem[_7069]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _7069 + ceil32(return_data.size) + ceil32(32 * mem[_7069 + mem[_7069]]) + 1
                mem[_7069 + ceil32(return_data.size)] = _7322
                require _7184 + (32 * _7322) + 32 <= return_data.size
                mem[_7069 + ceil32(return_data.size) + 32 len 32 * _7322] = mem[_7069 + _7184 + 32 len 32 * _7322]
                mem[mem[64]] = 32
                mem[mem[64] + 32] = _7322
                mem[mem[64] + 64 len 32 * _7322] = mem[_7069 + ceil32(return_data.size) + 32 len 32 * _7322]
                var89001 = _7322
                var89002 = _7069 + ceil32(return_data.size) + (32 * _7322) + 32
                return Array(len=_7322, data=mem[mem[64] + 64 len 32 * _7322])
            mem[mem[64] + 32 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
            if s > !t:
                revert with 0, 17
            if s + t > test266151307():
                revert with 0, 65
            mem[mem[64] + (32 * s + t) + 32] = s + t
            mem[64] = _2207 + (64 * s + t) + 64
            if not s + t:
                _3456 = mem[mem[ceil32(return_data.size) + 160]]
                idx = 0
                u = 0
                while idx < _3456:
                    mem[0] = arg1
                    mem[32] = 1
                    mem[mem[64] + 32] = idx
                    mem[mem[64] + 64] = stor1[arg1].field_512
                    mem[mem[64] + 96] = stor8
                    _3509 = mem[64]
                    mem[mem[64]] = 96
                    mem[64] = mem[64] + 128
                    if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                        revert with 0, 50
                    if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        revert with 0, 18
                    if sha3(mem[_3509 + 32 len mem[_3509]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        if idx == -1:
                            revert with 0, 17
                        _3456 = mem[mem[ceil32(return_data.size) + 160]]
                        idx = idx + 1
                        u = u
                        continue 
                    if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                        revert with 0, 50
                    if u >= mem[_2207]:
                        revert with 0, 50
                    mem[(32 * u) + _2207 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                    if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                        revert with 0, 50
                    if u >= mem[_2207 + (32 * s + t) + 32]:
                        revert with 0, 50
                    mem[(32 * u) + _2207 + (32 * s + t) + 64] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                    if u == -1:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _3456 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = idx + 1
                    u = u + 1
                    continue 
                idx = 0
                while idx < stor5.length:
                    mem[0] = 5
                    _5256 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5256] = address(stor5[idx].field_0)
                    mem[_5256 + 32] = address(stor5[idx].field_256)
                    mem[0] = address(stor5[idx].field_0)
                    mem[32] = sha3(arg1, 1) + 3
                    if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                        _5322 = mem[64]
                        mem[mem[64]] = 0
                        mem[mem[64] + 32] = 0
                        mem[64] = mem[64] + 64
                        _6769 = mem[_5322]
                        v = 0
                        w = u
                        while v < _6769:
                            if v >= mem[_5322]:
                                revert with 0, 50
                            if w >= mem[_2207]:
                                revert with 0, 50
                            mem[(32 * w) + _2207 + 32] = mem[(32 * v) + _5322 + 32]
                            if v >= mem[_5322 + 32]:
                                revert with 0, 50
                            if w >= mem[_2207 + (32 * s + t) + 32]:
                                revert with 0, 50
                            mem[(32 * w) + _2207 + (32 * s + t) + 64] = mem[(32 * v) + _5322 + 64]
                            if w == -1:
                                revert with 0, 17
                            if v == -1:
                                revert with 0, 17
                            _6769 = mem[_5322]
                            v = v + 1
                            w = w + 1
                            continue 
                    else:
                        mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = arg1
                        mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                        require ext_code.size(address(stor5[idx].field_256))
                        staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                                gas gas_remaining wei
                               args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _5502 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 64
                        _5575 = mem[_5502]
                        require mem[_5502] <= test266151307()
                        require _5502 + mem[_5502] + 31 < _5502 + return_data.size
                        _5717 = mem[_5502 + mem[_5502]]
                        if mem[_5502 + mem[_5502]] > test266151307():
                            revert with 0, 65
                        if ceil32(32 * mem[_5502 + mem[_5502]]) + 1 < 0 or _5502 + ceil32(return_data.size) + ceil32(32 * mem[_5502 + mem[_5502]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = _5502 + ceil32(return_data.size) + ceil32(32 * mem[_5502 + mem[_5502]]) + 1
                        mem[_5502 + ceil32(return_data.size)] = _5717
                        require _5575 + (32 * _5717) + 32 <= return_data.size
                        v = 0
                        w = _5502 + _5575 + 32
                        x = _5502 + ceil32(return_data.size) + 32
                        while v < _5717:
                            mem[x] = mem[w]
                            v = v + 1
                            w = w + 32
                            x = x + 32
                            continue 
                        _6957 = mem[_5502 + 32]
                        require mem[_5502 + 32] <= test266151307()
                        require _5502 + mem[_5502 + 32] + 31 < _5502 + return_data.size
                        _7072 = mem[_5502 + mem[_5502 + 32]]
                        if mem[_5502 + mem[_5502 + 32]] > test266151307():
                            revert with 0, 65
                        _7259 = mem[64]
                        if mem[64] + ceil32(32 * mem[_5502 + mem[_5502 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_5502 + mem[_5502 + 32]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = mem[64] + ceil32(32 * mem[_5502 + mem[_5502 + 32]]) + 1
                        mem[_7259] = _7072
                        require _6957 + (32 * _7072) + 32 <= return_data.size
                        v = 0
                        w = _5502 + _6957 + 32
                        x = _7259 + 32
                        while v < _7072:
                            mem[x] = mem[w]
                            v = v + 1
                            w = w + 32
                            x = x + 32
                            continue 
                        _9229 = mem[_5502 + ceil32(return_data.size)]
                        v = 0
                        w = u
                        while v < _9229:
                            if v >= mem[_5502 + ceil32(return_data.size)]:
                                revert with 0, 50
                            if w >= mem[_2207]:
                                revert with 0, 50
                            mem[(32 * w) + _2207 + 32] = mem[(32 * v) + _5502 + ceil32(return_data.size) + 32]
                            if v >= mem[_7259]:
                                revert with 0, 50
                            if w >= mem[_2207 + (32 * s + t) + 32]:
                                revert with 0, 50
                            mem[(32 * w) + _2207 + (32 * s + t) + 64] = mem[(32 * v) + _7259 + 32]
                            if w == -1:
                                revert with 0, 17
                            if v == -1:
                                revert with 0, 17
                            _9229 = mem[_5502 + ceil32(return_data.size)]
                            v = v + 1
                            w = w + 1
                            continue 
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                if s > !t:
                    revert with 0, 17
                if u != s + t:
                    revert with 0, 1
                if 1 >= stor9.length:
                    revert with 0, 50
                mem[0] = 9
                mem[mem[64]] = 0x15d2cfca00000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 64
                _5464 = mem[_2207]
                mem[mem[64] + 68] = mem[_2207]
                mem[mem[64] + 100 len 32 * _5464] = mem[_2207 + 32 len 32 * _5464]
                idx = _5464
                mem[mem[64] + 36] = arg1
                require ext_code.size(address(stor9.field_256))
                staticcall address(stor9.field_256).0x15d2cfca with:
                        gas gas_remaining wei
                       args 64, arg1, mem[mem[64] + 68 len (32 * _5464) + 32]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _7071 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _7185 = mem[_7071]
                require mem[_7071] <= test266151307()
                require _7071 + mem[_7071] + 31 < _7071 + return_data.size
                _7323 = mem[_7071 + mem[_7071]]
                if mem[_7071 + mem[_7071]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_7071 + mem[_7071]]) + 1 < 0 or _7071 + ceil32(return_data.size) + ceil32(32 * mem[_7071 + mem[_7071]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _7071 + ceil32(return_data.size) + ceil32(32 * mem[_7071 + mem[_7071]]) + 1
                mem[_7071 + ceil32(return_data.size)] = _7323
                require _7185 + (32 * _7323) + 32 <= return_data.size
                mem[_7071 + ceil32(return_data.size) + 32 len 32 * _7323] = mem[_7071 + _7185 + 32 len 32 * _7323]
                mem[mem[64]] = 32
                mem[mem[64] + 32] = _7323
                mem[mem[64] + 64 len 32 * _7323] = mem[_7071 + ceil32(return_data.size) + 32 len 32 * _7323]
                var89001 = _7323
                var89002 = _7071 + ceil32(return_data.size) + (32 * _7323) + 32
                return Array(len=_7323, data=mem[mem[64] + 64 len 32 * _7323])
            mem[_2207 + (32 * s + t) + 64 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
            _3458 = mem[mem[ceil32(return_data.size) + 160]]
            idx = 0
            u = 0
            while idx < _3458:
                mem[0] = arg1
                mem[32] = 1
                mem[mem[64] + 32] = idx
                mem[mem[64] + 64] = stor1[arg1].field_512
                mem[mem[64] + 96] = stor8
                _3516 = mem[64]
                mem[mem[64]] = 96
                mem[64] = mem[64] + 128
                if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                    revert with 0, 50
                if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    revert with 0, 18
                if sha3(mem[_3516 + 32 len mem[_3516]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    if idx == -1:
                        revert with 0, 17
                    _3458 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = idx + 1
                    u = u
                    continue 
                if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                    revert with 0, 50
                if u >= mem[_2207]:
                    revert with 0, 50
                mem[(32 * u) + _2207 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                    revert with 0, 50
                if u >= mem[_2207 + (32 * s + t) + 32]:
                    revert with 0, 50
                mem[(32 * u) + _2207 + (32 * s + t) + 64] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                if u == -1:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _3458 = mem[mem[ceil32(return_data.size) + 160]]
                idx = idx + 1
                u = u + 1
                continue 
            idx = 0
            while idx < stor5.length:
                mem[0] = 5
                _5261 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5261] = address(stor5[idx].field_0)
                mem[_5261 + 32] = address(stor5[idx].field_256)
                mem[0] = address(stor5[idx].field_0)
                mem[32] = sha3(arg1, 1) + 3
                if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                    _5323 = mem[64]
                    mem[mem[64]] = 0
                    mem[mem[64] + 32] = 0
                    mem[64] = mem[64] + 64
                    _6770 = mem[_5323]
                    v = 0
                    w = u
                    while v < _6770:
                        if v >= mem[_5323]:
                            revert with 0, 50
                        if w >= mem[_2207]:
                            revert with 0, 50
                        mem[(32 * w) + _2207 + 32] = mem[(32 * v) + _5323 + 32]
                        if v >= mem[_5323 + 32]:
                            revert with 0, 50
                        if w >= mem[_2207 + (32 * s + t) + 32]:
                            revert with 0, 50
                        mem[(32 * w) + _2207 + (32 * s + t) + 64] = mem[(32 * v) + _5323 + 64]
                        if w == -1:
                            revert with 0, 17
                        if v == -1:
                            revert with 0, 17
                        _6770 = mem[_5323]
                        v = v + 1
                        w = w + 1
                        continue 
                else:
                    mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = arg1
                    mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    require ext_code.size(address(stor5[idx].field_256))
                    staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                            gas gas_remaining wei
                           args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _5505 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 64
                    _5578 = mem[_5505]
                    require mem[_5505] <= test266151307()
                    require _5505 + mem[_5505] + 31 < _5505 + return_data.size
                    _5719 = mem[_5505 + mem[_5505]]
                    if mem[_5505 + mem[_5505]] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[_5505 + mem[_5505]]) + 1 < 0 or _5505 + ceil32(return_data.size) + ceil32(32 * mem[_5505 + mem[_5505]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = _5505 + ceil32(return_data.size) + ceil32(32 * mem[_5505 + mem[_5505]]) + 1
                    mem[_5505 + ceil32(return_data.size)] = _5719
                    require _5578 + (32 * _5719) + 32 <= return_data.size
                    v = 0
                    w = _5505 + _5578 + 32
                    x = _5505 + ceil32(return_data.size) + 32
                    while v < _5719:
                        mem[x] = mem[w]
                        v = v + 1
                        w = w + 32
                        x = x + 32
                        continue 
                    _6960 = mem[_5505 + 32]
                    require mem[_5505 + 32] <= test266151307()
                    require _5505 + mem[_5505 + 32] + 31 < _5505 + return_data.size
                    _7074 = mem[_5505 + mem[_5505 + 32]]
                    if mem[_5505 + mem[_5505 + 32]] > test266151307():
                        revert with 0, 65
                    _7260 = mem[64]
                    if mem[64] + ceil32(32 * mem[_5505 + mem[_5505 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_5505 + mem[_5505 + 32]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = mem[64] + ceil32(32 * mem[_5505 + mem[_5505 + 32]]) + 1
                    mem[_7260] = _7074
                    require _6960 + (32 * _7074) + 32 <= return_data.size
                    v = 0
                    w = _5505 + _6960 + 32
                    x = _7260 + 32
                    while v < _7074:
                        mem[x] = mem[w]
                        v = v + 1
                        w = w + 32
                        x = x + 32
                        continue 
                    _9230 = mem[_5505 + ceil32(return_data.size)]
                    v = 0
                    w = u
                    while v < _9230:
                        if v >= mem[_5505 + ceil32(return_data.size)]:
                            revert with 0, 50
                        if w >= mem[_2207]:
                            revert with 0, 50
                        mem[(32 * w) + _2207 + 32] = mem[(32 * v) + _5505 + ceil32(return_data.size) + 32]
                        if v >= mem[_7260]:
                            revert with 0, 50
                        if w >= mem[_2207 + (32 * s + t) + 32]:
                            revert with 0, 50
                        mem[(32 * w) + _2207 + (32 * s + t) + 64] = mem[(32 * v) + _7260 + 32]
                        if w == -1:
                            revert with 0, 17
                        if v == -1:
                            revert with 0, 17
                        _9230 = mem[_5505 + ceil32(return_data.size)]
                        v = v + 1
                        w = w + 1
                        continue 
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            if s > !t:
                revert with 0, 17
            if u != s + t:
                revert with 0, 1
            if 1 >= stor9.length:
                revert with 0, 50
            mem[0] = 9
            mem[mem[64]] = 0x15d2cfca00000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 64
            _5466 = mem[_2207]
            mem[mem[64] + 68] = mem[_2207]
            mem[mem[64] + 100 len 32 * _5466] = mem[_2207 + 32 len 32 * _5466]
            idx = _5466
            var63002 = _2207 + (32 * _5466) + 32
            mem[mem[64] + 36] = arg1
            require ext_code.size(address(stor9.field_256))
            staticcall address(stor9.field_256).0x15d2cfca with:
                    gas gas_remaining wei
                   args 64, arg1, mem[mem[64] + 68 len (32 * _5466) + 32]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _7073 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _7186 = mem[_7073]
            require mem[_7073] <= test266151307()
            require _7073 + mem[_7073] + 31 < _7073 + return_data.size
            _7324 = mem[_7073 + mem[_7073]]
            if mem[_7073 + mem[_7073]] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[_7073 + mem[_7073]]) + 1 < 0 or _7073 + ceil32(return_data.size) + ceil32(32 * mem[_7073 + mem[_7073]]) + 1 > test266151307():
                revert with 0, 65
            mem[64] = _7073 + ceil32(return_data.size) + ceil32(32 * mem[_7073 + mem[_7073]]) + 1
            mem[_7073 + ceil32(return_data.size)] = _7324
            require _7186 + (32 * _7324) + 32 <= return_data.size
            mem[_7073 + ceil32(return_data.size) + 32 len 32 * _7324] = mem[_7073 + _7186 + 32 len 32 * _7324]
            mem[mem[64]] = 32
            mem[mem[64] + 32] = _7324
            mem[mem[64] + 64 len 32 * _7324] = mem[_7073 + ceil32(return_data.size) + 32 len 32 * _7324]
            var90001 = _7324
            var90002 = _7073 + ceil32(return_data.size) + (32 * _7324) + 32
            return Array(len=_7324, data=mem[mem[64] + 64 len 32 * _7324])
        mem[0] = sha3(ext_call.return_data[31 len 1], 10) + 1
        mem[ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + 256] = stor10[ext_call.return_data[31 len 1]][1].field_0
        idx = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + 256
        s = 0
        while ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 224 > idx:
            mem[idx + 32] = stor10[ext_call.return_data[31 len 1]][s + 1].field_256
            idx = idx + 32
            s = s + 1
            continue 
        mem[ceil32(return_data.size) + 128] = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + 224
        mem[64] = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + (32 * stor10[ext_call.return_data[31 len 1]].field_512) + 288
        mem[ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 256] = stor10[ext_call.return_data[31 len 1]].field_512
        if not stor10[ext_call.return_data[31 len 1]].field_512:
            mem[ceil32(return_data.size) + 160] = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 256
            idx = 0
            s = 0
            while idx < stor10[ext_call.return_data[31 len 1]].field_512:
                mem[0] = arg1
                mem[32] = 1
                mem[mem[64] + 32] = idx
                mem[mem[64] + 64] = stor1[arg1].field_512
                mem[mem[64] + 96] = stor8
                _1055 = mem[64]
                mem[mem[64]] = 96
                mem[64] = mem[64] + 128
                if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                    revert with 0, 50
                if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    revert with 0, 18
                if sha3(mem[_1055 + 32 len mem[_1055]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s
                    continue 
                if s == -1:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s + 1
                continue 
            idx = 0
            t = 0
            while idx < stor5.length:
                mem[0] = 5
                _2192 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2192] = address(stor5[idx].field_0)
                mem[_2192 + 32] = address(stor5[idx].field_256)
                mem[0] = address(stor5[idx].field_0)
                mem[32] = sha3(arg1, 1) + 3
                if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                    _2210 = mem[64]
                    mem[mem[64]] = 0
                    mem[mem[64] + 32] = 0
                    mem[64] = mem[64] + 64
                    if t > !mem[_2210]:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    t = t + mem[_2210]
                    continue 
                mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = arg1
                mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                require ext_code.size(address(stor5[idx].field_256))
                staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                        gas gas_remaining wei
                       args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _2293 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 64
                _2333 = mem[_2293]
                require mem[_2293] <= test266151307()
                require _2293 + mem[_2293] + 31 < _2293 + return_data.size
                _2461 = mem[_2293 + mem[_2293]]
                if mem[_2293 + mem[_2293]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_2293 + mem[_2293]]) + 1 < 0 or _2293 + ceil32(return_data.size) + ceil32(32 * mem[_2293 + mem[_2293]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _2293 + ceil32(return_data.size) + ceil32(32 * mem[_2293 + mem[_2293]]) + 1
                mem[_2293 + ceil32(return_data.size)] = _2461
                require _2333 + (32 * _2461) + 32 <= return_data.size
                s = 0
                u = _2293 + _2333 + 32
                v = _2293 + ceil32(return_data.size) + 32
                while s < _2461:
                    mem[v] = mem[u]
                    s = s + 1
                    u = u + 32
                    v = v + 32
                    continue 
                _3622 = mem[_2293 + 32]
                require mem[_2293 + 32] <= test266151307()
                require _2293 + mem[_2293 + 32] + 31 < _2293 + return_data.size
                _3656 = mem[_2293 + mem[_2293 + 32]]
                if mem[_2293 + mem[_2293 + 32]] > test266151307():
                    revert with 0, 65
                _3864 = mem[64]
                if mem[64] + ceil32(32 * mem[_2293 + mem[_2293 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_2293 + mem[_2293 + 32]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = mem[64] + ceil32(32 * mem[_2293 + mem[_2293 + 32]]) + 1
                mem[_3864] = _3656
                require _3622 + (32 * _3656) + 32 <= return_data.size
                s = 0
                u = _2293 + _3622 + 32
                v = _3864 + 32
                while s < _3656:
                    mem[v] = mem[u]
                    s = s + 1
                    u = u + 32
                    v = v + 32
                    continue 
                if t > !mem[_2293 + ceil32(return_data.size)]:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                t = t + mem[_2293 + ceil32(return_data.size)]
                continue 
            if s > !t:
                revert with 0, 17
            if s + t > test266151307():
                revert with 0, 65
            _2209 = mem[64]
            mem[mem[64]] = s + t
            if s + t:
                mem[mem[64] + 32 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
                if s > !t:
                    revert with 0, 17
                if s + t > test266151307():
                    revert with 0, 65
                mem[mem[64] + (32 * s + t) + 32] = s + t
                mem[64] = _2209 + (64 * s + t) + 64
                if not s + t:
                    _3464 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = 0
                    u = 0
                    while idx < _3464:
                        mem[0] = arg1
                        mem[32] = 1
                        mem[mem[64] + 32] = idx
                        mem[mem[64] + 64] = stor1[arg1].field_512
                        mem[mem[64] + 96] = stor8
                        _3538 = mem[64]
                        mem[mem[64]] = 96
                        mem[64] = mem[64] + 128
                        if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                            revert with 0, 50
                        if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                            revert with 0, 18
                        if sha3(mem[_3538 + 32 len mem[_3538]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                            if idx == -1:
                                revert with 0, 17
                            _3464 = mem[mem[ceil32(return_data.size) + 160]]
                            idx = idx + 1
                            u = u
                            continue 
                        if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                            revert with 0, 50
                        if u >= mem[_2209]:
                            revert with 0, 50
                        mem[(32 * u) + _2209 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                        if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                            revert with 0, 50
                        if u >= mem[_2209 + (32 * s + t) + 32]:
                            revert with 0, 50
                        mem[(32 * u) + _2209 + (32 * s + t) + 64] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                        if u == -1:
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        _3464 = mem[mem[ceil32(return_data.size) + 160]]
                        idx = idx + 1
                        u = u + 1
                        continue 
                    idx = 0
                    while idx < stor5.length:
                        mem[0] = 5
                        _5276 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5276] = address(stor5[idx].field_0)
                        mem[_5276 + 32] = address(stor5[idx].field_256)
                        mem[0] = address(stor5[idx].field_0)
                        mem[32] = sha3(arg1, 1) + 3
                        if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                            _5327 = mem[64]
                            mem[mem[64]] = 0
                            mem[mem[64] + 32] = 0
                            mem[64] = mem[64] + 64
                            _6773 = mem[_5327]
                            v = 0
                            w = u
                            while v < _6773:
                                if v >= mem[_5327]:
                                    revert with 0, 50
                                if w >= mem[_2209]:
                                    revert with 0, 50
                                mem[(32 * w) + _2209 + 32] = mem[(32 * v) + _5327 + 32]
                                if v >= mem[_5327 + 32]:
                                    revert with 0, 50
                                if w >= mem[_2209 + (32 * s + t) + 32]:
                                    revert with 0, 50
                                mem[(32 * w) + _2209 + (32 * s + t) + 64] = mem[(32 * v) + _5327 + 64]
                                if w == -1:
                                    revert with 0, 17
                                if v == -1:
                                    revert with 0, 17
                                _6773 = mem[_5327]
                                v = v + 1
                                w = w + 1
                                continue 
                        else:
                            mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = arg1
                            mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                            require ext_code.size(address(stor5[idx].field_256))
                            staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                                    gas gas_remaining wei
                                   args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _5514 = mem[64]
                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 64
                            _5587 = mem[_5514]
                            require mem[_5514] <= test266151307()
                            require _5514 + mem[_5514] + 31 < _5514 + return_data.size
                            _5725 = mem[_5514 + mem[_5514]]
                            if mem[_5514 + mem[_5514]] > test266151307():
                                revert with 0, 65
                            if ceil32(32 * mem[_5514 + mem[_5514]]) + 1 < 0 or _5514 + ceil32(return_data.size) + ceil32(32 * mem[_5514 + mem[_5514]]) + 1 > test266151307():
                                revert with 0, 65
                            mem[64] = _5514 + ceil32(return_data.size) + ceil32(32 * mem[_5514 + mem[_5514]]) + 1
                            mem[_5514 + ceil32(return_data.size)] = _5725
                            require _5587 + (32 * _5725) + 32 <= return_data.size
                            v = 0
                            w = _5514 + _5587 + 32
                            x = _5514 + ceil32(return_data.size) + 32
                            while v < _5725:
                                mem[x] = mem[w]
                                v = v + 1
                                w = w + 32
                                x = x + 32
                                continue 
                            _6969 = mem[_5514 + 32]
                            require mem[_5514 + 32] <= test266151307()
                            require _5514 + mem[_5514 + 32] + 31 < _5514 + return_data.size
                            _7080 = mem[_5514 + mem[_5514 + 32]]
                            if mem[_5514 + mem[_5514 + 32]] > test266151307():
                                revert with 0, 65
                            _7263 = mem[64]
                            if mem[64] + ceil32(32 * mem[_5514 + mem[_5514 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_5514 + mem[_5514 + 32]]) + 1 > test266151307():
                                revert with 0, 65
                            mem[64] = mem[64] + ceil32(32 * mem[_5514 + mem[_5514 + 32]]) + 1
                            mem[_7263] = _7080
                            require _6969 + (32 * _7080) + 32 <= return_data.size
                            v = 0
                            w = _5514 + _6969 + 32
                            x = _7263 + 32
                            while v < _7080:
                                mem[x] = mem[w]
                                v = v + 1
                                w = w + 32
                                x = x + 32
                                continue 
                            _9233 = mem[_5514 + ceil32(return_data.size)]
                            v = 0
                            w = u
                            while v < _9233:
                                if v >= mem[_5514 + ceil32(return_data.size)]:
                                    revert with 0, 50
                                if w >= mem[_2209]:
                                    revert with 0, 50
                                mem[(32 * w) + _2209 + 32] = mem[(32 * v) + _5514 + ceil32(return_data.size) + 32]
                                if v >= mem[_7263]:
                                    revert with 0, 50
                                if w >= mem[_2209 + (32 * s + t) + 32]:
                                    revert with 0, 50
                                mem[(32 * w) + _2209 + (32 * s + t) + 64] = mem[(32 * v) + _7263 + 32]
                                if w == -1:
                                    revert with 0, 17
                                if v == -1:
                                    revert with 0, 17
                                _9233 = mem[_5514 + ceil32(return_data.size)]
                                v = v + 1
                                w = w + 1
                                continue 
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
                    if s > !t:
                        revert with 0, 17
                    if u != s + t:
                        revert with 0, 1
                    if 1 >= stor9.length:
                        revert with 0, 50
                    mem[0] = 9
                    mem[mem[64]] = 0x15d2cfca00000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 64
                    _5472 = mem[_2209]
                    mem[mem[64] + 68] = mem[_2209]
                    mem[mem[64] + 100 len 32 * _5472] = mem[_2209 + 32 len 32 * _5472]
                    idx = _5472
                    var62002 = _2209 + (32 * _5472) + 32
                    mem[mem[64] + 36] = arg1
                    require ext_code.size(address(stor9.field_256))
                    staticcall address(stor9.field_256).0x15d2cfca with:
                            gas gas_remaining wei
                           args 64, arg1, mem[mem[64] + 68 len (32 * _5472) + 32]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _7079 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _7189 = mem[_7079]
                    require mem[_7079] <= test266151307()
                    require _7079 + mem[_7079] + 31 < _7079 + return_data.size
                    _7327 = mem[_7079 + mem[_7079]]
                    if mem[_7079 + mem[_7079]] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[_7079 + mem[_7079]]) + 1 < 0 or _7079 + ceil32(return_data.size) + ceil32(32 * mem[_7079 + mem[_7079]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = _7079 + ceil32(return_data.size) + ceil32(32 * mem[_7079 + mem[_7079]]) + 1
                    mem[_7079 + ceil32(return_data.size)] = _7327
                    require _7189 + (32 * _7327) + 32 <= return_data.size
                    mem[_7079 + ceil32(return_data.size) + 32 len 32 * _7327] = mem[_7079 + _7189 + 32 len 32 * _7327]
                    mem[mem[64]] = 32
                    mem[mem[64] + 32] = _7327
                    mem[mem[64] + 64 len 32 * _7327] = mem[_7079 + ceil32(return_data.size) + 32 len 32 * _7327]
                    var89001 = _7327
                    var89002 = _7079 + ceil32(return_data.size) + (32 * _7327) + 32
                    return Array(len=_7327, data=mem[mem[64] + 64 len 32 * _7327])
                mem[_2209 + (32 * s + t) + 64 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
                _3466 = mem[mem[ceil32(return_data.size) + 160]]
                idx = 0
                u = 0
                while idx < _3466:
                    mem[0] = arg1
                    mem[32] = 1
                    mem[mem[64] + 32] = idx
                    mem[mem[64] + 64] = stor1[arg1].field_512
                    mem[mem[64] + 96] = stor8
                    _3545 = mem[64]
                    mem[mem[64]] = 96
                    mem[64] = mem[64] + 128
                    if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                        revert with 0, 50
                    if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        revert with 0, 18
                    if sha3(mem[_3545 + 32 len mem[_3545]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        if idx == -1:
                            revert with 0, 17
                        _3466 = mem[mem[ceil32(return_data.size) + 160]]
                        idx = idx + 1
                        u = u
                        continue 
                    if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                        revert with 0, 50
                    if u >= mem[_2209]:
                        revert with 0, 50
                    mem[(32 * u) + _2209 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                    if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                        revert with 0, 50
                    if u >= mem[_2209 + (32 * s + t) + 32]:
                        revert with 0, 50
                    mem[(32 * u) + _2209 + (32 * s + t) + 64] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                    if u == -1:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _3466 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = idx + 1
                    u = u + 1
                    continue 
                idx = 0
                while idx < stor5.length:
                    mem[0] = 5
                    _5281 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5281] = address(stor5[idx].field_0)
                    mem[_5281 + 32] = address(stor5[idx].field_256)
                    mem[0] = address(stor5[idx].field_0)
                    mem[32] = sha3(arg1, 1) + 3
                    if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                        _5328 = mem[64]
                        mem[mem[64]] = 0
                        mem[mem[64] + 32] = 0
                        mem[64] = mem[64] + 64
                        _6774 = mem[_5328]
                        v = 0
                        w = u
                        while v < _6774:
                            if v >= mem[_5328]:
                                revert with 0, 50
                            if w >= mem[_2209]:
                                revert with 0, 50
                            mem[(32 * w) + _2209 + 32] = mem[(32 * v) + _5328 + 32]
                            if v >= mem[_5328 + 32]:
                                revert with 0, 50
                            if w >= mem[_2209 + (32 * s + t) + 32]:
                                revert with 0, 50
                            mem[(32 * w) + _2209 + (32 * s + t) + 64] = mem[(32 * v) + _5328 + 64]
                            if w == -1:
                                revert with 0, 17
                            if v == -1:
                                revert with 0, 17
                            _6774 = mem[_5328]
                            v = v + 1
                            w = w + 1
                            continue 
                    else:
                        mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = arg1
                        mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                        require ext_code.size(address(stor5[idx].field_256))
                        staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                                gas gas_remaining wei
                               args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _5517 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 64
                        _5590 = mem[_5517]
                        require mem[_5517] <= test266151307()
                        require _5517 + mem[_5517] + 31 < _5517 + return_data.size
                        _5727 = mem[_5517 + mem[_5517]]
                        if mem[_5517 + mem[_5517]] > test266151307():
                            revert with 0, 65
                        if ceil32(32 * mem[_5517 + mem[_5517]]) + 1 < 0 or _5517 + ceil32(return_data.size) + ceil32(32 * mem[_5517 + mem[_5517]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = _5517 + ceil32(return_data.size) + ceil32(32 * mem[_5517 + mem[_5517]]) + 1
                        mem[_5517 + ceil32(return_data.size)] = _5727
                        require _5590 + (32 * _5727) + 32 <= return_data.size
                        v = 0
                        w = _5517 + _5590 + 32
                        x = _5517 + ceil32(return_data.size) + 32
                        while v < _5727:
                            mem[x] = mem[w]
                            v = v + 1
                            w = w + 32
                            x = x + 32
                            continue 
                        _6972 = mem[_5517 + 32]
                        require mem[_5517 + 32] <= test266151307()
                        require _5517 + mem[_5517 + 32] + 31 < _5517 + return_data.size
                        _7082 = mem[_5517 + mem[_5517 + 32]]
                        if mem[_5517 + mem[_5517 + 32]] > test266151307():
                            revert with 0, 65
                        _7264 = mem[64]
                        if mem[64] + ceil32(32 * mem[_5517 + mem[_5517 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_5517 + mem[_5517 + 32]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = mem[64] + ceil32(32 * mem[_5517 + mem[_5517 + 32]]) + 1
                        mem[_7264] = _7082
                        require _6972 + (32 * _7082) + 32 <= return_data.size
                        v = 0
                        w = _5517 + _6972 + 32
                        x = _7264 + 32
                        while v < _7082:
                            mem[x] = mem[w]
                            v = v + 1
                            w = w + 32
                            x = x + 32
                            continue 
                        _9234 = mem[_5517 + ceil32(return_data.size)]
                        v = 0
                        w = u
                        while v < _9234:
                            if v >= mem[_5517 + ceil32(return_data.size)]:
                                revert with 0, 50
                            if w >= mem[_2209]:
                                revert with 0, 50
                            mem[(32 * w) + _2209 + 32] = mem[(32 * v) + _5517 + ceil32(return_data.size) + 32]
                            if v >= mem[_7264]:
                                revert with 0, 50
                            if w >= mem[_2209 + (32 * s + t) + 32]:
                                revert with 0, 50
                            mem[(32 * w) + _2209 + (32 * s + t) + 64] = mem[(32 * v) + _7264 + 32]
                            if w == -1:
                                revert with 0, 17
                            if v == -1:
                                revert with 0, 17
                            _9234 = mem[_5517 + ceil32(return_data.size)]
                            v = v + 1
                            w = w + 1
                            continue 
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                if s > !t:
                    revert with 0, 17
                if u != s + t:
                    revert with 0, 1
                if 1 >= stor9.length:
                    revert with 0, 50
                mem[0] = 9
                mem[mem[64]] = 0x15d2cfca00000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 64
                _5474 = mem[_2209]
                mem[mem[64] + 68] = mem[_2209]
                mem[mem[64] + 100 len 32 * _5474] = mem[_2209 + 32 len 32 * _5474]
                idx = _5474
                var63002 = _2209 + (32 * _5474) + 32
                mem[mem[64] + 36] = arg1
                require ext_code.size(address(stor9.field_256))
                staticcall address(stor9.field_256).0x15d2cfca with:
                        gas gas_remaining wei
                       args 64, arg1, mem[mem[64] + 68 len (32 * _5474) + 32]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _7081 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _7190 = mem[_7081]
                require mem[_7081] <= test266151307()
                require _7081 + mem[_7081] + 31 < _7081 + return_data.size
                _7328 = mem[_7081 + mem[_7081]]
                if mem[_7081 + mem[_7081]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_7081 + mem[_7081]]) + 1 < 0 or _7081 + ceil32(return_data.size) + ceil32(32 * mem[_7081 + mem[_7081]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _7081 + ceil32(return_data.size) + ceil32(32 * mem[_7081 + mem[_7081]]) + 1
                mem[_7081 + ceil32(return_data.size)] = _7328
                require _7190 + (32 * _7328) + 32 <= return_data.size
                mem[_7081 + ceil32(return_data.size) + 32 len 32 * _7328] = mem[_7081 + _7190 + 32 len 32 * _7328]
                mem[mem[64]] = 32
                mem[mem[64] + 32] = _7328
                mem[mem[64] + 64 len 32 * _7328] = mem[_7081 + ceil32(return_data.size) + 32 len 32 * _7328]
                var90001 = _7328
                var90002 = _7081 + ceil32(return_data.size) + (32 * _7328) + 32
                return Array(len=_7328, data=mem[mem[64] + 64 len 32 * _7328])
            if s > !t:
                revert with 0, 17
            if s + t > test266151307():
                revert with 0, 65
            _2292 = mem[64] + (32 * s + t) + 32
            mem[mem[64] + (32 * s + t) + 32] = s + t
            mem[64] = _2292 + (32 * s + t) + 32
            if s + t:
                mem[_2292 + 32 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
                _3462 = mem[mem[ceil32(return_data.size) + 160]]
                idx = 0
                u = 0
                while idx < _3462:
                    mem[0] = arg1
                    mem[32] = 1
                    mem[mem[64] + 32] = idx
                    mem[mem[64] + 64] = stor1[arg1].field_512
                    mem[mem[64] + 96] = stor8
                    _3531 = mem[64]
                    mem[mem[64]] = 96
                    mem[64] = mem[64] + 128
                    if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                        revert with 0, 50
                    if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        revert with 0, 18
                    if sha3(mem[_3531 + 32 len mem[_3531]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        if idx == -1:
                            revert with 0, 17
                        _3462 = mem[mem[ceil32(return_data.size) + 160]]
                        idx = idx + 1
                        u = u
                        continue 
                    if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                        revert with 0, 50
                    if u >= mem[_2209]:
                        revert with 0, 50
                    mem[(32 * u) + _2209 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                    if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                        revert with 0, 50
                    if u >= mem[_2292]:
                        revert with 0, 50
                    mem[(32 * u) + _2292 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                    if u == -1:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _3462 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = idx + 1
                    u = u + 1
                    continue 
                idx = 0
                while idx < stor5.length:
                    mem[0] = 5
                    _5271 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5271] = address(stor5[idx].field_0)
                    mem[_5271 + 32] = address(stor5[idx].field_256)
                    mem[0] = address(stor5[idx].field_0)
                    mem[32] = sha3(arg1, 1) + 3
                    if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                        _5326 = mem[64]
                        mem[mem[64]] = 0
                        mem[mem[64] + 32] = 0
                        mem[64] = mem[64] + 64
                        _6772 = mem[_5326]
                        s = 0
                        t = u
                        while s < _6772:
                            if s >= mem[_5326]:
                                revert with 0, 50
                            if t >= mem[_2209]:
                                revert with 0, 50
                            mem[(32 * t) + _2209 + 32] = mem[(32 * s) + _5326 + 32]
                            if s >= mem[_5326 + 32]:
                                revert with 0, 50
                            if t >= mem[_2292]:
                                revert with 0, 50
                            mem[(32 * t) + _2292 + 32] = mem[(32 * s) + _5326 + 64]
                            if t == -1:
                                revert with 0, 17
                            if s == -1:
                                revert with 0, 17
                            _6772 = mem[_5326]
                            s = s + 1
                            t = t + 1
                            continue 
                    else:
                        mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = arg1
                        mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                        require ext_code.size(address(stor5[idx].field_256))
                        staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                                gas gas_remaining wei
                               args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _5511 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 64
                        _5584 = mem[_5511]
                        require mem[_5511] <= test266151307()
                        require _5511 + mem[_5511] + 31 < _5511 + return_data.size
                        _5723 = mem[_5511 + mem[_5511]]
                        if mem[_5511 + mem[_5511]] > test266151307():
                            revert with 0, 65
                        if ceil32(32 * mem[_5511 + mem[_5511]]) + 1 < 0 or _5511 + ceil32(return_data.size) + ceil32(32 * mem[_5511 + mem[_5511]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = _5511 + ceil32(return_data.size) + ceil32(32 * mem[_5511 + mem[_5511]]) + 1
                        mem[_5511 + ceil32(return_data.size)] = _5723
                        require _5584 + (32 * _5723) + 32 <= return_data.size
                        s = 0
                        t = _5511 + _5584 + 32
                        v = _5511 + ceil32(return_data.size) + 32
                        while s < _5723:
                            mem[v] = mem[t]
                            s = s + 1
                            t = t + 32
                            v = v + 32
                            continue 
                        _6966 = mem[_5511 + 32]
                        require mem[_5511 + 32] <= test266151307()
                        require _5511 + mem[_5511 + 32] + 31 < _5511 + return_data.size
                        _7078 = mem[_5511 + mem[_5511 + 32]]
                        if mem[_5511 + mem[_5511 + 32]] > test266151307():
                            revert with 0, 65
                        _7262 = mem[64]
                        if mem[64] + ceil32(32 * mem[_5511 + mem[_5511 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_5511 + mem[_5511 + 32]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = mem[64] + ceil32(32 * mem[_5511 + mem[_5511 + 32]]) + 1
                        mem[_7262] = _7078
                        require _6966 + (32 * _7078) + 32 <= return_data.size
                        s = 0
                        t = _5511 + _6966 + 32
                        v = _7262 + 32
                        while s < _7078:
                            mem[v] = mem[t]
                            s = s + 1
                            t = t + 32
                            v = v + 32
                            continue 
                        _9232 = mem[_5511 + ceil32(return_data.size)]
                        s = 0
                        t = u
                        while s < _9232:
                            if s >= mem[_5511 + ceil32(return_data.size)]:
                                revert with 0, 50
                            if t >= mem[_2209]:
                                revert with 0, 50
                            mem[(32 * t) + _2209 + 32] = mem[(32 * s) + _5511 + ceil32(return_data.size) + 32]
                            if s >= mem[_7262]:
                                revert with 0, 50
                            if t >= mem[_2292]:
                                revert with 0, 50
                            mem[(32 * t) + _2292 + 32] = mem[(32 * s) + _7262 + 32]
                            if t == -1:
                                revert with 0, 17
                            if s == -1:
                                revert with 0, 17
                            _9232 = mem[_5511 + ceil32(return_data.size)]
                            s = s + 1
                            t = t + 1
                            continue 
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                if s > !t:
                    revert with 0, 17
                if u != s + t:
                    revert with 0, 1
                if 1 >= stor9.length:
                    revert with 0, 50
                mem[0] = 9
                mem[mem[64]] = 0x15d2cfca00000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 64
                _5470 = mem[_2209]
                mem[mem[64] + 68] = mem[_2209]
                mem[mem[64] + 100 len 32 * _5470] = mem[_2209 + 32 len 32 * _5470]
                idx = _5470
                var62002 = _2209 + (32 * _5470) + 32
                mem[mem[64] + 36] = arg1
                require ext_code.size(address(stor9.field_256))
                staticcall address(stor9.field_256).0x15d2cfca with:
                        gas gas_remaining wei
                       args 64, arg1, mem[mem[64] + 68 len (32 * _5470) + 32]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _7077 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _7188 = mem[_7077]
                require mem[_7077] <= test266151307()
                require _7077 + mem[_7077] + 31 < _7077 + return_data.size
                _7326 = mem[_7077 + mem[_7077]]
                if mem[_7077 + mem[_7077]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_7077 + mem[_7077]]) + 1 < 0 or _7077 + ceil32(return_data.size) + ceil32(32 * mem[_7077 + mem[_7077]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _7077 + ceil32(return_data.size) + ceil32(32 * mem[_7077 + mem[_7077]]) + 1
                mem[_7077 + ceil32(return_data.size)] = _7326
                require _7188 + (32 * _7326) + 32 <= return_data.size
                mem[_7077 + ceil32(return_data.size) + 32 len 32 * _7326] = mem[_7077 + _7188 + 32 len 32 * _7326]
                mem[mem[64]] = 32
                mem[mem[64] + 32] = _7326
                mem[mem[64] + 64 len 32 * _7326] = mem[_7077 + ceil32(return_data.size) + 32 len 32 * _7326]
                var89001 = _7326
                var89002 = _7077 + ceil32(return_data.size) + (32 * _7326) + 32
                return Array(len=_7326, data=mem[mem[64] + 64 len 32 * _7326])
            _3460 = mem[mem[ceil32(return_data.size) + 160]]
            idx = 0
            u = 0
            while idx < _3460:
                mem[0] = arg1
                mem[32] = 1
                mem[mem[64] + 32] = idx
                mem[mem[64] + 64] = stor1[arg1].field_512
                mem[mem[64] + 96] = stor8
                _3524 = mem[64]
                mem[mem[64]] = 96
                mem[64] = mem[64] + 128
                if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                    revert with 0, 50
                if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    revert with 0, 18
                if sha3(mem[_3524 + 32 len mem[_3524]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    if idx == -1:
                        revert with 0, 17
                    _3460 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = idx + 1
                    u = u
                    continue 
                if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                    revert with 0, 50
                if u >= mem[_2209]:
                    revert with 0, 50
                mem[(32 * u) + _2209 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                    revert with 0, 50
                if u >= mem[_2292]:
                    revert with 0, 50
                mem[(32 * u) + _2292 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                if u == -1:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _3460 = mem[mem[ceil32(return_data.size) + 160]]
                idx = idx + 1
                u = u + 1
                continue 
            idx = 0
            while idx < stor5.length:
                mem[0] = 5
                _5266 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5266] = address(stor5[idx].field_0)
                mem[_5266 + 32] = address(stor5[idx].field_256)
                mem[0] = address(stor5[idx].field_0)
                mem[32] = sha3(arg1, 1) + 3
                if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                    _5325 = mem[64]
                    mem[mem[64]] = 0
                    mem[mem[64] + 32] = 0
                    mem[64] = mem[64] + 64
                    _6771 = mem[_5325]
                    s = 0
                    t = u
                    while s < _6771:
                        if s >= mem[_5325]:
                            revert with 0, 50
                        if t >= mem[_2209]:
                            revert with 0, 50
                        mem[(32 * t) + _2209 + 32] = mem[(32 * s) + _5325 + 32]
                        if s >= mem[_5325 + 32]:
                            revert with 0, 50
                        if t >= mem[_2292]:
                            revert with 0, 50
                        mem[(32 * t) + _2292 + 32] = mem[(32 * s) + _5325 + 64]
                        if t == -1:
                            revert with 0, 17
                        if s == -1:
                            revert with 0, 17
                        _6771 = mem[_5325]
                        s = s + 1
                        t = t + 1
                        continue 
                else:
                    mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = arg1
                    mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    require ext_code.size(address(stor5[idx].field_256))
                    staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                            gas gas_remaining wei
                           args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _5508 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 64
                    _5581 = mem[_5508]
                    require mem[_5508] <= test266151307()
                    require _5508 + mem[_5508] + 31 < _5508 + return_data.size
                    _5721 = mem[_5508 + mem[_5508]]
                    if mem[_5508 + mem[_5508]] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[_5508 + mem[_5508]]) + 1 < 0 or _5508 + ceil32(return_data.size) + ceil32(32 * mem[_5508 + mem[_5508]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = _5508 + ceil32(return_data.size) + ceil32(32 * mem[_5508 + mem[_5508]]) + 1
                    mem[_5508 + ceil32(return_data.size)] = _5721
                    require _5581 + (32 * _5721) + 32 <= return_data.size
                    s = 0
                    t = _5508 + _5581 + 32
                    v = _5508 + ceil32(return_data.size) + 32
                    while s < _5721:
                        mem[v] = mem[t]
                        s = s + 1
                        t = t + 32
                        v = v + 32
                        continue 
                    _6963 = mem[_5508 + 32]
                    require mem[_5508 + 32] <= test266151307()
                    require _5508 + mem[_5508 + 32] + 31 < _5508 + return_data.size
                    _7076 = mem[_5508 + mem[_5508 + 32]]
                    if mem[_5508 + mem[_5508 + 32]] > test266151307():
                        revert with 0, 65
                    _7261 = mem[64]
                    if mem[64] + ceil32(32 * mem[_5508 + mem[_5508 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_5508 + mem[_5508 + 32]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = mem[64] + ceil32(32 * mem[_5508 + mem[_5508 + 32]]) + 1
                    mem[_7261] = _7076
                    require _6963 + (32 * _7076) + 32 <= return_data.size
                    s = 0
                    t = _5508 + _6963 + 32
                    v = _7261 + 32
                    while s < _7076:
                        mem[v] = mem[t]
                        s = s + 1
                        t = t + 32
                        v = v + 32
                        continue 
                    _9231 = mem[_5508 + ceil32(return_data.size)]
                    s = 0
                    t = u
                    while s < _9231:
                        if s >= mem[_5508 + ceil32(return_data.size)]:
                            revert with 0, 50
                        if t >= mem[_2209]:
                            revert with 0, 50
                        mem[(32 * t) + _2209 + 32] = mem[(32 * s) + _5508 + ceil32(return_data.size) + 32]
                        if s >= mem[_7261]:
                            revert with 0, 50
                        if t >= mem[_2292]:
                            revert with 0, 50
                        mem[(32 * t) + _2292 + 32] = mem[(32 * s) + _7261 + 32]
                        if t == -1:
                            revert with 0, 17
                        if s == -1:
                            revert with 0, 17
                        _9231 = mem[_5508 + ceil32(return_data.size)]
                        s = s + 1
                        t = t + 1
                        continue 
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            if s > !t:
                revert with 0, 17
            if u != s + t:
                revert with 0, 1
            if 1 >= stor9.length:
                revert with 0, 50
            mem[0] = 9
            mem[mem[64]] = 0x15d2cfca00000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 64
            _5468 = mem[_2209]
            mem[mem[64] + 68] = mem[_2209]
            mem[mem[64] + 100 len 32 * _5468] = mem[_2209 + 32 len 32 * _5468]
            idx = _5468
            mem[mem[64] + 36] = arg1
            require ext_code.size(address(stor9.field_256))
            staticcall address(stor9.field_256).0x15d2cfca with:
                    gas gas_remaining wei
                   args 64, arg1, mem[mem[64] + 68 len (32 * _5468) + 32]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _7075 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _7187 = mem[_7075]
            require mem[_7075] <= test266151307()
            require _7075 + mem[_7075] + 31 < _7075 + return_data.size
            _7325 = mem[_7075 + mem[_7075]]
            if mem[_7075 + mem[_7075]] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[_7075 + mem[_7075]]) + 1 < 0 or _7075 + ceil32(return_data.size) + ceil32(32 * mem[_7075 + mem[_7075]]) + 1 > test266151307():
                revert with 0, 65
            mem[64] = _7075 + ceil32(return_data.size) + ceil32(32 * mem[_7075 + mem[_7075]]) + 1
            mem[_7075 + ceil32(return_data.size)] = _7325
            require _7187 + (32 * _7325) + 32 <= return_data.size
            mem[_7075 + ceil32(return_data.size) + 32 len 32 * _7325] = mem[_7075 + _7187 + 32 len 32 * _7325]
            var80001 = _7325
            var80002 = _7075 + _7187 + (32 * _7325) + 32
            var80004 = _7075 + ceil32(return_data.size) + (32 * _7325) + 32
            mem[mem[64]] = 32
            mem[mem[64] + 32] = _7325
            mem[mem[64] + 64 len 32 * _7325] = mem[_7075 + ceil32(return_data.size) + 32 len 32 * _7325]
            var88001 = _7325
            var88002 = _7075 + ceil32(return_data.size) + (32 * _7325) + 32
            return Array(len=_7325, data=mem[mem[64] + 64 len 32 * _7325])
        mem[0] = sha3(ext_call.return_data[31 len 1], 10) + 2
        mem[ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 288] = stor10[ext_call.return_data[31 len 1]][2].field_0
        idx = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 288
        s = 0
        while ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + (32 * stor10[ext_call.return_data[31 len 1]].field_512) + 256 > idx:
            mem[idx + 32] = stor10[ext_call.return_data[31 len 1]][s + 2].field_256
            idx = idx + 32
            s = s + 1
            continue 
        mem[ceil32(return_data.size) + 160] = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 256
        idx = 0
        s = 0
        while idx < stor10[ext_call.return_data[31 len 1]].field_512:
            mem[0] = arg1
            mem[32] = 1
            mem[mem[64] + 32] = idx
            mem[mem[64] + 64] = stor1[arg1].field_512
            mem[mem[64] + 96] = stor8
            _3553 = mem[64]
            mem[mem[64]] = 96
            mem[64] = mem[64] + 128
            if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                revert with 0, 50
            if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                revert with 0, 18
            if sha3(mem[_3553 + 32 len mem[_3553]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s
                continue 
            if s == -1:
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = s + 1
            continue 
        idx = 0
        t = 0
        while idx < stor5.length:
            mem[0] = 5
            _5286 = mem[64]
            mem[64] = mem[64] + 64
            mem[_5286] = address(stor5[idx].field_0)
            mem[_5286 + 32] = address(stor5[idx].field_256)
            mem[0] = address(stor5[idx].field_0)
            mem[32] = sha3(arg1, 1) + 3
            if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                _5331 = mem[64]
                mem[mem[64]] = 0
                mem[mem[64] + 32] = 0
                mem[64] = mem[64] + 64
                if t > !mem[_5331]:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                t = t + mem[_5331]
                continue 
            mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = arg1
            mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
            require ext_code.size(address(stor5[idx].field_256))
            staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                    gas gas_remaining wei
                   args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _5521 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 64
            _5595 = mem[_5521]
            require mem[_5521] <= test266151307()
            require _5521 + mem[_5521] + 31 < _5521 + return_data.size
            _5737 = mem[_5521 + mem[_5521]]
            if mem[_5521 + mem[_5521]] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[_5521 + mem[_5521]]) + 1 < 0 or _5521 + ceil32(return_data.size) + ceil32(32 * mem[_5521 + mem[_5521]]) + 1 > test266151307():
                revert with 0, 65
            mem[64] = _5521 + ceil32(return_data.size) + ceil32(32 * mem[_5521 + mem[_5521]]) + 1
            mem[_5521 + ceil32(return_data.size)] = _5737
            require _5595 + (32 * _5737) + 32 <= return_data.size
            s = 0
            u = _5521 + _5595 + 32
            v = _5521 + ceil32(return_data.size) + 32
            while s < _5737:
                mem[v] = mem[u]
                s = s + 1
                u = u + 32
                v = v + 32
                continue 
            _6979 = mem[_5521 + 32]
            require mem[_5521 + 32] <= test266151307()
            require _5521 + mem[_5521 + 32] + 31 < _5521 + return_data.size
            _7083 = mem[_5521 + mem[_5521 + 32]]
            if mem[_5521 + mem[_5521 + 32]] > test266151307():
                revert with 0, 65
            _7281 = mem[64]
            if mem[64] + ceil32(32 * mem[_5521 + mem[_5521 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_5521 + mem[_5521 + 32]]) + 1 > test266151307():
                revert with 0, 65
            mem[64] = mem[64] + ceil32(32 * mem[_5521 + mem[_5521 + 32]]) + 1
            mem[_7281] = _7083
            require _6979 + (32 * _7083) + 32 <= return_data.size
            s = 0
            u = _5521 + _6979 + 32
            v = _7281 + 32
            while s < _7083:
                mem[v] = mem[u]
                s = s + 1
                u = u + 32
                v = v + 32
                continue 
            if t > !mem[_5521 + ceil32(return_data.size)]:
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            t = t + mem[_5521 + ceil32(return_data.size)]
            continue 
        if s > !t:
            revert with 0, 17
        if s + t > test266151307():
            revert with 0, 65
        _5330 = mem[64]
        mem[mem[64]] = s + t
        if not s + t:
            if s > !t:
                revert with 0, 17
            if s + t > test266151307():
                revert with 0, 65
            _5520 = mem[64] + (32 * s + t) + 32
            mem[mem[64] + (32 * s + t) + 32] = s + t
            mem[64] = _5520 + (32 * s + t) + 32
            if not s + t:
                _6776 = mem[mem[ceil32(return_data.size) + 160]]
                idx = 0
                u = 0
                while idx < _6776:
                    mem[0] = arg1
                    mem[32] = 1
                    mem[mem[64] + 32] = idx
                    mem[mem[64] + 64] = stor1[arg1].field_512
                    mem[mem[64] + 96] = stor8
                    _6839 = mem[64]
                    mem[mem[64]] = 96
                    mem[64] = mem[64] + 128
                    if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                        revert with 0, 50
                    if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        revert with 0, 18
                    if sha3(mem[_6839 + 32 len mem[_6839]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        if idx == -1:
                            revert with 0, 17
                        _6776 = mem[mem[ceil32(return_data.size) + 160]]
                        idx = idx + 1
                        u = u
                        continue 
                    if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                        revert with 0, 50
                    if u >= mem[_5330]:
                        revert with 0, 50
                    mem[(32 * u) + _5330 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                    if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                        revert with 0, 50
                    if u >= mem[_5520]:
                        revert with 0, 50
                    mem[(32 * u) + _5520 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                    if u == -1:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _6776 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = idx + 1
                    u = u + 1
                    continue 
                idx = 0
                while idx < stor5.length:
                    mem[0] = 5
                    _8270 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_8270] = address(stor5[idx].field_0)
                    mem[_8270 + 32] = address(stor5[idx].field_256)
                    mem[0] = address(stor5[idx].field_0)
                    mem[32] = sha3(arg1, 1) + 3
                    if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                        _8338 = mem[64]
                        mem[mem[64]] = 0
                        mem[mem[64] + 32] = 0
                        mem[64] = mem[64] + 64
                        _9235 = mem[_8338]
                        s = 0
                        t = u
                        while s < _9235:
                            if s >= mem[_8338]:
                                revert with 0, 50
                            if t >= mem[_5330]:
                                revert with 0, 50
                            mem[(32 * t) + _5330 + 32] = mem[(32 * s) + _8338 + 32]
                            if s >= mem[_8338 + 32]:
                                revert with 0, 50
                            if t >= mem[_5520]:
                                revert with 0, 50
                            mem[(32 * t) + _5520 + 32] = mem[(32 * s) + _8338 + 64]
                            if t == -1:
                                revert with 0, 17
                            if s == -1:
                                revert with 0, 17
                            _9235 = mem[_8338]
                            s = s + 1
                            t = t + 1
                            continue 
                    else:
                        mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = arg1
                        mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                        require ext_code.size(address(stor5[idx].field_256))
                        staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                                gas gas_remaining wei
                               args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _8563 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 64
                        _8638 = mem[_8563]
                        require mem[_8563] <= test266151307()
                        require _8563 + mem[_8563] + 31 < _8563 + return_data.size
                        _8718 = mem[_8563 + mem[_8563]]
                        if mem[_8563 + mem[_8563]] > test266151307():
                            revert with 0, 65
                        if ceil32(32 * mem[_8563 + mem[_8563]]) + 1 < 0 or _8563 + ceil32(return_data.size) + ceil32(32 * mem[_8563 + mem[_8563]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = _8563 + ceil32(return_data.size) + ceil32(32 * mem[_8563 + mem[_8563]]) + 1
                        mem[_8563 + ceil32(return_data.size)] = _8718
                        require _8638 + (32 * _8718) + 32 <= return_data.size
                        s = 0
                        t = _8563 + _8638 + 32
                        v = _8563 + ceil32(return_data.size) + 32
                        while s < _8718:
                            mem[v] = mem[t]
                            s = s + 1
                            t = t + 32
                            v = v + 32
                            continue 
                        _9364 = mem[_8563 + 32]
                        require mem[_8563 + 32] <= test266151307()
                        require _8563 + mem[_8563 + 32] + 31 < _8563 + return_data.size
                        _9510 = mem[_8563 + mem[_8563 + 32]]
                        if mem[_8563 + mem[_8563 + 32]] > test266151307():
                            revert with 0, 65
                        _9594 = mem[64]
                        if mem[64] + ceil32(32 * mem[_8563 + mem[_8563 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_8563 + mem[_8563 + 32]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = mem[64] + ceil32(32 * mem[_8563 + mem[_8563 + 32]]) + 1
                        mem[_9594] = _9510
                        require _9364 + (32 * _9510) + 32 <= return_data.size
                        s = 0
                        t = _8563 + _9364 + 32
                        v = _9594 + 32
                        while s < _9510:
                            mem[v] = mem[t]
                            s = s + 1
                            t = t + 32
                            v = v + 32
                            continue 
                        _10299 = mem[_8563 + ceil32(return_data.size)]
                        s = 0
                        t = u
                        while s < _10299:
                            if s >= mem[_8563 + ceil32(return_data.size)]:
                                revert with 0, 50
                            if t >= mem[_5330]:
                                revert with 0, 50
                            mem[(32 * t) + _5330 + 32] = mem[(32 * s) + _8563 + ceil32(return_data.size) + 32]
                            if s >= mem[_9594]:
                                revert with 0, 50
                            if t >= mem[_5520]:
                                revert with 0, 50
                            mem[(32 * t) + _5520 + 32] = mem[(32 * s) + _9594 + 32]
                            if t == -1:
                                revert with 0, 17
                            if s == -1:
                                revert with 0, 17
                            _10299 = mem[_8563 + ceil32(return_data.size)]
                            s = s + 1
                            t = t + 1
                            continue 
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                if s > !t:
                    revert with 0, 17
                if u != s + t:
                    revert with 0, 1
                if 1 >= stor9.length:
                    revert with 0, 50
                mem[0] = 9
                mem[mem[64]] = 0x15d2cfca00000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 64
                _8511 = mem[_5330]
                mem[mem[64] + 68] = mem[_5330]
                mem[mem[64] + 100 len 32 * _8511] = mem[_5330 + 32 len 32 * _8511]
                idx = _8511
                var65002 = _5330 + (32 * _8511) + 32
                mem[mem[64] + 36] = arg1
                require ext_code.size(address(stor9.field_256))
                staticcall address(stor9.field_256).0x15d2cfca with:
                        gas gas_remaining wei
                       args 64, arg1, mem[mem[64] + 68 len (32 * _8511) + 32]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _9509 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _9562 = mem[_9509]
                require mem[_9509] <= test266151307()
                require _9509 + mem[_9509] + 31 < _9509 + return_data.size
                _9623 = mem[_9509 + mem[_9509]]
                if mem[_9509 + mem[_9509]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_9509 + mem[_9509]]) + 1 < 0 or _9509 + ceil32(return_data.size) + ceil32(32 * mem[_9509 + mem[_9509]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _9509 + ceil32(return_data.size) + ceil32(32 * mem[_9509 + mem[_9509]]) + 1
                mem[_9509 + ceil32(return_data.size)] = _9623
                require _9562 + (32 * _9623) + 32 <= return_data.size
                mem[_9509 + ceil32(return_data.size) + 32 len 32 * _9623] = mem[_9509 + _9562 + 32 len 32 * _9623]
                mem[mem[64]] = 32
                mem[mem[64] + 32] = _9623
                mem[mem[64] + 64 len 32 * _9623] = mem[_9509 + ceil32(return_data.size) + 32 len 32 * _9623]
                var92001 = _9623
                var92002 = _9509 + ceil32(return_data.size) + (32 * _9623) + 32
                return Array(len=_9623, data=mem[mem[64] + 64 len 32 * _9623])
            mem[_5520 + 32 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
            _6778 = mem[mem[ceil32(return_data.size) + 160]]
            idx = 0
            u = 0
            while idx < _6778:
                mem[0] = arg1
                mem[32] = 1
                mem[mem[64] + 32] = idx
                mem[mem[64] + 64] = stor1[arg1].field_512
                mem[mem[64] + 96] = stor8
                _6846 = mem[64]
                mem[mem[64]] = 96
                mem[64] = mem[64] + 128
                if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                    revert with 0, 50
                if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    revert with 0, 18
                if sha3(mem[_6846 + 32 len mem[_6846]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    if idx == -1:
                        revert with 0, 17
                    _6778 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = idx + 1
                    u = u
                    continue 
                if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                    revert with 0, 50
                if u >= mem[_5330]:
                    revert with 0, 50
                mem[(32 * u) + _5330 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                    revert with 0, 50
                if u >= mem[_5520]:
                    revert with 0, 50
                mem[(32 * u) + _5520 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                if u == -1:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _6778 = mem[mem[ceil32(return_data.size) + 160]]
                idx = idx + 1
                u = u + 1
                continue 
            idx = 0
            while idx < stor5.length:
                mem[0] = 5
                _8275 = mem[64]
                mem[64] = mem[64] + 64
                mem[_8275] = address(stor5[idx].field_0)
                mem[_8275 + 32] = address(stor5[idx].field_256)
                mem[0] = address(stor5[idx].field_0)
                mem[32] = sha3(arg1, 1) + 3
                if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                    _8339 = mem[64]
                    mem[mem[64]] = 0
                    mem[mem[64] + 32] = 0
                    mem[64] = mem[64] + 64
                    _9236 = mem[_8339]
                    s = 0
                    t = u
                    while s < _9236:
                        if s >= mem[_8339]:
                            revert with 0, 50
                        if t >= mem[_5330]:
                            revert with 0, 50
                        mem[(32 * t) + _5330 + 32] = mem[(32 * s) + _8339 + 32]
                        if s >= mem[_8339 + 32]:
                            revert with 0, 50
                        if t >= mem[_5520]:
                            revert with 0, 50
                        mem[(32 * t) + _5520 + 32] = mem[(32 * s) + _8339 + 64]
                        if t == -1:
                            revert with 0, 17
                        if s == -1:
                            revert with 0, 17
                        _9236 = mem[_8339]
                        s = s + 1
                        t = t + 1
                        continue 
                else:
                    mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = arg1
                    mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    require ext_code.size(address(stor5[idx].field_256))
                    staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                            gas gas_remaining wei
                           args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _8566 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 64
                    _8641 = mem[_8566]
                    require mem[_8566] <= test266151307()
                    require _8566 + mem[_8566] + 31 < _8566 + return_data.size
                    _8720 = mem[_8566 + mem[_8566]]
                    if mem[_8566 + mem[_8566]] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[_8566 + mem[_8566]]) + 1 < 0 or _8566 + ceil32(return_data.size) + ceil32(32 * mem[_8566 + mem[_8566]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = _8566 + ceil32(return_data.size) + ceil32(32 * mem[_8566 + mem[_8566]]) + 1
                    mem[_8566 + ceil32(return_data.size)] = _8720
                    require _8641 + (32 * _8720) + 32 <= return_data.size
                    s = 0
                    t = _8566 + _8641 + 32
                    v = _8566 + ceil32(return_data.size) + 32
                    while s < _8720:
                        mem[v] = mem[t]
                        s = s + 1
                        t = t + 32
                        v = v + 32
                        continue 
                    _9367 = mem[_8566 + 32]
                    require mem[_8566 + 32] <= test266151307()
                    require _8566 + mem[_8566 + 32] + 31 < _8566 + return_data.size
                    _9512 = mem[_8566 + mem[_8566 + 32]]
                    if mem[_8566 + mem[_8566 + 32]] > test266151307():
                        revert with 0, 65
                    _9595 = mem[64]
                    if mem[64] + ceil32(32 * mem[_8566 + mem[_8566 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_8566 + mem[_8566 + 32]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = mem[64] + ceil32(32 * mem[_8566 + mem[_8566 + 32]]) + 1
                    mem[_9595] = _9512
                    require _9367 + (32 * _9512) + 32 <= return_data.size
                    s = 0
                    t = _8566 + _9367 + 32
                    v = _9595 + 32
                    while s < _9512:
                        mem[v] = mem[t]
                        s = s + 1
                        t = t + 32
                        v = v + 32
                        continue 
                    _10300 = mem[_8566 + ceil32(return_data.size)]
                    s = 0
                    t = u
                    while s < _10300:
                        if s >= mem[_8566 + ceil32(return_data.size)]:
                            revert with 0, 50
                        if t >= mem[_5330]:
                            revert with 0, 50
                        mem[(32 * t) + _5330 + 32] = mem[(32 * s) + _8566 + ceil32(return_data.size) + 32]
                        if s >= mem[_9595]:
                            revert with 0, 50
                        if t >= mem[_5520]:
                            revert with 0, 50
                        mem[(32 * t) + _5520 + 32] = mem[(32 * s) + _9595 + 32]
                        if t == -1:
                            revert with 0, 17
                        if s == -1:
                            revert with 0, 17
                        _10300 = mem[_8566 + ceil32(return_data.size)]
                        s = s + 1
                        t = t + 1
                        continue 
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            if s > !t:
                revert with 0, 17
            if u != s + t:
                revert with 0, 1
            if 1 >= stor9.length:
                revert with 0, 50
            mem[0] = 9
            mem[mem[64]] = 0x15d2cfca00000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 64
            _8513 = mem[_5330]
            mem[mem[64] + 68] = mem[_5330]
            mem[mem[64] + 100 len 32 * _8513] = mem[_5330 + 32 len 32 * _8513]
            idx = _8513
            mem[mem[64] + 36] = arg1
            require ext_code.size(address(stor9.field_256))
            staticcall address(stor9.field_256).0x15d2cfca with:
                    gas gas_remaining wei
                   args 64, arg1, mem[mem[64] + 68 len (32 * _8513) + 32]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _9511 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _9563 = mem[_9511]
            require mem[_9511] <= test266151307()
            require _9511 + mem[_9511] + 31 < _9511 + return_data.size
            _9624 = mem[_9511 + mem[_9511]]
            if mem[_9511 + mem[_9511]] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[_9511 + mem[_9511]]) + 1 < 0 or _9511 + ceil32(return_data.size) + ceil32(32 * mem[_9511 + mem[_9511]]) + 1 > test266151307():
                revert with 0, 65
            mem[64] = _9511 + ceil32(return_data.size) + ceil32(32 * mem[_9511 + mem[_9511]]) + 1
            mem[_9511 + ceil32(return_data.size)] = _9624
            require _9563 + (32 * _9624) + 32 <= return_data.size
            mem[_9511 + ceil32(return_data.size) + 32 len 32 * _9624] = mem[_9511 + _9563 + 32 len 32 * _9624]
            mem[mem[64]] = 32
            mem[mem[64] + 32] = _9624
            mem[mem[64] + 64 len 32 * _9624] = mem[_9511 + ceil32(return_data.size) + 32 len 32 * _9624]
            var93001 = _9624
            var93002 = _9511 + ceil32(return_data.size) + (32 * _9624) + 32
            return Array(len=_9624, data=mem[mem[64] + 64 len 32 * _9624])
        mem[mem[64] + 32 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
        if s > !t:
            revert with 0, 17
        if s + t > test266151307():
            revert with 0, 65
        mem[mem[64] + (32 * s + t) + 32] = s + t
        mem[64] = _5330 + (64 * s + t) + 64
        if not s + t:
            _6780 = mem[mem[ceil32(return_data.size) + 160]]
            idx = 0
            u = 0
            while idx < _6780:
                mem[0] = arg1
                mem[32] = 1
                mem[mem[64] + 32] = idx
                mem[mem[64] + 64] = stor1[arg1].field_512
                mem[mem[64] + 96] = stor8
                _6853 = mem[64]
                mem[mem[64]] = 96
                mem[64] = mem[64] + 128
                if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                    revert with 0, 50
                if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    revert with 0, 18
                if sha3(mem[_6853 + 32 len mem[_6853]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    if idx == -1:
                        revert with 0, 17
                    _6780 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = idx + 1
                    u = u
                    continue 
                if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                    revert with 0, 50
                if u >= mem[_5330]:
                    revert with 0, 50
                mem[(32 * u) + _5330 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                    revert with 0, 50
                if u >= mem[_5330 + (32 * s + t) + 32]:
                    revert with 0, 50
                mem[(32 * u) + _5330 + (32 * s + t) + 64] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                if u == -1:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _6780 = mem[mem[ceil32(return_data.size) + 160]]
                idx = idx + 1
                u = u + 1
                continue 
            idx = 0
            while idx < stor5.length:
                mem[0] = 5
                _8280 = mem[64]
                mem[64] = mem[64] + 64
                mem[_8280] = address(stor5[idx].field_0)
                mem[_8280 + 32] = address(stor5[idx].field_256)
                mem[0] = address(stor5[idx].field_0)
                mem[32] = sha3(arg1, 1) + 3
                if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                    _8340 = mem[64]
                    mem[mem[64]] = 0
                    mem[mem[64] + 32] = 0
                    mem[64] = mem[64] + 64
                    _9237 = mem[_8340]
                    v = 0
                    w = u
                    while v < _9237:
                        if v >= mem[_8340]:
                            revert with 0, 50
                        if w >= mem[_5330]:
                            revert with 0, 50
                        mem[(32 * w) + _5330 + 32] = mem[(32 * v) + _8340 + 32]
                        if v >= mem[_8340 + 32]:
                            revert with 0, 50
                        if w >= mem[_5330 + (32 * s + t) + 32]:
                            revert with 0, 50
                        mem[(32 * w) + _5330 + (32 * s + t) + 64] = mem[(32 * v) + _8340 + 64]
                        if w == -1:
                            revert with 0, 17
                        if v == -1:
                            revert with 0, 17
                        _9237 = mem[_8340]
                        v = v + 1
                        w = w + 1
                        continue 
                else:
                    mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = arg1
                    mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    require ext_code.size(address(stor5[idx].field_256))
                    staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                            gas gas_remaining wei
                           args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _8569 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 64
                    _8644 = mem[_8569]
                    require mem[_8569] <= test266151307()
                    require _8569 + mem[_8569] + 31 < _8569 + return_data.size
                    _8722 = mem[_8569 + mem[_8569]]
                    if mem[_8569 + mem[_8569]] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[_8569 + mem[_8569]]) + 1 < 0 or _8569 + ceil32(return_data.size) + ceil32(32 * mem[_8569 + mem[_8569]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = _8569 + ceil32(return_data.size) + ceil32(32 * mem[_8569 + mem[_8569]]) + 1
                    mem[_8569 + ceil32(return_data.size)] = _8722
                    require _8644 + (32 * _8722) + 32 <= return_data.size
                    v = 0
                    w = _8569 + _8644 + 32
                    x = _8569 + ceil32(return_data.size) + 32
                    while v < _8722:
                        mem[x] = mem[w]
                        v = v + 1
                        w = w + 32
                        x = x + 32
                        continue 
                    _9370 = mem[_8569 + 32]
                    require mem[_8569 + 32] <= test266151307()
                    require _8569 + mem[_8569 + 32] + 31 < _8569 + return_data.size
                    _9514 = mem[_8569 + mem[_8569 + 32]]
                    if mem[_8569 + mem[_8569 + 32]] > test266151307():
                        revert with 0, 65
                    _9596 = mem[64]
                    if mem[64] + ceil32(32 * mem[_8569 + mem[_8569 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_8569 + mem[_8569 + 32]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = mem[64] + ceil32(32 * mem[_8569 + mem[_8569 + 32]]) + 1
                    mem[_9596] = _9514
                    require _9370 + (32 * _9514) + 32 <= return_data.size
                    v = 0
                    w = _8569 + _9370 + 32
                    x = _9596 + 32
                    while v < _9514:
                        mem[x] = mem[w]
                        v = v + 1
                        w = w + 32
                        x = x + 32
                        continue 
                    _10301 = mem[_8569 + ceil32(return_data.size)]
                    v = 0
                    w = u
                    while v < _10301:
                        if v >= mem[_8569 + ceil32(return_data.size)]:
                            revert with 0, 50
                        if w >= mem[_5330]:
                            revert with 0, 50
                        mem[(32 * w) + _5330 + 32] = mem[(32 * v) + _8569 + ceil32(return_data.size) + 32]
                        if v >= mem[_9596]:
                            revert with 0, 50
                        if w >= mem[_5330 + (32 * s + t) + 32]:
                            revert with 0, 50
                        mem[(32 * w) + _5330 + (32 * s + t) + 64] = mem[(32 * v) + _9596 + 32]
                        if w == -1:
                            revert with 0, 17
                        if v == -1:
                            revert with 0, 17
                        _10301 = mem[_8569 + ceil32(return_data.size)]
                        v = v + 1
                        w = w + 1
                        continue 
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            if s > !t:
                revert with 0, 17
            if u != s + t:
                revert with 0, 1
            if 1 >= stor9.length:
                revert with 0, 50
            mem[0] = 9
            mem[mem[64]] = 0x15d2cfca00000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 64
            _8515 = mem[_5330]
            mem[mem[64] + 68] = mem[_5330]
            mem[mem[64] + 100 len 32 * _8515] = mem[_5330 + 32 len 32 * _8515]
            idx = _8515
            mem[mem[64] + 36] = arg1
            require ext_code.size(address(stor9.field_256))
            staticcall address(stor9.field_256).0x15d2cfca with:
                    gas gas_remaining wei
                   args 64, arg1, mem[mem[64] + 68 len (32 * _8515) + 32]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _9513 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _9564 = mem[_9513]
            require mem[_9513] <= test266151307()
            require _9513 + mem[_9513] + 31 < _9513 + return_data.size
            _9625 = mem[_9513 + mem[_9513]]
            if mem[_9513 + mem[_9513]] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[_9513 + mem[_9513]]) + 1 < 0 or _9513 + ceil32(return_data.size) + ceil32(32 * mem[_9513 + mem[_9513]]) + 1 > test266151307():
                revert with 0, 65
            mem[64] = _9513 + ceil32(return_data.size) + ceil32(32 * mem[_9513 + mem[_9513]]) + 1
            mem[_9513 + ceil32(return_data.size)] = _9625
            require _9564 + (32 * _9625) + 32 <= return_data.size
            mem[_9513 + ceil32(return_data.size) + 32 len 32 * _9625] = mem[_9513 + _9564 + 32 len 32 * _9625]
            mem[mem[64]] = 32
            mem[mem[64] + 32] = _9625
            mem[mem[64] + 64 len 32 * _9625] = mem[_9513 + ceil32(return_data.size) + 32 len 32 * _9625]
            var93001 = _9625
            var93002 = _9513 + ceil32(return_data.size) + (32 * _9625) + 32
            return Array(len=_9625, data=mem[mem[64] + 64 len 32 * _9625])
        mem[_5330 + (32 * s + t) + 64 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
        _6782 = mem[mem[ceil32(return_data.size) + 160]]
        idx = 0
        u = 0
        while idx < _6782:
            mem[0] = arg1
            mem[32] = 1
            mem[mem[64] + 32] = idx
            mem[mem[64] + 64] = stor1[arg1].field_512
            mem[mem[64] + 96] = stor8
            _6860 = mem[64]
            mem[mem[64]] = 96
            mem[64] = mem[64] + 128
            if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                revert with 0, 50
            if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                revert with 0, 18
            if sha3(mem[_6860 + 32 len mem[_6860]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                if idx == -1:
                    revert with 0, 17
                _6782 = mem[mem[ceil32(return_data.size) + 160]]
                idx = idx + 1
                u = u
                continue 
            if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                revert with 0, 50
            if u >= mem[_5330]:
                revert with 0, 50
            mem[(32 * u) + _5330 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
            if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                revert with 0, 50
            if u >= mem[_5330 + (32 * s + t) + 32]:
                revert with 0, 50
            mem[(32 * u) + _5330 + (32 * s + t) + 64] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
            if u == -1:
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            _6782 = mem[mem[ceil32(return_data.size) + 160]]
            idx = idx + 1
            u = u + 1
            continue 
        idx = 0
        while idx < stor5.length:
            mem[0] = 5
            _8285 = mem[64]
            mem[64] = mem[64] + 64
            mem[_8285] = address(stor5[idx].field_0)
            mem[_8285 + 32] = address(stor5[idx].field_256)
            mem[0] = address(stor5[idx].field_0)
            mem[32] = sha3(arg1, 1) + 3
            if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                _8341 = mem[64]
                mem[mem[64]] = 0
                mem[mem[64] + 32] = 0
                mem[64] = mem[64] + 64
                _9238 = mem[_8341]
                v = 0
                w = u
                while v < _9238:
                    if v >= mem[_8341]:
                        revert with 0, 50
                    if w >= mem[_5330]:
                        revert with 0, 50
                    mem[(32 * w) + _5330 + 32] = mem[(32 * v) + _8341 + 32]
                    if v >= mem[_8341 + 32]:
                        revert with 0, 50
                    if w >= mem[_5330 + (32 * s + t) + 32]:
                        revert with 0, 50
                    mem[(32 * w) + _5330 + (32 * s + t) + 64] = mem[(32 * v) + _8341 + 64]
                    if w == -1:
                        revert with 0, 17
                    if v == -1:
                        revert with 0, 17
                    _9238 = mem[_8341]
                    v = v + 1
                    w = w + 1
                    continue 
            else:
                mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = arg1
                mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                require ext_code.size(address(stor5[idx].field_256))
                staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                        gas gas_remaining wei
                       args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _8572 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 64
                _8647 = mem[_8572]
                require mem[_8572] <= test266151307()
                require _8572 + mem[_8572] + 31 < _8572 + return_data.size
                _8724 = mem[_8572 + mem[_8572]]
                if mem[_8572 + mem[_8572]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_8572 + mem[_8572]]) + 1 < 0 or _8572 + ceil32(return_data.size) + ceil32(32 * mem[_8572 + mem[_8572]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _8572 + ceil32(return_data.size) + ceil32(32 * mem[_8572 + mem[_8572]]) + 1
                mem[_8572 + ceil32(return_data.size)] = _8724
                require _8647 + (32 * _8724) + 32 <= return_data.size
                v = 0
                w = _8572 + _8647 + 32
                x = _8572 + ceil32(return_data.size) + 32
                while v < _8724:
                    mem[x] = mem[w]
                    v = v + 1
                    w = w + 32
                    x = x + 32
                    continue 
                _9373 = mem[_8572 + 32]
                require mem[_8572 + 32] <= test266151307()
                require _8572 + mem[_8572 + 32] + 31 < _8572 + return_data.size
                _9516 = mem[_8572 + mem[_8572 + 32]]
                if mem[_8572 + mem[_8572 + 32]] > test266151307():
                    revert with 0, 65
                _9597 = mem[64]
                if mem[64] + ceil32(32 * mem[_8572 + mem[_8572 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_8572 + mem[_8572 + 32]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = mem[64] + ceil32(32 * mem[_8572 + mem[_8572 + 32]]) + 1
                mem[_9597] = _9516
                require _9373 + (32 * _9516) + 32 <= return_data.size
                v = 0
                w = _8572 + _9373 + 32
                x = _9597 + 32
                while v < _9516:
                    mem[x] = mem[w]
                    v = v + 1
                    w = w + 32
                    x = x + 32
                    continue 
                _10302 = mem[_8572 + ceil32(return_data.size)]
                v = 0
                w = u
                while v < _10302:
                    if v >= mem[_8572 + ceil32(return_data.size)]:
                        revert with 0, 50
                    if w >= mem[_5330]:
                        revert with 0, 50
                    mem[(32 * w) + _5330 + 32] = mem[(32 * v) + _8572 + ceil32(return_data.size) + 32]
                    if v >= mem[_9597]:
                        revert with 0, 50
                    if w >= mem[_5330 + (32 * s + t) + 32]:
                        revert with 0, 50
                    mem[(32 * w) + _5330 + (32 * s + t) + 64] = mem[(32 * v) + _9597 + 32]
                    if w == -1:
                        revert with 0, 17
                    if v == -1:
                        revert with 0, 17
                    _10302 = mem[_8572 + ceil32(return_data.size)]
                    v = v + 1
                    w = w + 1
                    continue 
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        if s > !t:
            revert with 0, 17
        if u != s + t:
            revert with 0, 1
        if 1 >= stor9.length:
            revert with 0, 50
        mem[0] = 9
        mem[mem[64]] = 0x15d2cfca00000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = 64
        _8517 = mem[_5330]
        mem[mem[64] + 68] = mem[_5330]
        mem[mem[64] + 100 len 32 * _8517] = mem[_5330 + 32 len 32 * _8517]
        idx = _8517
        var67002 = _5330 + (32 * _8517) + 32
        mem[mem[64] + 36] = arg1
        require ext_code.size(address(stor9.field_256))
        staticcall address(stor9.field_256).0x15d2cfca with:
                gas gas_remaining wei
               args 64, arg1, mem[mem[64] + 68 len (32 * _8517) + 32]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _9515 = mem[64]
        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _9565 = mem[_9515]
        require mem[_9515] <= test266151307()
        require _9515 + mem[_9515] + 31 < _9515 + return_data.size
        _9626 = mem[_9515 + mem[_9515]]
        if mem[_9515 + mem[_9515]] > test266151307():
            revert with 0, 65
        if ceil32(32 * mem[_9515 + mem[_9515]]) + 1 < 0 or _9515 + ceil32(return_data.size) + ceil32(32 * mem[_9515 + mem[_9515]]) + 1 > test266151307():
            revert with 0, 65
        mem[64] = _9515 + ceil32(return_data.size) + ceil32(32 * mem[_9515 + mem[_9515]]) + 1
        mem[_9515 + ceil32(return_data.size)] = _9626
        require _9565 + (32 * _9626) + 32 <= return_data.size
        mem[_9515 + ceil32(return_data.size) + 32 len 32 * _9626] = mem[_9515 + _9565 + 32 len 32 * _9626]
        mem[mem[64]] = 32
        mem[mem[64] + 32] = _9626
        mem[mem[64] + 64 len 32 * _9626] = mem[_9515 + ceil32(return_data.size) + 32 len 32 * _9626]
        var94001 = _9626
        var94002 = _9515 + ceil32(return_data.size) + (32 * _9626) + 32
        return Array(len=_9626, data=mem[mem[64] + 64 len 32 * _9626])
    mem[0] = sha3(ext_call.return_data[31 len 1], 10)
    mem[ceil32(return_data.size) + 224] = stor10[ext_call.return_data[31 len 1]].field_0
    idx = ceil32(return_data.size) + 224
    s = 0
    while ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + 192 > idx:
        mem[idx + 32] = stor10[ext_call.return_data[31 len 1]][s].field_256
        idx = idx + 32
        s = s + 1
        continue 
    mem[ceil32(return_data.size) + 96] = ceil32(return_data.size) + 192
    mem[ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + 224] = stor10[ext_call.return_data[31 len 1]].field_256
    if not stor10[ext_call.return_data[31 len 1]].field_256:
        mem[ceil32(return_data.size) + 128] = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + 224
        mem[64] = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + (32 * stor10[ext_call.return_data[31 len 1]].field_512) + 288
        mem[ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 256] = stor10[ext_call.return_data[31 len 1]].field_512
        if not stor10[ext_call.return_data[31 len 1]].field_512:
            mem[ceil32(return_data.size) + 160] = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 256
            idx = 0
            s = 0
            while idx < stor10[ext_call.return_data[31 len 1]].field_512:
                mem[0] = arg1
                mem[32] = 1
                mem[mem[64] + 32] = idx
                mem[mem[64] + 64] = stor1[arg1].field_512
                mem[mem[64] + 96] = stor8
                _1062 = mem[64]
                mem[mem[64]] = 96
                mem[64] = mem[64] + 128
                if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                    revert with 0, 50
                if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    revert with 0, 18
                if sha3(mem[_1062 + 32 len mem[_1062]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s
                    continue 
                if s == -1:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s + 1
                continue 
            idx = 0
            t = 0
            while idx < stor5.length:
                mem[0] = 5
                _2197 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2197] = address(stor5[idx].field_0)
                mem[_2197 + 32] = address(stor5[idx].field_256)
                mem[0] = address(stor5[idx].field_0)
                mem[32] = sha3(arg1, 1) + 3
                if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                    _2212 = mem[64]
                    mem[mem[64]] = 0
                    mem[mem[64] + 32] = 0
                    mem[64] = mem[64] + 64
                    if t > !mem[_2212]:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    t = t + mem[_2212]
                    continue 
                mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = arg1
                mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                require ext_code.size(address(stor5[idx].field_256))
                staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                        gas gas_remaining wei
                       args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _2296 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 64
                _2336 = mem[_2296]
                require mem[_2296] <= test266151307()
                require _2296 + mem[_2296] + 31 < _2296 + return_data.size
                _2474 = mem[_2296 + mem[_2296]]
                if mem[_2296 + mem[_2296]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_2296 + mem[_2296]]) + 1 < 0 or _2296 + ceil32(return_data.size) + ceil32(32 * mem[_2296 + mem[_2296]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _2296 + ceil32(return_data.size) + ceil32(32 * mem[_2296 + mem[_2296]]) + 1
                mem[_2296 + ceil32(return_data.size)] = _2474
                require _2336 + (32 * _2474) + 32 <= return_data.size
                s = 0
                u = _2296 + _2336 + 32
                v = _2296 + ceil32(return_data.size) + 32
                while s < _2474:
                    mem[v] = mem[u]
                    s = s + 1
                    u = u + 32
                    v = v + 32
                    continue 
                _3628 = mem[_2296 + 32]
                require mem[_2296 + 32] <= test266151307()
                require _2296 + mem[_2296 + 32] + 31 < _2296 + return_data.size
                _3657 = mem[_2296 + mem[_2296 + 32]]
                if mem[_2296 + mem[_2296 + 32]] > test266151307():
                    revert with 0, 65
                _3882 = mem[64]
                if mem[64] + ceil32(32 * mem[_2296 + mem[_2296 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_2296 + mem[_2296 + 32]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = mem[64] + ceil32(32 * mem[_2296 + mem[_2296 + 32]]) + 1
                mem[_3882] = _3657
                require _3628 + (32 * _3657) + 32 <= return_data.size
                s = 0
                u = _2296 + _3628 + 32
                v = _3882 + 32
                while s < _3657:
                    mem[v] = mem[u]
                    s = s + 1
                    u = u + 32
                    v = v + 32
                    continue 
                if t > !mem[_2296 + ceil32(return_data.size)]:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                t = t + mem[_2296 + ceil32(return_data.size)]
                continue 
            if s > !t:
                revert with 0, 17
            if s + t > test266151307():
                revert with 0, 65
            _2211 = mem[64]
            mem[mem[64]] = s + t
            if not s + t:
                if s > !t:
                    revert with 0, 17
                if s + t > test266151307():
                    revert with 0, 65
                _2295 = mem[64] + (32 * s + t) + 32
                mem[mem[64] + (32 * s + t) + 32] = s + t
                mem[64] = _2295 + (32 * s + t) + 32
                if s + t:
                    mem[_2295 + 32 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
                    _3472 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = 0
                    u = 0
                    while idx < _3472:
                        mem[0] = arg1
                        mem[32] = 1
                        mem[mem[64] + 32] = idx
                        mem[mem[64] + 64] = stor1[arg1].field_512
                        mem[mem[64] + 96] = stor8
                        _3567 = mem[64]
                        mem[mem[64]] = 96
                        mem[64] = mem[64] + 128
                        if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                            revert with 0, 50
                        if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                            revert with 0, 18
                        if sha3(mem[_3567 + 32 len mem[_3567]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                            if idx == -1:
                                revert with 0, 17
                            _3472 = mem[mem[ceil32(return_data.size) + 160]]
                            idx = idx + 1
                            u = u
                            continue 
                        if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                            revert with 0, 50
                        if u >= mem[_2211]:
                            revert with 0, 50
                        mem[(32 * u) + _2211 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                        if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                            revert with 0, 50
                        if u >= mem[_2295]:
                            revert with 0, 50
                        mem[(32 * u) + _2295 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                        if u == -1:
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        _3472 = mem[mem[ceil32(return_data.size) + 160]]
                        idx = idx + 1
                        u = u + 1
                        continue 
                    idx = 0
                    while idx < stor5.length:
                        mem[0] = 5
                        _5296 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5296] = address(stor5[idx].field_0)
                        mem[_5296 + 32] = address(stor5[idx].field_256)
                        mem[0] = address(stor5[idx].field_0)
                        mem[32] = sha3(arg1, 1) + 3
                        if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                            _5333 = mem[64]
                            mem[mem[64]] = 0
                            mem[mem[64] + 32] = 0
                            mem[64] = mem[64] + 64
                            _6784 = mem[_5333]
                            s = 0
                            t = u
                            while s < _6784:
                                if s >= mem[_5333]:
                                    revert with 0, 50
                                if t >= mem[_2211]:
                                    revert with 0, 50
                                mem[(32 * t) + _2211 + 32] = mem[(32 * s) + _5333 + 32]
                                if s >= mem[_5333 + 32]:
                                    revert with 0, 50
                                if t >= mem[_2295]:
                                    revert with 0, 50
                                mem[(32 * t) + _2295 + 32] = mem[(32 * s) + _5333 + 64]
                                if t == -1:
                                    revert with 0, 17
                                if s == -1:
                                    revert with 0, 17
                                _6784 = mem[_5333]
                                s = s + 1
                                t = t + 1
                                continue 
                        else:
                            mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = arg1
                            mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                            require ext_code.size(address(stor5[idx].field_256))
                            staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                                    gas gas_remaining wei
                                   args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _5525 = mem[64]
                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 64
                            _5599 = mem[_5525]
                            require mem[_5525] <= test266151307()
                            require _5525 + mem[_5525] + 31 < _5525 + return_data.size
                            _5741 = mem[_5525 + mem[_5525]]
                            if mem[_5525 + mem[_5525]] > test266151307():
                                revert with 0, 65
                            if ceil32(32 * mem[_5525 + mem[_5525]]) + 1 < 0 or _5525 + ceil32(return_data.size) + ceil32(32 * mem[_5525 + mem[_5525]]) + 1 > test266151307():
                                revert with 0, 65
                            mem[64] = _5525 + ceil32(return_data.size) + ceil32(32 * mem[_5525 + mem[_5525]]) + 1
                            mem[_5525 + ceil32(return_data.size)] = _5741
                            require _5599 + (32 * _5741) + 32 <= return_data.size
                            s = 0
                            t = _5525 + _5599 + 32
                            v = _5525 + ceil32(return_data.size) + 32
                            while s < _5741:
                                mem[v] = mem[t]
                                s = s + 1
                                t = t + 32
                                v = v + 32
                                continue 
                            _6983 = mem[_5525 + 32]
                            require mem[_5525 + 32] <= test266151307()
                            require _5525 + mem[_5525 + 32] + 31 < _5525 + return_data.size
                            _7087 = mem[_5525 + mem[_5525 + 32]]
                            if mem[_5525 + mem[_5525 + 32]] > test266151307():
                                revert with 0, 65
                            _7283 = mem[64]
                            if mem[64] + ceil32(32 * mem[_5525 + mem[_5525 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_5525 + mem[_5525 + 32]]) + 1 > test266151307():
                                revert with 0, 65
                            mem[64] = mem[64] + ceil32(32 * mem[_5525 + mem[_5525 + 32]]) + 1
                            mem[_7283] = _7087
                            require _6983 + (32 * _7087) + 32 <= return_data.size
                            s = 0
                            t = _5525 + _6983 + 32
                            v = _7283 + 32
                            while s < _7087:
                                mem[v] = mem[t]
                                s = s + 1
                                t = t + 32
                                v = v + 32
                                continue 
                            _9240 = mem[_5525 + ceil32(return_data.size)]
                            s = 0
                            t = u
                            while s < _9240:
                                if s >= mem[_5525 + ceil32(return_data.size)]:
                                    revert with 0, 50
                                if t >= mem[_2211]:
                                    revert with 0, 50
                                mem[(32 * t) + _2211 + 32] = mem[(32 * s) + _5525 + ceil32(return_data.size) + 32]
                                if s >= mem[_7283]:
                                    revert with 0, 50
                                if t >= mem[_2295]:
                                    revert with 0, 50
                                mem[(32 * t) + _2295 + 32] = mem[(32 * s) + _7283 + 32]
                                if t == -1:
                                    revert with 0, 17
                                if s == -1:
                                    revert with 0, 17
                                _9240 = mem[_5525 + ceil32(return_data.size)]
                                s = s + 1
                                t = t + 1
                                continue 
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
                    if s > !t:
                        revert with 0, 17
                    if u != s + t:
                        revert with 0, 1
                    if 1 >= stor9.length:
                        revert with 0, 50
                    mem[0] = 9
                    mem[mem[64]] = 0x15d2cfca00000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 64
                    _5478 = mem[_2211]
                    mem[mem[64] + 68] = mem[_2211]
                    mem[mem[64] + 100 len 32 * _5478] = mem[_2211 + 32 len 32 * _5478]
                    idx = _5478
                    var62002 = _2211 + (32 * _5478) + 32
                    mem[mem[64] + 36] = arg1
                    require ext_code.size(address(stor9.field_256))
                    staticcall address(stor9.field_256).0x15d2cfca with:
                            gas gas_remaining wei
                           args 64, arg1, mem[mem[64] + 68 len (32 * _5478) + 32]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _7086 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _7204 = mem[_7086]
                    require mem[_7086] <= test266151307()
                    require _7086 + mem[_7086] + 31 < _7086 + return_data.size
                    _7346 = mem[_7086 + mem[_7086]]
                    if mem[_7086 + mem[_7086]] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[_7086 + mem[_7086]]) + 1 < 0 or _7086 + ceil32(return_data.size) + ceil32(32 * mem[_7086 + mem[_7086]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = _7086 + ceil32(return_data.size) + ceil32(32 * mem[_7086 + mem[_7086]]) + 1
                    mem[_7086 + ceil32(return_data.size)] = _7346
                    require _7204 + (32 * _7346) + 32 <= return_data.size
                    mem[_7086 + ceil32(return_data.size) + 32 len 32 * _7346] = mem[_7086 + _7204 + 32 len 32 * _7346]
                    mem[mem[64]] = 32
                    mem[mem[64] + 32] = _7346
                    mem[mem[64] + 64 len 32 * _7346] = mem[_7086 + ceil32(return_data.size) + 32 len 32 * _7346]
                    var89001 = _7346
                    var89002 = _7086 + ceil32(return_data.size) + (32 * _7346) + 32
                    return Array(len=_7346, data=mem[mem[64] + 64 len 32 * _7346])
                _3470 = mem[mem[ceil32(return_data.size) + 160]]
                idx = 0
                u = 0
                while idx < _3470:
                    mem[0] = arg1
                    mem[32] = 1
                    mem[mem[64] + 32] = idx
                    mem[mem[64] + 64] = stor1[arg1].field_512
                    mem[mem[64] + 96] = stor8
                    _3560 = mem[64]
                    mem[mem[64]] = 96
                    mem[64] = mem[64] + 128
                    if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                        revert with 0, 50
                    if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        revert with 0, 18
                    if sha3(mem[_3560 + 32 len mem[_3560]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        if idx == -1:
                            revert with 0, 17
                        _3470 = mem[mem[ceil32(return_data.size) + 160]]
                        idx = idx + 1
                        u = u
                        continue 
                    if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                        revert with 0, 50
                    if u >= mem[_2211]:
                        revert with 0, 50
                    mem[(32 * u) + _2211 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                    if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                        revert with 0, 50
                    if u >= mem[_2295]:
                        revert with 0, 50
                    mem[(32 * u) + _2295 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                    if u == -1:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _3470 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = idx + 1
                    u = u + 1
                    continue 
                idx = 0
                while idx < stor5.length:
                    mem[0] = 5
                    _5291 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5291] = address(stor5[idx].field_0)
                    mem[_5291 + 32] = address(stor5[idx].field_256)
                    mem[0] = address(stor5[idx].field_0)
                    mem[32] = sha3(arg1, 1) + 3
                    if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                        _5332 = mem[64]
                        mem[mem[64]] = 0
                        mem[mem[64] + 32] = 0
                        mem[64] = mem[64] + 64
                        _6783 = mem[_5332]
                        s = 0
                        t = u
                        while s < _6783:
                            if s >= mem[_5332]:
                                revert with 0, 50
                            if t >= mem[_2211]:
                                revert with 0, 50
                            mem[(32 * t) + _2211 + 32] = mem[(32 * s) + _5332 + 32]
                            if s >= mem[_5332 + 32]:
                                revert with 0, 50
                            if t >= mem[_2295]:
                                revert with 0, 50
                            mem[(32 * t) + _2295 + 32] = mem[(32 * s) + _5332 + 64]
                            if t == -1:
                                revert with 0, 17
                            if s == -1:
                                revert with 0, 17
                            _6783 = mem[_5332]
                            s = s + 1
                            t = t + 1
                            continue 
                    else:
                        mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = arg1
                        mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                        require ext_code.size(address(stor5[idx].field_256))
                        staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                                gas gas_remaining wei
                               args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _5522 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 64
                        _5596 = mem[_5522]
                        require mem[_5522] <= test266151307()
                        require _5522 + mem[_5522] + 31 < _5522 + return_data.size
                        _5739 = mem[_5522 + mem[_5522]]
                        if mem[_5522 + mem[_5522]] > test266151307():
                            revert with 0, 65
                        if ceil32(32 * mem[_5522 + mem[_5522]]) + 1 < 0 or _5522 + ceil32(return_data.size) + ceil32(32 * mem[_5522 + mem[_5522]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = _5522 + ceil32(return_data.size) + ceil32(32 * mem[_5522 + mem[_5522]]) + 1
                        mem[_5522 + ceil32(return_data.size)] = _5739
                        require _5596 + (32 * _5739) + 32 <= return_data.size
                        s = 0
                        t = _5522 + _5596 + 32
                        v = _5522 + ceil32(return_data.size) + 32
                        while s < _5739:
                            mem[v] = mem[t]
                            s = s + 1
                            t = t + 32
                            v = v + 32
                            continue 
                        _6980 = mem[_5522 + 32]
                        require mem[_5522 + 32] <= test266151307()
                        require _5522 + mem[_5522 + 32] + 31 < _5522 + return_data.size
                        _7085 = mem[_5522 + mem[_5522 + 32]]
                        if mem[_5522 + mem[_5522 + 32]] > test266151307():
                            revert with 0, 65
                        _7282 = mem[64]
                        if mem[64] + ceil32(32 * mem[_5522 + mem[_5522 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_5522 + mem[_5522 + 32]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = mem[64] + ceil32(32 * mem[_5522 + mem[_5522 + 32]]) + 1
                        mem[_7282] = _7085
                        require _6980 + (32 * _7085) + 32 <= return_data.size
                        s = 0
                        t = _5522 + _6980 + 32
                        v = _7282 + 32
                        while s < _7085:
                            mem[v] = mem[t]
                            s = s + 1
                            t = t + 32
                            v = v + 32
                            continue 
                        _9239 = mem[_5522 + ceil32(return_data.size)]
                        s = 0
                        t = u
                        while s < _9239:
                            if s >= mem[_5522 + ceil32(return_data.size)]:
                                revert with 0, 50
                            if t >= mem[_2211]:
                                revert with 0, 50
                            mem[(32 * t) + _2211 + 32] = mem[(32 * s) + _5522 + ceil32(return_data.size) + 32]
                            if s >= mem[_7282]:
                                revert with 0, 50
                            if t >= mem[_2295]:
                                revert with 0, 50
                            mem[(32 * t) + _2295 + 32] = mem[(32 * s) + _7282 + 32]
                            if t == -1:
                                revert with 0, 17
                            if s == -1:
                                revert with 0, 17
                            _9239 = mem[_5522 + ceil32(return_data.size)]
                            s = s + 1
                            t = t + 1
                            continue 
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                if s > !t:
                    revert with 0, 17
                if u != s + t:
                    revert with 0, 1
                if 1 >= stor9.length:
                    revert with 0, 50
                mem[0] = 9
                mem[mem[64]] = 0x15d2cfca00000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 64
                _5476 = mem[_2211]
                mem[mem[64] + 68] = mem[_2211]
                mem[mem[64] + 100 len 32 * _5476] = mem[_2211 + 32 len 32 * _5476]
                idx = _5476
                mem[mem[64] + 36] = arg1
                require ext_code.size(address(stor9.field_256))
                staticcall address(stor9.field_256).0x15d2cfca with:
                        gas gas_remaining wei
                       args 64, arg1, mem[mem[64] + 68 len (32 * _5476) + 32]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _7084 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _7203 = mem[_7084]
                require mem[_7084] <= test266151307()
                require _7084 + mem[_7084] + 31 < _7084 + return_data.size
                _7345 = mem[_7084 + mem[_7084]]
                if mem[_7084 + mem[_7084]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_7084 + mem[_7084]]) + 1 < 0 or _7084 + ceil32(return_data.size) + ceil32(32 * mem[_7084 + mem[_7084]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _7084 + ceil32(return_data.size) + ceil32(32 * mem[_7084 + mem[_7084]]) + 1
                mem[_7084 + ceil32(return_data.size)] = _7345
                require _7203 + (32 * _7345) + 32 <= return_data.size
                mem[_7084 + ceil32(return_data.size) + 32 len 32 * _7345] = mem[_7084 + _7203 + 32 len 32 * _7345]
                var80001 = _7345
                var80002 = _7084 + _7203 + (32 * _7345) + 32
                var80004 = _7084 + ceil32(return_data.size) + (32 * _7345) + 32
                mem[mem[64]] = 32
                mem[mem[64] + 32] = _7345
                mem[mem[64] + 64 len 32 * _7345] = mem[_7084 + ceil32(return_data.size) + 32 len 32 * _7345]
                var88001 = _7345
                var88002 = _7084 + ceil32(return_data.size) + (32 * _7345) + 32
                return Array(len=_7345, data=mem[mem[64] + 64 len 32 * _7345])
            mem[mem[64] + 32 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
            if s > !t:
                revert with 0, 17
            if s + t > test266151307():
                revert with 0, 65
            mem[mem[64] + (32 * s + t) + 32] = s + t
            mem[64] = _2211 + (64 * s + t) + 64
            if not s + t:
                _3474 = mem[mem[ceil32(return_data.size) + 160]]
                idx = 0
                u = 0
                while idx < _3474:
                    mem[0] = arg1
                    mem[32] = 1
                    mem[mem[64] + 32] = idx
                    mem[mem[64] + 64] = stor1[arg1].field_512
                    mem[mem[64] + 96] = stor8
                    _3574 = mem[64]
                    mem[mem[64]] = 96
                    mem[64] = mem[64] + 128
                    if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                        revert with 0, 50
                    if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        revert with 0, 18
                    if sha3(mem[_3574 + 32 len mem[_3574]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        if idx == -1:
                            revert with 0, 17
                        _3474 = mem[mem[ceil32(return_data.size) + 160]]
                        idx = idx + 1
                        u = u
                        continue 
                    if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                        revert with 0, 50
                    if u >= mem[_2211]:
                        revert with 0, 50
                    mem[(32 * u) + _2211 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                    if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                        revert with 0, 50
                    if u >= mem[_2211 + (32 * s + t) + 32]:
                        revert with 0, 50
                    mem[(32 * u) + _2211 + (32 * s + t) + 64] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                    if u == -1:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _3474 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = idx + 1
                    u = u + 1
                    continue 
                idx = 0
                while idx < stor5.length:
                    mem[0] = 5
                    _5301 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5301] = address(stor5[idx].field_0)
                    mem[_5301 + 32] = address(stor5[idx].field_256)
                    mem[0] = address(stor5[idx].field_0)
                    mem[32] = sha3(arg1, 1) + 3
                    if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                        _5334 = mem[64]
                        mem[mem[64]] = 0
                        mem[mem[64] + 32] = 0
                        mem[64] = mem[64] + 64
                        _6785 = mem[_5334]
                        v = 0
                        w = u
                        while v < _6785:
                            if v >= mem[_5334]:
                                revert with 0, 50
                            if w >= mem[_2211]:
                                revert with 0, 50
                            mem[(32 * w) + _2211 + 32] = mem[(32 * v) + _5334 + 32]
                            if v >= mem[_5334 + 32]:
                                revert with 0, 50
                            if w >= mem[_2211 + (32 * s + t) + 32]:
                                revert with 0, 50
                            mem[(32 * w) + _2211 + (32 * s + t) + 64] = mem[(32 * v) + _5334 + 64]
                            if w == -1:
                                revert with 0, 17
                            if v == -1:
                                revert with 0, 17
                            _6785 = mem[_5334]
                            v = v + 1
                            w = w + 1
                            continue 
                    else:
                        mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = arg1
                        mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                        require ext_code.size(address(stor5[idx].field_256))
                        staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                                gas gas_remaining wei
                               args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _5528 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 64
                        _5602 = mem[_5528]
                        require mem[_5528] <= test266151307()
                        require _5528 + mem[_5528] + 31 < _5528 + return_data.size
                        _5743 = mem[_5528 + mem[_5528]]
                        if mem[_5528 + mem[_5528]] > test266151307():
                            revert with 0, 65
                        if ceil32(32 * mem[_5528 + mem[_5528]]) + 1 < 0 or _5528 + ceil32(return_data.size) + ceil32(32 * mem[_5528 + mem[_5528]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = _5528 + ceil32(return_data.size) + ceil32(32 * mem[_5528 + mem[_5528]]) + 1
                        mem[_5528 + ceil32(return_data.size)] = _5743
                        require _5602 + (32 * _5743) + 32 <= return_data.size
                        v = 0
                        w = _5528 + _5602 + 32
                        x = _5528 + ceil32(return_data.size) + 32
                        while v < _5743:
                            mem[x] = mem[w]
                            v = v + 1
                            w = w + 32
                            x = x + 32
                            continue 
                        _6986 = mem[_5528 + 32]
                        require mem[_5528 + 32] <= test266151307()
                        require _5528 + mem[_5528 + 32] + 31 < _5528 + return_data.size
                        _7089 = mem[_5528 + mem[_5528 + 32]]
                        if mem[_5528 + mem[_5528 + 32]] > test266151307():
                            revert with 0, 65
                        _7284 = mem[64]
                        if mem[64] + ceil32(32 * mem[_5528 + mem[_5528 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_5528 + mem[_5528 + 32]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = mem[64] + ceil32(32 * mem[_5528 + mem[_5528 + 32]]) + 1
                        mem[_7284] = _7089
                        require _6986 + (32 * _7089) + 32 <= return_data.size
                        v = 0
                        w = _5528 + _6986 + 32
                        x = _7284 + 32
                        while v < _7089:
                            mem[x] = mem[w]
                            v = v + 1
                            w = w + 32
                            x = x + 32
                            continue 
                        _9241 = mem[_5528 + ceil32(return_data.size)]
                        v = 0
                        w = u
                        while v < _9241:
                            if v >= mem[_5528 + ceil32(return_data.size)]:
                                revert with 0, 50
                            if w >= mem[_2211]:
                                revert with 0, 50
                            mem[(32 * w) + _2211 + 32] = mem[(32 * v) + _5528 + ceil32(return_data.size) + 32]
                            if v >= mem[_7284]:
                                revert with 0, 50
                            if w >= mem[_2211 + (32 * s + t) + 32]:
                                revert with 0, 50
                            mem[(32 * w) + _2211 + (32 * s + t) + 64] = mem[(32 * v) + _7284 + 32]
                            if w == -1:
                                revert with 0, 17
                            if v == -1:
                                revert with 0, 17
                            _9241 = mem[_5528 + ceil32(return_data.size)]
                            v = v + 1
                            w = w + 1
                            continue 
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                if s > !t:
                    revert with 0, 17
                if u != s + t:
                    revert with 0, 1
                if 1 >= stor9.length:
                    revert with 0, 50
                mem[0] = 9
                mem[mem[64]] = 0x15d2cfca00000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 64
                _5480 = mem[_2211]
                mem[mem[64] + 68] = mem[_2211]
                mem[mem[64] + 100 len 32 * _5480] = mem[_2211 + 32 len 32 * _5480]
                idx = _5480
                var62002 = _2211 + (32 * _5480) + 32
                mem[mem[64] + 36] = arg1
                require ext_code.size(address(stor9.field_256))
                staticcall address(stor9.field_256).0x15d2cfca with:
                        gas gas_remaining wei
                       args 64, arg1, mem[mem[64] + 68 len (32 * _5480) + 32]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _7088 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _7205 = mem[_7088]
                require mem[_7088] <= test266151307()
                require _7088 + mem[_7088] + 31 < _7088 + return_data.size
                _7347 = mem[_7088 + mem[_7088]]
                if mem[_7088 + mem[_7088]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_7088 + mem[_7088]]) + 1 < 0 or _7088 + ceil32(return_data.size) + ceil32(32 * mem[_7088 + mem[_7088]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _7088 + ceil32(return_data.size) + ceil32(32 * mem[_7088 + mem[_7088]]) + 1
                mem[_7088 + ceil32(return_data.size)] = _7347
                require _7205 + (32 * _7347) + 32 <= return_data.size
                mem[_7088 + ceil32(return_data.size) + 32 len 32 * _7347] = mem[_7088 + _7205 + 32 len 32 * _7347]
                mem[mem[64]] = 32
                mem[mem[64] + 32] = _7347
                mem[mem[64] + 64 len 32 * _7347] = mem[_7088 + ceil32(return_data.size) + 32 len 32 * _7347]
                var89001 = _7347
                var89002 = _7088 + ceil32(return_data.size) + (32 * _7347) + 32
                return Array(len=_7347, data=mem[mem[64] + 64 len 32 * _7347])
            mem[_2211 + (32 * s + t) + 64 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
            _3476 = mem[mem[ceil32(return_data.size) + 160]]
            idx = 0
            u = 0
            while idx < _3476:
                mem[0] = arg1
                mem[32] = 1
                mem[mem[64] + 32] = idx
                mem[mem[64] + 64] = stor1[arg1].field_512
                mem[mem[64] + 96] = stor8
                _3581 = mem[64]
                mem[mem[64]] = 96
                mem[64] = mem[64] + 128
                if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                    revert with 0, 50
                if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    revert with 0, 18
                if sha3(mem[_3581 + 32 len mem[_3581]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    if idx == -1:
                        revert with 0, 17
                    _3476 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = idx + 1
                    u = u
                    continue 
                if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                    revert with 0, 50
                if u >= mem[_2211]:
                    revert with 0, 50
                mem[(32 * u) + _2211 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                    revert with 0, 50
                if u >= mem[_2211 + (32 * s + t) + 32]:
                    revert with 0, 50
                mem[(32 * u) + _2211 + (32 * s + t) + 64] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                if u == -1:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _3476 = mem[mem[ceil32(return_data.size) + 160]]
                idx = idx + 1
                u = u + 1
                continue 
            idx = 0
            while idx < stor5.length:
                mem[0] = 5
                _5306 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5306] = address(stor5[idx].field_0)
                mem[_5306 + 32] = address(stor5[idx].field_256)
                mem[0] = address(stor5[idx].field_0)
                mem[32] = sha3(arg1, 1) + 3
                if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                    _5335 = mem[64]
                    mem[mem[64]] = 0
                    mem[mem[64] + 32] = 0
                    mem[64] = mem[64] + 64
                    _6786 = mem[_5335]
                    v = 0
                    w = u
                    while v < _6786:
                        if v >= mem[_5335]:
                            revert with 0, 50
                        if w >= mem[_2211]:
                            revert with 0, 50
                        mem[(32 * w) + _2211 + 32] = mem[(32 * v) + _5335 + 32]
                        if v >= mem[_5335 + 32]:
                            revert with 0, 50
                        if w >= mem[_2211 + (32 * s + t) + 32]:
                            revert with 0, 50
                        mem[(32 * w) + _2211 + (32 * s + t) + 64] = mem[(32 * v) + _5335 + 64]
                        if w == -1:
                            revert with 0, 17
                        if v == -1:
                            revert with 0, 17
                        _6786 = mem[_5335]
                        v = v + 1
                        w = w + 1
                        continue 
                else:
                    mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = arg1
                    mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    require ext_code.size(address(stor5[idx].field_256))
                    staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                            gas gas_remaining wei
                           args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _5531 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 64
                    _5605 = mem[_5531]
                    require mem[_5531] <= test266151307()
                    require _5531 + mem[_5531] + 31 < _5531 + return_data.size
                    _5745 = mem[_5531 + mem[_5531]]
                    if mem[_5531 + mem[_5531]] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[_5531 + mem[_5531]]) + 1 < 0 or _5531 + ceil32(return_data.size) + ceil32(32 * mem[_5531 + mem[_5531]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = _5531 + ceil32(return_data.size) + ceil32(32 * mem[_5531 + mem[_5531]]) + 1
                    mem[_5531 + ceil32(return_data.size)] = _5745
                    require _5605 + (32 * _5745) + 32 <= return_data.size
                    v = 0
                    w = _5531 + _5605 + 32
                    x = _5531 + ceil32(return_data.size) + 32
                    while v < _5745:
                        mem[x] = mem[w]
                        v = v + 1
                        w = w + 32
                        x = x + 32
                        continue 
                    _6989 = mem[_5531 + 32]
                    require mem[_5531 + 32] <= test266151307()
                    require _5531 + mem[_5531 + 32] + 31 < _5531 + return_data.size
                    _7091 = mem[_5531 + mem[_5531 + 32]]
                    if mem[_5531 + mem[_5531 + 32]] > test266151307():
                        revert with 0, 65
                    _7285 = mem[64]
                    if mem[64] + ceil32(32 * mem[_5531 + mem[_5531 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_5531 + mem[_5531 + 32]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = mem[64] + ceil32(32 * mem[_5531 + mem[_5531 + 32]]) + 1
                    mem[_7285] = _7091
                    require _6989 + (32 * _7091) + 32 <= return_data.size
                    v = 0
                    w = _5531 + _6989 + 32
                    x = _7285 + 32
                    while v < _7091:
                        mem[x] = mem[w]
                        v = v + 1
                        w = w + 32
                        x = x + 32
                        continue 
                    _9242 = mem[_5531 + ceil32(return_data.size)]
                    v = 0
                    w = u
                    while v < _9242:
                        if v >= mem[_5531 + ceil32(return_data.size)]:
                            revert with 0, 50
                        if w >= mem[_2211]:
                            revert with 0, 50
                        mem[(32 * w) + _2211 + 32] = mem[(32 * v) + _5531 + ceil32(return_data.size) + 32]
                        if v >= mem[_7285]:
                            revert with 0, 50
                        if w >= mem[_2211 + (32 * s + t) + 32]:
                            revert with 0, 50
                        mem[(32 * w) + _2211 + (32 * s + t) + 64] = mem[(32 * v) + _7285 + 32]
                        if w == -1:
                            revert with 0, 17
                        if v == -1:
                            revert with 0, 17
                        _9242 = mem[_5531 + ceil32(return_data.size)]
                        v = v + 1
                        w = w + 1
                        continue 
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            if s > !t:
                revert with 0, 17
            if u != s + t:
                revert with 0, 1
            if 1 >= stor9.length:
                revert with 0, 50
            mem[0] = 9
            mem[mem[64]] = 0x15d2cfca00000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 64
            _5482 = mem[_2211]
            mem[mem[64] + 68] = mem[_2211]
            mem[mem[64] + 100 len 32 * _5482] = mem[_2211 + 32 len 32 * _5482]
            idx = _5482
            var63002 = _2211 + (32 * _5482) + 32
            mem[mem[64] + 36] = arg1
            require ext_code.size(address(stor9.field_256))
            staticcall address(stor9.field_256).0x15d2cfca with:
                    gas gas_remaining wei
                   args 64, arg1, mem[mem[64] + 68 len (32 * _5482) + 32]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _7090 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _7206 = mem[_7090]
            require mem[_7090] <= test266151307()
            require _7090 + mem[_7090] + 31 < _7090 + return_data.size
            _7348 = mem[_7090 + mem[_7090]]
            if mem[_7090 + mem[_7090]] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[_7090 + mem[_7090]]) + 1 < 0 or _7090 + ceil32(return_data.size) + ceil32(32 * mem[_7090 + mem[_7090]]) + 1 > test266151307():
                revert with 0, 65
            mem[64] = _7090 + ceil32(return_data.size) + ceil32(32 * mem[_7090 + mem[_7090]]) + 1
            mem[_7090 + ceil32(return_data.size)] = _7348
            require _7206 + (32 * _7348) + 32 <= return_data.size
            mem[_7090 + ceil32(return_data.size) + 32 len 32 * _7348] = mem[_7090 + _7206 + 32 len 32 * _7348]
            var82001 = _7348
            var82002 = _7090 + _7206 + (32 * _7348) + 32
            var82004 = _7090 + ceil32(return_data.size) + (32 * _7348) + 32
            mem[mem[64]] = 32
            mem[mem[64] + 32] = _7348
            mem[mem[64] + 64 len 32 * _7348] = mem[_7090 + ceil32(return_data.size) + 32 len 32 * _7348]
            var90001 = _7348
            var90002 = _7090 + ceil32(return_data.size) + (32 * _7348) + 32
            return Array(len=_7348, data=mem[mem[64] + 64 len 32 * _7348])
        mem[0] = sha3(ext_call.return_data[31 len 1], 10) + 2
        mem[ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 288] = stor10[ext_call.return_data[31 len 1]][2].field_0
        idx = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 288
        s = 0
        while ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + (32 * stor10[ext_call.return_data[31 len 1]].field_512) + 256 > idx:
            mem[idx + 32] = stor10[ext_call.return_data[31 len 1]][s + 2].field_256
            idx = idx + 32
            s = s + 1
            continue 
        mem[ceil32(return_data.size) + 160] = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 256
        idx = 0
        s = 0
        while idx < stor10[ext_call.return_data[31 len 1]].field_512:
            mem[0] = arg1
            mem[32] = 1
            mem[mem[64] + 32] = idx
            mem[mem[64] + 64] = stor1[arg1].field_512
            mem[mem[64] + 96] = stor8
            _3589 = mem[64]
            mem[mem[64]] = 96
            mem[64] = mem[64] + 128
            if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                revert with 0, 50
            if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                revert with 0, 18
            if sha3(mem[_3589 + 32 len mem[_3589]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s
                continue 
            if s == -1:
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = s + 1
            continue 
        idx = 0
        t = 0
        while idx < stor5.length:
            mem[0] = 5
            _5311 = mem[64]
            mem[64] = mem[64] + 64
            mem[_5311] = address(stor5[idx].field_0)
            mem[_5311 + 32] = address(stor5[idx].field_256)
            mem[0] = address(stor5[idx].field_0)
            mem[32] = sha3(arg1, 1) + 3
            if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                _5338 = mem[64]
                mem[mem[64]] = 0
                mem[mem[64] + 32] = 0
                mem[64] = mem[64] + 64
                if t > !mem[_5338]:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                t = t + mem[_5338]
                continue 
            mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = arg1
            mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
            require ext_code.size(address(stor5[idx].field_256))
            staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                    gas gas_remaining wei
                   args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _5535 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 64
            _5610 = mem[_5535]
            require mem[_5535] <= test266151307()
            require _5535 + mem[_5535] + 31 < _5535 + return_data.size
            _5755 = mem[_5535 + mem[_5535]]
            if mem[_5535 + mem[_5535]] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[_5535 + mem[_5535]]) + 1 < 0 or _5535 + ceil32(return_data.size) + ceil32(32 * mem[_5535 + mem[_5535]]) + 1 > test266151307():
                revert with 0, 65
            mem[64] = _5535 + ceil32(return_data.size) + ceil32(32 * mem[_5535 + mem[_5535]]) + 1
            mem[_5535 + ceil32(return_data.size)] = _5755
            require _5610 + (32 * _5755) + 32 <= return_data.size
            s = 0
            u = _5535 + _5610 + 32
            v = _5535 + ceil32(return_data.size) + 32
            while s < _5755:
                mem[v] = mem[u]
                s = s + 1
                u = u + 32
                v = v + 32
                continue 
            _6996 = mem[_5535 + 32]
            require mem[_5535 + 32] <= test266151307()
            require _5535 + mem[_5535 + 32] + 31 < _5535 + return_data.size
            _7092 = mem[_5535 + mem[_5535 + 32]]
            if mem[_5535 + mem[_5535 + 32]] > test266151307():
                revert with 0, 65
            _7302 = mem[64]
            if mem[64] + ceil32(32 * mem[_5535 + mem[_5535 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_5535 + mem[_5535 + 32]]) + 1 > test266151307():
                revert with 0, 65
            mem[64] = mem[64] + ceil32(32 * mem[_5535 + mem[_5535 + 32]]) + 1
            mem[_7302] = _7092
            require _6996 + (32 * _7092) + 32 <= return_data.size
            s = 0
            u = _5535 + _6996 + 32
            v = _7302 + 32
            while s < _7092:
                mem[v] = mem[u]
                s = s + 1
                u = u + 32
                v = v + 32
                continue 
            if t > !mem[_5535 + ceil32(return_data.size)]:
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            t = t + mem[_5535 + ceil32(return_data.size)]
            continue 
        if s > !t:
            revert with 0, 17
        if s + t > test266151307():
            revert with 0, 65
        _5337 = mem[64]
        mem[mem[64]] = s + t
        if s + t:
            mem[mem[64] + 32 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
            if s > !t:
                revert with 0, 17
            if s + t > test266151307():
                revert with 0, 65
            mem[mem[64] + (32 * s + t) + 32] = s + t
            mem[64] = _5337 + (64 * s + t) + 64
            if not s + t:
                _6792 = mem[mem[ceil32(return_data.size) + 160]]
                idx = 0
                u = 0
                while idx < _6792:
                    mem[0] = arg1
                    mem[32] = 1
                    mem[mem[64] + 32] = idx
                    mem[mem[64] + 64] = stor1[arg1].field_512
                    mem[mem[64] + 96] = stor8
                    _6894 = mem[64]
                    mem[mem[64]] = 96
                    mem[64] = mem[64] + 128
                    if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                        revert with 0, 50
                    if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        revert with 0, 18
                    if sha3(mem[_6894 + 32 len mem[_6894]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        if idx == -1:
                            revert with 0, 17
                        _6792 = mem[mem[ceil32(return_data.size) + 160]]
                        idx = idx + 1
                        u = u
                        continue 
                    if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                        revert with 0, 50
                    if u >= mem[_5337]:
                        revert with 0, 50
                    mem[(32 * u) + _5337 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                    if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                        revert with 0, 50
                    if u >= mem[_5337 + (32 * s + t) + 32]:
                        revert with 0, 50
                    mem[(32 * u) + _5337 + (32 * s + t) + 64] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                    if u == -1:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _6792 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = idx + 1
                    u = u + 1
                    continue 
                idx = 0
                while idx < stor5.length:
                    mem[0] = 5
                    _8304 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_8304] = address(stor5[idx].field_0)
                    mem[_8304 + 32] = address(stor5[idx].field_256)
                    mem[0] = address(stor5[idx].field_0)
                    mem[32] = sha3(arg1, 1) + 3
                    if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                        _8345 = mem[64]
                        mem[mem[64]] = 0
                        mem[mem[64] + 32] = 0
                        mem[64] = mem[64] + 64
                        _9245 = mem[_8345]
                        v = 0
                        w = u
                        while v < _9245:
                            if v >= mem[_8345]:
                                revert with 0, 50
                            if w >= mem[_5337]:
                                revert with 0, 50
                            mem[(32 * w) + _5337 + 32] = mem[(32 * v) + _8345 + 32]
                            if v >= mem[_8345 + 32]:
                                revert with 0, 50
                            if w >= mem[_5337 + (32 * s + t) + 32]:
                                revert with 0, 50
                            mem[(32 * w) + _5337 + (32 * s + t) + 64] = mem[(32 * v) + _8345 + 64]
                            if w == -1:
                                revert with 0, 17
                            if v == -1:
                                revert with 0, 17
                            _9245 = mem[_8345]
                            v = v + 1
                            w = w + 1
                            continue 
                    else:
                        mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = arg1
                        mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                        require ext_code.size(address(stor5[idx].field_256))
                        staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                                gas gas_remaining wei
                               args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _8593 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 64
                        _8656 = mem[_8593]
                        require mem[_8593] <= test266151307()
                        require _8593 + mem[_8593] + 31 < _8593 + return_data.size
                        _8730 = mem[_8593 + mem[_8593]]
                        if mem[_8593 + mem[_8593]] > test266151307():
                            revert with 0, 65
                        if ceil32(32 * mem[_8593 + mem[_8593]]) + 1 < 0 or _8593 + ceil32(return_data.size) + ceil32(32 * mem[_8593 + mem[_8593]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = _8593 + ceil32(return_data.size) + ceil32(32 * mem[_8593 + mem[_8593]]) + 1
                        mem[_8593 + ceil32(return_data.size)] = _8730
                        require _8656 + (32 * _8730) + 32 <= return_data.size
                        v = 0
                        w = _8593 + _8656 + 32
                        x = _8593 + ceil32(return_data.size) + 32
                        while v < _8730:
                            mem[x] = mem[w]
                            v = v + 1
                            w = w + 32
                            x = x + 32
                            continue 
                        _9390 = mem[_8593 + 32]
                        require mem[_8593 + 32] <= test266151307()
                        require _8593 + mem[_8593 + 32] + 31 < _8593 + return_data.size
                        _9522 = mem[_8593 + mem[_8593 + 32]]
                        if mem[_8593 + mem[_8593 + 32]] > test266151307():
                            revert with 0, 65
                        _9600 = mem[64]
                        if mem[64] + ceil32(32 * mem[_8593 + mem[_8593 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_8593 + mem[_8593 + 32]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = mem[64] + ceil32(32 * mem[_8593 + mem[_8593 + 32]]) + 1
                        mem[_9600] = _9522
                        require _9390 + (32 * _9522) + 32 <= return_data.size
                        v = 0
                        w = _8593 + _9390 + 32
                        x = _9600 + 32
                        while v < _9522:
                            mem[x] = mem[w]
                            v = v + 1
                            w = w + 32
                            x = x + 32
                            continue 
                        _10305 = mem[_8593 + ceil32(return_data.size)]
                        v = 0
                        w = u
                        while v < _10305:
                            if v >= mem[_8593 + ceil32(return_data.size)]:
                                revert with 0, 50
                            if w >= mem[_5337]:
                                revert with 0, 50
                            mem[(32 * w) + _5337 + 32] = mem[(32 * v) + _8593 + ceil32(return_data.size) + 32]
                            if v >= mem[_9600]:
                                revert with 0, 50
                            if w >= mem[_5337 + (32 * s + t) + 32]:
                                revert with 0, 50
                            mem[(32 * w) + _5337 + (32 * s + t) + 64] = mem[(32 * v) + _9600 + 32]
                            if w == -1:
                                revert with 0, 17
                            if v == -1:
                                revert with 0, 17
                            _10305 = mem[_8593 + ceil32(return_data.size)]
                            v = v + 1
                            w = w + 1
                            continue 
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                if s > !t:
                    revert with 0, 17
                if u != s + t:
                    revert with 0, 1
                if 1 >= stor9.length:
                    revert with 0, 50
                mem[0] = 9
                mem[mem[64]] = 0x15d2cfca00000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 64
                _8527 = mem[_5337]
                mem[mem[64] + 68] = mem[_5337]
                mem[mem[64] + 100 len 32 * _8527] = mem[_5337 + 32 len 32 * _8527]
                idx = _8527
                var66002 = _5337 + (32 * _8527) + 32
                mem[mem[64] + 36] = arg1
                require ext_code.size(address(stor9.field_256))
                staticcall address(stor9.field_256).0x15d2cfca with:
                        gas gas_remaining wei
                       args 64, arg1, mem[mem[64] + 68 len (32 * _8527) + 32]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _9521 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _9568 = mem[_9521]
                require mem[_9521] <= test266151307()
                require _9521 + mem[_9521] + 31 < _9521 + return_data.size
                _9629 = mem[_9521 + mem[_9521]]
                if mem[_9521 + mem[_9521]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_9521 + mem[_9521]]) + 1 < 0 or _9521 + ceil32(return_data.size) + ceil32(32 * mem[_9521 + mem[_9521]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _9521 + ceil32(return_data.size) + ceil32(32 * mem[_9521 + mem[_9521]]) + 1
                mem[_9521 + ceil32(return_data.size)] = _9629
                require _9568 + (32 * _9629) + 32 <= return_data.size
                mem[_9521 + ceil32(return_data.size) + 32 len 32 * _9629] = mem[_9521 + _9568 + 32 len 32 * _9629]
                mem[mem[64]] = 32
                mem[mem[64] + 32] = _9629
                mem[mem[64] + 64 len 32 * _9629] = mem[_9521 + ceil32(return_data.size) + 32 len 32 * _9629]
                var93001 = _9629
                var93002 = _9521 + ceil32(return_data.size) + (32 * _9629) + 32
                return Array(len=_9629, data=mem[mem[64] + 64 len 32 * _9629])
            mem[_5337 + (32 * s + t) + 64 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
            _6794 = mem[mem[ceil32(return_data.size) + 160]]
            idx = 0
            u = 0
            while idx < _6794:
                mem[0] = arg1
                mem[32] = 1
                mem[mem[64] + 32] = idx
                mem[mem[64] + 64] = stor1[arg1].field_512
                mem[mem[64] + 96] = stor8
                _6901 = mem[64]
                mem[mem[64]] = 96
                mem[64] = mem[64] + 128
                if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                    revert with 0, 50
                if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    revert with 0, 18
                if sha3(mem[_6901 + 32 len mem[_6901]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    if idx == -1:
                        revert with 0, 17
                    _6794 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = idx + 1
                    u = u
                    continue 
                if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                    revert with 0, 50
                if u >= mem[_5337]:
                    revert with 0, 50
                mem[(32 * u) + _5337 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                    revert with 0, 50
                if u >= mem[_5337 + (32 * s + t) + 32]:
                    revert with 0, 50
                mem[(32 * u) + _5337 + (32 * s + t) + 64] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                if u == -1:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _6794 = mem[mem[ceil32(return_data.size) + 160]]
                idx = idx + 1
                u = u + 1
                continue 
            idx = 0
            while idx < stor5.length:
                mem[0] = 5
                _8309 = mem[64]
                mem[64] = mem[64] + 64
                mem[_8309] = address(stor5[idx].field_0)
                mem[_8309 + 32] = address(stor5[idx].field_256)
                mem[0] = address(stor5[idx].field_0)
                mem[32] = sha3(arg1, 1) + 3
                if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                    _8346 = mem[64]
                    mem[mem[64]] = 0
                    mem[mem[64] + 32] = 0
                    mem[64] = mem[64] + 64
                    _9246 = mem[_8346]
                    v = 0
                    w = u
                    while v < _9246:
                        if v >= mem[_8346]:
                            revert with 0, 50
                        if w >= mem[_5337]:
                            revert with 0, 50
                        mem[(32 * w) + _5337 + 32] = mem[(32 * v) + _8346 + 32]
                        if v >= mem[_8346 + 32]:
                            revert with 0, 50
                        if w >= mem[_5337 + (32 * s + t) + 32]:
                            revert with 0, 50
                        mem[(32 * w) + _5337 + (32 * s + t) + 64] = mem[(32 * v) + _8346 + 64]
                        if w == -1:
                            revert with 0, 17
                        if v == -1:
                            revert with 0, 17
                        _9246 = mem[_8346]
                        v = v + 1
                        w = w + 1
                        continue 
                else:
                    mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = arg1
                    mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    require ext_code.size(address(stor5[idx].field_256))
                    staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                            gas gas_remaining wei
                           args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _8596 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 64
                    _8659 = mem[_8596]
                    require mem[_8596] <= test266151307()
                    require _8596 + mem[_8596] + 31 < _8596 + return_data.size
                    _8732 = mem[_8596 + mem[_8596]]
                    if mem[_8596 + mem[_8596]] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[_8596 + mem[_8596]]) + 1 < 0 or _8596 + ceil32(return_data.size) + ceil32(32 * mem[_8596 + mem[_8596]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = _8596 + ceil32(return_data.size) + ceil32(32 * mem[_8596 + mem[_8596]]) + 1
                    mem[_8596 + ceil32(return_data.size)] = _8732
                    require _8659 + (32 * _8732) + 32 <= return_data.size
                    v = 0
                    w = _8596 + _8659 + 32
                    x = _8596 + ceil32(return_data.size) + 32
                    while v < _8732:
                        mem[x] = mem[w]
                        v = v + 1
                        w = w + 32
                        x = x + 32
                        continue 
                    _9393 = mem[_8596 + 32]
                    require mem[_8596 + 32] <= test266151307()
                    require _8596 + mem[_8596 + 32] + 31 < _8596 + return_data.size
                    _9524 = mem[_8596 + mem[_8596 + 32]]
                    if mem[_8596 + mem[_8596 + 32]] > test266151307():
                        revert with 0, 65
                    _9601 = mem[64]
                    if mem[64] + ceil32(32 * mem[_8596 + mem[_8596 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_8596 + mem[_8596 + 32]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = mem[64] + ceil32(32 * mem[_8596 + mem[_8596 + 32]]) + 1
                    mem[_9601] = _9524
                    require _9393 + (32 * _9524) + 32 <= return_data.size
                    v = 0
                    w = _8596 + _9393 + 32
                    x = _9601 + 32
                    while v < _9524:
                        mem[x] = mem[w]
                        v = v + 1
                        w = w + 32
                        x = x + 32
                        continue 
                    _10306 = mem[_8596 + ceil32(return_data.size)]
                    v = 0
                    w = u
                    while v < _10306:
                        if v >= mem[_8596 + ceil32(return_data.size)]:
                            revert with 0, 50
                        if w >= mem[_5337]:
                            revert with 0, 50
                        mem[(32 * w) + _5337 + 32] = mem[(32 * v) + _8596 + ceil32(return_data.size) + 32]
                        if v >= mem[_9601]:
                            revert with 0, 50
                        if w >= mem[_5337 + (32 * s + t) + 32]:
                            revert with 0, 50
                        mem[(32 * w) + _5337 + (32 * s + t) + 64] = mem[(32 * v) + _9601 + 32]
                        if w == -1:
                            revert with 0, 17
                        if v == -1:
                            revert with 0, 17
                        _10306 = mem[_8596 + ceil32(return_data.size)]
                        v = v + 1
                        w = w + 1
                        continue 
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            if s > !t:
                revert with 0, 17
            if u != s + t:
                revert with 0, 1
            if 1 >= stor9.length:
                revert with 0, 50
            mem[0] = 9
            mem[mem[64]] = 0x15d2cfca00000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 64
            _8529 = mem[_5337]
            mem[mem[64] + 68] = mem[_5337]
            mem[mem[64] + 100 len 32 * _8529] = mem[_5337 + 32 len 32 * _8529]
            idx = _8529
            var67002 = _5337 + (32 * _8529) + 32
            mem[mem[64] + 36] = arg1
            require ext_code.size(address(stor9.field_256))
            staticcall address(stor9.field_256).0x15d2cfca with:
                    gas gas_remaining wei
                   args 64, arg1, mem[mem[64] + 68 len (32 * _8529) + 32]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _9523 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _9569 = mem[_9523]
            require mem[_9523] <= test266151307()
            require _9523 + mem[_9523] + 31 < _9523 + return_data.size
            _9630 = mem[_9523 + mem[_9523]]
            if mem[_9523 + mem[_9523]] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[_9523 + mem[_9523]]) + 1 < 0 or _9523 + ceil32(return_data.size) + ceil32(32 * mem[_9523 + mem[_9523]]) + 1 > test266151307():
                revert with 0, 65
            mem[64] = _9523 + ceil32(return_data.size) + ceil32(32 * mem[_9523 + mem[_9523]]) + 1
            mem[_9523 + ceil32(return_data.size)] = _9630
            require _9569 + (32 * _9630) + 32 <= return_data.size
            mem[_9523 + ceil32(return_data.size) + 32 len 32 * _9630] = mem[_9523 + _9569 + 32 len 32 * _9630]
            mem[mem[64]] = 32
            mem[mem[64] + 32] = _9630
            mem[mem[64] + 64 len 32 * _9630] = mem[_9523 + ceil32(return_data.size) + 32 len 32 * _9630]
            var94001 = _9630
            var94002 = _9523 + ceil32(return_data.size) + (32 * _9630) + 32
            return Array(len=_9630, data=mem[mem[64] + 64 len 32 * _9630])
        if s > !t:
            revert with 0, 17
        if s + t > test266151307():
            revert with 0, 65
        _5534 = mem[64] + (32 * s + t) + 32
        mem[mem[64] + (32 * s + t) + 32] = s + t
        mem[64] = _5534 + (32 * s + t) + 32
        if s + t:
            mem[_5534 + 32 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
            _6790 = mem[mem[ceil32(return_data.size) + 160]]
            idx = 0
            u = 0
            while idx < _6790:
                mem[0] = arg1
                mem[32] = 1
                mem[mem[64] + 32] = idx
                mem[mem[64] + 64] = stor1[arg1].field_512
                mem[mem[64] + 96] = stor8
                _6887 = mem[64]
                mem[mem[64]] = 96
                mem[64] = mem[64] + 128
                if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                    revert with 0, 50
                if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    revert with 0, 18
                if sha3(mem[_6887 + 32 len mem[_6887]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    if idx == -1:
                        revert with 0, 17
                    _6790 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = idx + 1
                    u = u
                    continue 
                if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                    revert with 0, 50
                if u >= mem[_5337]:
                    revert with 0, 50
                mem[(32 * u) + _5337 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                    revert with 0, 50
                if u >= mem[_5534]:
                    revert with 0, 50
                mem[(32 * u) + _5534 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                if u == -1:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _6790 = mem[mem[ceil32(return_data.size) + 160]]
                idx = idx + 1
                u = u + 1
                continue 
            idx = 0
            while idx < stor5.length:
                mem[0] = 5
                _8299 = mem[64]
                mem[64] = mem[64] + 64
                mem[_8299] = address(stor5[idx].field_0)
                mem[_8299 + 32] = address(stor5[idx].field_256)
                mem[0] = address(stor5[idx].field_0)
                mem[32] = sha3(arg1, 1) + 3
                if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                    _8344 = mem[64]
                    mem[mem[64]] = 0
                    mem[mem[64] + 32] = 0
                    mem[64] = mem[64] + 64
                    _9244 = mem[_8344]
                    s = 0
                    t = u
                    while s < _9244:
                        if s >= mem[_8344]:
                            revert with 0, 50
                        if t >= mem[_5337]:
                            revert with 0, 50
                        mem[(32 * t) + _5337 + 32] = mem[(32 * s) + _8344 + 32]
                        if s >= mem[_8344 + 32]:
                            revert with 0, 50
                        if t >= mem[_5534]:
                            revert with 0, 50
                        mem[(32 * t) + _5534 + 32] = mem[(32 * s) + _8344 + 64]
                        if t == -1:
                            revert with 0, 17
                        if s == -1:
                            revert with 0, 17
                        _9244 = mem[_8344]
                        s = s + 1
                        t = t + 1
                        continue 
                else:
                    mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = arg1
                    mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    require ext_code.size(address(stor5[idx].field_256))
                    staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                            gas gas_remaining wei
                           args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _8590 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 64
                    _8653 = mem[_8590]
                    require mem[_8590] <= test266151307()
                    require _8590 + mem[_8590] + 31 < _8590 + return_data.size
                    _8728 = mem[_8590 + mem[_8590]]
                    if mem[_8590 + mem[_8590]] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[_8590 + mem[_8590]]) + 1 < 0 or _8590 + ceil32(return_data.size) + ceil32(32 * mem[_8590 + mem[_8590]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = _8590 + ceil32(return_data.size) + ceil32(32 * mem[_8590 + mem[_8590]]) + 1
                    mem[_8590 + ceil32(return_data.size)] = _8728
                    require _8653 + (32 * _8728) + 32 <= return_data.size
                    s = 0
                    t = _8590 + _8653 + 32
                    v = _8590 + ceil32(return_data.size) + 32
                    while s < _8728:
                        mem[v] = mem[t]
                        s = s + 1
                        t = t + 32
                        v = v + 32
                        continue 
                    _9387 = mem[_8590 + 32]
                    require mem[_8590 + 32] <= test266151307()
                    require _8590 + mem[_8590 + 32] + 31 < _8590 + return_data.size
                    _9520 = mem[_8590 + mem[_8590 + 32]]
                    if mem[_8590 + mem[_8590 + 32]] > test266151307():
                        revert with 0, 65
                    _9599 = mem[64]
                    if mem[64] + ceil32(32 * mem[_8590 + mem[_8590 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_8590 + mem[_8590 + 32]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = mem[64] + ceil32(32 * mem[_8590 + mem[_8590 + 32]]) + 1
                    mem[_9599] = _9520
                    require _9387 + (32 * _9520) + 32 <= return_data.size
                    s = 0
                    t = _8590 + _9387 + 32
                    v = _9599 + 32
                    while s < _9520:
                        mem[v] = mem[t]
                        s = s + 1
                        t = t + 32
                        v = v + 32
                        continue 
                    _10304 = mem[_8590 + ceil32(return_data.size)]
                    s = 0
                    t = u
                    while s < _10304:
                        if s >= mem[_8590 + ceil32(return_data.size)]:
                            revert with 0, 50
                        if t >= mem[_5337]:
                            revert with 0, 50
                        mem[(32 * t) + _5337 + 32] = mem[(32 * s) + _8590 + ceil32(return_data.size) + 32]
                        if s >= mem[_9599]:
                            revert with 0, 50
                        if t >= mem[_5534]:
                            revert with 0, 50
                        mem[(32 * t) + _5534 + 32] = mem[(32 * s) + _9599 + 32]
                        if t == -1:
                            revert with 0, 17
                        if s == -1:
                            revert with 0, 17
                        _10304 = mem[_8590 + ceil32(return_data.size)]
                        s = s + 1
                        t = t + 1
                        continue 
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            if s > !t:
                revert with 0, 17
            if u != s + t:
                revert with 0, 1
            if 1 >= stor9.length:
                revert with 0, 50
            mem[0] = 9
            mem[mem[64]] = 0x15d2cfca00000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 64
            _8525 = mem[_5337]
            mem[mem[64] + 68] = mem[_5337]
            mem[mem[64] + 100 len 32 * _8525] = mem[_5337 + 32 len 32 * _8525]
            idx = _8525
            var66002 = _5337 + (32 * _8525) + 32
            mem[mem[64] + 36] = arg1
            require ext_code.size(address(stor9.field_256))
            staticcall address(stor9.field_256).0x15d2cfca with:
                    gas gas_remaining wei
                   args 64, arg1, mem[mem[64] + 68 len (32 * _8525) + 32]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _9519 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _9567 = mem[_9519]
            require mem[_9519] <= test266151307()
            require _9519 + mem[_9519] + 31 < _9519 + return_data.size
            _9628 = mem[_9519 + mem[_9519]]
            if mem[_9519 + mem[_9519]] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[_9519 + mem[_9519]]) + 1 < 0 or _9519 + ceil32(return_data.size) + ceil32(32 * mem[_9519 + mem[_9519]]) + 1 > test266151307():
                revert with 0, 65
            mem[64] = _9519 + ceil32(return_data.size) + ceil32(32 * mem[_9519 + mem[_9519]]) + 1
            mem[_9519 + ceil32(return_data.size)] = _9628
            require _9567 + (32 * _9628) + 32 <= return_data.size
            mem[_9519 + ceil32(return_data.size) + 32 len 32 * _9628] = mem[_9519 + _9567 + 32 len 32 * _9628]
            mem[mem[64]] = 32
            mem[mem[64] + 32] = _9628
            mem[mem[64] + 64 len 32 * _9628] = mem[_9519 + ceil32(return_data.size) + 32 len 32 * _9628]
            var93001 = _9628
            var93002 = _9519 + ceil32(return_data.size) + (32 * _9628) + 32
            return Array(len=_9628, data=mem[mem[64] + 64 len 32 * _9628])
        _6788 = mem[mem[ceil32(return_data.size) + 160]]
        idx = 0
        u = 0
        while idx < _6788:
            mem[0] = arg1
            mem[32] = 1
            mem[mem[64] + 32] = idx
            mem[mem[64] + 64] = stor1[arg1].field_512
            mem[mem[64] + 96] = stor8
            _6880 = mem[64]
            mem[mem[64]] = 96
            mem[64] = mem[64] + 128
            if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                revert with 0, 50
            if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                revert with 0, 18
            if sha3(mem[_6880 + 32 len mem[_6880]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                if idx == -1:
                    revert with 0, 17
                _6788 = mem[mem[ceil32(return_data.size) + 160]]
                idx = idx + 1
                u = u
                continue 
            if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                revert with 0, 50
            if u >= mem[_5337]:
                revert with 0, 50
            mem[(32 * u) + _5337 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
            if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                revert with 0, 50
            if u >= mem[_5534]:
                revert with 0, 50
            mem[(32 * u) + _5534 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
            if u == -1:
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            _6788 = mem[mem[ceil32(return_data.size) + 160]]
            idx = idx + 1
            u = u + 1
            continue 
        idx = 0
        while idx < stor5.length:
            mem[0] = 5
            _8294 = mem[64]
            mem[64] = mem[64] + 64
            mem[_8294] = address(stor5[idx].field_0)
            mem[_8294 + 32] = address(stor5[idx].field_256)
            mem[0] = address(stor5[idx].field_0)
            mem[32] = sha3(arg1, 1) + 3
            if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                _8343 = mem[64]
                mem[mem[64]] = 0
                mem[mem[64] + 32] = 0
                mem[64] = mem[64] + 64
                _9243 = mem[_8343]
                s = 0
                t = u
                while s < _9243:
                    if s >= mem[_8343]:
                        revert with 0, 50
                    if t >= mem[_5337]:
                        revert with 0, 50
                    mem[(32 * t) + _5337 + 32] = mem[(32 * s) + _8343 + 32]
                    if s >= mem[_8343 + 32]:
                        revert with 0, 50
                    if t >= mem[_5534]:
                        revert with 0, 50
                    mem[(32 * t) + _5534 + 32] = mem[(32 * s) + _8343 + 64]
                    if t == -1:
                        revert with 0, 17
                    if s == -1:
                        revert with 0, 17
                    _9243 = mem[_8343]
                    s = s + 1
                    t = t + 1
                    continue 
            else:
                mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = arg1
                mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                require ext_code.size(address(stor5[idx].field_256))
                staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                        gas gas_remaining wei
                       args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _8587 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 64
                _8650 = mem[_8587]
                require mem[_8587] <= test266151307()
                require _8587 + mem[_8587] + 31 < _8587 + return_data.size
                _8726 = mem[_8587 + mem[_8587]]
                if mem[_8587 + mem[_8587]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_8587 + mem[_8587]]) + 1 < 0 or _8587 + ceil32(return_data.size) + ceil32(32 * mem[_8587 + mem[_8587]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _8587 + ceil32(return_data.size) + ceil32(32 * mem[_8587 + mem[_8587]]) + 1
                mem[_8587 + ceil32(return_data.size)] = _8726
                require _8650 + (32 * _8726) + 32 <= return_data.size
                s = 0
                t = _8587 + _8650 + 32
                v = _8587 + ceil32(return_data.size) + 32
                while s < _8726:
                    mem[v] = mem[t]
                    s = s + 1
                    t = t + 32
                    v = v + 32
                    continue 
                _9384 = mem[_8587 + 32]
                require mem[_8587 + 32] <= test266151307()
                require _8587 + mem[_8587 + 32] + 31 < _8587 + return_data.size
                _9518 = mem[_8587 + mem[_8587 + 32]]
                if mem[_8587 + mem[_8587 + 32]] > test266151307():
                    revert with 0, 65
                _9598 = mem[64]
                if mem[64] + ceil32(32 * mem[_8587 + mem[_8587 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_8587 + mem[_8587 + 32]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = mem[64] + ceil32(32 * mem[_8587 + mem[_8587 + 32]]) + 1
                mem[_9598] = _9518
                require _9384 + (32 * _9518) + 32 <= return_data.size
                s = 0
                t = _8587 + _9384 + 32
                v = _9598 + 32
                while s < _9518:
                    mem[v] = mem[t]
                    s = s + 1
                    t = t + 32
                    v = v + 32
                    continue 
                _10303 = mem[_8587 + ceil32(return_data.size)]
                s = 0
                t = u
                while s < _10303:
                    if s >= mem[_8587 + ceil32(return_data.size)]:
                        revert with 0, 50
                    if t >= mem[_5337]:
                        revert with 0, 50
                    mem[(32 * t) + _5337 + 32] = mem[(32 * s) + _8587 + ceil32(return_data.size) + 32]
                    if s >= mem[_9598]:
                        revert with 0, 50
                    if t >= mem[_5534]:
                        revert with 0, 50
                    mem[(32 * t) + _5534 + 32] = mem[(32 * s) + _9598 + 32]
                    if t == -1:
                        revert with 0, 17
                    if s == -1:
                        revert with 0, 17
                    _10303 = mem[_8587 + ceil32(return_data.size)]
                    s = s + 1
                    t = t + 1
                    continue 
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        if s > !t:
            revert with 0, 17
        if u != s + t:
            revert with 0, 1
        if 1 >= stor9.length:
            revert with 0, 50
        mem[0] = 9
        mem[mem[64]] = 0x15d2cfca00000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = 64
        _8523 = mem[_5337]
        mem[mem[64] + 68] = mem[_5337]
        mem[mem[64] + 100 len 32 * _8523] = mem[_5337 + 32 len 32 * _8523]
        idx = _8523
        var65002 = _5337 + (32 * _8523) + 32
        mem[mem[64] + 36] = arg1
        require ext_code.size(address(stor9.field_256))
        staticcall address(stor9.field_256).0x15d2cfca with:
                gas gas_remaining wei
               args 64, arg1, mem[mem[64] + 68 len (32 * _8523) + 32]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _9517 = mem[64]
        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _9566 = mem[_9517]
        require mem[_9517] <= test266151307()
        require _9517 + mem[_9517] + 31 < _9517 + return_data.size
        _9627 = mem[_9517 + mem[_9517]]
        if mem[_9517 + mem[_9517]] > test266151307():
            revert with 0, 65
        if ceil32(32 * mem[_9517 + mem[_9517]]) + 1 < 0 or _9517 + ceil32(return_data.size) + ceil32(32 * mem[_9517 + mem[_9517]]) + 1 > test266151307():
            revert with 0, 65
        mem[64] = _9517 + ceil32(return_data.size) + ceil32(32 * mem[_9517 + mem[_9517]]) + 1
        mem[_9517 + ceil32(return_data.size)] = _9627
        require _9566 + (32 * _9627) + 32 <= return_data.size
        mem[_9517 + ceil32(return_data.size) + 32 len 32 * _9627] = mem[_9517 + _9566 + 32 len 32 * _9627]
        var84001 = _9627
        var84002 = _9517 + _9566 + (32 * _9627) + 32
        var84004 = _9517 + ceil32(return_data.size) + (32 * _9627) + 32
        mem[mem[64]] = 32
        mem[mem[64] + 32] = _9627
        mem[mem[64] + 64 len 32 * _9627] = mem[_9517 + ceil32(return_data.size) + 32 len 32 * _9627]
        var92001 = _9627
        var92002 = _9517 + ceil32(return_data.size) + (32 * _9627) + 32
        return Array(len=_9627, data=mem[mem[64] + 64 len 32 * _9627])
    mem[0] = sha3(ext_call.return_data[31 len 1], 10) + 1
    mem[ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + 256] = stor10[ext_call.return_data[31 len 1]][1].field_0
    idx = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + 256
    s = 0
    while ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 224 > idx:
        mem[idx + 32] = stor10[ext_call.return_data[31 len 1]][s + 1].field_256
        idx = idx + 32
        s = s + 1
        continue 
    mem[ceil32(return_data.size) + 128] = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + 224
    mem[64] = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + (32 * stor10[ext_call.return_data[31 len 1]].field_512) + 288
    mem[ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 256] = stor10[ext_call.return_data[31 len 1]].field_512
    if not stor10[ext_call.return_data[31 len 1]].field_512:
        mem[ceil32(return_data.size) + 160] = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 256
        idx = 0
        s = 0
        while idx < stor10[ext_call.return_data[31 len 1]].field_512:
            mem[0] = arg1
            mem[32] = 1
            mem[mem[64] + 32] = idx
            mem[mem[64] + 64] = stor1[arg1].field_512
            mem[mem[64] + 96] = stor8
            _3596 = mem[64]
            mem[mem[64]] = 96
            mem[64] = mem[64] + 128
            if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                revert with 0, 50
            if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                revert with 0, 18
            if sha3(mem[_3596 + 32 len mem[_3596]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s
                continue 
            if s == -1:
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = s + 1
            continue 
        idx = 0
        t = 0
        while idx < stor5.length:
            mem[0] = 5
            _5316 = mem[64]
            mem[64] = mem[64] + 64
            mem[_5316] = address(stor5[idx].field_0)
            mem[_5316 + 32] = address(stor5[idx].field_256)
            mem[0] = address(stor5[idx].field_0)
            mem[32] = sha3(arg1, 1) + 3
            if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                _5340 = mem[64]
                mem[mem[64]] = 0
                mem[mem[64] + 32] = 0
                mem[64] = mem[64] + 64
                if t > !mem[_5340]:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                t = t + mem[_5340]
                continue 
            mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = arg1
            mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
            require ext_code.size(address(stor5[idx].field_256))
            staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                    gas gas_remaining wei
                   args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _5537 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 64
            _5613 = mem[_5537]
            require mem[_5537] <= test266151307()
            require _5537 + mem[_5537] + 31 < _5537 + return_data.size
            _5765 = mem[_5537 + mem[_5537]]
            if mem[_5537 + mem[_5537]] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[_5537 + mem[_5537]]) + 1 < 0 or _5537 + ceil32(return_data.size) + ceil32(32 * mem[_5537 + mem[_5537]]) + 1 > test266151307():
                revert with 0, 65
            mem[64] = _5537 + ceil32(return_data.size) + ceil32(32 * mem[_5537 + mem[_5537]]) + 1
            mem[_5537 + ceil32(return_data.size)] = _5765
            require _5613 + (32 * _5765) + 32 <= return_data.size
            s = 0
            u = _5537 + _5613 + 32
            v = _5537 + ceil32(return_data.size) + 32
            while s < _5765:
                mem[v] = mem[u]
                s = s + 1
                u = u + 32
                v = v + 32
                continue 
            _7001 = mem[_5537 + 32]
            require mem[_5537 + 32] <= test266151307()
            require _5537 + mem[_5537 + 32] + 31 < _5537 + return_data.size
            _7093 = mem[_5537 + mem[_5537 + 32]]
            if mem[_5537 + mem[_5537 + 32]] > test266151307():
                revert with 0, 65
            _7319 = mem[64]
            if mem[64] + ceil32(32 * mem[_5537 + mem[_5537 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_5537 + mem[_5537 + 32]]) + 1 > test266151307():
                revert with 0, 65
            mem[64] = mem[64] + ceil32(32 * mem[_5537 + mem[_5537 + 32]]) + 1
            mem[_7319] = _7093
            require _7001 + (32 * _7093) + 32 <= return_data.size
            s = 0
            u = _5537 + _7001 + 32
            v = _7319 + 32
            while s < _7093:
                mem[v] = mem[u]
                s = s + 1
                u = u + 32
                v = v + 32
                continue 
            if t > !mem[_5537 + ceil32(return_data.size)]:
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            t = t + mem[_5537 + ceil32(return_data.size)]
            continue 
        if s > !t:
            revert with 0, 17
        if s + t > test266151307():
            revert with 0, 65
        _5339 = mem[64]
        mem[mem[64]] = s + t
        if s + t:
            mem[mem[64] + 32 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
            if s > !t:
                revert with 0, 17
            if s + t > test266151307():
                revert with 0, 65
            mem[mem[64] + (32 * s + t) + 32] = s + t
            mem[64] = _5339 + (64 * s + t) + 64
            if not s + t:
                _6800 = mem[mem[ceil32(return_data.size) + 160]]
                idx = 0
                u = 0
                while idx < _6800:
                    mem[0] = arg1
                    mem[32] = 1
                    mem[mem[64] + 32] = idx
                    mem[mem[64] + 64] = stor1[arg1].field_512
                    mem[mem[64] + 96] = stor8
                    _6923 = mem[64]
                    mem[mem[64]] = 96
                    mem[64] = mem[64] + 128
                    if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                        revert with 0, 50
                    if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        revert with 0, 18
                    if sha3(mem[_6923 + 32 len mem[_6923]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        if idx == -1:
                            revert with 0, 17
                        _6800 = mem[mem[ceil32(return_data.size) + 160]]
                        idx = idx + 1
                        u = u
                        continue 
                    if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                        revert with 0, 50
                    if u >= mem[_5339]:
                        revert with 0, 50
                    mem[(32 * u) + _5339 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                    if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                        revert with 0, 50
                    if u >= mem[_5339 + (32 * s + t) + 32]:
                        revert with 0, 50
                    mem[(32 * u) + _5339 + (32 * s + t) + 64] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                    if u == -1:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _6800 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = idx + 1
                    u = u + 1
                    continue 
                idx = 0
                while idx < stor5.length:
                    mem[0] = 5
                    _8324 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_8324] = address(stor5[idx].field_0)
                    mem[_8324 + 32] = address(stor5[idx].field_256)
                    mem[0] = address(stor5[idx].field_0)
                    mem[32] = sha3(arg1, 1) + 3
                    if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                        _8350 = mem[64]
                        mem[mem[64]] = 0
                        mem[mem[64] + 32] = 0
                        mem[64] = mem[64] + 64
                        _9249 = mem[_8350]
                        v = 0
                        w = u
                        while v < _9249:
                            if v >= mem[_8350]:
                                revert with 0, 50
                            if w >= mem[_5339]:
                                revert with 0, 50
                            mem[(32 * w) + _5339 + 32] = mem[(32 * v) + _8350 + 32]
                            if v >= mem[_8350 + 32]:
                                revert with 0, 50
                            if w >= mem[_5339 + (32 * s + t) + 32]:
                                revert with 0, 50
                            mem[(32 * w) + _5339 + (32 * s + t) + 64] = mem[(32 * v) + _8350 + 64]
                            if w == -1:
                                revert with 0, 17
                            if v == -1:
                                revert with 0, 17
                            _9249 = mem[_8350]
                            v = v + 1
                            w = w + 1
                            continue 
                    else:
                        mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = arg1
                        mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                        require ext_code.size(address(stor5[idx].field_256))
                        staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                                gas gas_remaining wei
                               args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _8605 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 64
                        _8668 = mem[_8605]
                        require mem[_8605] <= test266151307()
                        require _8605 + mem[_8605] + 31 < _8605 + return_data.size
                        _8738 = mem[_8605 + mem[_8605]]
                        if mem[_8605 + mem[_8605]] > test266151307():
                            revert with 0, 65
                        if ceil32(32 * mem[_8605 + mem[_8605]]) + 1 < 0 or _8605 + ceil32(return_data.size) + ceil32(32 * mem[_8605 + mem[_8605]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = _8605 + ceil32(return_data.size) + ceil32(32 * mem[_8605 + mem[_8605]]) + 1
                        mem[_8605 + ceil32(return_data.size)] = _8738
                        require _8668 + (32 * _8738) + 32 <= return_data.size
                        v = 0
                        w = _8605 + _8668 + 32
                        x = _8605 + ceil32(return_data.size) + 32
                        while v < _8738:
                            mem[x] = mem[w]
                            v = v + 1
                            w = w + 32
                            x = x + 32
                            continue 
                        _9402 = mem[_8605 + 32]
                        require mem[_8605 + 32] <= test266151307()
                        require _8605 + mem[_8605 + 32] + 31 < _8605 + return_data.size
                        _9530 = mem[_8605 + mem[_8605 + 32]]
                        if mem[_8605 + mem[_8605 + 32]] > test266151307():
                            revert with 0, 65
                        _9604 = mem[64]
                        if mem[64] + ceil32(32 * mem[_8605 + mem[_8605 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_8605 + mem[_8605 + 32]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = mem[64] + ceil32(32 * mem[_8605 + mem[_8605 + 32]]) + 1
                        mem[_9604] = _9530
                        require _9402 + (32 * _9530) + 32 <= return_data.size
                        v = 0
                        w = _8605 + _9402 + 32
                        x = _9604 + 32
                        while v < _9530:
                            mem[x] = mem[w]
                            v = v + 1
                            w = w + 32
                            x = x + 32
                            continue 
                        _10309 = mem[_8605 + ceil32(return_data.size)]
                        v = 0
                        w = u
                        while v < _10309:
                            if v >= mem[_8605 + ceil32(return_data.size)]:
                                revert with 0, 50
                            if w >= mem[_5339]:
                                revert with 0, 50
                            mem[(32 * w) + _5339 + 32] = mem[(32 * v) + _8605 + ceil32(return_data.size) + 32]
                            if v >= mem[_9604]:
                                revert with 0, 50
                            if w >= mem[_5339 + (32 * s + t) + 32]:
                                revert with 0, 50
                            mem[(32 * w) + _5339 + (32 * s + t) + 64] = mem[(32 * v) + _9604 + 32]
                            if w == -1:
                                revert with 0, 17
                            if v == -1:
                                revert with 0, 17
                            _10309 = mem[_8605 + ceil32(return_data.size)]
                            v = v + 1
                            w = w + 1
                            continue 
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                if s > !t:
                    revert with 0, 17
                if u != s + t:
                    revert with 0, 1
                if 1 >= stor9.length:
                    revert with 0, 50
                mem[0] = 9
                mem[mem[64]] = 0x15d2cfca00000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 64
                _8535 = mem[_5339]
                mem[mem[64] + 68] = mem[_5339]
                mem[mem[64] + 100 len 32 * _8535] = mem[_5339 + 32 len 32 * _8535]
                idx = _8535
                var66002 = _5339 + (32 * _8535) + 32
                mem[mem[64] + 36] = arg1
                require ext_code.size(address(stor9.field_256))
                staticcall address(stor9.field_256).0x15d2cfca with:
                        gas gas_remaining wei
                       args 64, arg1, mem[mem[64] + 68 len (32 * _8535) + 32]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _9529 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _9572 = mem[_9529]
                require mem[_9529] <= test266151307()
                require _9529 + mem[_9529] + 31 < _9529 + return_data.size
                _9633 = mem[_9529 + mem[_9529]]
                if mem[_9529 + mem[_9529]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_9529 + mem[_9529]]) + 1 < 0 or _9529 + ceil32(return_data.size) + ceil32(32 * mem[_9529 + mem[_9529]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _9529 + ceil32(return_data.size) + ceil32(32 * mem[_9529 + mem[_9529]]) + 1
                mem[_9529 + ceil32(return_data.size)] = _9633
                require _9572 + (32 * _9633) + 32 <= return_data.size
                mem[_9529 + ceil32(return_data.size) + 32 len 32 * _9633] = mem[_9529 + _9572 + 32 len 32 * _9633]
                mem[mem[64]] = 32
                mem[mem[64] + 32] = _9633
                mem[mem[64] + 64 len 32 * _9633] = mem[_9529 + ceil32(return_data.size) + 32 len 32 * _9633]
                var93001 = _9633
                var93002 = _9529 + ceil32(return_data.size) + (32 * _9633) + 32
                return Array(len=_9633, data=mem[mem[64] + 64 len 32 * _9633])
            mem[_5339 + (32 * s + t) + 64 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
            _6802 = mem[mem[ceil32(return_data.size) + 160]]
            idx = 0
            u = 0
            while idx < _6802:
                mem[0] = arg1
                mem[32] = 1
                mem[mem[64] + 32] = idx
                mem[mem[64] + 64] = stor1[arg1].field_512
                mem[mem[64] + 96] = stor8
                _6930 = mem[64]
                mem[mem[64]] = 96
                mem[64] = mem[64] + 128
                if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                    revert with 0, 50
                if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    revert with 0, 18
                if sha3(mem[_6930 + 32 len mem[_6930]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    if idx == -1:
                        revert with 0, 17
                    _6802 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = idx + 1
                    u = u
                    continue 
                if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                    revert with 0, 50
                if u >= mem[_5339]:
                    revert with 0, 50
                mem[(32 * u) + _5339 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                    revert with 0, 50
                if u >= mem[_5339 + (32 * s + t) + 32]:
                    revert with 0, 50
                mem[(32 * u) + _5339 + (32 * s + t) + 64] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                if u == -1:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _6802 = mem[mem[ceil32(return_data.size) + 160]]
                idx = idx + 1
                u = u + 1
                continue 
            idx = 0
            while idx < stor5.length:
                mem[0] = 5
                _8329 = mem[64]
                mem[64] = mem[64] + 64
                mem[_8329] = address(stor5[idx].field_0)
                mem[_8329 + 32] = address(stor5[idx].field_256)
                mem[0] = address(stor5[idx].field_0)
                mem[32] = sha3(arg1, 1) + 3
                if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                    _8351 = mem[64]
                    mem[mem[64]] = 0
                    mem[mem[64] + 32] = 0
                    mem[64] = mem[64] + 64
                    _9250 = mem[_8351]
                    v = 0
                    w = u
                    while v < _9250:
                        if v >= mem[_8351]:
                            revert with 0, 50
                        if w >= mem[_5339]:
                            revert with 0, 50
                        mem[(32 * w) + _5339 + 32] = mem[(32 * v) + _8351 + 32]
                        if v >= mem[_8351 + 32]:
                            revert with 0, 50
                        if w >= mem[_5339 + (32 * s + t) + 32]:
                            revert with 0, 50
                        mem[(32 * w) + _5339 + (32 * s + t) + 64] = mem[(32 * v) + _8351 + 64]
                        if w == -1:
                            revert with 0, 17
                        if v == -1:
                            revert with 0, 17
                        _9250 = mem[_8351]
                        v = v + 1
                        w = w + 1
                        continue 
                else:
                    mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = arg1
                    mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    require ext_code.size(address(stor5[idx].field_256))
                    staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                            gas gas_remaining wei
                           args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _8608 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 64
                    _8671 = mem[_8608]
                    require mem[_8608] <= test266151307()
                    require _8608 + mem[_8608] + 31 < _8608 + return_data.size
                    _8740 = mem[_8608 + mem[_8608]]
                    if mem[_8608 + mem[_8608]] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[_8608 + mem[_8608]]) + 1 < 0 or _8608 + ceil32(return_data.size) + ceil32(32 * mem[_8608 + mem[_8608]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = _8608 + ceil32(return_data.size) + ceil32(32 * mem[_8608 + mem[_8608]]) + 1
                    mem[_8608 + ceil32(return_data.size)] = _8740
                    require _8671 + (32 * _8740) + 32 <= return_data.size
                    v = 0
                    w = _8608 + _8671 + 32
                    x = _8608 + ceil32(return_data.size) + 32
                    while v < _8740:
                        mem[x] = mem[w]
                        v = v + 1
                        w = w + 32
                        x = x + 32
                        continue 
                    _9405 = mem[_8608 + 32]
                    require mem[_8608 + 32] <= test266151307()
                    require _8608 + mem[_8608 + 32] + 31 < _8608 + return_data.size
                    _9532 = mem[_8608 + mem[_8608 + 32]]
                    if mem[_8608 + mem[_8608 + 32]] > test266151307():
                        revert with 0, 65
                    _9605 = mem[64]
                    if mem[64] + ceil32(32 * mem[_8608 + mem[_8608 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_8608 + mem[_8608 + 32]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = mem[64] + ceil32(32 * mem[_8608 + mem[_8608 + 32]]) + 1
                    mem[_9605] = _9532
                    require _9405 + (32 * _9532) + 32 <= return_data.size
                    v = 0
                    w = _8608 + _9405 + 32
                    x = _9605 + 32
                    while v < _9532:
                        mem[x] = mem[w]
                        v = v + 1
                        w = w + 32
                        x = x + 32
                        continue 
                    _10310 = mem[_8608 + ceil32(return_data.size)]
                    v = 0
                    w = u
                    while v < _10310:
                        if v >= mem[_8608 + ceil32(return_data.size)]:
                            revert with 0, 50
                        if w >= mem[_5339]:
                            revert with 0, 50
                        mem[(32 * w) + _5339 + 32] = mem[(32 * v) + _8608 + ceil32(return_data.size) + 32]
                        if v >= mem[_9605]:
                            revert with 0, 50
                        if w >= mem[_5339 + (32 * s + t) + 32]:
                            revert with 0, 50
                        mem[(32 * w) + _5339 + (32 * s + t) + 64] = mem[(32 * v) + _9605 + 32]
                        if w == -1:
                            revert with 0, 17
                        if v == -1:
                            revert with 0, 17
                        _10310 = mem[_8608 + ceil32(return_data.size)]
                        v = v + 1
                        w = w + 1
                        continue 
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            if s > !t:
                revert with 0, 17
            if u != s + t:
                revert with 0, 1
            if 1 >= stor9.length:
                revert with 0, 50
            mem[0] = 9
            mem[mem[64]] = 0x15d2cfca00000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 64
            _8537 = mem[_5339]
            mem[mem[64] + 68] = mem[_5339]
            mem[mem[64] + 100 len 32 * _8537] = mem[_5339 + 32 len 32 * _8537]
            idx = _8537
            var67002 = _5339 + (32 * _8537) + 32
            mem[mem[64] + 36] = arg1
            require ext_code.size(address(stor9.field_256))
            staticcall address(stor9.field_256).0x15d2cfca with:
                    gas gas_remaining wei
                   args 64, arg1, mem[mem[64] + 68 len (32 * _8537) + 32]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _9531 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _9573 = mem[_9531]
            require mem[_9531] <= test266151307()
            require _9531 + mem[_9531] + 31 < _9531 + return_data.size
            _9634 = mem[_9531 + mem[_9531]]
            if mem[_9531 + mem[_9531]] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[_9531 + mem[_9531]]) + 1 < 0 or _9531 + ceil32(return_data.size) + ceil32(32 * mem[_9531 + mem[_9531]]) + 1 > test266151307():
                revert with 0, 65
            mem[64] = _9531 + ceil32(return_data.size) + ceil32(32 * mem[_9531 + mem[_9531]]) + 1
            mem[_9531 + ceil32(return_data.size)] = _9634
            require _9573 + (32 * _9634) + 32 <= return_data.size
            mem[_9531 + ceil32(return_data.size) + 32 len 32 * _9634] = mem[_9531 + _9573 + 32 len 32 * _9634]
            mem[mem[64]] = 32
            mem[mem[64] + 32] = _9634
            mem[mem[64] + 64 len 32 * _9634] = mem[_9531 + ceil32(return_data.size) + 32 len 32 * _9634]
            var94001 = _9634
            var94002 = _9531 + ceil32(return_data.size) + (32 * _9634) + 32
            return Array(len=_9634, data=mem[mem[64] + 64 len 32 * _9634])
        if s > !t:
            revert with 0, 17
        if s + t > test266151307():
            revert with 0, 65
        _5536 = mem[64] + (32 * s + t) + 32
        mem[mem[64] + (32 * s + t) + 32] = s + t
        mem[64] = _5536 + (32 * s + t) + 32
        if s + t:
            mem[_5536 + 32 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
            _6798 = mem[mem[ceil32(return_data.size) + 160]]
            idx = 0
            u = 0
            while idx < _6798:
                mem[0] = arg1
                mem[32] = 1
                mem[mem[64] + 32] = idx
                mem[mem[64] + 64] = stor1[arg1].field_512
                mem[mem[64] + 96] = stor8
                _6916 = mem[64]
                mem[mem[64]] = 96
                mem[64] = mem[64] + 128
                if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                    revert with 0, 50
                if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    revert with 0, 18
                if sha3(mem[_6916 + 32 len mem[_6916]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    if idx == -1:
                        revert with 0, 17
                    _6798 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = idx + 1
                    u = u
                    continue 
                if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                    revert with 0, 50
                if u >= mem[_5339]:
                    revert with 0, 50
                mem[(32 * u) + _5339 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                    revert with 0, 50
                if u >= mem[_5536]:
                    revert with 0, 50
                mem[(32 * u) + _5536 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                if u == -1:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _6798 = mem[mem[ceil32(return_data.size) + 160]]
                idx = idx + 1
                u = u + 1
                continue 
            idx = 0
            while idx < stor5.length:
                mem[0] = 5
                _8319 = mem[64]
                mem[64] = mem[64] + 64
                mem[_8319] = address(stor5[idx].field_0)
                mem[_8319 + 32] = address(stor5[idx].field_256)
                mem[0] = address(stor5[idx].field_0)
                mem[32] = sha3(arg1, 1) + 3
                if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                    _8349 = mem[64]
                    mem[mem[64]] = 0
                    mem[mem[64] + 32] = 0
                    mem[64] = mem[64] + 64
                    _9248 = mem[_8349]
                    s = 0
                    t = u
                    while s < _9248:
                        if s >= mem[_8349]:
                            revert with 0, 50
                        if t >= mem[_5339]:
                            revert with 0, 50
                        mem[(32 * t) + _5339 + 32] = mem[(32 * s) + _8349 + 32]
                        if s >= mem[_8349 + 32]:
                            revert with 0, 50
                        if t >= mem[_5536]:
                            revert with 0, 50
                        mem[(32 * t) + _5536 + 32] = mem[(32 * s) + _8349 + 64]
                        if t == -1:
                            revert with 0, 17
                        if s == -1:
                            revert with 0, 17
                        _9248 = mem[_8349]
                        s = s + 1
                        t = t + 1
                        continue 
                else:
                    mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = arg1
                    mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    require ext_code.size(address(stor5[idx].field_256))
                    staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                            gas gas_remaining wei
                           args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _8602 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 64
                    _8665 = mem[_8602]
                    require mem[_8602] <= test266151307()
                    require _8602 + mem[_8602] + 31 < _8602 + return_data.size
                    _8736 = mem[_8602 + mem[_8602]]
                    if mem[_8602 + mem[_8602]] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[_8602 + mem[_8602]]) + 1 < 0 or _8602 + ceil32(return_data.size) + ceil32(32 * mem[_8602 + mem[_8602]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = _8602 + ceil32(return_data.size) + ceil32(32 * mem[_8602 + mem[_8602]]) + 1
                    mem[_8602 + ceil32(return_data.size)] = _8736
                    require _8665 + (32 * _8736) + 32 <= return_data.size
                    s = 0
                    t = _8602 + _8665 + 32
                    v = _8602 + ceil32(return_data.size) + 32
                    while s < _8736:
                        mem[v] = mem[t]
                        s = s + 1
                        t = t + 32
                        v = v + 32
                        continue 
                    _9399 = mem[_8602 + 32]
                    require mem[_8602 + 32] <= test266151307()
                    require _8602 + mem[_8602 + 32] + 31 < _8602 + return_data.size
                    _9528 = mem[_8602 + mem[_8602 + 32]]
                    if mem[_8602 + mem[_8602 + 32]] > test266151307():
                        revert with 0, 65
                    _9603 = mem[64]
                    if mem[64] + ceil32(32 * mem[_8602 + mem[_8602 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_8602 + mem[_8602 + 32]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = mem[64] + ceil32(32 * mem[_8602 + mem[_8602 + 32]]) + 1
                    mem[_9603] = _9528
                    require _9399 + (32 * _9528) + 32 <= return_data.size
                    s = 0
                    t = _8602 + _9399 + 32
                    v = _9603 + 32
                    while s < _9528:
                        mem[v] = mem[t]
                        s = s + 1
                        t = t + 32
                        v = v + 32
                        continue 
                    _10308 = mem[_8602 + ceil32(return_data.size)]
                    s = 0
                    t = u
                    while s < _10308:
                        if s >= mem[_8602 + ceil32(return_data.size)]:
                            revert with 0, 50
                        if t >= mem[_5339]:
                            revert with 0, 50
                        mem[(32 * t) + _5339 + 32] = mem[(32 * s) + _8602 + ceil32(return_data.size) + 32]
                        if s >= mem[_9603]:
                            revert with 0, 50
                        if t >= mem[_5536]:
                            revert with 0, 50
                        mem[(32 * t) + _5536 + 32] = mem[(32 * s) + _9603 + 32]
                        if t == -1:
                            revert with 0, 17
                        if s == -1:
                            revert with 0, 17
                        _10308 = mem[_8602 + ceil32(return_data.size)]
                        s = s + 1
                        t = t + 1
                        continue 
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            if s > !t:
                revert with 0, 17
            if u != s + t:
                revert with 0, 1
            if 1 >= stor9.length:
                revert with 0, 50
            mem[0] = 9
            mem[mem[64]] = 0x15d2cfca00000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 64
            _8533 = mem[_5339]
            mem[mem[64] + 68] = mem[_5339]
            mem[mem[64] + 100 len 32 * _8533] = mem[_5339 + 32 len 32 * _8533]
            idx = _8533
            var66002 = _5339 + (32 * _8533) + 32
            mem[mem[64] + 36] = arg1
            require ext_code.size(address(stor9.field_256))
            staticcall address(stor9.field_256).0x15d2cfca with:
                    gas gas_remaining wei
                   args 64, arg1, mem[mem[64] + 68 len (32 * _8533) + 32]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _9527 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _9571 = mem[_9527]
            require mem[_9527] <= test266151307()
            require _9527 + mem[_9527] + 31 < _9527 + return_data.size
            _9632 = mem[_9527 + mem[_9527]]
            if mem[_9527 + mem[_9527]] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[_9527 + mem[_9527]]) + 1 < 0 or _9527 + ceil32(return_data.size) + ceil32(32 * mem[_9527 + mem[_9527]]) + 1 > test266151307():
                revert with 0, 65
            mem[64] = _9527 + ceil32(return_data.size) + ceil32(32 * mem[_9527 + mem[_9527]]) + 1
            mem[_9527 + ceil32(return_data.size)] = _9632
            require _9571 + (32 * _9632) + 32 <= return_data.size
            mem[_9527 + ceil32(return_data.size) + 32 len 32 * _9632] = mem[_9527 + _9571 + 32 len 32 * _9632]
            mem[mem[64]] = 32
            mem[mem[64] + 32] = _9632
            mem[mem[64] + 64 len 32 * _9632] = mem[_9527 + ceil32(return_data.size) + 32 len 32 * _9632]
            var93001 = _9632
            var93002 = _9527 + ceil32(return_data.size) + (32 * _9632) + 32
            return Array(len=_9632, data=mem[mem[64] + 64 len 32 * _9632])
        _6796 = mem[mem[ceil32(return_data.size) + 160]]
        idx = 0
        u = 0
        while idx < _6796:
            mem[0] = arg1
            mem[32] = 1
            mem[mem[64] + 32] = idx
            mem[mem[64] + 64] = stor1[arg1].field_512
            mem[mem[64] + 96] = stor8
            _6909 = mem[64]
            mem[mem[64]] = 96
            mem[64] = mem[64] + 128
            if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                revert with 0, 50
            if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                revert with 0, 18
            if sha3(mem[_6909 + 32 len mem[_6909]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                if idx == -1:
                    revert with 0, 17
                _6796 = mem[mem[ceil32(return_data.size) + 160]]
                idx = idx + 1
                u = u
                continue 
            if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                revert with 0, 50
            if u >= mem[_5339]:
                revert with 0, 50
            mem[(32 * u) + _5339 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
            if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                revert with 0, 50
            if u >= mem[_5536]:
                revert with 0, 50
            mem[(32 * u) + _5536 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
            if u == -1:
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            _6796 = mem[mem[ceil32(return_data.size) + 160]]
            idx = idx + 1
            u = u + 1
            continue 
        idx = 0
        while idx < stor5.length:
            mem[0] = 5
            _8314 = mem[64]
            mem[64] = mem[64] + 64
            mem[_8314] = address(stor5[idx].field_0)
            mem[_8314 + 32] = address(stor5[idx].field_256)
            mem[0] = address(stor5[idx].field_0)
            mem[32] = sha3(arg1, 1) + 3
            if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                _8348 = mem[64]
                mem[mem[64]] = 0
                mem[mem[64] + 32] = 0
                mem[64] = mem[64] + 64
                _9247 = mem[_8348]
                s = 0
                t = u
                while s < _9247:
                    if s >= mem[_8348]:
                        revert with 0, 50
                    if t >= mem[_5339]:
                        revert with 0, 50
                    mem[(32 * t) + _5339 + 32] = mem[(32 * s) + _8348 + 32]
                    if s >= mem[_8348 + 32]:
                        revert with 0, 50
                    if t >= mem[_5536]:
                        revert with 0, 50
                    mem[(32 * t) + _5536 + 32] = mem[(32 * s) + _8348 + 64]
                    if t == -1:
                        revert with 0, 17
                    if s == -1:
                        revert with 0, 17
                    _9247 = mem[_8348]
                    s = s + 1
                    t = t + 1
                    continue 
            else:
                mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = arg1
                mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                require ext_code.size(address(stor5[idx].field_256))
                staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                        gas gas_remaining wei
                       args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _8599 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 64
                _8662 = mem[_8599]
                require mem[_8599] <= test266151307()
                require _8599 + mem[_8599] + 31 < _8599 + return_data.size
                _8734 = mem[_8599 + mem[_8599]]
                if mem[_8599 + mem[_8599]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_8599 + mem[_8599]]) + 1 < 0 or _8599 + ceil32(return_data.size) + ceil32(32 * mem[_8599 + mem[_8599]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _8599 + ceil32(return_data.size) + ceil32(32 * mem[_8599 + mem[_8599]]) + 1
                mem[_8599 + ceil32(return_data.size)] = _8734
                require _8662 + (32 * _8734) + 32 <= return_data.size
                s = 0
                t = _8599 + _8662 + 32
                v = _8599 + ceil32(return_data.size) + 32
                while s < _8734:
                    mem[v] = mem[t]
                    s = s + 1
                    t = t + 32
                    v = v + 32
                    continue 
                _9396 = mem[_8599 + 32]
                require mem[_8599 + 32] <= test266151307()
                require _8599 + mem[_8599 + 32] + 31 < _8599 + return_data.size
                _9526 = mem[_8599 + mem[_8599 + 32]]
                if mem[_8599 + mem[_8599 + 32]] > test266151307():
                    revert with 0, 65
                _9602 = mem[64]
                if mem[64] + ceil32(32 * mem[_8599 + mem[_8599 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_8599 + mem[_8599 + 32]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = mem[64] + ceil32(32 * mem[_8599 + mem[_8599 + 32]]) + 1
                mem[_9602] = _9526
                require _9396 + (32 * _9526) + 32 <= return_data.size
                s = 0
                t = _8599 + _9396 + 32
                v = _9602 + 32
                while s < _9526:
                    mem[v] = mem[t]
                    s = s + 1
                    t = t + 32
                    v = v + 32
                    continue 
                _10307 = mem[_8599 + ceil32(return_data.size)]
                s = 0
                t = u
                while s < _10307:
                    if s >= mem[_8599 + ceil32(return_data.size)]:
                        revert with 0, 50
                    if t >= mem[_5339]:
                        revert with 0, 50
                    mem[(32 * t) + _5339 + 32] = mem[(32 * s) + _8599 + ceil32(return_data.size) + 32]
                    if s >= mem[_9602]:
                        revert with 0, 50
                    if t >= mem[_5536]:
                        revert with 0, 50
                    mem[(32 * t) + _5536 + 32] = mem[(32 * s) + _9602 + 32]
                    if t == -1:
                        revert with 0, 17
                    if s == -1:
                        revert with 0, 17
                    _10307 = mem[_8599 + ceil32(return_data.size)]
                    s = s + 1
                    t = t + 1
                    continue 
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        if s > !t:
            revert with 0, 17
        if u != s + t:
            revert with 0, 1
        if 1 >= stor9.length:
            revert with 0, 50
        mem[0] = 9
        mem[mem[64]] = 0x15d2cfca00000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = 64
        _8531 = mem[_5339]
        mem[mem[64] + 68] = mem[_5339]
        mem[mem[64] + 100 len 32 * _8531] = mem[_5339 + 32 len 32 * _8531]
        idx = _8531
        var65002 = _5339 + (32 * _8531) + 32
        mem[mem[64] + 36] = arg1
        require ext_code.size(address(stor9.field_256))
        staticcall address(stor9.field_256).0x15d2cfca with:
                gas gas_remaining wei
               args 64, arg1, mem[mem[64] + 68 len (32 * _8531) + 32]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _9525 = mem[64]
        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _9570 = mem[_9525]
        require mem[_9525] <= test266151307()
        require _9525 + mem[_9525] + 31 < _9525 + return_data.size
        _9631 = mem[_9525 + mem[_9525]]
        if mem[_9525 + mem[_9525]] > test266151307():
            revert with 0, 65
        if ceil32(32 * mem[_9525 + mem[_9525]]) + 1 < 0 or _9525 + ceil32(return_data.size) + ceil32(32 * mem[_9525 + mem[_9525]]) + 1 > test266151307():
            revert with 0, 65
        mem[64] = _9525 + ceil32(return_data.size) + ceil32(32 * mem[_9525 + mem[_9525]]) + 1
        mem[_9525 + ceil32(return_data.size)] = _9631
        require _9570 + (32 * _9631) + 32 <= return_data.size
        mem[_9525 + ceil32(return_data.size) + 32 len 32 * _9631] = mem[_9525 + _9570 + 32 len 32 * _9631]
        var84001 = _9631
        var84002 = _9525 + _9570 + (32 * _9631) + 32
        var84004 = _9525 + ceil32(return_data.size) + (32 * _9631) + 32
        mem[mem[64]] = 32
        mem[mem[64] + 32] = _9631
        mem[mem[64] + 64 len 32 * _9631] = mem[_9525 + ceil32(return_data.size) + 32 len 32 * _9631]
        var92001 = _9631
        var92002 = _9525 + ceil32(return_data.size) + (32 * _9631) + 32
        return Array(len=_9631, data=mem[mem[64] + 64 len 32 * _9631])
    mem[0] = sha3(ext_call.return_data[31 len 1], 10) + 2
    mem[ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 288] = stor10[ext_call.return_data[31 len 1]][2].field_0
    idx = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 288
    s = 0
    while ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + (32 * stor10[ext_call.return_data[31 len 1]].field_512) + 256 > idx:
        mem[idx + 32] = stor10[ext_call.return_data[31 len 1]][s + 2].field_256
        idx = idx + 32
        s = s + 1
        continue 
    mem[ceil32(return_data.size) + 160] = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 256
    idx = 0
    s = 0
    while idx < stor10[ext_call.return_data[31 len 1]].field_512:
        mem[0] = arg1
        mem[32] = 1
        mem[mem[64] + 32] = idx
        mem[mem[64] + 64] = stor1[arg1].field_512
        mem[mem[64] + 96] = stor8
        _6938 = mem[64]
        mem[mem[64]] = 96
        mem[64] = mem[64] + 128
        if idx >= mem[mem[ceil32(return_data.size) + 160]]:
            revert with 0, 50
        if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
            revert with 0, 18
        if sha3(mem[_6938 + 32 len mem[_6938]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = s
            continue 
        if s == -1:
            revert with 0, 17
        if idx == -1:
            revert with 0, 17
        idx = idx + 1
        s = s + 1
        continue 
    idx = 0
    t = 0
    while idx < stor5.length:
        mem[0] = 5
        _8334 = mem[64]
        mem[64] = mem[64] + 64
        mem[_8334] = address(stor5[idx].field_0)
        mem[_8334 + 32] = address(stor5[idx].field_256)
        mem[0] = address(stor5[idx].field_0)
        mem[32] = sha3(arg1, 1) + 3
        if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
            _8354 = mem[64]
            mem[mem[64]] = 0
            mem[mem[64] + 32] = 0
            mem[64] = mem[64] + 64
            if t > !mem[_8354]:
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            t = t + mem[_8354]
            continue 
        mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = arg1
        mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
        require ext_code.size(address(stor5[idx].field_256))
        staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                gas gas_remaining wei
               args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _8612 = mem[64]
        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 64
        _8676 = mem[_8612]
        require mem[_8612] <= test266151307()
        require _8612 + mem[_8612] + 31 < _8612 + return_data.size
        _8750 = mem[_8612 + mem[_8612]]
        if mem[_8612 + mem[_8612]] > test266151307():
            revert with 0, 65
        if ceil32(32 * mem[_8612 + mem[_8612]]) + 1 < 0 or _8612 + ceil32(return_data.size) + ceil32(32 * mem[_8612 + mem[_8612]]) + 1 > test266151307():
            revert with 0, 65
        mem[64] = _8612 + ceil32(return_data.size) + ceil32(32 * mem[_8612 + mem[_8612]]) + 1
        mem[_8612 + ceil32(return_data.size)] = _8750
        require _8676 + (32 * _8750) + 32 <= return_data.size
        s = 0
        u = _8612 + _8676 + 32
        v = _8612 + ceil32(return_data.size) + 32
        while s < _8750:
            mem[v] = mem[u]
            s = s + 1
            u = u + 32
            v = v + 32
            continue 
        _9412 = mem[_8612 + 32]
        require mem[_8612 + 32] <= test266151307()
        require _8612 + mem[_8612 + 32] + 31 < _8612 + return_data.size
        _9533 = mem[_8612 + mem[_8612 + 32]]
        if mem[_8612 + mem[_8612 + 32]] > test266151307():
            revert with 0, 65
        _9622 = mem[64]
        if mem[64] + ceil32(32 * mem[_8612 + mem[_8612 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_8612 + mem[_8612 + 32]]) + 1 > test266151307():
            revert with 0, 65
        mem[64] = mem[64] + ceil32(32 * mem[_8612 + mem[_8612 + 32]]) + 1
        mem[_9622] = _9533
        require _9412 + (32 * _9533) + 32 <= return_data.size
        s = 0
        u = _8612 + _9412 + 32
        v = _9622 + 32
        while s < _9533:
            mem[v] = mem[u]
            s = s + 1
            u = u + 32
            v = v + 32
            continue 
        if t > !mem[_8612 + ceil32(return_data.size)]:
            revert with 0, 17
        if idx == -1:
            revert with 0, 17
        idx = idx + 1
        t = t + mem[_8612 + ceil32(return_data.size)]
        continue 
    if s > !t:
        revert with 0, 17
    if s + t > test266151307():
        revert with 0, 65
    _8353 = mem[64]
    mem[mem[64]] = s + t
    if not s + t:
        if s > !t:
            revert with 0, 17
        if s + t > test266151307():
            revert with 0, 65
        _8611 = mem[64] + (32 * s + t) + 32
        mem[mem[64] + (32 * s + t) + 32] = s + t
        mem[64] = _8611 + (32 * s + t) + 32
        if not s + t:
            _9252 = mem[mem[ceil32(return_data.size) + 160]]
            idx = 0
            u = 0
            while idx < _9252:
                mem[0] = arg1
                mem[32] = 1
                mem[mem[64] + 32] = idx
                mem[mem[64] + 64] = stor1[arg1].field_512
                mem[mem[64] + 96] = stor8
                _9321 = mem[64]
                mem[mem[64]] = 96
                mem[64] = mem[64] + 128
                if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                    revert with 0, 50
                if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    revert with 0, 18
                if sha3(mem[_9321 + 32 len mem[_9321]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    if idx == -1:
                        revert with 0, 17
                    _9252 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = idx + 1
                    u = u
                    continue 
                if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                    revert with 0, 50
                if u >= mem[_8353]:
                    revert with 0, 50
                mem[(32 * u) + _8353 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                    revert with 0, 50
                if u >= mem[_8611]:
                    revert with 0, 50
                mem[(32 * u) + _8611 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                if u == -1:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _9252 = mem[mem[ceil32(return_data.size) + 160]]
                idx = idx + 1
                u = u + 1
                continue 
            idx = 0
            while idx < stor5.length:
                mem[0] = 5
                _9995 = mem[64]
                mem[64] = mem[64] + 64
                mem[_9995] = address(stor5[idx].field_0)
                mem[_9995 + 32] = address(stor5[idx].field_256)
                mem[0] = address(stor5[idx].field_0)
                mem[32] = sha3(arg1, 1) + 3
                if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                    _10014 = mem[64]
                    mem[mem[64]] = 0
                    mem[mem[64] + 32] = 0
                    mem[64] = mem[64] + 64
                    _10311 = mem[_10014]
                    s = 0
                    t = u
                    while s < _10311:
                        if s >= mem[_10014]:
                            revert with 0, 50
                        if t >= mem[_8353]:
                            revert with 0, 50
                        mem[(32 * t) + _8353 + 32] = mem[(32 * s) + _10014 + 32]
                        if s >= mem[_10014 + 32]:
                            revert with 0, 50
                        if t >= mem[_8611]:
                            revert with 0, 50
                        mem[(32 * t) + _8611 + 32] = mem[(32 * s) + _10014 + 64]
                        if t == -1:
                            revert with 0, 17
                        if s == -1:
                            revert with 0, 17
                        _10311 = mem[_10014]
                        s = s + 1
                        t = t + 1
                        continue 
                else:
                    mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = arg1
                    mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    require ext_code.size(address(stor5[idx].field_256))
                    staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                            gas gas_remaining wei
                           args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _10171 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 64
                    _10191 = mem[_10171]
                    require mem[_10171] <= test266151307()
                    require _10171 + mem[_10171] + 31 < _10171 + return_data.size
                    _10208 = mem[_10171 + mem[_10171]]
                    if mem[_10171 + mem[_10171]] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[_10171 + mem[_10171]]) + 1 < 0 or _10171 + ceil32(return_data.size) + ceil32(32 * mem[_10171 + mem[_10171]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = _10171 + ceil32(return_data.size) + ceil32(32 * mem[_10171 + mem[_10171]]) + 1
                    mem[_10171 + ceil32(return_data.size)] = _10208
                    require _10191 + (32 * _10208) + 32 <= return_data.size
                    s = 0
                    t = _10171 + _10191 + 32
                    v = _10171 + ceil32(return_data.size) + 32
                    while s < _10208:
                        mem[v] = mem[t]
                        s = s + 1
                        t = t + 32
                        v = v + 32
                        continue 
                    _10375 = mem[_10171 + 32]
                    require mem[_10171 + 32] <= test266151307()
                    require _10171 + mem[_10171 + 32] + 31 < _10171 + return_data.size
                    _10452 = mem[_10171 + mem[_10171 + 32]]
                    if mem[_10171 + mem[_10171 + 32]] > test266151307():
                        revert with 0, 65
                    _10463 = mem[64]
                    if mem[64] + ceil32(32 * mem[_10171 + mem[_10171 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_10171 + mem[_10171 + 32]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = mem[64] + ceil32(32 * mem[_10171 + mem[_10171 + 32]]) + 1
                    mem[_10463] = _10452
                    require _10375 + (32 * _10452) + 32 <= return_data.size
                    s = 0
                    t = _10171 + _10375 + 32
                    v = _10463 + 32
                    while s < _10452:
                        mem[v] = mem[t]
                        s = s + 1
                        t = t + 32
                        v = v + 32
                        continue 
                    _10579 = mem[_10171 + ceil32(return_data.size)]
                    s = 0
                    t = u
                    while s < _10579:
                        if s >= mem[_10171 + ceil32(return_data.size)]:
                            revert with 0, 50
                        if t >= mem[_8353]:
                            revert with 0, 50
                        mem[(32 * t) + _8353 + 32] = mem[(32 * s) + _10171 + ceil32(return_data.size) + 32]
                        if s >= mem[_10463]:
                            revert with 0, 50
                        if t >= mem[_8611]:
                            revert with 0, 50
                        mem[(32 * t) + _8611 + 32] = mem[(32 * s) + _10463 + 32]
                        if t == -1:
                            revert with 0, 17
                        if s == -1:
                            revert with 0, 17
                        _10579 = mem[_10171 + ceil32(return_data.size)]
                        s = s + 1
                        t = t + 1
                        continue 
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            if s > !t:
                revert with 0, 17
            if u != s + t:
                revert with 0, 1
            if 1 >= stor9.length:
                revert with 0, 50
            mem[0] = 9
            mem[mem[64]] = 0x15d2cfca00000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 64
            _10127 = mem[_8353]
            mem[mem[64] + 68] = mem[_8353]
            mem[mem[64] + 100 len 32 * _10127] = mem[_8353 + 32 len 32 * _10127]
            idx = _10127
            var69002 = _8353 + (32 * _10127) + 32
            mem[mem[64] + 36] = arg1
            require ext_code.size(address(stor9.field_256))
            staticcall address(stor9.field_256).0x15d2cfca with:
                    gas gas_remaining wei
                   args 64, arg1, mem[mem[64] + 68 len (32 * _10127) + 32]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _10451 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _10459 = mem[_10451]
            require mem[_10451] <= test266151307()
            require _10451 + mem[_10451] + 31 < _10451 + return_data.size
            _10467 = mem[_10451 + mem[_10451]]
            if mem[_10451 + mem[_10451]] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[_10451 + mem[_10451]]) + 1 < 0 or _10451 + ceil32(return_data.size) + ceil32(32 * mem[_10451 + mem[_10451]]) + 1 > test266151307():
                revert with 0, 65
            mem[64] = _10451 + ceil32(return_data.size) + ceil32(32 * mem[_10451 + mem[_10451]]) + 1
            mem[_10451 + ceil32(return_data.size)] = _10467
            require _10459 + (32 * _10467) + 32 <= return_data.size
            mem[_10451 + ceil32(return_data.size) + 32 len 32 * _10467] = mem[_10451 + _10459 + 32 len 32 * _10467]
            var88001 = _10467
            var88002 = _10451 + _10459 + (32 * _10467) + 32
            var88004 = _10451 + ceil32(return_data.size) + (32 * _10467) + 32
            mem[mem[64]] = 32
            mem[mem[64] + 32] = _10467
            mem[mem[64] + 64 len 32 * _10467] = mem[_10451 + ceil32(return_data.size) + 32 len 32 * _10467]
            var96001 = _10467
            var96002 = _10451 + ceil32(return_data.size) + (32 * _10467) + 32
            return Array(len=_10467, data=mem[mem[64] + 64 len 32 * _10467])
        mem[_8611 + 32 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
        _9254 = mem[mem[ceil32(return_data.size) + 160]]
        idx = 0
        u = 0
        while idx < _9254:
            mem[0] = arg1
            mem[32] = 1
            mem[mem[64] + 32] = idx
            mem[mem[64] + 64] = stor1[arg1].field_512
            mem[mem[64] + 96] = stor8
            _9328 = mem[64]
            mem[mem[64]] = 96
            mem[64] = mem[64] + 128
            if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                revert with 0, 50
            if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                revert with 0, 18
            if sha3(mem[_9328 + 32 len mem[_9328]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                if idx == -1:
                    revert with 0, 17
                _9254 = mem[mem[ceil32(return_data.size) + 160]]
                idx = idx + 1
                u = u
                continue 
            if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                revert with 0, 50
            if u >= mem[_8353]:
                revert with 0, 50
            mem[(32 * u) + _8353 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
            if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                revert with 0, 50
            if u >= mem[_8611]:
                revert with 0, 50
            mem[(32 * u) + _8611 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
            if u == -1:
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            _9254 = mem[mem[ceil32(return_data.size) + 160]]
            idx = idx + 1
            u = u + 1
            continue 
        idx = 0
        while idx < stor5.length:
            mem[0] = 5
            _10000 = mem[64]
            mem[64] = mem[64] + 64
            mem[_10000] = address(stor5[idx].field_0)
            mem[_10000 + 32] = address(stor5[idx].field_256)
            mem[0] = address(stor5[idx].field_0)
            mem[32] = sha3(arg1, 1) + 3
            if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                _10015 = mem[64]
                mem[mem[64]] = 0
                mem[mem[64] + 32] = 0
                mem[64] = mem[64] + 64
                _10312 = mem[_10015]
                s = 0
                t = u
                while s < _10312:
                    if s >= mem[_10015]:
                        revert with 0, 50
                    if t >= mem[_8353]:
                        revert with 0, 50
                    mem[(32 * t) + _8353 + 32] = mem[(32 * s) + _10015 + 32]
                    if s >= mem[_10015 + 32]:
                        revert with 0, 50
                    if t >= mem[_8611]:
                        revert with 0, 50
                    mem[(32 * t) + _8611 + 32] = mem[(32 * s) + _10015 + 64]
                    if t == -1:
                        revert with 0, 17
                    if s == -1:
                        revert with 0, 17
                    _10312 = mem[_10015]
                    s = s + 1
                    t = t + 1
                    continue 
            else:
                mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = arg1
                mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                require ext_code.size(address(stor5[idx].field_256))
                staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                        gas gas_remaining wei
                       args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _10174 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 64
                _10194 = mem[_10174]
                require mem[_10174] <= test266151307()
                require _10174 + mem[_10174] + 31 < _10174 + return_data.size
                _10210 = mem[_10174 + mem[_10174]]
                if mem[_10174 + mem[_10174]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_10174 + mem[_10174]]) + 1 < 0 or _10174 + ceil32(return_data.size) + ceil32(32 * mem[_10174 + mem[_10174]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _10174 + ceil32(return_data.size) + ceil32(32 * mem[_10174 + mem[_10174]]) + 1
                mem[_10174 + ceil32(return_data.size)] = _10210
                require _10194 + (32 * _10210) + 32 <= return_data.size
                s = 0
                t = _10174 + _10194 + 32
                v = _10174 + ceil32(return_data.size) + 32
                while s < _10210:
                    mem[v] = mem[t]
                    s = s + 1
                    t = t + 32
                    v = v + 32
                    continue 
                _10378 = mem[_10174 + 32]
                require mem[_10174 + 32] <= test266151307()
                require _10174 + mem[_10174 + 32] + 31 < _10174 + return_data.size
                _10454 = mem[_10174 + mem[_10174 + 32]]
                if mem[_10174 + mem[_10174 + 32]] > test266151307():
                    revert with 0, 65
                _10464 = mem[64]
                if mem[64] + ceil32(32 * mem[_10174 + mem[_10174 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_10174 + mem[_10174 + 32]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = mem[64] + ceil32(32 * mem[_10174 + mem[_10174 + 32]]) + 1
                mem[_10464] = _10454
                require _10378 + (32 * _10454) + 32 <= return_data.size
                s = 0
                t = _10174 + _10378 + 32
                v = _10464 + 32
                while s < _10454:
                    mem[v] = mem[t]
                    s = s + 1
                    t = t + 32
                    v = v + 32
                    continue 
                _10580 = mem[_10174 + ceil32(return_data.size)]
                s = 0
                t = u
                while s < _10580:
                    if s >= mem[_10174 + ceil32(return_data.size)]:
                        revert with 0, 50
                    if t >= mem[_8353]:
                        revert with 0, 50
                    mem[(32 * t) + _8353 + 32] = mem[(32 * s) + _10174 + ceil32(return_data.size) + 32]
                    if s >= mem[_10464]:
                        revert with 0, 50
                    if t >= mem[_8611]:
                        revert with 0, 50
                    mem[(32 * t) + _8611 + 32] = mem[(32 * s) + _10464 + 32]
                    if t == -1:
                        revert with 0, 17
                    if s == -1:
                        revert with 0, 17
                    _10580 = mem[_10174 + ceil32(return_data.size)]
                    s = s + 1
                    t = t + 1
                    continue 
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        if s > !t:
            revert with 0, 17
        if u != s + t:
            revert with 0, 1
        if 1 >= stor9.length:
            revert with 0, 50
        mem[0] = 9
        mem[mem[64]] = 0x15d2cfca00000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = 64
        _10129 = mem[_8353]
        mem[mem[64] + 68] = mem[_8353]
        mem[mem[64] + 100 len 32 * _10129] = mem[_8353 + 32 len 32 * _10129]
        idx = _10129
        mem[mem[64] + 36] = arg1
        require ext_code.size(address(stor9.field_256))
        staticcall address(stor9.field_256).0x15d2cfca with:
                gas gas_remaining wei
               args 64, arg1, mem[mem[64] + 68 len (32 * _10129) + 32]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _10453 = mem[64]
        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _10460 = mem[_10453]
        require mem[_10453] <= test266151307()
        require _10453 + mem[_10453] + 31 < _10453 + return_data.size
        _10468 = mem[_10453 + mem[_10453]]
        if mem[_10453 + mem[_10453]] > test266151307():
            revert with 0, 65
        if ceil32(32 * mem[_10453 + mem[_10453]]) + 1 < 0 or _10453 + ceil32(return_data.size) + ceil32(32 * mem[_10453 + mem[_10453]]) + 1 > test266151307():
            revert with 0, 65
        mem[64] = _10453 + ceil32(return_data.size) + ceil32(32 * mem[_10453 + mem[_10453]]) + 1
        mem[_10453 + ceil32(return_data.size)] = _10468
        require _10460 + (32 * _10468) + 32 <= return_data.size
        mem[_10453 + ceil32(return_data.size) + 32 len 32 * _10468] = mem[_10453 + _10460 + 32 len 32 * _10468]
        var89001 = _10468
        var89002 = _10453 + _10460 + (32 * _10468) + 32
        var89004 = _10453 + ceil32(return_data.size) + (32 * _10468) + 32
        mem[mem[64]] = 32
        mem[mem[64] + 32] = _10468
        mem[mem[64] + 64 len 32 * _10468] = mem[_10453 + ceil32(return_data.size) + 32 len 32 * _10468]
        var97001 = _10468
        var97002 = _10453 + ceil32(return_data.size) + (32 * _10468) + 32
        return Array(len=_10468, data=mem[mem[64] + 64 len 32 * _10468])
    mem[mem[64] + 32 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
    if s > !t:
        revert with 0, 17
    if s + t > test266151307():
        revert with 0, 65
    mem[mem[64] + (32 * s + t) + 32] = s + t
    mem[64] = _8353 + (64 * s + t) + 64
    if not s + t:
        _9256 = mem[mem[ceil32(return_data.size) + 160]]
        idx = 0
        u = 0
        while idx < _9256:
            mem[0] = arg1
            mem[32] = 1
            mem[mem[64] + 32] = idx
            mem[mem[64] + 64] = stor1[arg1].field_512
            mem[mem[64] + 96] = stor8
            _9335 = mem[64]
            mem[mem[64]] = 96
            mem[64] = mem[64] + 128
            if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                revert with 0, 50
            if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                revert with 0, 18
            if sha3(mem[_9335 + 32 len mem[_9335]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                if idx == -1:
                    revert with 0, 17
                _9256 = mem[mem[ceil32(return_data.size) + 160]]
                idx = idx + 1
                u = u
                continue 
            if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                revert with 0, 50
            if u >= mem[_8353]:
                revert with 0, 50
            mem[(32 * u) + _8353 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
            if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                revert with 0, 50
            if u >= mem[_8353 + (32 * s + t) + 32]:
                revert with 0, 50
            mem[(32 * u) + _8353 + (32 * s + t) + 64] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
            if u == -1:
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            _9256 = mem[mem[ceil32(return_data.size) + 160]]
            idx = idx + 1
            u = u + 1
            continue 
        idx = 0
        while idx < stor5.length:
            mem[0] = 5
            _10005 = mem[64]
            mem[64] = mem[64] + 64
            mem[_10005] = address(stor5[idx].field_0)
            mem[_10005 + 32] = address(stor5[idx].field_256)
            mem[0] = address(stor5[idx].field_0)
            mem[32] = sha3(arg1, 1) + 3
            if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                _10016 = mem[64]
                mem[mem[64]] = 0
                mem[mem[64] + 32] = 0
                mem[64] = mem[64] + 64
                _10313 = mem[_10016]
                v = 0
                w = u
                while v < _10313:
                    if v >= mem[_10016]:
                        revert with 0, 50
                    if w >= mem[_8353]:
                        revert with 0, 50
                    mem[(32 * w) + _8353 + 32] = mem[(32 * v) + _10016 + 32]
                    if v >= mem[_10016 + 32]:
                        revert with 0, 50
                    if w >= mem[_8353 + (32 * s + t) + 32]:
                        revert with 0, 50
                    mem[(32 * w) + _8353 + (32 * s + t) + 64] = mem[(32 * v) + _10016 + 64]
                    if w == -1:
                        revert with 0, 17
                    if v == -1:
                        revert with 0, 17
                    _10313 = mem[_10016]
                    v = v + 1
                    w = w + 1
                    continue 
            else:
                mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = arg1
                mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                require ext_code.size(address(stor5[idx].field_256))
                staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                        gas gas_remaining wei
                       args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _10177 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 64
                _10197 = mem[_10177]
                require mem[_10177] <= test266151307()
                require _10177 + mem[_10177] + 31 < _10177 + return_data.size
                _10212 = mem[_10177 + mem[_10177]]
                if mem[_10177 + mem[_10177]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_10177 + mem[_10177]]) + 1 < 0 or _10177 + ceil32(return_data.size) + ceil32(32 * mem[_10177 + mem[_10177]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _10177 + ceil32(return_data.size) + ceil32(32 * mem[_10177 + mem[_10177]]) + 1
                mem[_10177 + ceil32(return_data.size)] = _10212
                require _10197 + (32 * _10212) + 32 <= return_data.size
                v = 0
                w = _10177 + _10197 + 32
                x = _10177 + ceil32(return_data.size) + 32
                while v < _10212:
                    mem[x] = mem[w]
                    v = v + 1
                    w = w + 32
                    x = x + 32
                    continue 
                _10381 = mem[_10177 + 32]
                require mem[_10177 + 32] <= test266151307()
                require _10177 + mem[_10177 + 32] + 31 < _10177 + return_data.size
                _10456 = mem[_10177 + mem[_10177 + 32]]
                if mem[_10177 + mem[_10177 + 32]] > test266151307():
                    revert with 0, 65
                _10465 = mem[64]
                if mem[64] + ceil32(32 * mem[_10177 + mem[_10177 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_10177 + mem[_10177 + 32]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = mem[64] + ceil32(32 * mem[_10177 + mem[_10177 + 32]]) + 1
                mem[_10465] = _10456
                require _10381 + (32 * _10456) + 32 <= return_data.size
                v = 0
                w = _10177 + _10381 + 32
                x = _10465 + 32
                while v < _10456:
                    mem[x] = mem[w]
                    v = v + 1
                    w = w + 32
                    x = x + 32
                    continue 
                _10581 = mem[_10177 + ceil32(return_data.size)]
                v = 0
                w = u
                while v < _10581:
                    if v >= mem[_10177 + ceil32(return_data.size)]:
                        revert with 0, 50
                    if w >= mem[_8353]:
                        revert with 0, 50
                    mem[(32 * w) + _8353 + 32] = mem[(32 * v) + _10177 + ceil32(return_data.size) + 32]
                    if v >= mem[_10465]:
                        revert with 0, 50
                    if w >= mem[_8353 + (32 * s + t) + 32]:
                        revert with 0, 50
                    mem[(32 * w) + _8353 + (32 * s + t) + 64] = mem[(32 * v) + _10465 + 32]
                    if w == -1:
                        revert with 0, 17
                    if v == -1:
                        revert with 0, 17
                    _10581 = mem[_10177 + ceil32(return_data.size)]
                    v = v + 1
                    w = w + 1
                    continue 
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        if s > !t:
            revert with 0, 17
        if u != s + t:
            revert with 0, 1
        if 1 >= stor9.length:
            revert with 0, 50
        mem[0] = 9
        mem[mem[64]] = 0x15d2cfca00000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = 64
        _10131 = mem[_8353]
        mem[mem[64] + 68] = mem[_8353]
        mem[mem[64] + 100 len 32 * _10131] = mem[_8353 + 32 len 32 * _10131]
        idx = _10131
        mem[mem[64] + 36] = arg1
        require ext_code.size(address(stor9.field_256))
        staticcall address(stor9.field_256).0x15d2cfca with:
                gas gas_remaining wei
               args 64, arg1, mem[mem[64] + 68 len (32 * _10131) + 32]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _10455 = mem[64]
        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _10461 = mem[_10455]
        require mem[_10455] <= test266151307()
        require _10455 + mem[_10455] + 31 < _10455 + return_data.size
        _10469 = mem[_10455 + mem[_10455]]
        if mem[_10455 + mem[_10455]] > test266151307():
            revert with 0, 65
        if ceil32(32 * mem[_10455 + mem[_10455]]) + 1 < 0 or _10455 + ceil32(return_data.size) + ceil32(32 * mem[_10455 + mem[_10455]]) + 1 > test266151307():
            revert with 0, 65
        mem[64] = _10455 + ceil32(return_data.size) + ceil32(32 * mem[_10455 + mem[_10455]]) + 1
        mem[_10455 + ceil32(return_data.size)] = _10469
        require _10461 + (32 * _10469) + 32 <= return_data.size
        mem[_10455 + ceil32(return_data.size) + 32 len 32 * _10469] = mem[_10455 + _10461 + 32 len 32 * _10469]
        var89001 = _10469
        var89002 = _10455 + _10461 + (32 * _10469) + 32
        var89004 = _10455 + ceil32(return_data.size) + (32 * _10469) + 32
        mem[mem[64]] = 32
        mem[mem[64] + 32] = _10469
        mem[mem[64] + 64 len 32 * _10469] = mem[_10455 + ceil32(return_data.size) + 32 len 32 * _10469]
        var97001 = _10469
        var97002 = _10455 + ceil32(return_data.size) + (32 * _10469) + 32
        return Array(len=_10469, data=mem[mem[64] + 64 len 32 * _10469])
    mem[_8353 + (32 * s + t) + 64 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
    _9258 = mem[mem[ceil32(return_data.size) + 160]]
    idx = 0
    u = 0
    while idx < _9258:
        mem[0] = arg1
        mem[32] = 1
        mem[mem[64] + 32] = idx
        mem[mem[64] + 64] = stor1[arg1].field_512
        mem[mem[64] + 96] = stor8
        _9342 = mem[64]
        mem[mem[64]] = 96
        mem[64] = mem[64] + 128
        if idx >= mem[mem[ceil32(return_data.size) + 160]]:
            revert with 0, 50
        if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
            revert with 0, 18
        if sha3(mem[_9342 + 32 len mem[_9342]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
            if idx == -1:
                revert with 0, 17
            _9258 = mem[mem[ceil32(return_data.size) + 160]]
            idx = idx + 1
            u = u
            continue 
        if idx >= mem[mem[ceil32(return_data.size) + 96]]:
            revert with 0, 50
        if u >= mem[_8353]:
            revert with 0, 50
        mem[(32 * u) + _8353 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
        if idx >= mem[mem[ceil32(return_data.size) + 128]]:
            revert with 0, 50
        if u >= mem[_8353 + (32 * s + t) + 32]:
            revert with 0, 50
        mem[(32 * u) + _8353 + (32 * s + t) + 64] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
        if u == -1:
            revert with 0, 17
        if idx == -1:
            revert with 0, 17
        _9258 = mem[mem[ceil32(return_data.size) + 160]]
        idx = idx + 1
        u = u + 1
        continue 
    idx = 0
    while idx < stor5.length:
        mem[0] = 5
        _10010 = mem[64]
        mem[64] = mem[64] + 64
        mem[_10010] = address(stor5[idx].field_0)
        mem[_10010 + 32] = address(stor5[idx].field_256)
        mem[0] = address(stor5[idx].field_0)
        mem[32] = sha3(arg1, 1) + 3
        if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
            _10017 = mem[64]
            mem[mem[64]] = 0
            mem[mem[64] + 32] = 0
            mem[64] = mem[64] + 64
            _10314 = mem[_10017]
            v = 0
            w = u
            while v < _10314:
                if v >= mem[_10017]:
                    revert with 0, 50
                if w >= mem[_8353]:
                    revert with 0, 50
                mem[(32 * w) + _8353 + 32] = mem[(32 * v) + _10017 + 32]
                if v >= mem[_10017 + 32]:
                    revert with 0, 50
                if w >= mem[_8353 + (32 * s + t) + 32]:
                    revert with 0, 50
                mem[(32 * w) + _8353 + (32 * s + t) + 64] = mem[(32 * v) + _10017 + 64]
                if w == -1:
                    revert with 0, 17
                if v == -1:
                    revert with 0, 17
                _10314 = mem[_10017]
                v = v + 1
                w = w + 1
                continue 
        else:
            mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = arg1
            mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
            require ext_code.size(address(stor5[idx].field_256))
            staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                    gas gas_remaining wei
                   args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _10180 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 64
            _10200 = mem[_10180]
            require mem[_10180] <= test266151307()
            require _10180 + mem[_10180] + 31 < _10180 + return_data.size
            _10214 = mem[_10180 + mem[_10180]]
            if mem[_10180 + mem[_10180]] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[_10180 + mem[_10180]]) + 1 < 0 or _10180 + ceil32(return_data.size) + ceil32(32 * mem[_10180 + mem[_10180]]) + 1 > test266151307():
                revert with 0, 65
            mem[64] = _10180 + ceil32(return_data.size) + ceil32(32 * mem[_10180 + mem[_10180]]) + 1
            mem[_10180 + ceil32(return_data.size)] = _10214
            require _10200 + (32 * _10214) + 32 <= return_data.size
            v = 0
            w = _10180 + _10200 + 32
            x = _10180 + ceil32(return_data.size) + 32
            while v < _10214:
                mem[x] = mem[w]
                v = v + 1
                w = w + 32
                x = x + 32
                continue 
            _10384 = mem[_10180 + 32]
            require mem[_10180 + 32] <= test266151307()
            require _10180 + mem[_10180 + 32] + 31 < _10180 + return_data.size
            _10458 = mem[_10180 + mem[_10180 + 32]]
            if mem[_10180 + mem[_10180 + 32]] > test266151307():
                revert with 0, 65
            _10466 = mem[64]
            if mem[64] + ceil32(32 * mem[_10180 + mem[_10180 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_10180 + mem[_10180 + 32]]) + 1 > test266151307():
                revert with 0, 65
            mem[64] = mem[64] + ceil32(32 * mem[_10180 + mem[_10180 + 32]]) + 1
            mem[_10466] = _10458
            require _10384 + (32 * _10458) + 32 <= return_data.size
            v = 0
            w = _10180 + _10384 + 32
            x = _10466 + 32
            while v < _10458:
                mem[x] = mem[w]
                v = v + 1
                w = w + 32
                x = x + 32
                continue 
            _10582 = mem[_10180 + ceil32(return_data.size)]
            v = 0
            w = u
            while v < _10582:
                if v >= mem[_10180 + ceil32(return_data.size)]:
                    revert with 0, 50
                if w >= mem[_8353]:
                    revert with 0, 50
                mem[(32 * w) + _8353 + 32] = mem[(32 * v) + _10180 + ceil32(return_data.size) + 32]
                if v >= mem[_10466]:
                    revert with 0, 50
                if w >= mem[_8353 + (32 * s + t) + 32]:
                    revert with 0, 50
                mem[(32 * w) + _8353 + (32 * s + t) + 64] = mem[(32 * v) + _10466 + 32]
                if w == -1:
                    revert with 0, 17
                if v == -1:
                    revert with 0, 17
                _10582 = mem[_10180 + ceil32(return_data.size)]
                v = v + 1
                w = w + 1
                continue 
        if idx == -1:
            revert with 0, 17
        idx = idx + 1
        continue 
    if s > !t:
        revert with 0, 17
    if u != s + t:
        revert with 0, 1
    if 1 >= stor9.length:
        revert with 0, 50
    mem[0] = 9
    mem[mem[64]] = 0x15d2cfca00000000000000000000000000000000000000000000000000000000
    mem[mem[64] + 4] = 64
    _10133 = mem[_8353]
    mem[mem[64] + 68] = mem[_8353]
    mem[mem[64] + 100 len 32 * _10133] = mem[_8353 + 32 len 32 * _10133]
    idx = _10133
    var71002 = _8353 + (32 * _10133) + 32
    mem[mem[64] + 36] = arg1
    require ext_code.size(address(stor9.field_256))
    staticcall address(stor9.field_256).0x15d2cfca with:
            gas gas_remaining wei
           args 64, arg1, mem[mem[64] + 68 len (32 * _10133) + 32]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _10457 = mem[64]
    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 32
    _10462 = mem[_10457]
    require mem[_10457] <= test266151307()
    require _10457 + mem[_10457] + 31 < _10457 + return_data.size
    _10470 = mem[_10457 + mem[_10457]]
    if mem[_10457 + mem[_10457]] > test266151307():
        revert with 0, 65
    if ceil32(32 * mem[_10457 + mem[_10457]]) + 1 < 0 or _10457 + ceil32(return_data.size) + ceil32(32 * mem[_10457 + mem[_10457]]) + 1 > test266151307():
        revert with 0, 65
    mem[64] = _10457 + ceil32(return_data.size) + ceil32(32 * mem[_10457 + mem[_10457]]) + 1
    mem[_10457 + ceil32(return_data.size)] = _10470
    require _10462 + (32 * _10470) + 32 <= return_data.size
    mem[_10457 + ceil32(return_data.size) + 32 len 32 * _10470] = mem[_10457 + _10462 + 32 len 32 * _10470]
    var90001 = _10470
    var90002 = _10457 + _10462 + (32 * _10470) + 32
    var90004 = _10457 + ceil32(return_data.size) + (32 * _10470) + 32
    mem[mem[64]] = 32
    mem[mem[64] + 32] = _10470
    mem[mem[64] + 64 len 32 * _10470] = mem[_10457 + ceil32(return_data.size) + 32 len 32 * _10470]
    var98001 = _10470
    var98002 = _10457 + ceil32(return_data.size) + (32 * _10470) + 32
    return Array(len=_10470, data=mem[mem[64] + 64 len 32 * _10470])
}

function sub_df2534dd(?) {
    require calldata.size - 4 >= 32
    if not stor1[arg1].field_512:
        mem[96] = 0
        mem[128] = 0
        if 0 >= stor9.length:
            revert with 0, 50
        mem[0] = arg1
        mem[160] = 0x15d2cfca00000000000000000000000000000000000000000000000000000000
        mem[164] = 64
        mem[228] = 0
        mem[260 len 0] = None
        mem[196] = stor1[arg1].field_512
        require ext_code.size(address(stor9.field_0))
        staticcall address(stor9.field_0).0x15d2cfca with:
                gas gas_remaining wei
               args 64, stor1[arg1].field_512, 0
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        mem[160 len return_data.size] = ext_call.return_data[0 len return_data.size]
        mem[64] = ceil32(return_data.size) + 160
        require return_data.size >= 32
        _147 = mem[160 len 4], 0
        require mem[160 len 4], 0 <= test266151307()
        require mem[160 len 4], 0 + 191 < return_data.size + 160
        _152 = mem[mem[160 len 4], 0 + 160]
        if mem[mem[160 len 4], 0 + 160] > test266151307():
            revert with 0, 65
        if ceil32(32 * mem[mem[160 len 4], 0 + 160]) + 1 < 0 or ceil32(return_data.size) + ceil32(32 * mem[mem[160 len 4], 0 + 160]) + 161 > test266151307():
            revert with 0, 65
        mem[64] = ceil32(return_data.size) + ceil32(32 * mem[mem[160 len 4], 0 + 160]) + 161
        mem[ceil32(return_data.size) + 160] = mem[mem[160 len 4], 0 + 160]
        require _147 + (32 * _152) + 32 <= return_data.size
        mem[ceil32(return_data.size) + 192 len 32 * _152] = mem[_147 + 192 len 32 * _152]
        mem[mem[64]] = 32
        mem[mem[64] + 32] = _152
        mem[mem[64] + 64 len 32 * _152] = mem[ceil32(return_data.size) + 192 len 32 * _152]
        return Array(len=_152, data=mem[mem[64] + 64 len 32 * _152])
    mem[100] = arg1
    require ext_code.size(stor11)
    staticcall stor11.0xe908c717 with:
            gas gas_remaining wei
           args arg1
    mem[96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[31 len 1]
    if ext_call.return_data[31 len 1] > 6:
        revert with 0, 33
    mem[0] = ext_call.return_data[31 len 1]
    mem[32] = 10
    mem[ceil32(return_data.size) + 192] = stor10[ext_call.return_data[31 len 1]].field_0
    if not stor10[ext_call.return_data[31 len 1]].field_0:
        mem[ceil32(return_data.size) + 96] = ceil32(return_data.size) + 192
        mem[ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + 224] = stor10[ext_call.return_data[31 len 1]].field_256
        if not stor10[ext_call.return_data[31 len 1]].field_256:
            mem[ceil32(return_data.size) + 128] = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + 224
            mem[64] = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + (32 * stor10[ext_call.return_data[31 len 1]].field_512) + 288
            mem[ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 256] = stor10[ext_call.return_data[31 len 1]].field_512
            if not stor10[ext_call.return_data[31 len 1]].field_512:
                mem[ceil32(return_data.size) + 160] = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 256
                idx = 0
                s = 0
                while idx < stor10[ext_call.return_data[31 len 1]].field_512:
                    mem[0] = arg1
                    mem[32] = 1
                    mem[mem[64] + 32] = idx
                    mem[mem[64] + 64] = stor1[arg1].field_512
                    mem[mem[64] + 96] = stor8
                    _131 = mem[64]
                    mem[mem[64]] = 96
                    mem[64] = mem[64] + 128
                    if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                        revert with 0, 50
                    if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        revert with 0, 18
                    if sha3(mem[_131 + 32 len mem[_131]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s
                        continue 
                    if s == -1:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + 1
                    continue 
                idx = 0
                t = 0
                while idx < stor5.length:
                    mem[0] = 5
                    _460 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_460] = address(stor5[idx].field_0)
                    mem[_460 + 32] = address(stor5[idx].field_256)
                    mem[0] = address(stor5[idx].field_0)
                    mem[32] = sha3(arg1, 1) + 3
                    if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                        _474 = mem[64]
                        mem[mem[64]] = 0
                        mem[mem[64] + 32] = 0
                        mem[64] = mem[64] + 64
                        if t > !mem[_474]:
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        t = t + mem[_474]
                        continue 
                    mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = arg1
                    mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    require ext_code.size(address(stor5[idx].field_256))
                    staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                            gas gas_remaining wei
                           args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _502 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 64
                    _514 = mem[_502]
                    require mem[_502] <= test266151307()
                    require _502 + mem[_502] + 31 < _502 + return_data.size
                    _563 = mem[_502 + mem[_502]]
                    if mem[_502 + mem[_502]] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[_502 + mem[_502]]) + 1 < 0 or _502 + ceil32(return_data.size) + ceil32(32 * mem[_502 + mem[_502]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = _502 + ceil32(return_data.size) + ceil32(32 * mem[_502 + mem[_502]]) + 1
                    mem[_502 + ceil32(return_data.size)] = _563
                    require _514 + (32 * _563) + 32 <= return_data.size
                    s = 0
                    u = _502 + _514 + 32
                    v = _502 + ceil32(return_data.size) + 32
                    while s < _563:
                        mem[v] = mem[u]
                        s = s + 1
                        u = u + 32
                        v = v + 32
                        continue 
                    _1085 = mem[_502 + 32]
                    require mem[_502 + 32] <= test266151307()
                    require _502 + mem[_502 + 32] + 31 < _502 + return_data.size
                    _1090 = mem[_502 + mem[_502 + 32]]
                    if mem[_502 + mem[_502 + 32]] > test266151307():
                        revert with 0, 65
                    _1180 = mem[64]
                    if mem[64] + ceil32(32 * mem[_502 + mem[_502 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_502 + mem[_502 + 32]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = mem[64] + ceil32(32 * mem[_502 + mem[_502 + 32]]) + 1
                    mem[_1180] = _1090
                    require _1085 + (32 * _1090) + 32 <= return_data.size
                    s = 0
                    u = _502 + _1085 + 32
                    v = _1180 + 32
                    while s < _1090:
                        mem[v] = mem[u]
                        s = s + 1
                        u = u + 32
                        v = v + 32
                        continue 
                    if t > !mem[_502 + ceil32(return_data.size)]:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    t = t + mem[_502 + ceil32(return_data.size)]
                    continue 
                if s > !t:
                    revert with 0, 17
                if s + t > test266151307():
                    revert with 0, 65
                _473 = mem[64]
                mem[mem[64]] = s + t
                if not s + t:
                    if s > !t:
                        revert with 0, 17
                    if s + t > test266151307():
                        revert with 0, 65
                    _501 = mem[64] + (32 * s + t) + 32
                    mem[mem[64] + (32 * s + t) + 32] = s + t
                    mem[64] = _501 + (32 * s + t) + 32
                    if not s + t:
                        _1017 = mem[mem[ceil32(return_data.size) + 160]]
                        idx = 0
                        u = 0
                        while idx < _1017:
                            mem[0] = arg1
                            mem[32] = 1
                            mem[mem[64] + 32] = idx
                            mem[mem[64] + 64] = stor1[arg1].field_512
                            mem[mem[64] + 96] = stor8
                            _1032 = mem[64]
                            mem[mem[64]] = 96
                            mem[64] = mem[64] + 128
                            if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                                revert with 0, 50
                            if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                                revert with 0, 18
                            if sha3(mem[_1032 + 32 len mem[_1032]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                u = u
                                continue 
                            if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                                revert with 0, 50
                            if u >= mem[_473]:
                                revert with 0, 50
                            mem[(32 * u) + _473 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                            if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                                revert with 0, 50
                            if u >= mem[_501]:
                                revert with 0, 50
                            mem[(32 * u) + _501 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                            if u == -1:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            u = u + 1
                            continue 
                        idx = 0
                        while idx < stor5.length:
                            mem[0] = 5
                            _2196 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2196] = address(stor5[idx].field_0)
                            mem[_2196 + 32] = address(stor5[idx].field_256)
                            mem[0] = address(stor5[idx].field_0)
                            mem[32] = sha3(arg1, 1) + 3
                            if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                                _2231 = mem[64]
                                mem[mem[64]] = 0
                                mem[mem[64] + 32] = 0
                                mem[64] = mem[64] + 64
                                _3495 = mem[_2231]
                                s = 0
                                t = u
                                while s < _3495:
                                    if s >= mem[_2231]:
                                        revert with 0, 50
                                    if t >= mem[_473]:
                                        revert with 0, 50
                                    mem[(32 * t) + _473 + 32] = mem[(32 * s) + _2231 + 32]
                                    if s >= mem[_2231 + 32]:
                                        revert with 0, 50
                                    if t >= mem[_501]:
                                        revert with 0, 50
                                    mem[(32 * t) + _501 + 32] = mem[(32 * s) + _2231 + 64]
                                    if t == -1:
                                        revert with 0, 17
                                    if s == -1:
                                        revert with 0, 17
                                    s = s + 1
                                    t = t + 1
                                    continue 
                            else:
                                mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = arg1
                                mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                                require ext_code.size(address(stor5[idx].field_256))
                                staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                                        gas gas_remaining wei
                                       args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _2311 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 64
                                _2349 = mem[_2311]
                                require mem[_2311] <= test266151307()
                                require _2311 + mem[_2311] + 31 < _2311 + return_data.size
                                _2468 = mem[_2311 + mem[_2311]]
                                if mem[_2311 + mem[_2311]] > test266151307():
                                    revert with 0, 65
                                if ceil32(32 * mem[_2311 + mem[_2311]]) + 1 < 0 or _2311 + ceil32(return_data.size) + ceil32(32 * mem[_2311 + mem[_2311]]) + 1 > test266151307():
                                    revert with 0, 65
                                mem[64] = _2311 + ceil32(return_data.size) + ceil32(32 * mem[_2311 + mem[_2311]]) + 1
                                mem[_2311 + ceil32(return_data.size)] = _2468
                                require _2349 + (32 * _2468) + 32 <= return_data.size
                                s = 0
                                t = _2311 + _2349 + 32
                                v = _2311 + ceil32(return_data.size) + 32
                                while s < _2468:
                                    mem[v] = mem[t]
                                    s = s + 1
                                    t = t + 32
                                    v = v + 32
                                    continue 
                                _3649 = mem[_2311 + 32]
                                require mem[_2311 + 32] <= test266151307()
                                require _2311 + mem[_2311 + 32] + 31 < _2311 + return_data.size
                                _3696 = mem[_2311 + mem[_2311 + 32]]
                                if mem[_2311 + mem[_2311 + 32]] > test266151307():
                                    revert with 0, 65
                                _3875 = mem[64]
                                if mem[64] + ceil32(32 * mem[_2311 + mem[_2311 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_2311 + mem[_2311 + 32]]) + 1 > test266151307():
                                    revert with 0, 65
                                mem[64] = mem[64] + ceil32(32 * mem[_2311 + mem[_2311 + 32]]) + 1
                                mem[_3875] = _3696
                                require _3649 + (32 * _3696) + 32 <= return_data.size
                                s = 0
                                t = _2311 + _3649 + 32
                                v = _3875 + 32
                                while s < _3696:
                                    mem[v] = mem[t]
                                    s = s + 1
                                    t = t + 32
                                    v = v + 32
                                    continue 
                                _6860 = mem[_2311 + ceil32(return_data.size)]
                                s = 0
                                t = u
                                while s < _6860:
                                    if s >= mem[_2311 + ceil32(return_data.size)]:
                                        revert with 0, 50
                                    if t >= mem[_473]:
                                        revert with 0, 50
                                    mem[(32 * t) + _473 + 32] = mem[(32 * s) + _2311 + ceil32(return_data.size) + 32]
                                    if s >= mem[_3875]:
                                        revert with 0, 50
                                    if t >= mem[_501]:
                                        revert with 0, 50
                                    mem[(32 * t) + _501 + 32] = mem[(32 * s) + _3875 + 32]
                                    if t == -1:
                                        revert with 0, 17
                                    if s == -1:
                                        revert with 0, 17
                                    _6860 = mem[_2311 + ceil32(return_data.size)]
                                    s = s + 1
                                    t = t + 1
                                    continue 
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            continue 
                        if s > !t:
                            revert with 0, 17
                        if u != s + t:
                            revert with 0, 1
                        if 0 >= stor9.length:
                            revert with 0, 50
                        mem[0] = arg1
                        mem[32] = 1
                        mem[mem[64]] = 0x15d2cfca00000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 64
                        _2301 = mem[_473]
                        mem[mem[64] + 68] = mem[_473]
                        mem[mem[64] + 100 len 32 * _2301] = mem[_473 + 32 len 32 * _2301]
                        mem[mem[64] + 36] = stor1[arg1].field_512
                        require ext_code.size(address(stor9.field_0))
                        staticcall address(stor9.field_0).0x15d2cfca with:
                                gas gas_remaining wei
                               args 64, stor1[arg1].field_512, mem[mem[64] + 68 len (32 * _2301) + 32]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3695 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _3805 = mem[_3695]
                        require mem[_3695] <= test266151307()
                        require _3695 + mem[_3695] + 31 < _3695 + return_data.size
                        _3945 = mem[_3695 + mem[_3695]]
                        if mem[_3695 + mem[_3695]] > test266151307():
                            revert with 0, 65
                        if ceil32(32 * mem[_3695 + mem[_3695]]) + 1 < 0 or _3695 + ceil32(return_data.size) + ceil32(32 * mem[_3695 + mem[_3695]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = _3695 + ceil32(return_data.size) + ceil32(32 * mem[_3695 + mem[_3695]]) + 1
                        mem[_3695 + ceil32(return_data.size)] = _3945
                        require _3805 + (32 * _3945) + 32 <= return_data.size
                        mem[_3695 + ceil32(return_data.size) + 32 len 32 * _3945] = mem[_3695 + _3805 + 32 len 32 * _3945]
                        mem[mem[64]] = 32
                        mem[mem[64] + 32] = _3945
                        mem[mem[64] + 64 len 32 * _3945] = mem[_3695 + ceil32(return_data.size) + 32 len 32 * _3945]
                        return Array(len=_3945, data=mem[mem[64] + 64 len 32 * _3945])
                    mem[_501 + 32 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
                    _1019 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = 0
                    u = 0
                    while idx < _1019:
                        mem[0] = arg1
                        mem[32] = 1
                        mem[mem[64] + 32] = idx
                        mem[mem[64] + 64] = stor1[arg1].field_512
                        mem[mem[64] + 96] = stor8
                        _1039 = mem[64]
                        mem[mem[64]] = 96
                        mem[64] = mem[64] + 128
                        if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                            revert with 0, 50
                        if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                            revert with 0, 18
                        if sha3(mem[_1039 + 32 len mem[_1039]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            u = u
                            continue 
                        if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                            revert with 0, 50
                        if u >= mem[_473]:
                            revert with 0, 50
                        mem[(32 * u) + _473 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                        if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                            revert with 0, 50
                        if u >= mem[_501]:
                            revert with 0, 50
                        mem[(32 * u) + _501 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                        if u == -1:
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        u = u + 1
                        continue 
                    idx = 0
                    while idx < stor5.length:
                        mem[0] = 5
                        _2201 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2201] = address(stor5[idx].field_0)
                        mem[_2201 + 32] = address(stor5[idx].field_256)
                        mem[0] = address(stor5[idx].field_0)
                        mem[32] = sha3(arg1, 1) + 3
                        if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                            _2232 = mem[64]
                            mem[mem[64]] = 0
                            mem[mem[64] + 32] = 0
                            mem[64] = mem[64] + 64
                            _3496 = mem[_2232]
                            s = 0
                            t = u
                            while s < _3496:
                                if s >= mem[_2232]:
                                    revert with 0, 50
                                if t >= mem[_473]:
                                    revert with 0, 50
                                mem[(32 * t) + _473 + 32] = mem[(32 * s) + _2232 + 32]
                                if s >= mem[_2232 + 32]:
                                    revert with 0, 50
                                if t >= mem[_501]:
                                    revert with 0, 50
                                mem[(32 * t) + _501 + 32] = mem[(32 * s) + _2232 + 64]
                                if t == -1:
                                    revert with 0, 17
                                if s == -1:
                                    revert with 0, 17
                                s = s + 1
                                t = t + 1
                                continue 
                        else:
                            mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = arg1
                            mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                            require ext_code.size(address(stor5[idx].field_256))
                            staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                                    gas gas_remaining wei
                                   args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2314 = mem[64]
                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 64
                            _2352 = mem[_2314]
                            require mem[_2314] <= test266151307()
                            require _2314 + mem[_2314] + 31 < _2314 + return_data.size
                            _2470 = mem[_2314 + mem[_2314]]
                            if mem[_2314 + mem[_2314]] > test266151307():
                                revert with 0, 65
                            if ceil32(32 * mem[_2314 + mem[_2314]]) + 1 < 0 or _2314 + ceil32(return_data.size) + ceil32(32 * mem[_2314 + mem[_2314]]) + 1 > test266151307():
                                revert with 0, 65
                            mem[64] = _2314 + ceil32(return_data.size) + ceil32(32 * mem[_2314 + mem[_2314]]) + 1
                            mem[_2314 + ceil32(return_data.size)] = _2470
                            require _2352 + (32 * _2470) + 32 <= return_data.size
                            s = 0
                            t = _2314 + _2352 + 32
                            v = _2314 + ceil32(return_data.size) + 32
                            while s < _2470:
                                mem[v] = mem[t]
                                s = s + 1
                                t = t + 32
                                v = v + 32
                                continue 
                            _3652 = mem[_2314 + 32]
                            require mem[_2314 + 32] <= test266151307()
                            require _2314 + mem[_2314 + 32] + 31 < _2314 + return_data.size
                            _3698 = mem[_2314 + mem[_2314 + 32]]
                            if mem[_2314 + mem[_2314 + 32]] > test266151307():
                                revert with 0, 65
                            _3876 = mem[64]
                            if mem[64] + ceil32(32 * mem[_2314 + mem[_2314 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_2314 + mem[_2314 + 32]]) + 1 > test266151307():
                                revert with 0, 65
                            mem[64] = mem[64] + ceil32(32 * mem[_2314 + mem[_2314 + 32]]) + 1
                            mem[_3876] = _3698
                            require _3652 + (32 * _3698) + 32 <= return_data.size
                            s = 0
                            t = _2314 + _3652 + 32
                            v = _3876 + 32
                            while s < _3698:
                                mem[v] = mem[t]
                                s = s + 1
                                t = t + 32
                                v = v + 32
                                continue 
                            _6861 = mem[_2314 + ceil32(return_data.size)]
                            s = 0
                            t = u
                            while s < _6861:
                                if s >= mem[_2314 + ceil32(return_data.size)]:
                                    revert with 0, 50
                                if t >= mem[_473]:
                                    revert with 0, 50
                                mem[(32 * t) + _473 + 32] = mem[(32 * s) + _2314 + ceil32(return_data.size) + 32]
                                if s >= mem[_3876]:
                                    revert with 0, 50
                                if t >= mem[_501]:
                                    revert with 0, 50
                                mem[(32 * t) + _501 + 32] = mem[(32 * s) + _3876 + 32]
                                if t == -1:
                                    revert with 0, 17
                                if s == -1:
                                    revert with 0, 17
                                _6861 = mem[_2314 + ceil32(return_data.size)]
                                s = s + 1
                                t = t + 1
                                continue 
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
                    if s > !t:
                        revert with 0, 17
                    if u != s + t:
                        revert with 0, 1
                    if 0 >= stor9.length:
                        revert with 0, 50
                    mem[0] = arg1
                    mem[32] = 1
                    mem[mem[64]] = 0x15d2cfca00000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 64
                    _2303 = mem[_473]
                    mem[mem[64] + 68] = mem[_473]
                    mem[mem[64] + 100 len 32 * _2303] = mem[_473 + 32 len 32 * _2303]
                    mem[mem[64] + 36] = stor1[arg1].field_512
                    require ext_code.size(address(stor9.field_0))
                    staticcall address(stor9.field_0).0x15d2cfca with:
                            gas gas_remaining wei
                           args 64, stor1[arg1].field_512, mem[mem[64] + 68 len (32 * _2303) + 32]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3697 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _3806 = mem[_3697]
                    require mem[_3697] <= test266151307()
                    require _3697 + mem[_3697] + 31 < _3697 + return_data.size
                    _3946 = mem[_3697 + mem[_3697]]
                    if mem[_3697 + mem[_3697]] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[_3697 + mem[_3697]]) + 1 < 0 or _3697 + ceil32(return_data.size) + ceil32(32 * mem[_3697 + mem[_3697]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = _3697 + ceil32(return_data.size) + ceil32(32 * mem[_3697 + mem[_3697]]) + 1
                    mem[_3697 + ceil32(return_data.size)] = _3946
                    require _3806 + (32 * _3946) + 32 <= return_data.size
                    mem[_3697 + ceil32(return_data.size) + 32 len 32 * _3946] = mem[_3697 + _3806 + 32 len 32 * _3946]
                    mem[mem[64]] = 32
                    mem[mem[64] + 32] = _3946
                    mem[mem[64] + 64 len 32 * _3946] = mem[_3697 + ceil32(return_data.size) + 32 len 32 * _3946]
                    return Array(len=_3946, data=mem[mem[64] + 64 len 32 * _3946])
                mem[mem[64] + 32 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
                if s > !t:
                    revert with 0, 17
                if s + t > test266151307():
                    revert with 0, 65
                mem[mem[64] + (32 * s + t) + 32] = s + t
                mem[64] = _473 + (64 * s + t) + 64
                if not s + t:
                    _1021 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = 0
                    u = 0
                    while idx < _1021:
                        mem[0] = arg1
                        mem[32] = 1
                        mem[mem[64] + 32] = idx
                        mem[mem[64] + 64] = stor1[arg1].field_512
                        mem[mem[64] + 96] = stor8
                        _1046 = mem[64]
                        mem[mem[64]] = 96
                        mem[64] = mem[64] + 128
                        if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                            revert with 0, 50
                        if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                            revert with 0, 18
                        if sha3(mem[_1046 + 32 len mem[_1046]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            u = u
                            continue 
                        if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                            revert with 0, 50
                        if u >= mem[_473]:
                            revert with 0, 50
                        mem[(32 * u) + _473 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                        if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                            revert with 0, 50
                        if u >= mem[_473 + (32 * s + t) + 32]:
                            revert with 0, 50
                        mem[(32 * u) + _473 + (32 * s + t) + 64] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                        if u == -1:
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        u = u + 1
                        continue 
                    idx = 0
                    while idx < stor5.length:
                        mem[0] = 5
                        _2206 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2206] = address(stor5[idx].field_0)
                        mem[_2206 + 32] = address(stor5[idx].field_256)
                        mem[0] = address(stor5[idx].field_0)
                        mem[32] = sha3(arg1, 1) + 3
                        if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                            _2233 = mem[64]
                            mem[mem[64]] = 0
                            mem[mem[64] + 32] = 0
                            mem[64] = mem[64] + 64
                            _3497 = mem[_2233]
                            v = 0
                            w = u
                            while v < _3497:
                                if v >= mem[_2233]:
                                    revert with 0, 50
                                if w >= mem[_473]:
                                    revert with 0, 50
                                mem[(32 * w) + _473 + 32] = mem[(32 * v) + _2233 + 32]
                                if v >= mem[_2233 + 32]:
                                    revert with 0, 50
                                if w >= mem[_473 + (32 * s + t) + 32]:
                                    revert with 0, 50
                                mem[(32 * w) + _473 + (32 * s + t) + 64] = mem[(32 * v) + _2233 + 64]
                                if w == -1:
                                    revert with 0, 17
                                if v == -1:
                                    revert with 0, 17
                                v = v + 1
                                w = w + 1
                                continue 
                        else:
                            mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = arg1
                            mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                            require ext_code.size(address(stor5[idx].field_256))
                            staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                                    gas gas_remaining wei
                                   args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2317 = mem[64]
                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 64
                            _2355 = mem[_2317]
                            require mem[_2317] <= test266151307()
                            require _2317 + mem[_2317] + 31 < _2317 + return_data.size
                            _2472 = mem[_2317 + mem[_2317]]
                            if mem[_2317 + mem[_2317]] > test266151307():
                                revert with 0, 65
                            if ceil32(32 * mem[_2317 + mem[_2317]]) + 1 < 0 or _2317 + ceil32(return_data.size) + ceil32(32 * mem[_2317 + mem[_2317]]) + 1 > test266151307():
                                revert with 0, 65
                            mem[64] = _2317 + ceil32(return_data.size) + ceil32(32 * mem[_2317 + mem[_2317]]) + 1
                            mem[_2317 + ceil32(return_data.size)] = _2472
                            require _2355 + (32 * _2472) + 32 <= return_data.size
                            v = 0
                            w = _2317 + _2355 + 32
                            x = _2317 + ceil32(return_data.size) + 32
                            while v < _2472:
                                mem[x] = mem[w]
                                v = v + 1
                                w = w + 32
                                x = x + 32
                                continue 
                            _3655 = mem[_2317 + 32]
                            require mem[_2317 + 32] <= test266151307()
                            require _2317 + mem[_2317 + 32] + 31 < _2317 + return_data.size
                            _3700 = mem[_2317 + mem[_2317 + 32]]
                            if mem[_2317 + mem[_2317 + 32]] > test266151307():
                                revert with 0, 65
                            _3877 = mem[64]
                            if mem[64] + ceil32(32 * mem[_2317 + mem[_2317 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_2317 + mem[_2317 + 32]]) + 1 > test266151307():
                                revert with 0, 65
                            mem[64] = mem[64] + ceil32(32 * mem[_2317 + mem[_2317 + 32]]) + 1
                            mem[_3877] = _3700
                            require _3655 + (32 * _3700) + 32 <= return_data.size
                            v = 0
                            w = _2317 + _3655 + 32
                            x = _3877 + 32
                            while v < _3700:
                                mem[x] = mem[w]
                                v = v + 1
                                w = w + 32
                                x = x + 32
                                continue 
                            _6862 = mem[_2317 + ceil32(return_data.size)]
                            v = 0
                            w = u
                            while v < _6862:
                                if v >= mem[_2317 + ceil32(return_data.size)]:
                                    revert with 0, 50
                                if w >= mem[_473]:
                                    revert with 0, 50
                                mem[(32 * w) + _473 + 32] = mem[(32 * v) + _2317 + ceil32(return_data.size) + 32]
                                if v >= mem[_3877]:
                                    revert with 0, 50
                                if w >= mem[_473 + (32 * s + t) + 32]:
                                    revert with 0, 50
                                mem[(32 * w) + _473 + (32 * s + t) + 64] = mem[(32 * v) + _3877 + 32]
                                if w == -1:
                                    revert with 0, 17
                                if v == -1:
                                    revert with 0, 17
                                _6862 = mem[_2317 + ceil32(return_data.size)]
                                v = v + 1
                                w = w + 1
                                continue 
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
                    if s > !t:
                        revert with 0, 17
                    if u != s + t:
                        revert with 0, 1
                    if 0 >= stor9.length:
                        revert with 0, 50
                    mem[0] = arg1
                    mem[32] = 1
                    mem[mem[64]] = 0x15d2cfca00000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 64
                    _2305 = mem[_473]
                    mem[mem[64] + 68] = mem[_473]
                    mem[mem[64] + 100 len 32 * _2305] = mem[_473 + 32 len 32 * _2305]
                    mem[mem[64] + 36] = stor1[arg1].field_512
                    require ext_code.size(address(stor9.field_0))
                    staticcall address(stor9.field_0).0x15d2cfca with:
                            gas gas_remaining wei
                           args 64, stor1[arg1].field_512, mem[mem[64] + 68 len (32 * _2305) + 32]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3699 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _3807 = mem[_3699]
                    require mem[_3699] <= test266151307()
                    require _3699 + mem[_3699] + 31 < _3699 + return_data.size
                    _3947 = mem[_3699 + mem[_3699]]
                    if mem[_3699 + mem[_3699]] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[_3699 + mem[_3699]]) + 1 < 0 or _3699 + ceil32(return_data.size) + ceil32(32 * mem[_3699 + mem[_3699]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = _3699 + ceil32(return_data.size) + ceil32(32 * mem[_3699 + mem[_3699]]) + 1
                    mem[_3699 + ceil32(return_data.size)] = _3947
                    require _3807 + (32 * _3947) + 32 <= return_data.size
                    mem[_3699 + ceil32(return_data.size) + 32 len 32 * _3947] = mem[_3699 + _3807 + 32 len 32 * _3947]
                    mem[mem[64]] = 32
                    mem[mem[64] + 32] = _3947
                    mem[mem[64] + 64 len 32 * _3947] = mem[_3699 + ceil32(return_data.size) + 32 len 32 * _3947]
                    return Array(len=_3947, data=mem[mem[64] + 64 len 32 * _3947])
                mem[_473 + (32 * s + t) + 64 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
                _1023 = mem[mem[ceil32(return_data.size) + 160]]
                idx = 0
                u = 0
                while idx < _1023:
                    mem[0] = arg1
                    mem[32] = 1
                    mem[mem[64] + 32] = idx
                    mem[mem[64] + 64] = stor1[arg1].field_512
                    mem[mem[64] + 96] = stor8
                    _1053 = mem[64]
                    mem[mem[64]] = 96
                    mem[64] = mem[64] + 128
                    if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                        revert with 0, 50
                    if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        revert with 0, 18
                    if sha3(mem[_1053 + 32 len mem[_1053]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        u = u
                        continue 
                    if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                        revert with 0, 50
                    if u >= mem[_473]:
                        revert with 0, 50
                    mem[(32 * u) + _473 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                    if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                        revert with 0, 50
                    if u >= mem[_473 + (32 * s + t) + 32]:
                        revert with 0, 50
                    mem[(32 * u) + _473 + (32 * s + t) + 64] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                    if u == -1:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    u = u + 1
                    continue 
                idx = 0
                while idx < stor5.length:
                    mem[0] = 5
                    _2211 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2211] = address(stor5[idx].field_0)
                    mem[_2211 + 32] = address(stor5[idx].field_256)
                    mem[0] = address(stor5[idx].field_0)
                    mem[32] = sha3(arg1, 1) + 3
                    if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                        _2234 = mem[64]
                        mem[mem[64]] = 0
                        mem[mem[64] + 32] = 0
                        mem[64] = mem[64] + 64
                        _3498 = mem[_2234]
                        v = 0
                        w = u
                        while v < _3498:
                            if v >= mem[_2234]:
                                revert with 0, 50
                            if w >= mem[_473]:
                                revert with 0, 50
                            mem[(32 * w) + _473 + 32] = mem[(32 * v) + _2234 + 32]
                            if v >= mem[_2234 + 32]:
                                revert with 0, 50
                            if w >= mem[_473 + (32 * s + t) + 32]:
                                revert with 0, 50
                            mem[(32 * w) + _473 + (32 * s + t) + 64] = mem[(32 * v) + _2234 + 64]
                            if w == -1:
                                revert with 0, 17
                            if v == -1:
                                revert with 0, 17
                            v = v + 1
                            w = w + 1
                            continue 
                    else:
                        mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = arg1
                        mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                        require ext_code.size(address(stor5[idx].field_256))
                        staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                                gas gas_remaining wei
                               args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2320 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 64
                        _2358 = mem[_2320]
                        require mem[_2320] <= test266151307()
                        require _2320 + mem[_2320] + 31 < _2320 + return_data.size
                        _2474 = mem[_2320 + mem[_2320]]
                        if mem[_2320 + mem[_2320]] > test266151307():
                            revert with 0, 65
                        if ceil32(32 * mem[_2320 + mem[_2320]]) + 1 < 0 or _2320 + ceil32(return_data.size) + ceil32(32 * mem[_2320 + mem[_2320]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = _2320 + ceil32(return_data.size) + ceil32(32 * mem[_2320 + mem[_2320]]) + 1
                        mem[_2320 + ceil32(return_data.size)] = _2474
                        require _2358 + (32 * _2474) + 32 <= return_data.size
                        v = 0
                        w = _2320 + _2358 + 32
                        x = _2320 + ceil32(return_data.size) + 32
                        while v < _2474:
                            mem[x] = mem[w]
                            v = v + 1
                            w = w + 32
                            x = x + 32
                            continue 
                        _3658 = mem[_2320 + 32]
                        require mem[_2320 + 32] <= test266151307()
                        require _2320 + mem[_2320 + 32] + 31 < _2320 + return_data.size
                        _3702 = mem[_2320 + mem[_2320 + 32]]
                        if mem[_2320 + mem[_2320 + 32]] > test266151307():
                            revert with 0, 65
                        _3878 = mem[64]
                        if mem[64] + ceil32(32 * mem[_2320 + mem[_2320 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_2320 + mem[_2320 + 32]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = mem[64] + ceil32(32 * mem[_2320 + mem[_2320 + 32]]) + 1
                        mem[_3878] = _3702
                        require _3658 + (32 * _3702) + 32 <= return_data.size
                        v = 0
                        w = _2320 + _3658 + 32
                        x = _3878 + 32
                        while v < _3702:
                            mem[x] = mem[w]
                            v = v + 1
                            w = w + 32
                            x = x + 32
                            continue 
                        _6863 = mem[_2320 + ceil32(return_data.size)]
                        v = 0
                        w = u
                        while v < _6863:
                            if v >= mem[_2320 + ceil32(return_data.size)]:
                                revert with 0, 50
                            if w >= mem[_473]:
                                revert with 0, 50
                            mem[(32 * w) + _473 + 32] = mem[(32 * v) + _2320 + ceil32(return_data.size) + 32]
                            if v >= mem[_3878]:
                                revert with 0, 50
                            if w >= mem[_473 + (32 * s + t) + 32]:
                                revert with 0, 50
                            mem[(32 * w) + _473 + (32 * s + t) + 64] = mem[(32 * v) + _3878 + 32]
                            if w == -1:
                                revert with 0, 17
                            if v == -1:
                                revert with 0, 17
                            _6863 = mem[_2320 + ceil32(return_data.size)]
                            v = v + 1
                            w = w + 1
                            continue 
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                if s > !t:
                    revert with 0, 17
                if u != s + t:
                    revert with 0, 1
                if 0 >= stor9.length:
                    revert with 0, 50
                mem[0] = arg1
                mem[32] = 1
                mem[mem[64]] = 0x15d2cfca00000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 64
                _2307 = mem[_473]
                mem[mem[64] + 68] = mem[_473]
                mem[mem[64] + 100 len 32 * _2307] = mem[_473 + 32 len 32 * _2307]
                mem[mem[64] + 36] = stor1[arg1].field_512
                require ext_code.size(address(stor9.field_0))
                staticcall address(stor9.field_0).0x15d2cfca with:
                        gas gas_remaining wei
                       args 64, stor1[arg1].field_512, mem[mem[64] + 68 len (32 * _2307) + 32]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3701 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _3808 = mem[_3701]
                require mem[_3701] <= test266151307()
                require _3701 + mem[_3701] + 31 < _3701 + return_data.size
                _3948 = mem[_3701 + mem[_3701]]
                if mem[_3701 + mem[_3701]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_3701 + mem[_3701]]) + 1 < 0 or _3701 + ceil32(return_data.size) + ceil32(32 * mem[_3701 + mem[_3701]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _3701 + ceil32(return_data.size) + ceil32(32 * mem[_3701 + mem[_3701]]) + 1
                mem[_3701 + ceil32(return_data.size)] = _3948
                require _3808 + (32 * _3948) + 32 <= return_data.size
                mem[_3701 + ceil32(return_data.size) + 32 len 32 * _3948] = mem[_3701 + _3808 + 32 len 32 * _3948]
                mem[mem[64]] = 32
                mem[mem[64] + 32] = _3948
                mem[mem[64] + 64 len 32 * _3948] = mem[_3701 + ceil32(return_data.size) + 32 len 32 * _3948]
                return Array(len=_3948, data=mem[mem[64] + 64 len 32 * _3948])
            mem[0] = sha3(ext_call.return_data[31 len 1], 10) + 2
            mem[ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 288] = stor10[ext_call.return_data[31 len 1]][2].field_0
            idx = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 288
            s = 0
            while ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + (32 * stor10[ext_call.return_data[31 len 1]].field_512) + 256 > idx:
                mem[idx + 32] = stor10[ext_call.return_data[31 len 1]][s + 2].field_256
                idx = idx + 32
                s = s + 1
                continue 
            mem[ceil32(return_data.size) + 160] = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 256
            idx = 0
            s = 0
            while idx < stor10[ext_call.return_data[31 len 1]].field_512:
                mem[0] = arg1
                mem[32] = 1
                mem[mem[64] + 32] = idx
                mem[mem[64] + 64] = stor1[arg1].field_512
                mem[mem[64] + 96] = stor8
                _1061 = mem[64]
                mem[mem[64]] = 96
                mem[64] = mem[64] + 128
                if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                    revert with 0, 50
                if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    revert with 0, 18
                if sha3(mem[_1061 + 32 len mem[_1061]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s
                    continue 
                if s == -1:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s + 1
                continue 
            idx = 0
            t = 0
            while idx < stor5.length:
                mem[0] = 5
                _2216 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2216] = address(stor5[idx].field_0)
                mem[_2216 + 32] = address(stor5[idx].field_256)
                mem[0] = address(stor5[idx].field_0)
                mem[32] = sha3(arg1, 1) + 3
                if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                    _2237 = mem[64]
                    mem[mem[64]] = 0
                    mem[mem[64] + 32] = 0
                    mem[64] = mem[64] + 64
                    if t > !mem[_2237]:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    t = t + mem[_2237]
                    continue 
                mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = arg1
                mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                require ext_code.size(address(stor5[idx].field_256))
                staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                        gas gas_remaining wei
                       args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _2324 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 64
                _2363 = mem[_2324]
                require mem[_2324] <= test266151307()
                require _2324 + mem[_2324] + 31 < _2324 + return_data.size
                _2484 = mem[_2324 + mem[_2324]]
                if mem[_2324 + mem[_2324]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_2324 + mem[_2324]]) + 1 < 0 or _2324 + ceil32(return_data.size) + ceil32(32 * mem[_2324 + mem[_2324]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _2324 + ceil32(return_data.size) + ceil32(32 * mem[_2324 + mem[_2324]]) + 1
                mem[_2324 + ceil32(return_data.size)] = _2484
                require _2363 + (32 * _2484) + 32 <= return_data.size
                s = 0
                u = _2324 + _2363 + 32
                v = _2324 + ceil32(return_data.size) + 32
                while s < _2484:
                    mem[v] = mem[u]
                    s = s + 1
                    u = u + 32
                    v = v + 32
                    continue 
                _3665 = mem[_2324 + 32]
                require mem[_2324 + 32] <= test266151307()
                require _2324 + mem[_2324 + 32] + 31 < _2324 + return_data.size
                _3703 = mem[_2324 + mem[_2324 + 32]]
                if mem[_2324 + mem[_2324 + 32]] > test266151307():
                    revert with 0, 65
                _3899 = mem[64]
                if mem[64] + ceil32(32 * mem[_2324 + mem[_2324 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_2324 + mem[_2324 + 32]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = mem[64] + ceil32(32 * mem[_2324 + mem[_2324 + 32]]) + 1
                mem[_3899] = _3703
                require _3665 + (32 * _3703) + 32 <= return_data.size
                s = 0
                u = _2324 + _3665 + 32
                v = _3899 + 32
                while s < _3703:
                    mem[v] = mem[u]
                    s = s + 1
                    u = u + 32
                    v = v + 32
                    continue 
                if t > !mem[_2324 + ceil32(return_data.size)]:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                t = t + mem[_2324 + ceil32(return_data.size)]
                continue 
            if s > !t:
                revert with 0, 17
            if s + t > test266151307():
                revert with 0, 65
            _2236 = mem[64]
            mem[mem[64]] = s + t
            if not s + t:
                if s > !t:
                    revert with 0, 17
                if s + t > test266151307():
                    revert with 0, 65
                _2323 = mem[64] + (32 * s + t) + 32
                mem[mem[64] + (32 * s + t) + 32] = s + t
                mem[64] = _2323 + (32 * s + t) + 32
                if not s + t:
                    _3500 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = 0
                    u = 0
                    while idx < _3500:
                        mem[0] = arg1
                        mem[32] = 1
                        mem[mem[64] + 32] = idx
                        mem[mem[64] + 64] = stor1[arg1].field_512
                        mem[mem[64] + 96] = stor8
                        _3543 = mem[64]
                        mem[mem[64]] = 96
                        mem[64] = mem[64] + 128
                        if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                            revert with 0, 50
                        if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                            revert with 0, 18
                        if sha3(mem[_3543 + 32 len mem[_3543]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                            if idx == -1:
                                revert with 0, 17
                            _3500 = mem[mem[ceil32(return_data.size) + 160]]
                            idx = idx + 1
                            u = u
                            continue 
                        if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                            revert with 0, 50
                        if u >= mem[_2236]:
                            revert with 0, 50
                        mem[(32 * u) + _2236 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                        if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                            revert with 0, 50
                        if u >= mem[_2323]:
                            revert with 0, 50
                        mem[(32 * u) + _2323 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                        if u == -1:
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        _3500 = mem[mem[ceil32(return_data.size) + 160]]
                        idx = idx + 1
                        u = u + 1
                        continue 
                    idx = 0
                    while idx < stor5.length:
                        mem[0] = 5
                        _5318 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5318] = address(stor5[idx].field_0)
                        mem[_5318 + 32] = address(stor5[idx].field_256)
                        mem[0] = address(stor5[idx].field_0)
                        mem[32] = sha3(arg1, 1) + 3
                        if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                            _5392 = mem[64]
                            mem[mem[64]] = 0
                            mem[mem[64] + 32] = 0
                            mem[64] = mem[64] + 64
                            _6864 = mem[_5392]
                            s = 0
                            t = u
                            while s < _6864:
                                if s >= mem[_5392]:
                                    revert with 0, 50
                                if t >= mem[_2236]:
                                    revert with 0, 50
                                mem[(32 * t) + _2236 + 32] = mem[(32 * s) + _5392 + 32]
                                if s >= mem[_5392 + 32]:
                                    revert with 0, 50
                                if t >= mem[_2323]:
                                    revert with 0, 50
                                mem[(32 * t) + _2323 + 32] = mem[(32 * s) + _5392 + 64]
                                if t == -1:
                                    revert with 0, 17
                                if s == -1:
                                    revert with 0, 17
                                _6864 = mem[_5392]
                                s = s + 1
                                t = t + 1
                                continue 
                        else:
                            mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = arg1
                            mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                            require ext_code.size(address(stor5[idx].field_256))
                            staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                                    gas gas_remaining wei
                                   args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _5580 = mem[64]
                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 64
                            _5653 = mem[_5580]
                            require mem[_5580] <= test266151307()
                            require _5580 + mem[_5580] + 31 < _5580 + return_data.size
                            _5797 = mem[_5580 + mem[_5580]]
                            if mem[_5580 + mem[_5580]] > test266151307():
                                revert with 0, 65
                            if ceil32(32 * mem[_5580 + mem[_5580]]) + 1 < 0 or _5580 + ceil32(return_data.size) + ceil32(32 * mem[_5580 + mem[_5580]]) + 1 > test266151307():
                                revert with 0, 65
                            mem[64] = _5580 + ceil32(return_data.size) + ceil32(32 * mem[_5580 + mem[_5580]]) + 1
                            mem[_5580 + ceil32(return_data.size)] = _5797
                            require _5653 + (32 * _5797) + 32 <= return_data.size
                            s = 0
                            t = _5580 + _5653 + 32
                            v = _5580 + ceil32(return_data.size) + 32
                            while s < _5797:
                                mem[v] = mem[t]
                                s = s + 1
                                t = t + 32
                                v = v + 32
                                continue 
                            _7048 = mem[_5580 + 32]
                            require mem[_5580 + 32] <= test266151307()
                            require _5580 + mem[_5580 + 32] + 31 < _5580 + return_data.size
                            _7165 = mem[_5580 + mem[_5580 + 32]]
                            if mem[_5580 + mem[_5580 + 32]] > test266151307():
                                revert with 0, 65
                            _7354 = mem[64]
                            if mem[64] + ceil32(32 * mem[_5580 + mem[_5580 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_5580 + mem[_5580 + 32]]) + 1 > test266151307():
                                revert with 0, 65
                            mem[64] = mem[64] + ceil32(32 * mem[_5580 + mem[_5580 + 32]]) + 1
                            mem[_7354] = _7165
                            require _7048 + (32 * _7165) + 32 <= return_data.size
                            s = 0
                            t = _5580 + _7048 + 32
                            v = _7354 + 32
                            while s < _7165:
                                mem[v] = mem[t]
                                s = s + 1
                                t = t + 32
                                v = v + 32
                                continue 
                            _9356 = mem[_5580 + ceil32(return_data.size)]
                            s = 0
                            t = u
                            while s < _9356:
                                if s >= mem[_5580 + ceil32(return_data.size)]:
                                    revert with 0, 50
                                if t >= mem[_2236]:
                                    revert with 0, 50
                                mem[(32 * t) + _2236 + 32] = mem[(32 * s) + _5580 + ceil32(return_data.size) + 32]
                                if s >= mem[_7354]:
                                    revert with 0, 50
                                if t >= mem[_2323]:
                                    revert with 0, 50
                                mem[(32 * t) + _2323 + 32] = mem[(32 * s) + _7354 + 32]
                                if t == -1:
                                    revert with 0, 17
                                if s == -1:
                                    revert with 0, 17
                                _9356 = mem[_5580 + ceil32(return_data.size)]
                                s = s + 1
                                t = t + 1
                                continue 
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
                    if s > !t:
                        revert with 0, 17
                    if u != s + t:
                        revert with 0, 1
                    if 0 >= stor9.length:
                        revert with 0, 50
                    mem[0] = arg1
                    mem[32] = 1
                    mem[mem[64]] = 0x15d2cfca00000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 64
                    _5544 = mem[_2236]
                    mem[mem[64] + 68] = mem[_2236]
                    mem[mem[64] + 100 len 32 * _5544] = mem[_2236 + 32 len 32 * _5544]
                    idx = _5544
                    mem[mem[64] + 36] = stor1[arg1].field_512
                    require ext_code.size(address(stor9.field_0))
                    staticcall address(stor9.field_0).0x15d2cfca with:
                            gas gas_remaining wei
                           args 64, stor1[arg1].field_512, mem[mem[64] + 68 len (32 * _5544) + 32]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _7164 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _7280 = mem[_7164]
                    require mem[_7164] <= test266151307()
                    require _7164 + mem[_7164] + 31 < _7164 + return_data.size
                    _7430 = mem[_7164 + mem[_7164]]
                    if mem[_7164 + mem[_7164]] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[_7164 + mem[_7164]]) + 1 < 0 or _7164 + ceil32(return_data.size) + ceil32(32 * mem[_7164 + mem[_7164]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = _7164 + ceil32(return_data.size) + ceil32(32 * mem[_7164 + mem[_7164]]) + 1
                    mem[_7164 + ceil32(return_data.size)] = _7430
                    require _7280 + (32 * _7430) + 32 <= return_data.size
                    mem[_7164 + ceil32(return_data.size) + 32 len 32 * _7430] = mem[_7164 + _7280 + 32 len 32 * _7430]
                    mem[mem[64]] = 32
                    mem[mem[64] + 32] = _7430
                    mem[mem[64] + 64 len 32 * _7430] = mem[_7164 + ceil32(return_data.size) + 32 len 32 * _7430]
                    var88001 = _7430
                    var88002 = _7164 + ceil32(return_data.size) + (32 * _7430) + 32
                    return Array(len=_7430, data=mem[mem[64] + 64 len 32 * _7430])
                mem[_2323 + 32 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
                _3502 = mem[mem[ceil32(return_data.size) + 160]]
                idx = 0
                u = 0
                while idx < _3502:
                    mem[0] = arg1
                    mem[32] = 1
                    mem[mem[64] + 32] = idx
                    mem[mem[64] + 64] = stor1[arg1].field_512
                    mem[mem[64] + 96] = stor8
                    _3550 = mem[64]
                    mem[mem[64]] = 96
                    mem[64] = mem[64] + 128
                    if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                        revert with 0, 50
                    if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        revert with 0, 18
                    if sha3(mem[_3550 + 32 len mem[_3550]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        if idx == -1:
                            revert with 0, 17
                        _3502 = mem[mem[ceil32(return_data.size) + 160]]
                        idx = idx + 1
                        u = u
                        continue 
                    if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                        revert with 0, 50
                    if u >= mem[_2236]:
                        revert with 0, 50
                    mem[(32 * u) + _2236 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                    if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                        revert with 0, 50
                    if u >= mem[_2323]:
                        revert with 0, 50
                    mem[(32 * u) + _2323 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                    if u == -1:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _3502 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = idx + 1
                    u = u + 1
                    continue 
                idx = 0
                while idx < stor5.length:
                    mem[0] = 5
                    _5323 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5323] = address(stor5[idx].field_0)
                    mem[_5323 + 32] = address(stor5[idx].field_256)
                    mem[0] = address(stor5[idx].field_0)
                    mem[32] = sha3(arg1, 1) + 3
                    if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                        _5393 = mem[64]
                        mem[mem[64]] = 0
                        mem[mem[64] + 32] = 0
                        mem[64] = mem[64] + 64
                        _6865 = mem[_5393]
                        s = 0
                        t = u
                        while s < _6865:
                            if s >= mem[_5393]:
                                revert with 0, 50
                            if t >= mem[_2236]:
                                revert with 0, 50
                            mem[(32 * t) + _2236 + 32] = mem[(32 * s) + _5393 + 32]
                            if s >= mem[_5393 + 32]:
                                revert with 0, 50
                            if t >= mem[_2323]:
                                revert with 0, 50
                            mem[(32 * t) + _2323 + 32] = mem[(32 * s) + _5393 + 64]
                            if t == -1:
                                revert with 0, 17
                            if s == -1:
                                revert with 0, 17
                            _6865 = mem[_5393]
                            s = s + 1
                            t = t + 1
                            continue 
                    else:
                        mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = arg1
                        mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                        require ext_code.size(address(stor5[idx].field_256))
                        staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                                gas gas_remaining wei
                               args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _5583 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 64
                        _5656 = mem[_5583]
                        require mem[_5583] <= test266151307()
                        require _5583 + mem[_5583] + 31 < _5583 + return_data.size
                        _5799 = mem[_5583 + mem[_5583]]
                        if mem[_5583 + mem[_5583]] > test266151307():
                            revert with 0, 65
                        if ceil32(32 * mem[_5583 + mem[_5583]]) + 1 < 0 or _5583 + ceil32(return_data.size) + ceil32(32 * mem[_5583 + mem[_5583]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = _5583 + ceil32(return_data.size) + ceil32(32 * mem[_5583 + mem[_5583]]) + 1
                        mem[_5583 + ceil32(return_data.size)] = _5799
                        require _5656 + (32 * _5799) + 32 <= return_data.size
                        s = 0
                        t = _5583 + _5656 + 32
                        v = _5583 + ceil32(return_data.size) + 32
                        while s < _5799:
                            mem[v] = mem[t]
                            s = s + 1
                            t = t + 32
                            v = v + 32
                            continue 
                        _7051 = mem[_5583 + 32]
                        require mem[_5583 + 32] <= test266151307()
                        require _5583 + mem[_5583 + 32] + 31 < _5583 + return_data.size
                        _7167 = mem[_5583 + mem[_5583 + 32]]
                        if mem[_5583 + mem[_5583 + 32]] > test266151307():
                            revert with 0, 65
                        _7355 = mem[64]
                        if mem[64] + ceil32(32 * mem[_5583 + mem[_5583 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_5583 + mem[_5583 + 32]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = mem[64] + ceil32(32 * mem[_5583 + mem[_5583 + 32]]) + 1
                        mem[_7355] = _7167
                        require _7051 + (32 * _7167) + 32 <= return_data.size
                        s = 0
                        t = _5583 + _7051 + 32
                        v = _7355 + 32
                        while s < _7167:
                            mem[v] = mem[t]
                            s = s + 1
                            t = t + 32
                            v = v + 32
                            continue 
                        _9357 = mem[_5583 + ceil32(return_data.size)]
                        s = 0
                        t = u
                        while s < _9357:
                            if s >= mem[_5583 + ceil32(return_data.size)]:
                                revert with 0, 50
                            if t >= mem[_2236]:
                                revert with 0, 50
                            mem[(32 * t) + _2236 + 32] = mem[(32 * s) + _5583 + ceil32(return_data.size) + 32]
                            if s >= mem[_7355]:
                                revert with 0, 50
                            if t >= mem[_2323]:
                                revert with 0, 50
                            mem[(32 * t) + _2323 + 32] = mem[(32 * s) + _7355 + 32]
                            if t == -1:
                                revert with 0, 17
                            if s == -1:
                                revert with 0, 17
                            _9357 = mem[_5583 + ceil32(return_data.size)]
                            s = s + 1
                            t = t + 1
                            continue 
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                if s > !t:
                    revert with 0, 17
                if u != s + t:
                    revert with 0, 1
                if 0 >= stor9.length:
                    revert with 0, 50
                mem[0] = arg1
                mem[32] = 1
                mem[mem[64]] = 0x15d2cfca00000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 64
                _5546 = mem[_2236]
                mem[mem[64] + 68] = mem[_2236]
                mem[mem[64] + 100 len 32 * _5546] = mem[_2236 + 32 len 32 * _5546]
                idx = _5546
                mem[mem[64] + 36] = stor1[arg1].field_512
                require ext_code.size(address(stor9.field_0))
                staticcall address(stor9.field_0).0x15d2cfca with:
                        gas gas_remaining wei
                       args 64, stor1[arg1].field_512, mem[mem[64] + 68 len (32 * _5546) + 32]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _7166 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _7281 = mem[_7166]
                require mem[_7166] <= test266151307()
                require _7166 + mem[_7166] + 31 < _7166 + return_data.size
                _7431 = mem[_7166 + mem[_7166]]
                if mem[_7166 + mem[_7166]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_7166 + mem[_7166]]) + 1 < 0 or _7166 + ceil32(return_data.size) + ceil32(32 * mem[_7166 + mem[_7166]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _7166 + ceil32(return_data.size) + ceil32(32 * mem[_7166 + mem[_7166]]) + 1
                mem[_7166 + ceil32(return_data.size)] = _7431
                require _7281 + (32 * _7431) + 32 <= return_data.size
                mem[_7166 + ceil32(return_data.size) + 32 len 32 * _7431] = mem[_7166 + _7281 + 32 len 32 * _7431]
                mem[mem[64]] = 32
                mem[mem[64] + 32] = _7431
                mem[mem[64] + 64 len 32 * _7431] = mem[_7166 + ceil32(return_data.size) + 32 len 32 * _7431]
                var89001 = _7431
                var89002 = _7166 + ceil32(return_data.size) + (32 * _7431) + 32
                return Array(len=_7431, data=mem[mem[64] + 64 len 32 * _7431])
            mem[mem[64] + 32 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
            if s > !t:
                revert with 0, 17
            if s + t > test266151307():
                revert with 0, 65
            mem[mem[64] + (32 * s + t) + 32] = s + t
            mem[64] = _2236 + (64 * s + t) + 64
            if not s + t:
                _3504 = mem[mem[ceil32(return_data.size) + 160]]
                idx = 0
                u = 0
                while idx < _3504:
                    mem[0] = arg1
                    mem[32] = 1
                    mem[mem[64] + 32] = idx
                    mem[mem[64] + 64] = stor1[arg1].field_512
                    mem[mem[64] + 96] = stor8
                    _3557 = mem[64]
                    mem[mem[64]] = 96
                    mem[64] = mem[64] + 128
                    if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                        revert with 0, 50
                    if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        revert with 0, 18
                    if sha3(mem[_3557 + 32 len mem[_3557]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        if idx == -1:
                            revert with 0, 17
                        _3504 = mem[mem[ceil32(return_data.size) + 160]]
                        idx = idx + 1
                        u = u
                        continue 
                    if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                        revert with 0, 50
                    if u >= mem[_2236]:
                        revert with 0, 50
                    mem[(32 * u) + _2236 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                    if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                        revert with 0, 50
                    if u >= mem[_2236 + (32 * s + t) + 32]:
                        revert with 0, 50
                    mem[(32 * u) + _2236 + (32 * s + t) + 64] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                    if u == -1:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _3504 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = idx + 1
                    u = u + 1
                    continue 
                idx = 0
                while idx < stor5.length:
                    mem[0] = 5
                    _5328 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5328] = address(stor5[idx].field_0)
                    mem[_5328 + 32] = address(stor5[idx].field_256)
                    mem[0] = address(stor5[idx].field_0)
                    mem[32] = sha3(arg1, 1) + 3
                    if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                        _5394 = mem[64]
                        mem[mem[64]] = 0
                        mem[mem[64] + 32] = 0
                        mem[64] = mem[64] + 64
                        _6866 = mem[_5394]
                        v = 0
                        w = u
                        while v < _6866:
                            if v >= mem[_5394]:
                                revert with 0, 50
                            if w >= mem[_2236]:
                                revert with 0, 50
                            mem[(32 * w) + _2236 + 32] = mem[(32 * v) + _5394 + 32]
                            if v >= mem[_5394 + 32]:
                                revert with 0, 50
                            if w >= mem[_2236 + (32 * s + t) + 32]:
                                revert with 0, 50
                            mem[(32 * w) + _2236 + (32 * s + t) + 64] = mem[(32 * v) + _5394 + 64]
                            if w == -1:
                                revert with 0, 17
                            if v == -1:
                                revert with 0, 17
                            _6866 = mem[_5394]
                            v = v + 1
                            w = w + 1
                            continue 
                    else:
                        mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = arg1
                        mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                        require ext_code.size(address(stor5[idx].field_256))
                        staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                                gas gas_remaining wei
                               args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _5586 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 64
                        _5659 = mem[_5586]
                        require mem[_5586] <= test266151307()
                        require _5586 + mem[_5586] + 31 < _5586 + return_data.size
                        _5801 = mem[_5586 + mem[_5586]]
                        if mem[_5586 + mem[_5586]] > test266151307():
                            revert with 0, 65
                        if ceil32(32 * mem[_5586 + mem[_5586]]) + 1 < 0 or _5586 + ceil32(return_data.size) + ceil32(32 * mem[_5586 + mem[_5586]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = _5586 + ceil32(return_data.size) + ceil32(32 * mem[_5586 + mem[_5586]]) + 1
                        mem[_5586 + ceil32(return_data.size)] = _5801
                        require _5659 + (32 * _5801) + 32 <= return_data.size
                        v = 0
                        w = _5586 + _5659 + 32
                        x = _5586 + ceil32(return_data.size) + 32
                        while v < _5801:
                            mem[x] = mem[w]
                            v = v + 1
                            w = w + 32
                            x = x + 32
                            continue 
                        _7054 = mem[_5586 + 32]
                        require mem[_5586 + 32] <= test266151307()
                        require _5586 + mem[_5586 + 32] + 31 < _5586 + return_data.size
                        _7169 = mem[_5586 + mem[_5586 + 32]]
                        if mem[_5586 + mem[_5586 + 32]] > test266151307():
                            revert with 0, 65
                        _7356 = mem[64]
                        if mem[64] + ceil32(32 * mem[_5586 + mem[_5586 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_5586 + mem[_5586 + 32]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = mem[64] + ceil32(32 * mem[_5586 + mem[_5586 + 32]]) + 1
                        mem[_7356] = _7169
                        require _7054 + (32 * _7169) + 32 <= return_data.size
                        v = 0
                        w = _5586 + _7054 + 32
                        x = _7356 + 32
                        while v < _7169:
                            mem[x] = mem[w]
                            v = v + 1
                            w = w + 32
                            x = x + 32
                            continue 
                        _9358 = mem[_5586 + ceil32(return_data.size)]
                        v = 0
                        w = u
                        while v < _9358:
                            if v >= mem[_5586 + ceil32(return_data.size)]:
                                revert with 0, 50
                            if w >= mem[_2236]:
                                revert with 0, 50
                            mem[(32 * w) + _2236 + 32] = mem[(32 * v) + _5586 + ceil32(return_data.size) + 32]
                            if v >= mem[_7356]:
                                revert with 0, 50
                            if w >= mem[_2236 + (32 * s + t) + 32]:
                                revert with 0, 50
                            mem[(32 * w) + _2236 + (32 * s + t) + 64] = mem[(32 * v) + _7356 + 32]
                            if w == -1:
                                revert with 0, 17
                            if v == -1:
                                revert with 0, 17
                            _9358 = mem[_5586 + ceil32(return_data.size)]
                            v = v + 1
                            w = w + 1
                            continue 
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                if s > !t:
                    revert with 0, 17
                if u != s + t:
                    revert with 0, 1
                if 0 >= stor9.length:
                    revert with 0, 50
                mem[0] = arg1
                mem[32] = 1
                mem[mem[64]] = 0x15d2cfca00000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 64
                _5548 = mem[_2236]
                mem[mem[64] + 68] = mem[_2236]
                mem[mem[64] + 100 len 32 * _5548] = mem[_2236 + 32 len 32 * _5548]
                idx = _5548
                mem[mem[64] + 36] = stor1[arg1].field_512
                require ext_code.size(address(stor9.field_0))
                staticcall address(stor9.field_0).0x15d2cfca with:
                        gas gas_remaining wei
                       args 64, stor1[arg1].field_512, mem[mem[64] + 68 len (32 * _5548) + 32]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _7168 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _7282 = mem[_7168]
                require mem[_7168] <= test266151307()
                require _7168 + mem[_7168] + 31 < _7168 + return_data.size
                _7432 = mem[_7168 + mem[_7168]]
                if mem[_7168 + mem[_7168]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_7168 + mem[_7168]]) + 1 < 0 or _7168 + ceil32(return_data.size) + ceil32(32 * mem[_7168 + mem[_7168]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _7168 + ceil32(return_data.size) + ceil32(32 * mem[_7168 + mem[_7168]]) + 1
                mem[_7168 + ceil32(return_data.size)] = _7432
                require _7282 + (32 * _7432) + 32 <= return_data.size
                mem[_7168 + ceil32(return_data.size) + 32 len 32 * _7432] = mem[_7168 + _7282 + 32 len 32 * _7432]
                mem[mem[64]] = 32
                mem[mem[64] + 32] = _7432
                mem[mem[64] + 64 len 32 * _7432] = mem[_7168 + ceil32(return_data.size) + 32 len 32 * _7432]
                var89001 = _7432
                var89002 = _7168 + ceil32(return_data.size) + (32 * _7432) + 32
                return Array(len=_7432, data=mem[mem[64] + 64 len 32 * _7432])
            mem[_2236 + (32 * s + t) + 64 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
            _3506 = mem[mem[ceil32(return_data.size) + 160]]
            idx = 0
            u = 0
            while idx < _3506:
                mem[0] = arg1
                mem[32] = 1
                mem[mem[64] + 32] = idx
                mem[mem[64] + 64] = stor1[arg1].field_512
                mem[mem[64] + 96] = stor8
                _3564 = mem[64]
                mem[mem[64]] = 96
                mem[64] = mem[64] + 128
                if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                    revert with 0, 50
                if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    revert with 0, 18
                if sha3(mem[_3564 + 32 len mem[_3564]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    if idx == -1:
                        revert with 0, 17
                    _3506 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = idx + 1
                    u = u
                    continue 
                if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                    revert with 0, 50
                if u >= mem[_2236]:
                    revert with 0, 50
                mem[(32 * u) + _2236 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                    revert with 0, 50
                if u >= mem[_2236 + (32 * s + t) + 32]:
                    revert with 0, 50
                mem[(32 * u) + _2236 + (32 * s + t) + 64] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                if u == -1:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _3506 = mem[mem[ceil32(return_data.size) + 160]]
                idx = idx + 1
                u = u + 1
                continue 
            idx = 0
            while idx < stor5.length:
                mem[0] = 5
                _5333 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5333] = address(stor5[idx].field_0)
                mem[_5333 + 32] = address(stor5[idx].field_256)
                mem[0] = address(stor5[idx].field_0)
                mem[32] = sha3(arg1, 1) + 3
                if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                    _5395 = mem[64]
                    mem[mem[64]] = 0
                    mem[mem[64] + 32] = 0
                    mem[64] = mem[64] + 64
                    _6867 = mem[_5395]
                    v = 0
                    w = u
                    while v < _6867:
                        if v >= mem[_5395]:
                            revert with 0, 50
                        if w >= mem[_2236]:
                            revert with 0, 50
                        mem[(32 * w) + _2236 + 32] = mem[(32 * v) + _5395 + 32]
                        if v >= mem[_5395 + 32]:
                            revert with 0, 50
                        if w >= mem[_2236 + (32 * s + t) + 32]:
                            revert with 0, 50
                        mem[(32 * w) + _2236 + (32 * s + t) + 64] = mem[(32 * v) + _5395 + 64]
                        if w == -1:
                            revert with 0, 17
                        if v == -1:
                            revert with 0, 17
                        _6867 = mem[_5395]
                        v = v + 1
                        w = w + 1
                        continue 
                else:
                    mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = arg1
                    mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    require ext_code.size(address(stor5[idx].field_256))
                    staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                            gas gas_remaining wei
                           args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _5589 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 64
                    _5662 = mem[_5589]
                    require mem[_5589] <= test266151307()
                    require _5589 + mem[_5589] + 31 < _5589 + return_data.size
                    _5803 = mem[_5589 + mem[_5589]]
                    if mem[_5589 + mem[_5589]] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[_5589 + mem[_5589]]) + 1 < 0 or _5589 + ceil32(return_data.size) + ceil32(32 * mem[_5589 + mem[_5589]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = _5589 + ceil32(return_data.size) + ceil32(32 * mem[_5589 + mem[_5589]]) + 1
                    mem[_5589 + ceil32(return_data.size)] = _5803
                    require _5662 + (32 * _5803) + 32 <= return_data.size
                    v = 0
                    w = _5589 + _5662 + 32
                    x = _5589 + ceil32(return_data.size) + 32
                    while v < _5803:
                        mem[x] = mem[w]
                        v = v + 1
                        w = w + 32
                        x = x + 32
                        continue 
                    _7057 = mem[_5589 + 32]
                    require mem[_5589 + 32] <= test266151307()
                    require _5589 + mem[_5589 + 32] + 31 < _5589 + return_data.size
                    _7171 = mem[_5589 + mem[_5589 + 32]]
                    if mem[_5589 + mem[_5589 + 32]] > test266151307():
                        revert with 0, 65
                    _7357 = mem[64]
                    if mem[64] + ceil32(32 * mem[_5589 + mem[_5589 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_5589 + mem[_5589 + 32]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = mem[64] + ceil32(32 * mem[_5589 + mem[_5589 + 32]]) + 1
                    mem[_7357] = _7171
                    require _7057 + (32 * _7171) + 32 <= return_data.size
                    v = 0
                    w = _5589 + _7057 + 32
                    x = _7357 + 32
                    while v < _7171:
                        mem[x] = mem[w]
                        v = v + 1
                        w = w + 32
                        x = x + 32
                        continue 
                    _9359 = mem[_5589 + ceil32(return_data.size)]
                    v = 0
                    w = u
                    while v < _9359:
                        if v >= mem[_5589 + ceil32(return_data.size)]:
                            revert with 0, 50
                        if w >= mem[_2236]:
                            revert with 0, 50
                        mem[(32 * w) + _2236 + 32] = mem[(32 * v) + _5589 + ceil32(return_data.size) + 32]
                        if v >= mem[_7357]:
                            revert with 0, 50
                        if w >= mem[_2236 + (32 * s + t) + 32]:
                            revert with 0, 50
                        mem[(32 * w) + _2236 + (32 * s + t) + 64] = mem[(32 * v) + _7357 + 32]
                        if w == -1:
                            revert with 0, 17
                        if v == -1:
                            revert with 0, 17
                        _9359 = mem[_5589 + ceil32(return_data.size)]
                        v = v + 1
                        w = w + 1
                        continue 
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            if s > !t:
                revert with 0, 17
            if u != s + t:
                revert with 0, 1
            if 0 >= stor9.length:
                revert with 0, 50
            mem[0] = arg1
            mem[32] = 1
            mem[mem[64]] = 0x15d2cfca00000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 64
            _5550 = mem[_2236]
            mem[mem[64] + 68] = mem[_2236]
            mem[mem[64] + 100 len 32 * _5550] = mem[_2236 + 32 len 32 * _5550]
            idx = _5550
            var63002 = _2236 + (32 * _5550) + 32
            mem[mem[64] + 36] = stor1[arg1].field_512
            require ext_code.size(address(stor9.field_0))
            staticcall address(stor9.field_0).0x15d2cfca with:
                    gas gas_remaining wei
                   args 64, stor1[arg1].field_512, mem[mem[64] + 68 len (32 * _5550) + 32]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _7170 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _7283 = mem[_7170]
            require mem[_7170] <= test266151307()
            require _7170 + mem[_7170] + 31 < _7170 + return_data.size
            _7433 = mem[_7170 + mem[_7170]]
            if mem[_7170 + mem[_7170]] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[_7170 + mem[_7170]]) + 1 < 0 or _7170 + ceil32(return_data.size) + ceil32(32 * mem[_7170 + mem[_7170]]) + 1 > test266151307():
                revert with 0, 65
            mem[64] = _7170 + ceil32(return_data.size) + ceil32(32 * mem[_7170 + mem[_7170]]) + 1
            mem[_7170 + ceil32(return_data.size)] = _7433
            require _7283 + (32 * _7433) + 32 <= return_data.size
            mem[_7170 + ceil32(return_data.size) + 32 len 32 * _7433] = mem[_7170 + _7283 + 32 len 32 * _7433]
            mem[mem[64]] = 32
            mem[mem[64] + 32] = _7433
            mem[mem[64] + 64 len 32 * _7433] = mem[_7170 + ceil32(return_data.size) + 32 len 32 * _7433]
            var90001 = _7433
            var90002 = _7170 + ceil32(return_data.size) + (32 * _7433) + 32
            return Array(len=_7433, data=mem[mem[64] + 64 len 32 * _7433])
        mem[0] = sha3(ext_call.return_data[31 len 1], 10) + 1
        mem[ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + 256] = stor10[ext_call.return_data[31 len 1]][1].field_0
        idx = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + 256
        s = 0
        while ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 224 > idx:
            mem[idx + 32] = stor10[ext_call.return_data[31 len 1]][s + 1].field_256
            idx = idx + 32
            s = s + 1
            continue 
        mem[ceil32(return_data.size) + 128] = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + 224
        mem[64] = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + (32 * stor10[ext_call.return_data[31 len 1]].field_512) + 288
        mem[ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 256] = stor10[ext_call.return_data[31 len 1]].field_512
        if not stor10[ext_call.return_data[31 len 1]].field_512:
            mem[ceil32(return_data.size) + 160] = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 256
            idx = 0
            s = 0
            while idx < stor10[ext_call.return_data[31 len 1]].field_512:
                mem[0] = arg1
                mem[32] = 1
                mem[mem[64] + 32] = idx
                mem[mem[64] + 64] = stor1[arg1].field_512
                mem[mem[64] + 96] = stor8
                _1068 = mem[64]
                mem[mem[64]] = 96
                mem[64] = mem[64] + 128
                if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                    revert with 0, 50
                if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    revert with 0, 18
                if sha3(mem[_1068 + 32 len mem[_1068]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s
                    continue 
                if s == -1:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s + 1
                continue 
            idx = 0
            t = 0
            while idx < stor5.length:
                mem[0] = 5
                _2221 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2221] = address(stor5[idx].field_0)
                mem[_2221 + 32] = address(stor5[idx].field_256)
                mem[0] = address(stor5[idx].field_0)
                mem[32] = sha3(arg1, 1) + 3
                if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                    _2239 = mem[64]
                    mem[mem[64]] = 0
                    mem[mem[64] + 32] = 0
                    mem[64] = mem[64] + 64
                    if t > !mem[_2239]:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    t = t + mem[_2239]
                    continue 
                mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = arg1
                mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                require ext_code.size(address(stor5[idx].field_256))
                staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                        gas gas_remaining wei
                       args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _2326 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 64
                _2366 = mem[_2326]
                require mem[_2326] <= test266151307()
                require _2326 + mem[_2326] + 31 < _2326 + return_data.size
                _2494 = mem[_2326 + mem[_2326]]
                if mem[_2326 + mem[_2326]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_2326 + mem[_2326]]) + 1 < 0 or _2326 + ceil32(return_data.size) + ceil32(32 * mem[_2326 + mem[_2326]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _2326 + ceil32(return_data.size) + ceil32(32 * mem[_2326 + mem[_2326]]) + 1
                mem[_2326 + ceil32(return_data.size)] = _2494
                require _2366 + (32 * _2494) + 32 <= return_data.size
                s = 0
                u = _2326 + _2366 + 32
                v = _2326 + ceil32(return_data.size) + 32
                while s < _2494:
                    mem[v] = mem[u]
                    s = s + 1
                    u = u + 32
                    v = v + 32
                    continue 
                _3670 = mem[_2326 + 32]
                require mem[_2326 + 32] <= test266151307()
                require _2326 + mem[_2326 + 32] + 31 < _2326 + return_data.size
                _3704 = mem[_2326 + mem[_2326 + 32]]
                if mem[_2326 + mem[_2326 + 32]] > test266151307():
                    revert with 0, 65
                _3920 = mem[64]
                if mem[64] + ceil32(32 * mem[_2326 + mem[_2326 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_2326 + mem[_2326 + 32]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = mem[64] + ceil32(32 * mem[_2326 + mem[_2326 + 32]]) + 1
                mem[_3920] = _3704
                require _3670 + (32 * _3704) + 32 <= return_data.size
                s = 0
                u = _2326 + _3670 + 32
                v = _3920 + 32
                while s < _3704:
                    mem[v] = mem[u]
                    s = s + 1
                    u = u + 32
                    v = v + 32
                    continue 
                if t > !mem[_2326 + ceil32(return_data.size)]:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                t = t + mem[_2326 + ceil32(return_data.size)]
                continue 
            if s > !t:
                revert with 0, 17
            if s + t > test266151307():
                revert with 0, 65
            _2238 = mem[64]
            mem[mem[64]] = s + t
            if s + t:
                mem[mem[64] + 32 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
                if s > !t:
                    revert with 0, 17
                if s + t > test266151307():
                    revert with 0, 65
                mem[mem[64] + (32 * s + t) + 32] = s + t
                mem[64] = _2238 + (64 * s + t) + 64
                if not s + t:
                    _3512 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = 0
                    u = 0
                    while idx < _3512:
                        mem[0] = arg1
                        mem[32] = 1
                        mem[mem[64] + 32] = idx
                        mem[mem[64] + 64] = stor1[arg1].field_512
                        mem[mem[64] + 96] = stor8
                        _3586 = mem[64]
                        mem[mem[64]] = 96
                        mem[64] = mem[64] + 128
                        if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                            revert with 0, 50
                        if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                            revert with 0, 18
                        if sha3(mem[_3586 + 32 len mem[_3586]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                            if idx == -1:
                                revert with 0, 17
                            _3512 = mem[mem[ceil32(return_data.size) + 160]]
                            idx = idx + 1
                            u = u
                            continue 
                        if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                            revert with 0, 50
                        if u >= mem[_2238]:
                            revert with 0, 50
                        mem[(32 * u) + _2238 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                        if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                            revert with 0, 50
                        if u >= mem[_2238 + (32 * s + t) + 32]:
                            revert with 0, 50
                        mem[(32 * u) + _2238 + (32 * s + t) + 64] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                        if u == -1:
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        _3512 = mem[mem[ceil32(return_data.size) + 160]]
                        idx = idx + 1
                        u = u + 1
                        continue 
                    idx = 0
                    while idx < stor5.length:
                        mem[0] = 5
                        _5348 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5348] = address(stor5[idx].field_0)
                        mem[_5348 + 32] = address(stor5[idx].field_256)
                        mem[0] = address(stor5[idx].field_0)
                        mem[32] = sha3(arg1, 1) + 3
                        if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                            _5399 = mem[64]
                            mem[mem[64]] = 0
                            mem[mem[64] + 32] = 0
                            mem[64] = mem[64] + 64
                            _6870 = mem[_5399]
                            v = 0
                            w = u
                            while v < _6870:
                                if v >= mem[_5399]:
                                    revert with 0, 50
                                if w >= mem[_2238]:
                                    revert with 0, 50
                                mem[(32 * w) + _2238 + 32] = mem[(32 * v) + _5399 + 32]
                                if v >= mem[_5399 + 32]:
                                    revert with 0, 50
                                if w >= mem[_2238 + (32 * s + t) + 32]:
                                    revert with 0, 50
                                mem[(32 * w) + _2238 + (32 * s + t) + 64] = mem[(32 * v) + _5399 + 64]
                                if w == -1:
                                    revert with 0, 17
                                if v == -1:
                                    revert with 0, 17
                                _6870 = mem[_5399]
                                v = v + 1
                                w = w + 1
                                continue 
                        else:
                            mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = arg1
                            mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                            require ext_code.size(address(stor5[idx].field_256))
                            staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                                    gas gas_remaining wei
                                   args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _5598 = mem[64]
                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 64
                            _5671 = mem[_5598]
                            require mem[_5598] <= test266151307()
                            require _5598 + mem[_5598] + 31 < _5598 + return_data.size
                            _5809 = mem[_5598 + mem[_5598]]
                            if mem[_5598 + mem[_5598]] > test266151307():
                                revert with 0, 65
                            if ceil32(32 * mem[_5598 + mem[_5598]]) + 1 < 0 or _5598 + ceil32(return_data.size) + ceil32(32 * mem[_5598 + mem[_5598]]) + 1 > test266151307():
                                revert with 0, 65
                            mem[64] = _5598 + ceil32(return_data.size) + ceil32(32 * mem[_5598 + mem[_5598]]) + 1
                            mem[_5598 + ceil32(return_data.size)] = _5809
                            require _5671 + (32 * _5809) + 32 <= return_data.size
                            v = 0
                            w = _5598 + _5671 + 32
                            x = _5598 + ceil32(return_data.size) + 32
                            while v < _5809:
                                mem[x] = mem[w]
                                v = v + 1
                                w = w + 32
                                x = x + 32
                                continue 
                            _7066 = mem[_5598 + 32]
                            require mem[_5598 + 32] <= test266151307()
                            require _5598 + mem[_5598 + 32] + 31 < _5598 + return_data.size
                            _7177 = mem[_5598 + mem[_5598 + 32]]
                            if mem[_5598 + mem[_5598 + 32]] > test266151307():
                                revert with 0, 65
                            _7360 = mem[64]
                            if mem[64] + ceil32(32 * mem[_5598 + mem[_5598 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_5598 + mem[_5598 + 32]]) + 1 > test266151307():
                                revert with 0, 65
                            mem[64] = mem[64] + ceil32(32 * mem[_5598 + mem[_5598 + 32]]) + 1
                            mem[_7360] = _7177
                            require _7066 + (32 * _7177) + 32 <= return_data.size
                            v = 0
                            w = _5598 + _7066 + 32
                            x = _7360 + 32
                            while v < _7177:
                                mem[x] = mem[w]
                                v = v + 1
                                w = w + 32
                                x = x + 32
                                continue 
                            _9362 = mem[_5598 + ceil32(return_data.size)]
                            v = 0
                            w = u
                            while v < _9362:
                                if v >= mem[_5598 + ceil32(return_data.size)]:
                                    revert with 0, 50
                                if w >= mem[_2238]:
                                    revert with 0, 50
                                mem[(32 * w) + _2238 + 32] = mem[(32 * v) + _5598 + ceil32(return_data.size) + 32]
                                if v >= mem[_7360]:
                                    revert with 0, 50
                                if w >= mem[_2238 + (32 * s + t) + 32]:
                                    revert with 0, 50
                                mem[(32 * w) + _2238 + (32 * s + t) + 64] = mem[(32 * v) + _7360 + 32]
                                if w == -1:
                                    revert with 0, 17
                                if v == -1:
                                    revert with 0, 17
                                _9362 = mem[_5598 + ceil32(return_data.size)]
                                v = v + 1
                                w = w + 1
                                continue 
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
                    if s > !t:
                        revert with 0, 17
                    if u != s + t:
                        revert with 0, 1
                    if 0 >= stor9.length:
                        revert with 0, 50
                    mem[0] = arg1
                    mem[32] = 1
                    mem[mem[64]] = 0x15d2cfca00000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 64
                    _5556 = mem[_2238]
                    mem[mem[64] + 68] = mem[_2238]
                    mem[mem[64] + 100 len 32 * _5556] = mem[_2238 + 32 len 32 * _5556]
                    idx = _5556
                    var62002 = _2238 + (32 * _5556) + 32
                    mem[mem[64] + 36] = stor1[arg1].field_512
                    require ext_code.size(address(stor9.field_0))
                    staticcall address(stor9.field_0).0x15d2cfca with:
                            gas gas_remaining wei
                           args 64, stor1[arg1].field_512, mem[mem[64] + 68 len (32 * _5556) + 32]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _7176 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _7286 = mem[_7176]
                    require mem[_7176] <= test266151307()
                    require _7176 + mem[_7176] + 31 < _7176 + return_data.size
                    _7436 = mem[_7176 + mem[_7176]]
                    if mem[_7176 + mem[_7176]] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[_7176 + mem[_7176]]) + 1 < 0 or _7176 + ceil32(return_data.size) + ceil32(32 * mem[_7176 + mem[_7176]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = _7176 + ceil32(return_data.size) + ceil32(32 * mem[_7176 + mem[_7176]]) + 1
                    mem[_7176 + ceil32(return_data.size)] = _7436
                    require _7286 + (32 * _7436) + 32 <= return_data.size
                    mem[_7176 + ceil32(return_data.size) + 32 len 32 * _7436] = mem[_7176 + _7286 + 32 len 32 * _7436]
                    mem[mem[64]] = 32
                    mem[mem[64] + 32] = _7436
                    mem[mem[64] + 64 len 32 * _7436] = mem[_7176 + ceil32(return_data.size) + 32 len 32 * _7436]
                    var89001 = _7436
                    var89002 = _7176 + ceil32(return_data.size) + (32 * _7436) + 32
                    return Array(len=_7436, data=mem[mem[64] + 64 len 32 * _7436])
                mem[_2238 + (32 * s + t) + 64 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
                _3514 = mem[mem[ceil32(return_data.size) + 160]]
                idx = 0
                u = 0
                while idx < _3514:
                    mem[0] = arg1
                    mem[32] = 1
                    mem[mem[64] + 32] = idx
                    mem[mem[64] + 64] = stor1[arg1].field_512
                    mem[mem[64] + 96] = stor8
                    _3593 = mem[64]
                    mem[mem[64]] = 96
                    mem[64] = mem[64] + 128
                    if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                        revert with 0, 50
                    if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        revert with 0, 18
                    if sha3(mem[_3593 + 32 len mem[_3593]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        if idx == -1:
                            revert with 0, 17
                        _3514 = mem[mem[ceil32(return_data.size) + 160]]
                        idx = idx + 1
                        u = u
                        continue 
                    if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                        revert with 0, 50
                    if u >= mem[_2238]:
                        revert with 0, 50
                    mem[(32 * u) + _2238 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                    if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                        revert with 0, 50
                    if u >= mem[_2238 + (32 * s + t) + 32]:
                        revert with 0, 50
                    mem[(32 * u) + _2238 + (32 * s + t) + 64] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                    if u == -1:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _3514 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = idx + 1
                    u = u + 1
                    continue 
                idx = 0
                while idx < stor5.length:
                    mem[0] = 5
                    _5353 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5353] = address(stor5[idx].field_0)
                    mem[_5353 + 32] = address(stor5[idx].field_256)
                    mem[0] = address(stor5[idx].field_0)
                    mem[32] = sha3(arg1, 1) + 3
                    if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                        _5400 = mem[64]
                        mem[mem[64]] = 0
                        mem[mem[64] + 32] = 0
                        mem[64] = mem[64] + 64
                        _6871 = mem[_5400]
                        v = 0
                        w = u
                        while v < _6871:
                            if v >= mem[_5400]:
                                revert with 0, 50
                            if w >= mem[_2238]:
                                revert with 0, 50
                            mem[(32 * w) + _2238 + 32] = mem[(32 * v) + _5400 + 32]
                            if v >= mem[_5400 + 32]:
                                revert with 0, 50
                            if w >= mem[_2238 + (32 * s + t) + 32]:
                                revert with 0, 50
                            mem[(32 * w) + _2238 + (32 * s + t) + 64] = mem[(32 * v) + _5400 + 64]
                            if w == -1:
                                revert with 0, 17
                            if v == -1:
                                revert with 0, 17
                            _6871 = mem[_5400]
                            v = v + 1
                            w = w + 1
                            continue 
                    else:
                        mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = arg1
                        mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                        require ext_code.size(address(stor5[idx].field_256))
                        staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                                gas gas_remaining wei
                               args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _5601 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 64
                        _5674 = mem[_5601]
                        require mem[_5601] <= test266151307()
                        require _5601 + mem[_5601] + 31 < _5601 + return_data.size
                        _5811 = mem[_5601 + mem[_5601]]
                        if mem[_5601 + mem[_5601]] > test266151307():
                            revert with 0, 65
                        if ceil32(32 * mem[_5601 + mem[_5601]]) + 1 < 0 or _5601 + ceil32(return_data.size) + ceil32(32 * mem[_5601 + mem[_5601]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = _5601 + ceil32(return_data.size) + ceil32(32 * mem[_5601 + mem[_5601]]) + 1
                        mem[_5601 + ceil32(return_data.size)] = _5811
                        require _5674 + (32 * _5811) + 32 <= return_data.size
                        v = 0
                        w = _5601 + _5674 + 32
                        x = _5601 + ceil32(return_data.size) + 32
                        while v < _5811:
                            mem[x] = mem[w]
                            v = v + 1
                            w = w + 32
                            x = x + 32
                            continue 
                        _7069 = mem[_5601 + 32]
                        require mem[_5601 + 32] <= test266151307()
                        require _5601 + mem[_5601 + 32] + 31 < _5601 + return_data.size
                        _7179 = mem[_5601 + mem[_5601 + 32]]
                        if mem[_5601 + mem[_5601 + 32]] > test266151307():
                            revert with 0, 65
                        _7361 = mem[64]
                        if mem[64] + ceil32(32 * mem[_5601 + mem[_5601 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_5601 + mem[_5601 + 32]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = mem[64] + ceil32(32 * mem[_5601 + mem[_5601 + 32]]) + 1
                        mem[_7361] = _7179
                        require _7069 + (32 * _7179) + 32 <= return_data.size
                        v = 0
                        w = _5601 + _7069 + 32
                        x = _7361 + 32
                        while v < _7179:
                            mem[x] = mem[w]
                            v = v + 1
                            w = w + 32
                            x = x + 32
                            continue 
                        _9363 = mem[_5601 + ceil32(return_data.size)]
                        v = 0
                        w = u
                        while v < _9363:
                            if v >= mem[_5601 + ceil32(return_data.size)]:
                                revert with 0, 50
                            if w >= mem[_2238]:
                                revert with 0, 50
                            mem[(32 * w) + _2238 + 32] = mem[(32 * v) + _5601 + ceil32(return_data.size) + 32]
                            if v >= mem[_7361]:
                                revert with 0, 50
                            if w >= mem[_2238 + (32 * s + t) + 32]:
                                revert with 0, 50
                            mem[(32 * w) + _2238 + (32 * s + t) + 64] = mem[(32 * v) + _7361 + 32]
                            if w == -1:
                                revert with 0, 17
                            if v == -1:
                                revert with 0, 17
                            _9363 = mem[_5601 + ceil32(return_data.size)]
                            v = v + 1
                            w = w + 1
                            continue 
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                if s > !t:
                    revert with 0, 17
                if u != s + t:
                    revert with 0, 1
                if 0 >= stor9.length:
                    revert with 0, 50
                mem[0] = arg1
                mem[32] = 1
                mem[mem[64]] = 0x15d2cfca00000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 64
                _5558 = mem[_2238]
                mem[mem[64] + 68] = mem[_2238]
                mem[mem[64] + 100 len 32 * _5558] = mem[_2238 + 32 len 32 * _5558]
                idx = _5558
                var63002 = _2238 + (32 * _5558) + 32
                mem[mem[64] + 36] = stor1[arg1].field_512
                require ext_code.size(address(stor9.field_0))
                staticcall address(stor9.field_0).0x15d2cfca with:
                        gas gas_remaining wei
                       args 64, stor1[arg1].field_512, mem[mem[64] + 68 len (32 * _5558) + 32]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _7178 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _7287 = mem[_7178]
                require mem[_7178] <= test266151307()
                require _7178 + mem[_7178] + 31 < _7178 + return_data.size
                _7437 = mem[_7178 + mem[_7178]]
                if mem[_7178 + mem[_7178]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_7178 + mem[_7178]]) + 1 < 0 or _7178 + ceil32(return_data.size) + ceil32(32 * mem[_7178 + mem[_7178]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _7178 + ceil32(return_data.size) + ceil32(32 * mem[_7178 + mem[_7178]]) + 1
                mem[_7178 + ceil32(return_data.size)] = _7437
                require _7287 + (32 * _7437) + 32 <= return_data.size
                mem[_7178 + ceil32(return_data.size) + 32 len 32 * _7437] = mem[_7178 + _7287 + 32 len 32 * _7437]
                mem[mem[64]] = 32
                mem[mem[64] + 32] = _7437
                mem[mem[64] + 64 len 32 * _7437] = mem[_7178 + ceil32(return_data.size) + 32 len 32 * _7437]
                var90001 = _7437
                var90002 = _7178 + ceil32(return_data.size) + (32 * _7437) + 32
                return Array(len=_7437, data=mem[mem[64] + 64 len 32 * _7437])
            if s > !t:
                revert with 0, 17
            if s + t > test266151307():
                revert with 0, 65
            _2325 = mem[64] + (32 * s + t) + 32
            mem[mem[64] + (32 * s + t) + 32] = s + t
            mem[64] = _2325 + (32 * s + t) + 32
            if s + t:
                mem[_2325 + 32 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
                _3510 = mem[mem[ceil32(return_data.size) + 160]]
                idx = 0
                u = 0
                while idx < _3510:
                    mem[0] = arg1
                    mem[32] = 1
                    mem[mem[64] + 32] = idx
                    mem[mem[64] + 64] = stor1[arg1].field_512
                    mem[mem[64] + 96] = stor8
                    _3579 = mem[64]
                    mem[mem[64]] = 96
                    mem[64] = mem[64] + 128
                    if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                        revert with 0, 50
                    if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        revert with 0, 18
                    if sha3(mem[_3579 + 32 len mem[_3579]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        if idx == -1:
                            revert with 0, 17
                        _3510 = mem[mem[ceil32(return_data.size) + 160]]
                        idx = idx + 1
                        u = u
                        continue 
                    if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                        revert with 0, 50
                    if u >= mem[_2238]:
                        revert with 0, 50
                    mem[(32 * u) + _2238 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                    if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                        revert with 0, 50
                    if u >= mem[_2325]:
                        revert with 0, 50
                    mem[(32 * u) + _2325 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                    if u == -1:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _3510 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = idx + 1
                    u = u + 1
                    continue 
                idx = 0
                while idx < stor5.length:
                    mem[0] = 5
                    _5343 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5343] = address(stor5[idx].field_0)
                    mem[_5343 + 32] = address(stor5[idx].field_256)
                    mem[0] = address(stor5[idx].field_0)
                    mem[32] = sha3(arg1, 1) + 3
                    if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                        _5398 = mem[64]
                        mem[mem[64]] = 0
                        mem[mem[64] + 32] = 0
                        mem[64] = mem[64] + 64
                        _6869 = mem[_5398]
                        s = 0
                        t = u
                        while s < _6869:
                            if s >= mem[_5398]:
                                revert with 0, 50
                            if t >= mem[_2238]:
                                revert with 0, 50
                            mem[(32 * t) + _2238 + 32] = mem[(32 * s) + _5398 + 32]
                            if s >= mem[_5398 + 32]:
                                revert with 0, 50
                            if t >= mem[_2325]:
                                revert with 0, 50
                            mem[(32 * t) + _2325 + 32] = mem[(32 * s) + _5398 + 64]
                            if t == -1:
                                revert with 0, 17
                            if s == -1:
                                revert with 0, 17
                            _6869 = mem[_5398]
                            s = s + 1
                            t = t + 1
                            continue 
                    else:
                        mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = arg1
                        mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                        require ext_code.size(address(stor5[idx].field_256))
                        staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                                gas gas_remaining wei
                               args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _5595 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 64
                        _5668 = mem[_5595]
                        require mem[_5595] <= test266151307()
                        require _5595 + mem[_5595] + 31 < _5595 + return_data.size
                        _5807 = mem[_5595 + mem[_5595]]
                        if mem[_5595 + mem[_5595]] > test266151307():
                            revert with 0, 65
                        if ceil32(32 * mem[_5595 + mem[_5595]]) + 1 < 0 or _5595 + ceil32(return_data.size) + ceil32(32 * mem[_5595 + mem[_5595]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = _5595 + ceil32(return_data.size) + ceil32(32 * mem[_5595 + mem[_5595]]) + 1
                        mem[_5595 + ceil32(return_data.size)] = _5807
                        require _5668 + (32 * _5807) + 32 <= return_data.size
                        s = 0
                        t = _5595 + _5668 + 32
                        v = _5595 + ceil32(return_data.size) + 32
                        while s < _5807:
                            mem[v] = mem[t]
                            s = s + 1
                            t = t + 32
                            v = v + 32
                            continue 
                        _7063 = mem[_5595 + 32]
                        require mem[_5595 + 32] <= test266151307()
                        require _5595 + mem[_5595 + 32] + 31 < _5595 + return_data.size
                        _7175 = mem[_5595 + mem[_5595 + 32]]
                        if mem[_5595 + mem[_5595 + 32]] > test266151307():
                            revert with 0, 65
                        _7359 = mem[64]
                        if mem[64] + ceil32(32 * mem[_5595 + mem[_5595 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_5595 + mem[_5595 + 32]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = mem[64] + ceil32(32 * mem[_5595 + mem[_5595 + 32]]) + 1
                        mem[_7359] = _7175
                        require _7063 + (32 * _7175) + 32 <= return_data.size
                        s = 0
                        t = _5595 + _7063 + 32
                        v = _7359 + 32
                        while s < _7175:
                            mem[v] = mem[t]
                            s = s + 1
                            t = t + 32
                            v = v + 32
                            continue 
                        _9361 = mem[_5595 + ceil32(return_data.size)]
                        s = 0
                        t = u
                        while s < _9361:
                            if s >= mem[_5595 + ceil32(return_data.size)]:
                                revert with 0, 50
                            if t >= mem[_2238]:
                                revert with 0, 50
                            mem[(32 * t) + _2238 + 32] = mem[(32 * s) + _5595 + ceil32(return_data.size) + 32]
                            if s >= mem[_7359]:
                                revert with 0, 50
                            if t >= mem[_2325]:
                                revert with 0, 50
                            mem[(32 * t) + _2325 + 32] = mem[(32 * s) + _7359 + 32]
                            if t == -1:
                                revert with 0, 17
                            if s == -1:
                                revert with 0, 17
                            _9361 = mem[_5595 + ceil32(return_data.size)]
                            s = s + 1
                            t = t + 1
                            continue 
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                if s > !t:
                    revert with 0, 17
                if u != s + t:
                    revert with 0, 1
                if 0 >= stor9.length:
                    revert with 0, 50
                mem[0] = arg1
                mem[32] = 1
                mem[mem[64]] = 0x15d2cfca00000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 64
                _5554 = mem[_2238]
                mem[mem[64] + 68] = mem[_2238]
                mem[mem[64] + 100 len 32 * _5554] = mem[_2238 + 32 len 32 * _5554]
                idx = _5554
                var62002 = _2238 + (32 * _5554) + 32
                mem[mem[64] + 36] = stor1[arg1].field_512
                require ext_code.size(address(stor9.field_0))
                staticcall address(stor9.field_0).0x15d2cfca with:
                        gas gas_remaining wei
                       args 64, stor1[arg1].field_512, mem[mem[64] + 68 len (32 * _5554) + 32]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _7174 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _7285 = mem[_7174]
                require mem[_7174] <= test266151307()
                require _7174 + mem[_7174] + 31 < _7174 + return_data.size
                _7435 = mem[_7174 + mem[_7174]]
                if mem[_7174 + mem[_7174]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_7174 + mem[_7174]]) + 1 < 0 or _7174 + ceil32(return_data.size) + ceil32(32 * mem[_7174 + mem[_7174]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _7174 + ceil32(return_data.size) + ceil32(32 * mem[_7174 + mem[_7174]]) + 1
                mem[_7174 + ceil32(return_data.size)] = _7435
                require _7285 + (32 * _7435) + 32 <= return_data.size
                mem[_7174 + ceil32(return_data.size) + 32 len 32 * _7435] = mem[_7174 + _7285 + 32 len 32 * _7435]
                mem[mem[64]] = 32
                mem[mem[64] + 32] = _7435
                mem[mem[64] + 64 len 32 * _7435] = mem[_7174 + ceil32(return_data.size) + 32 len 32 * _7435]
                var89001 = _7435
                var89002 = _7174 + ceil32(return_data.size) + (32 * _7435) + 32
                return Array(len=_7435, data=mem[mem[64] + 64 len 32 * _7435])
            _3508 = mem[mem[ceil32(return_data.size) + 160]]
            idx = 0
            u = 0
            while idx < _3508:
                mem[0] = arg1
                mem[32] = 1
                mem[mem[64] + 32] = idx
                mem[mem[64] + 64] = stor1[arg1].field_512
                mem[mem[64] + 96] = stor8
                _3572 = mem[64]
                mem[mem[64]] = 96
                mem[64] = mem[64] + 128
                if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                    revert with 0, 50
                if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    revert with 0, 18
                if sha3(mem[_3572 + 32 len mem[_3572]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    if idx == -1:
                        revert with 0, 17
                    _3508 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = idx + 1
                    u = u
                    continue 
                if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                    revert with 0, 50
                if u >= mem[_2238]:
                    revert with 0, 50
                mem[(32 * u) + _2238 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                    revert with 0, 50
                if u >= mem[_2325]:
                    revert with 0, 50
                mem[(32 * u) + _2325 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                if u == -1:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _3508 = mem[mem[ceil32(return_data.size) + 160]]
                idx = idx + 1
                u = u + 1
                continue 
            idx = 0
            while idx < stor5.length:
                mem[0] = 5
                _5338 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5338] = address(stor5[idx].field_0)
                mem[_5338 + 32] = address(stor5[idx].field_256)
                mem[0] = address(stor5[idx].field_0)
                mem[32] = sha3(arg1, 1) + 3
                if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                    _5397 = mem[64]
                    mem[mem[64]] = 0
                    mem[mem[64] + 32] = 0
                    mem[64] = mem[64] + 64
                    _6868 = mem[_5397]
                    s = 0
                    t = u
                    while s < _6868:
                        if s >= mem[_5397]:
                            revert with 0, 50
                        if t >= mem[_2238]:
                            revert with 0, 50
                        mem[(32 * t) + _2238 + 32] = mem[(32 * s) + _5397 + 32]
                        if s >= mem[_5397 + 32]:
                            revert with 0, 50
                        if t >= mem[_2325]:
                            revert with 0, 50
                        mem[(32 * t) + _2325 + 32] = mem[(32 * s) + _5397 + 64]
                        if t == -1:
                            revert with 0, 17
                        if s == -1:
                            revert with 0, 17
                        _6868 = mem[_5397]
                        s = s + 1
                        t = t + 1
                        continue 
                else:
                    mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = arg1
                    mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    require ext_code.size(address(stor5[idx].field_256))
                    staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                            gas gas_remaining wei
                           args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _5592 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 64
                    _5665 = mem[_5592]
                    require mem[_5592] <= test266151307()
                    require _5592 + mem[_5592] + 31 < _5592 + return_data.size
                    _5805 = mem[_5592 + mem[_5592]]
                    if mem[_5592 + mem[_5592]] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[_5592 + mem[_5592]]) + 1 < 0 or _5592 + ceil32(return_data.size) + ceil32(32 * mem[_5592 + mem[_5592]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = _5592 + ceil32(return_data.size) + ceil32(32 * mem[_5592 + mem[_5592]]) + 1
                    mem[_5592 + ceil32(return_data.size)] = _5805
                    require _5665 + (32 * _5805) + 32 <= return_data.size
                    s = 0
                    t = _5592 + _5665 + 32
                    v = _5592 + ceil32(return_data.size) + 32
                    while s < _5805:
                        mem[v] = mem[t]
                        s = s + 1
                        t = t + 32
                        v = v + 32
                        continue 
                    _7060 = mem[_5592 + 32]
                    require mem[_5592 + 32] <= test266151307()
                    require _5592 + mem[_5592 + 32] + 31 < _5592 + return_data.size
                    _7173 = mem[_5592 + mem[_5592 + 32]]
                    if mem[_5592 + mem[_5592 + 32]] > test266151307():
                        revert with 0, 65
                    _7358 = mem[64]
                    if mem[64] + ceil32(32 * mem[_5592 + mem[_5592 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_5592 + mem[_5592 + 32]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = mem[64] + ceil32(32 * mem[_5592 + mem[_5592 + 32]]) + 1
                    mem[_7358] = _7173
                    require _7060 + (32 * _7173) + 32 <= return_data.size
                    s = 0
                    t = _5592 + _7060 + 32
                    v = _7358 + 32
                    while s < _7173:
                        mem[v] = mem[t]
                        s = s + 1
                        t = t + 32
                        v = v + 32
                        continue 
                    _9360 = mem[_5592 + ceil32(return_data.size)]
                    s = 0
                    t = u
                    while s < _9360:
                        if s >= mem[_5592 + ceil32(return_data.size)]:
                            revert with 0, 50
                        if t >= mem[_2238]:
                            revert with 0, 50
                        mem[(32 * t) + _2238 + 32] = mem[(32 * s) + _5592 + ceil32(return_data.size) + 32]
                        if s >= mem[_7358]:
                            revert with 0, 50
                        if t >= mem[_2325]:
                            revert with 0, 50
                        mem[(32 * t) + _2325 + 32] = mem[(32 * s) + _7358 + 32]
                        if t == -1:
                            revert with 0, 17
                        if s == -1:
                            revert with 0, 17
                        _9360 = mem[_5592 + ceil32(return_data.size)]
                        s = s + 1
                        t = t + 1
                        continue 
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            if s > !t:
                revert with 0, 17
            if u != s + t:
                revert with 0, 1
            if 0 >= stor9.length:
                revert with 0, 50
            mem[0] = arg1
            mem[32] = 1
            mem[mem[64]] = 0x15d2cfca00000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 64
            _5552 = mem[_2238]
            mem[mem[64] + 68] = mem[_2238]
            mem[mem[64] + 100 len 32 * _5552] = mem[_2238 + 32 len 32 * _5552]
            idx = _5552
            mem[mem[64] + 36] = stor1[arg1].field_512
            require ext_code.size(address(stor9.field_0))
            staticcall address(stor9.field_0).0x15d2cfca with:
                    gas gas_remaining wei
                   args 64, stor1[arg1].field_512, mem[mem[64] + 68 len (32 * _5552) + 32]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _7172 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _7284 = mem[_7172]
            require mem[_7172] <= test266151307()
            require _7172 + mem[_7172] + 31 < _7172 + return_data.size
            _7434 = mem[_7172 + mem[_7172]]
            if mem[_7172 + mem[_7172]] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[_7172 + mem[_7172]]) + 1 < 0 or _7172 + ceil32(return_data.size) + ceil32(32 * mem[_7172 + mem[_7172]]) + 1 > test266151307():
                revert with 0, 65
            mem[64] = _7172 + ceil32(return_data.size) + ceil32(32 * mem[_7172 + mem[_7172]]) + 1
            mem[_7172 + ceil32(return_data.size)] = _7434
            require _7284 + (32 * _7434) + 32 <= return_data.size
            mem[_7172 + ceil32(return_data.size) + 32 len 32 * _7434] = mem[_7172 + _7284 + 32 len 32 * _7434]
            var80001 = _7434
            var80002 = _7172 + _7284 + (32 * _7434) + 32
            var80004 = _7172 + ceil32(return_data.size) + (32 * _7434) + 32
            mem[mem[64]] = 32
            mem[mem[64] + 32] = _7434
            mem[mem[64] + 64 len 32 * _7434] = mem[_7172 + ceil32(return_data.size) + 32 len 32 * _7434]
            var88001 = _7434
            var88002 = _7172 + ceil32(return_data.size) + (32 * _7434) + 32
            return Array(len=_7434, data=mem[mem[64] + 64 len 32 * _7434])
        mem[0] = sha3(ext_call.return_data[31 len 1], 10) + 2
        mem[ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 288] = stor10[ext_call.return_data[31 len 1]][2].field_0
        idx = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 288
        s = 0
        while ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + (32 * stor10[ext_call.return_data[31 len 1]].field_512) + 256 > idx:
            mem[idx + 32] = stor10[ext_call.return_data[31 len 1]][s + 2].field_256
            idx = idx + 32
            s = s + 1
            continue 
        mem[ceil32(return_data.size) + 160] = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 256
        idx = 0
        s = 0
        while idx < stor10[ext_call.return_data[31 len 1]].field_512:
            mem[0] = arg1
            mem[32] = 1
            mem[mem[64] + 32] = idx
            mem[mem[64] + 64] = stor1[arg1].field_512
            mem[mem[64] + 96] = stor8
            _3601 = mem[64]
            mem[mem[64]] = 96
            mem[64] = mem[64] + 128
            if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                revert with 0, 50
            if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                revert with 0, 18
            if sha3(mem[_3601 + 32 len mem[_3601]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s
                continue 
            if s == -1:
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = s + 1
            continue 
        idx = 0
        t = 0
        while idx < stor5.length:
            mem[0] = 5
            _5358 = mem[64]
            mem[64] = mem[64] + 64
            mem[_5358] = address(stor5[idx].field_0)
            mem[_5358 + 32] = address(stor5[idx].field_256)
            mem[0] = address(stor5[idx].field_0)
            mem[32] = sha3(arg1, 1) + 3
            if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                _5403 = mem[64]
                mem[mem[64]] = 0
                mem[mem[64] + 32] = 0
                mem[64] = mem[64] + 64
                if t > !mem[_5403]:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                t = t + mem[_5403]
                continue 
            mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = arg1
            mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
            require ext_code.size(address(stor5[idx].field_256))
            staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                    gas gas_remaining wei
                   args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _5605 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 64
            _5679 = mem[_5605]
            require mem[_5605] <= test266151307()
            require _5605 + mem[_5605] + 31 < _5605 + return_data.size
            _5821 = mem[_5605 + mem[_5605]]
            if mem[_5605 + mem[_5605]] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[_5605 + mem[_5605]]) + 1 < 0 or _5605 + ceil32(return_data.size) + ceil32(32 * mem[_5605 + mem[_5605]]) + 1 > test266151307():
                revert with 0, 65
            mem[64] = _5605 + ceil32(return_data.size) + ceil32(32 * mem[_5605 + mem[_5605]]) + 1
            mem[_5605 + ceil32(return_data.size)] = _5821
            require _5679 + (32 * _5821) + 32 <= return_data.size
            s = 0
            u = _5605 + _5679 + 32
            v = _5605 + ceil32(return_data.size) + 32
            while s < _5821:
                mem[v] = mem[u]
                s = s + 1
                u = u + 32
                v = v + 32
                continue 
            _7076 = mem[_5605 + 32]
            require mem[_5605 + 32] <= test266151307()
            require _5605 + mem[_5605 + 32] + 31 < _5605 + return_data.size
            _7180 = mem[_5605 + mem[_5605 + 32]]
            if mem[_5605 + mem[_5605 + 32]] > test266151307():
                revert with 0, 65
            _7382 = mem[64]
            if mem[64] + ceil32(32 * mem[_5605 + mem[_5605 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_5605 + mem[_5605 + 32]]) + 1 > test266151307():
                revert with 0, 65
            mem[64] = mem[64] + ceil32(32 * mem[_5605 + mem[_5605 + 32]]) + 1
            mem[_7382] = _7180
            require _7076 + (32 * _7180) + 32 <= return_data.size
            s = 0
            u = _5605 + _7076 + 32
            v = _7382 + 32
            while s < _7180:
                mem[v] = mem[u]
                s = s + 1
                u = u + 32
                v = v + 32
                continue 
            if t > !mem[_5605 + ceil32(return_data.size)]:
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            t = t + mem[_5605 + ceil32(return_data.size)]
            continue 
        if s > !t:
            revert with 0, 17
        if s + t > test266151307():
            revert with 0, 65
        _5402 = mem[64]
        mem[mem[64]] = s + t
        if not s + t:
            if s > !t:
                revert with 0, 17
            if s + t > test266151307():
                revert with 0, 65
            _5604 = mem[64] + (32 * s + t) + 32
            mem[mem[64] + (32 * s + t) + 32] = s + t
            mem[64] = _5604 + (32 * s + t) + 32
            if not s + t:
                _6873 = mem[mem[ceil32(return_data.size) + 160]]
                idx = 0
                u = 0
                while idx < _6873:
                    mem[0] = arg1
                    mem[32] = 1
                    mem[mem[64] + 32] = idx
                    mem[mem[64] + 64] = stor1[arg1].field_512
                    mem[mem[64] + 96] = stor8
                    _6936 = mem[64]
                    mem[mem[64]] = 96
                    mem[64] = mem[64] + 128
                    if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                        revert with 0, 50
                    if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        revert with 0, 18
                    if sha3(mem[_6936 + 32 len mem[_6936]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        if idx == -1:
                            revert with 0, 17
                        _6873 = mem[mem[ceil32(return_data.size) + 160]]
                        idx = idx + 1
                        u = u
                        continue 
                    if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                        revert with 0, 50
                    if u >= mem[_5402]:
                        revert with 0, 50
                    mem[(32 * u) + _5402 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                    if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                        revert with 0, 50
                    if u >= mem[_5604]:
                        revert with 0, 50
                    mem[(32 * u) + _5604 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                    if u == -1:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _6873 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = idx + 1
                    u = u + 1
                    continue 
                idx = 0
                while idx < stor5.length:
                    mem[0] = 5
                    _8383 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_8383] = address(stor5[idx].field_0)
                    mem[_8383 + 32] = address(stor5[idx].field_256)
                    mem[0] = address(stor5[idx].field_0)
                    mem[32] = sha3(arg1, 1) + 3
                    if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                        _8451 = mem[64]
                        mem[mem[64]] = 0
                        mem[mem[64] + 32] = 0
                        mem[64] = mem[64] + 64
                        _9364 = mem[_8451]
                        s = 0
                        t = u
                        while s < _9364:
                            if s >= mem[_8451]:
                                revert with 0, 50
                            if t >= mem[_5402]:
                                revert with 0, 50
                            mem[(32 * t) + _5402 + 32] = mem[(32 * s) + _8451 + 32]
                            if s >= mem[_8451 + 32]:
                                revert with 0, 50
                            if t >= mem[_5604]:
                                revert with 0, 50
                            mem[(32 * t) + _5604 + 32] = mem[(32 * s) + _8451 + 64]
                            if t == -1:
                                revert with 0, 17
                            if s == -1:
                                revert with 0, 17
                            _9364 = mem[_8451]
                            s = s + 1
                            t = t + 1
                            continue 
                    else:
                        mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = arg1
                        mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                        require ext_code.size(address(stor5[idx].field_256))
                        staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                                gas gas_remaining wei
                               args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _8688 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 64
                        _8763 = mem[_8688]
                        require mem[_8688] <= test266151307()
                        require _8688 + mem[_8688] + 31 < _8688 + return_data.size
                        _8843 = mem[_8688 + mem[_8688]]
                        if mem[_8688 + mem[_8688]] > test266151307():
                            revert with 0, 65
                        if ceil32(32 * mem[_8688 + mem[_8688]]) + 1 < 0 or _8688 + ceil32(return_data.size) + ceil32(32 * mem[_8688 + mem[_8688]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = _8688 + ceil32(return_data.size) + ceil32(32 * mem[_8688 + mem[_8688]]) + 1
                        mem[_8688 + ceil32(return_data.size)] = _8843
                        require _8763 + (32 * _8843) + 32 <= return_data.size
                        s = 0
                        t = _8688 + _8763 + 32
                        v = _8688 + ceil32(return_data.size) + 32
                        while s < _8843:
                            mem[v] = mem[t]
                            s = s + 1
                            t = t + 32
                            v = v + 32
                            continue 
                        _9493 = mem[_8688 + 32]
                        require mem[_8688 + 32] <= test266151307()
                        require _8688 + mem[_8688 + 32] + 31 < _8688 + return_data.size
                        _9639 = mem[_8688 + mem[_8688 + 32]]
                        if mem[_8688 + mem[_8688 + 32]] > test266151307():
                            revert with 0, 65
                        _9723 = mem[64]
                        if mem[64] + ceil32(32 * mem[_8688 + mem[_8688 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_8688 + mem[_8688 + 32]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = mem[64] + ceil32(32 * mem[_8688 + mem[_8688 + 32]]) + 1
                        mem[_9723] = _9639
                        require _9493 + (32 * _9639) + 32 <= return_data.size
                        s = 0
                        t = _8688 + _9493 + 32
                        v = _9723 + 32
                        while s < _9639:
                            mem[v] = mem[t]
                            s = s + 1
                            t = t + 32
                            v = v + 32
                            continue 
                        _10436 = mem[_8688 + ceil32(return_data.size)]
                        s = 0
                        t = u
                        while s < _10436:
                            if s >= mem[_8688 + ceil32(return_data.size)]:
                                revert with 0, 50
                            if t >= mem[_5402]:
                                revert with 0, 50
                            mem[(32 * t) + _5402 + 32] = mem[(32 * s) + _8688 + ceil32(return_data.size) + 32]
                            if s >= mem[_9723]:
                                revert with 0, 50
                            if t >= mem[_5604]:
                                revert with 0, 50
                            mem[(32 * t) + _5604 + 32] = mem[(32 * s) + _9723 + 32]
                            if t == -1:
                                revert with 0, 17
                            if s == -1:
                                revert with 0, 17
                            _10436 = mem[_8688 + ceil32(return_data.size)]
                            s = s + 1
                            t = t + 1
                            continue 
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                if s > !t:
                    revert with 0, 17
                if u != s + t:
                    revert with 0, 1
                if 0 >= stor9.length:
                    revert with 0, 50
                mem[0] = arg1
                mem[32] = 1
                mem[mem[64]] = 0x15d2cfca00000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 64
                _8636 = mem[_5402]
                mem[mem[64] + 68] = mem[_5402]
                mem[mem[64] + 100 len 32 * _8636] = mem[_5402 + 32 len 32 * _8636]
                idx = _8636
                var65002 = _5402 + (32 * _8636) + 32
                mem[mem[64] + 36] = stor1[arg1].field_512
                require ext_code.size(address(stor9.field_0))
                staticcall address(stor9.field_0).0x15d2cfca with:
                        gas gas_remaining wei
                       args 64, stor1[arg1].field_512, mem[mem[64] + 68 len (32 * _8636) + 32]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _9638 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _9691 = mem[_9638]
                require mem[_9638] <= test266151307()
                require _9638 + mem[_9638] + 31 < _9638 + return_data.size
                _9756 = mem[_9638 + mem[_9638]]
                if mem[_9638 + mem[_9638]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_9638 + mem[_9638]]) + 1 < 0 or _9638 + ceil32(return_data.size) + ceil32(32 * mem[_9638 + mem[_9638]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _9638 + ceil32(return_data.size) + ceil32(32 * mem[_9638 + mem[_9638]]) + 1
                mem[_9638 + ceil32(return_data.size)] = _9756
                require _9691 + (32 * _9756) + 32 <= return_data.size
                mem[_9638 + ceil32(return_data.size) + 32 len 32 * _9756] = mem[_9638 + _9691 + 32 len 32 * _9756]
                mem[mem[64]] = 32
                mem[mem[64] + 32] = _9756
                mem[mem[64] + 64 len 32 * _9756] = mem[_9638 + ceil32(return_data.size) + 32 len 32 * _9756]
                var92001 = _9756
                var92002 = _9638 + ceil32(return_data.size) + (32 * _9756) + 32
                return Array(len=_9756, data=mem[mem[64] + 64 len 32 * _9756])
            mem[_5604 + 32 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
            _6875 = mem[mem[ceil32(return_data.size) + 160]]
            idx = 0
            u = 0
            while idx < _6875:
                mem[0] = arg1
                mem[32] = 1
                mem[mem[64] + 32] = idx
                mem[mem[64] + 64] = stor1[arg1].field_512
                mem[mem[64] + 96] = stor8
                _6943 = mem[64]
                mem[mem[64]] = 96
                mem[64] = mem[64] + 128
                if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                    revert with 0, 50
                if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    revert with 0, 18
                if sha3(mem[_6943 + 32 len mem[_6943]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    if idx == -1:
                        revert with 0, 17
                    _6875 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = idx + 1
                    u = u
                    continue 
                if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                    revert with 0, 50
                if u >= mem[_5402]:
                    revert with 0, 50
                mem[(32 * u) + _5402 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                    revert with 0, 50
                if u >= mem[_5604]:
                    revert with 0, 50
                mem[(32 * u) + _5604 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                if u == -1:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _6875 = mem[mem[ceil32(return_data.size) + 160]]
                idx = idx + 1
                u = u + 1
                continue 
            idx = 0
            while idx < stor5.length:
                mem[0] = 5
                _8388 = mem[64]
                mem[64] = mem[64] + 64
                mem[_8388] = address(stor5[idx].field_0)
                mem[_8388 + 32] = address(stor5[idx].field_256)
                mem[0] = address(stor5[idx].field_0)
                mem[32] = sha3(arg1, 1) + 3
                if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                    _8452 = mem[64]
                    mem[mem[64]] = 0
                    mem[mem[64] + 32] = 0
                    mem[64] = mem[64] + 64
                    _9365 = mem[_8452]
                    s = 0
                    t = u
                    while s < _9365:
                        if s >= mem[_8452]:
                            revert with 0, 50
                        if t >= mem[_5402]:
                            revert with 0, 50
                        mem[(32 * t) + _5402 + 32] = mem[(32 * s) + _8452 + 32]
                        if s >= mem[_8452 + 32]:
                            revert with 0, 50
                        if t >= mem[_5604]:
                            revert with 0, 50
                        mem[(32 * t) + _5604 + 32] = mem[(32 * s) + _8452 + 64]
                        if t == -1:
                            revert with 0, 17
                        if s == -1:
                            revert with 0, 17
                        _9365 = mem[_8452]
                        s = s + 1
                        t = t + 1
                        continue 
                else:
                    mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = arg1
                    mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    require ext_code.size(address(stor5[idx].field_256))
                    staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                            gas gas_remaining wei
                           args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _8691 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 64
                    _8766 = mem[_8691]
                    require mem[_8691] <= test266151307()
                    require _8691 + mem[_8691] + 31 < _8691 + return_data.size
                    _8845 = mem[_8691 + mem[_8691]]
                    if mem[_8691 + mem[_8691]] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[_8691 + mem[_8691]]) + 1 < 0 or _8691 + ceil32(return_data.size) + ceil32(32 * mem[_8691 + mem[_8691]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = _8691 + ceil32(return_data.size) + ceil32(32 * mem[_8691 + mem[_8691]]) + 1
                    mem[_8691 + ceil32(return_data.size)] = _8845
                    require _8766 + (32 * _8845) + 32 <= return_data.size
                    s = 0
                    t = _8691 + _8766 + 32
                    v = _8691 + ceil32(return_data.size) + 32
                    while s < _8845:
                        mem[v] = mem[t]
                        s = s + 1
                        t = t + 32
                        v = v + 32
                        continue 
                    _9496 = mem[_8691 + 32]
                    require mem[_8691 + 32] <= test266151307()
                    require _8691 + mem[_8691 + 32] + 31 < _8691 + return_data.size
                    _9641 = mem[_8691 + mem[_8691 + 32]]
                    if mem[_8691 + mem[_8691 + 32]] > test266151307():
                        revert with 0, 65
                    _9724 = mem[64]
                    if mem[64] + ceil32(32 * mem[_8691 + mem[_8691 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_8691 + mem[_8691 + 32]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = mem[64] + ceil32(32 * mem[_8691 + mem[_8691 + 32]]) + 1
                    mem[_9724] = _9641
                    require _9496 + (32 * _9641) + 32 <= return_data.size
                    s = 0
                    t = _8691 + _9496 + 32
                    v = _9724 + 32
                    while s < _9641:
                        mem[v] = mem[t]
                        s = s + 1
                        t = t + 32
                        v = v + 32
                        continue 
                    _10437 = mem[_8691 + ceil32(return_data.size)]
                    s = 0
                    t = u
                    while s < _10437:
                        if s >= mem[_8691 + ceil32(return_data.size)]:
                            revert with 0, 50
                        if t >= mem[_5402]:
                            revert with 0, 50
                        mem[(32 * t) + _5402 + 32] = mem[(32 * s) + _8691 + ceil32(return_data.size) + 32]
                        if s >= mem[_9724]:
                            revert with 0, 50
                        if t >= mem[_5604]:
                            revert with 0, 50
                        mem[(32 * t) + _5604 + 32] = mem[(32 * s) + _9724 + 32]
                        if t == -1:
                            revert with 0, 17
                        if s == -1:
                            revert with 0, 17
                        _10437 = mem[_8691 + ceil32(return_data.size)]
                        s = s + 1
                        t = t + 1
                        continue 
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            if s > !t:
                revert with 0, 17
            if u != s + t:
                revert with 0, 1
            if 0 >= stor9.length:
                revert with 0, 50
            mem[0] = arg1
            mem[32] = 1
            mem[mem[64]] = 0x15d2cfca00000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 64
            _8638 = mem[_5402]
            mem[mem[64] + 68] = mem[_5402]
            mem[mem[64] + 100 len 32 * _8638] = mem[_5402 + 32 len 32 * _8638]
            idx = _8638
            mem[mem[64] + 36] = stor1[arg1].field_512
            require ext_code.size(address(stor9.field_0))
            staticcall address(stor9.field_0).0x15d2cfca with:
                    gas gas_remaining wei
                   args 64, stor1[arg1].field_512, mem[mem[64] + 68 len (32 * _8638) + 32]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _9640 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _9692 = mem[_9640]
            require mem[_9640] <= test266151307()
            require _9640 + mem[_9640] + 31 < _9640 + return_data.size
            _9757 = mem[_9640 + mem[_9640]]
            if mem[_9640 + mem[_9640]] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[_9640 + mem[_9640]]) + 1 < 0 or _9640 + ceil32(return_data.size) + ceil32(32 * mem[_9640 + mem[_9640]]) + 1 > test266151307():
                revert with 0, 65
            mem[64] = _9640 + ceil32(return_data.size) + ceil32(32 * mem[_9640 + mem[_9640]]) + 1
            mem[_9640 + ceil32(return_data.size)] = _9757
            require _9692 + (32 * _9757) + 32 <= return_data.size
            mem[_9640 + ceil32(return_data.size) + 32 len 32 * _9757] = mem[_9640 + _9692 + 32 len 32 * _9757]
            mem[mem[64]] = 32
            mem[mem[64] + 32] = _9757
            mem[mem[64] + 64 len 32 * _9757] = mem[_9640 + ceil32(return_data.size) + 32 len 32 * _9757]
            var93001 = _9757
            var93002 = _9640 + ceil32(return_data.size) + (32 * _9757) + 32
            return Array(len=_9757, data=mem[mem[64] + 64 len 32 * _9757])
        mem[mem[64] + 32 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
        if s > !t:
            revert with 0, 17
        if s + t > test266151307():
            revert with 0, 65
        mem[mem[64] + (32 * s + t) + 32] = s + t
        mem[64] = _5402 + (64 * s + t) + 64
        if not s + t:
            _6877 = mem[mem[ceil32(return_data.size) + 160]]
            idx = 0
            u = 0
            while idx < _6877:
                mem[0] = arg1
                mem[32] = 1
                mem[mem[64] + 32] = idx
                mem[mem[64] + 64] = stor1[arg1].field_512
                mem[mem[64] + 96] = stor8
                _6950 = mem[64]
                mem[mem[64]] = 96
                mem[64] = mem[64] + 128
                if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                    revert with 0, 50
                if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    revert with 0, 18
                if sha3(mem[_6950 + 32 len mem[_6950]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    if idx == -1:
                        revert with 0, 17
                    _6877 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = idx + 1
                    u = u
                    continue 
                if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                    revert with 0, 50
                if u >= mem[_5402]:
                    revert with 0, 50
                mem[(32 * u) + _5402 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                    revert with 0, 50
                if u >= mem[_5402 + (32 * s + t) + 32]:
                    revert with 0, 50
                mem[(32 * u) + _5402 + (32 * s + t) + 64] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                if u == -1:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _6877 = mem[mem[ceil32(return_data.size) + 160]]
                idx = idx + 1
                u = u + 1
                continue 
            idx = 0
            while idx < stor5.length:
                mem[0] = 5
                _8393 = mem[64]
                mem[64] = mem[64] + 64
                mem[_8393] = address(stor5[idx].field_0)
                mem[_8393 + 32] = address(stor5[idx].field_256)
                mem[0] = address(stor5[idx].field_0)
                mem[32] = sha3(arg1, 1) + 3
                if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                    _8453 = mem[64]
                    mem[mem[64]] = 0
                    mem[mem[64] + 32] = 0
                    mem[64] = mem[64] + 64
                    _9366 = mem[_8453]
                    v = 0
                    w = u
                    while v < _9366:
                        if v >= mem[_8453]:
                            revert with 0, 50
                        if w >= mem[_5402]:
                            revert with 0, 50
                        mem[(32 * w) + _5402 + 32] = mem[(32 * v) + _8453 + 32]
                        if v >= mem[_8453 + 32]:
                            revert with 0, 50
                        if w >= mem[_5402 + (32 * s + t) + 32]:
                            revert with 0, 50
                        mem[(32 * w) + _5402 + (32 * s + t) + 64] = mem[(32 * v) + _8453 + 64]
                        if w == -1:
                            revert with 0, 17
                        if v == -1:
                            revert with 0, 17
                        _9366 = mem[_8453]
                        v = v + 1
                        w = w + 1
                        continue 
                else:
                    mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = arg1
                    mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    require ext_code.size(address(stor5[idx].field_256))
                    staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                            gas gas_remaining wei
                           args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _8694 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 64
                    _8769 = mem[_8694]
                    require mem[_8694] <= test266151307()
                    require _8694 + mem[_8694] + 31 < _8694 + return_data.size
                    _8847 = mem[_8694 + mem[_8694]]
                    if mem[_8694 + mem[_8694]] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[_8694 + mem[_8694]]) + 1 < 0 or _8694 + ceil32(return_data.size) + ceil32(32 * mem[_8694 + mem[_8694]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = _8694 + ceil32(return_data.size) + ceil32(32 * mem[_8694 + mem[_8694]]) + 1
                    mem[_8694 + ceil32(return_data.size)] = _8847
                    require _8769 + (32 * _8847) + 32 <= return_data.size
                    v = 0
                    w = _8694 + _8769 + 32
                    x = _8694 + ceil32(return_data.size) + 32
                    while v < _8847:
                        mem[x] = mem[w]
                        v = v + 1
                        w = w + 32
                        x = x + 32
                        continue 
                    _9499 = mem[_8694 + 32]
                    require mem[_8694 + 32] <= test266151307()
                    require _8694 + mem[_8694 + 32] + 31 < _8694 + return_data.size
                    _9643 = mem[_8694 + mem[_8694 + 32]]
                    if mem[_8694 + mem[_8694 + 32]] > test266151307():
                        revert with 0, 65
                    _9725 = mem[64]
                    if mem[64] + ceil32(32 * mem[_8694 + mem[_8694 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_8694 + mem[_8694 + 32]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = mem[64] + ceil32(32 * mem[_8694 + mem[_8694 + 32]]) + 1
                    mem[_9725] = _9643
                    require _9499 + (32 * _9643) + 32 <= return_data.size
                    v = 0
                    w = _8694 + _9499 + 32
                    x = _9725 + 32
                    while v < _9643:
                        mem[x] = mem[w]
                        v = v + 1
                        w = w + 32
                        x = x + 32
                        continue 
                    _10438 = mem[_8694 + ceil32(return_data.size)]
                    v = 0
                    w = u
                    while v < _10438:
                        if v >= mem[_8694 + ceil32(return_data.size)]:
                            revert with 0, 50
                        if w >= mem[_5402]:
                            revert with 0, 50
                        mem[(32 * w) + _5402 + 32] = mem[(32 * v) + _8694 + ceil32(return_data.size) + 32]
                        if v >= mem[_9725]:
                            revert with 0, 50
                        if w >= mem[_5402 + (32 * s + t) + 32]:
                            revert with 0, 50
                        mem[(32 * w) + _5402 + (32 * s + t) + 64] = mem[(32 * v) + _9725 + 32]
                        if w == -1:
                            revert with 0, 17
                        if v == -1:
                            revert with 0, 17
                        _10438 = mem[_8694 + ceil32(return_data.size)]
                        v = v + 1
                        w = w + 1
                        continue 
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            if s > !t:
                revert with 0, 17
            if u != s + t:
                revert with 0, 1
            if 0 >= stor9.length:
                revert with 0, 50
            mem[0] = arg1
            mem[32] = 1
            mem[mem[64]] = 0x15d2cfca00000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 64
            _8640 = mem[_5402]
            mem[mem[64] + 68] = mem[_5402]
            mem[mem[64] + 100 len 32 * _8640] = mem[_5402 + 32 len 32 * _8640]
            idx = _8640
            mem[mem[64] + 36] = stor1[arg1].field_512
            require ext_code.size(address(stor9.field_0))
            staticcall address(stor9.field_0).0x15d2cfca with:
                    gas gas_remaining wei
                   args 64, stor1[arg1].field_512, mem[mem[64] + 68 len (32 * _8640) + 32]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _9642 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _9693 = mem[_9642]
            require mem[_9642] <= test266151307()
            require _9642 + mem[_9642] + 31 < _9642 + return_data.size
            _9758 = mem[_9642 + mem[_9642]]
            if mem[_9642 + mem[_9642]] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[_9642 + mem[_9642]]) + 1 < 0 or _9642 + ceil32(return_data.size) + ceil32(32 * mem[_9642 + mem[_9642]]) + 1 > test266151307():
                revert with 0, 65
            mem[64] = _9642 + ceil32(return_data.size) + ceil32(32 * mem[_9642 + mem[_9642]]) + 1
            mem[_9642 + ceil32(return_data.size)] = _9758
            require _9693 + (32 * _9758) + 32 <= return_data.size
            mem[_9642 + ceil32(return_data.size) + 32 len 32 * _9758] = mem[_9642 + _9693 + 32 len 32 * _9758]
            mem[mem[64]] = 32
            mem[mem[64] + 32] = _9758
            mem[mem[64] + 64 len 32 * _9758] = mem[_9642 + ceil32(return_data.size) + 32 len 32 * _9758]
            var93001 = _9758
            var93002 = _9642 + ceil32(return_data.size) + (32 * _9758) + 32
            return Array(len=_9758, data=mem[mem[64] + 64 len 32 * _9758])
        mem[_5402 + (32 * s + t) + 64 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
        _6879 = mem[mem[ceil32(return_data.size) + 160]]
        idx = 0
        u = 0
        while idx < _6879:
            mem[0] = arg1
            mem[32] = 1
            mem[mem[64] + 32] = idx
            mem[mem[64] + 64] = stor1[arg1].field_512
            mem[mem[64] + 96] = stor8
            _6957 = mem[64]
            mem[mem[64]] = 96
            mem[64] = mem[64] + 128
            if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                revert with 0, 50
            if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                revert with 0, 18
            if sha3(mem[_6957 + 32 len mem[_6957]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                if idx == -1:
                    revert with 0, 17
                _6879 = mem[mem[ceil32(return_data.size) + 160]]
                idx = idx + 1
                u = u
                continue 
            if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                revert with 0, 50
            if u >= mem[_5402]:
                revert with 0, 50
            mem[(32 * u) + _5402 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
            if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                revert with 0, 50
            if u >= mem[_5402 + (32 * s + t) + 32]:
                revert with 0, 50
            mem[(32 * u) + _5402 + (32 * s + t) + 64] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
            if u == -1:
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            _6879 = mem[mem[ceil32(return_data.size) + 160]]
            idx = idx + 1
            u = u + 1
            continue 
        idx = 0
        while idx < stor5.length:
            mem[0] = 5
            _8398 = mem[64]
            mem[64] = mem[64] + 64
            mem[_8398] = address(stor5[idx].field_0)
            mem[_8398 + 32] = address(stor5[idx].field_256)
            mem[0] = address(stor5[idx].field_0)
            mem[32] = sha3(arg1, 1) + 3
            if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                _8454 = mem[64]
                mem[mem[64]] = 0
                mem[mem[64] + 32] = 0
                mem[64] = mem[64] + 64
                _9367 = mem[_8454]
                v = 0
                w = u
                while v < _9367:
                    if v >= mem[_8454]:
                        revert with 0, 50
                    if w >= mem[_5402]:
                        revert with 0, 50
                    mem[(32 * w) + _5402 + 32] = mem[(32 * v) + _8454 + 32]
                    if v >= mem[_8454 + 32]:
                        revert with 0, 50
                    if w >= mem[_5402 + (32 * s + t) + 32]:
                        revert with 0, 50
                    mem[(32 * w) + _5402 + (32 * s + t) + 64] = mem[(32 * v) + _8454 + 64]
                    if w == -1:
                        revert with 0, 17
                    if v == -1:
                        revert with 0, 17
                    _9367 = mem[_8454]
                    v = v + 1
                    w = w + 1
                    continue 
            else:
                mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = arg1
                mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                require ext_code.size(address(stor5[idx].field_256))
                staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                        gas gas_remaining wei
                       args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _8697 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 64
                _8772 = mem[_8697]
                require mem[_8697] <= test266151307()
                require _8697 + mem[_8697] + 31 < _8697 + return_data.size
                _8849 = mem[_8697 + mem[_8697]]
                if mem[_8697 + mem[_8697]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_8697 + mem[_8697]]) + 1 < 0 or _8697 + ceil32(return_data.size) + ceil32(32 * mem[_8697 + mem[_8697]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _8697 + ceil32(return_data.size) + ceil32(32 * mem[_8697 + mem[_8697]]) + 1
                mem[_8697 + ceil32(return_data.size)] = _8849
                require _8772 + (32 * _8849) + 32 <= return_data.size
                v = 0
                w = _8697 + _8772 + 32
                x = _8697 + ceil32(return_data.size) + 32
                while v < _8849:
                    mem[x] = mem[w]
                    v = v + 1
                    w = w + 32
                    x = x + 32
                    continue 
                _9502 = mem[_8697 + 32]
                require mem[_8697 + 32] <= test266151307()
                require _8697 + mem[_8697 + 32] + 31 < _8697 + return_data.size
                _9645 = mem[_8697 + mem[_8697 + 32]]
                if mem[_8697 + mem[_8697 + 32]] > test266151307():
                    revert with 0, 65
                _9726 = mem[64]
                if mem[64] + ceil32(32 * mem[_8697 + mem[_8697 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_8697 + mem[_8697 + 32]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = mem[64] + ceil32(32 * mem[_8697 + mem[_8697 + 32]]) + 1
                mem[_9726] = _9645
                require _9502 + (32 * _9645) + 32 <= return_data.size
                v = 0
                w = _8697 + _9502 + 32
                x = _9726 + 32
                while v < _9645:
                    mem[x] = mem[w]
                    v = v + 1
                    w = w + 32
                    x = x + 32
                    continue 
                _10439 = mem[_8697 + ceil32(return_data.size)]
                v = 0
                w = u
                while v < _10439:
                    if v >= mem[_8697 + ceil32(return_data.size)]:
                        revert with 0, 50
                    if w >= mem[_5402]:
                        revert with 0, 50
                    mem[(32 * w) + _5402 + 32] = mem[(32 * v) + _8697 + ceil32(return_data.size) + 32]
                    if v >= mem[_9726]:
                        revert with 0, 50
                    if w >= mem[_5402 + (32 * s + t) + 32]:
                        revert with 0, 50
                    mem[(32 * w) + _5402 + (32 * s + t) + 64] = mem[(32 * v) + _9726 + 32]
                    if w == -1:
                        revert with 0, 17
                    if v == -1:
                        revert with 0, 17
                    _10439 = mem[_8697 + ceil32(return_data.size)]
                    v = v + 1
                    w = w + 1
                    continue 
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        if s > !t:
            revert with 0, 17
        if u != s + t:
            revert with 0, 1
        if 0 >= stor9.length:
            revert with 0, 50
        mem[0] = arg1
        mem[32] = 1
        mem[mem[64]] = 0x15d2cfca00000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = 64
        _8642 = mem[_5402]
        mem[mem[64] + 68] = mem[_5402]
        mem[mem[64] + 100 len 32 * _8642] = mem[_5402 + 32 len 32 * _8642]
        idx = _8642
        var67002 = _5402 + (32 * _8642) + 32
        mem[mem[64] + 36] = stor1[arg1].field_512
        require ext_code.size(address(stor9.field_0))
        staticcall address(stor9.field_0).0x15d2cfca with:
                gas gas_remaining wei
               args 64, stor1[arg1].field_512, mem[mem[64] + 68 len (32 * _8642) + 32]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _9644 = mem[64]
        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _9694 = mem[_9644]
        require mem[_9644] <= test266151307()
        require _9644 + mem[_9644] + 31 < _9644 + return_data.size
        _9759 = mem[_9644 + mem[_9644]]
        if mem[_9644 + mem[_9644]] > test266151307():
            revert with 0, 65
        if ceil32(32 * mem[_9644 + mem[_9644]]) + 1 < 0 or _9644 + ceil32(return_data.size) + ceil32(32 * mem[_9644 + mem[_9644]]) + 1 > test266151307():
            revert with 0, 65
        mem[64] = _9644 + ceil32(return_data.size) + ceil32(32 * mem[_9644 + mem[_9644]]) + 1
        mem[_9644 + ceil32(return_data.size)] = _9759
        require _9694 + (32 * _9759) + 32 <= return_data.size
        mem[_9644 + ceil32(return_data.size) + 32 len 32 * _9759] = mem[_9644 + _9694 + 32 len 32 * _9759]
        mem[mem[64]] = 32
        mem[mem[64] + 32] = _9759
        mem[mem[64] + 64 len 32 * _9759] = mem[_9644 + ceil32(return_data.size) + 32 len 32 * _9759]
        var94001 = _9759
        var94002 = _9644 + ceil32(return_data.size) + (32 * _9759) + 32
        return Array(len=_9759, data=mem[mem[64] + 64 len 32 * _9759])
    mem[0] = sha3(ext_call.return_data[31 len 1], 10)
    mem[ceil32(return_data.size) + 224] = stor10[ext_call.return_data[31 len 1]].field_0
    idx = ceil32(return_data.size) + 224
    s = 0
    while ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + 192 > idx:
        mem[idx + 32] = stor10[ext_call.return_data[31 len 1]][s].field_256
        idx = idx + 32
        s = s + 1
        continue 
    mem[ceil32(return_data.size) + 96] = ceil32(return_data.size) + 192
    mem[ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + 224] = stor10[ext_call.return_data[31 len 1]].field_256
    if not stor10[ext_call.return_data[31 len 1]].field_256:
        mem[ceil32(return_data.size) + 128] = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + 224
        mem[64] = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + (32 * stor10[ext_call.return_data[31 len 1]].field_512) + 288
        mem[ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 256] = stor10[ext_call.return_data[31 len 1]].field_512
        if not stor10[ext_call.return_data[31 len 1]].field_512:
            mem[ceil32(return_data.size) + 160] = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 256
            idx = 0
            s = 0
            while idx < stor10[ext_call.return_data[31 len 1]].field_512:
                mem[0] = arg1
                mem[32] = 1
                mem[mem[64] + 32] = idx
                mem[mem[64] + 64] = stor1[arg1].field_512
                mem[mem[64] + 96] = stor8
                _1075 = mem[64]
                mem[mem[64]] = 96
                mem[64] = mem[64] + 128
                if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                    revert with 0, 50
                if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    revert with 0, 18
                if sha3(mem[_1075 + 32 len mem[_1075]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s
                    continue 
                if s == -1:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s + 1
                continue 
            idx = 0
            t = 0
            while idx < stor5.length:
                mem[0] = 5
                _2226 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2226] = address(stor5[idx].field_0)
                mem[_2226 + 32] = address(stor5[idx].field_256)
                mem[0] = address(stor5[idx].field_0)
                mem[32] = sha3(arg1, 1) + 3
                if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                    _2241 = mem[64]
                    mem[mem[64]] = 0
                    mem[mem[64] + 32] = 0
                    mem[64] = mem[64] + 64
                    if t > !mem[_2241]:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    t = t + mem[_2241]
                    continue 
                mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = arg1
                mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                require ext_code.size(address(stor5[idx].field_256))
                staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                        gas gas_remaining wei
                       args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _2329 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 64
                _2369 = mem[_2329]
                require mem[_2329] <= test266151307()
                require _2329 + mem[_2329] + 31 < _2329 + return_data.size
                _2507 = mem[_2329 + mem[_2329]]
                if mem[_2329 + mem[_2329]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_2329 + mem[_2329]]) + 1 < 0 or _2329 + ceil32(return_data.size) + ceil32(32 * mem[_2329 + mem[_2329]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _2329 + ceil32(return_data.size) + ceil32(32 * mem[_2329 + mem[_2329]]) + 1
                mem[_2329 + ceil32(return_data.size)] = _2507
                require _2369 + (32 * _2507) + 32 <= return_data.size
                s = 0
                u = _2329 + _2369 + 32
                v = _2329 + ceil32(return_data.size) + 32
                while s < _2507:
                    mem[v] = mem[u]
                    s = s + 1
                    u = u + 32
                    v = v + 32
                    continue 
                _3676 = mem[_2329 + 32]
                require mem[_2329 + 32] <= test266151307()
                require _2329 + mem[_2329 + 32] + 31 < _2329 + return_data.size
                _3705 = mem[_2329 + mem[_2329 + 32]]
                if mem[_2329 + mem[_2329 + 32]] > test266151307():
                    revert with 0, 65
                _3942 = mem[64]
                if mem[64] + ceil32(32 * mem[_2329 + mem[_2329 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_2329 + mem[_2329 + 32]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = mem[64] + ceil32(32 * mem[_2329 + mem[_2329 + 32]]) + 1
                mem[_3942] = _3705
                require _3676 + (32 * _3705) + 32 <= return_data.size
                s = 0
                u = _2329 + _3676 + 32
                v = _3942 + 32
                while s < _3705:
                    mem[v] = mem[u]
                    s = s + 1
                    u = u + 32
                    v = v + 32
                    continue 
                if t > !mem[_2329 + ceil32(return_data.size)]:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                t = t + mem[_2329 + ceil32(return_data.size)]
                continue 
            if s > !t:
                revert with 0, 17
            if s + t > test266151307():
                revert with 0, 65
            _2240 = mem[64]
            mem[mem[64]] = s + t
            if not s + t:
                if s > !t:
                    revert with 0, 17
                if s + t > test266151307():
                    revert with 0, 65
                _2328 = mem[64] + (32 * s + t) + 32
                mem[mem[64] + (32 * s + t) + 32] = s + t
                mem[64] = _2328 + (32 * s + t) + 32
                if s + t:
                    mem[_2328 + 32 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
                    _3520 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = 0
                    u = 0
                    while idx < _3520:
                        mem[0] = arg1
                        mem[32] = 1
                        mem[mem[64] + 32] = idx
                        mem[mem[64] + 64] = stor1[arg1].field_512
                        mem[mem[64] + 96] = stor8
                        _3615 = mem[64]
                        mem[mem[64]] = 96
                        mem[64] = mem[64] + 128
                        if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                            revert with 0, 50
                        if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                            revert with 0, 18
                        if sha3(mem[_3615 + 32 len mem[_3615]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                            if idx == -1:
                                revert with 0, 17
                            _3520 = mem[mem[ceil32(return_data.size) + 160]]
                            idx = idx + 1
                            u = u
                            continue 
                        if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                            revert with 0, 50
                        if u >= mem[_2240]:
                            revert with 0, 50
                        mem[(32 * u) + _2240 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                        if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                            revert with 0, 50
                        if u >= mem[_2328]:
                            revert with 0, 50
                        mem[(32 * u) + _2328 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                        if u == -1:
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        _3520 = mem[mem[ceil32(return_data.size) + 160]]
                        idx = idx + 1
                        u = u + 1
                        continue 
                    idx = 0
                    while idx < stor5.length:
                        mem[0] = 5
                        _5368 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5368] = address(stor5[idx].field_0)
                        mem[_5368 + 32] = address(stor5[idx].field_256)
                        mem[0] = address(stor5[idx].field_0)
                        mem[32] = sha3(arg1, 1) + 3
                        if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                            _5405 = mem[64]
                            mem[mem[64]] = 0
                            mem[mem[64] + 32] = 0
                            mem[64] = mem[64] + 64
                            _6881 = mem[_5405]
                            s = 0
                            t = u
                            while s < _6881:
                                if s >= mem[_5405]:
                                    revert with 0, 50
                                if t >= mem[_2240]:
                                    revert with 0, 50
                                mem[(32 * t) + _2240 + 32] = mem[(32 * s) + _5405 + 32]
                                if s >= mem[_5405 + 32]:
                                    revert with 0, 50
                                if t >= mem[_2328]:
                                    revert with 0, 50
                                mem[(32 * t) + _2328 + 32] = mem[(32 * s) + _5405 + 64]
                                if t == -1:
                                    revert with 0, 17
                                if s == -1:
                                    revert with 0, 17
                                _6881 = mem[_5405]
                                s = s + 1
                                t = t + 1
                                continue 
                        else:
                            mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = arg1
                            mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                            require ext_code.size(address(stor5[idx].field_256))
                            staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                                    gas gas_remaining wei
                                   args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _5609 = mem[64]
                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 64
                            _5683 = mem[_5609]
                            require mem[_5609] <= test266151307()
                            require _5609 + mem[_5609] + 31 < _5609 + return_data.size
                            _5825 = mem[_5609 + mem[_5609]]
                            if mem[_5609 + mem[_5609]] > test266151307():
                                revert with 0, 65
                            if ceil32(32 * mem[_5609 + mem[_5609]]) + 1 < 0 or _5609 + ceil32(return_data.size) + ceil32(32 * mem[_5609 + mem[_5609]]) + 1 > test266151307():
                                revert with 0, 65
                            mem[64] = _5609 + ceil32(return_data.size) + ceil32(32 * mem[_5609 + mem[_5609]]) + 1
                            mem[_5609 + ceil32(return_data.size)] = _5825
                            require _5683 + (32 * _5825) + 32 <= return_data.size
                            s = 0
                            t = _5609 + _5683 + 32
                            v = _5609 + ceil32(return_data.size) + 32
                            while s < _5825:
                                mem[v] = mem[t]
                                s = s + 1
                                t = t + 32
                                v = v + 32
                                continue 
                            _7080 = mem[_5609 + 32]
                            require mem[_5609 + 32] <= test266151307()
                            require _5609 + mem[_5609 + 32] + 31 < _5609 + return_data.size
                            _7184 = mem[_5609 + mem[_5609 + 32]]
                            if mem[_5609 + mem[_5609 + 32]] > test266151307():
                                revert with 0, 65
                            _7384 = mem[64]
                            if mem[64] + ceil32(32 * mem[_5609 + mem[_5609 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_5609 + mem[_5609 + 32]]) + 1 > test266151307():
                                revert with 0, 65
                            mem[64] = mem[64] + ceil32(32 * mem[_5609 + mem[_5609 + 32]]) + 1
                            mem[_7384] = _7184
                            require _7080 + (32 * _7184) + 32 <= return_data.size
                            s = 0
                            t = _5609 + _7080 + 32
                            v = _7384 + 32
                            while s < _7184:
                                mem[v] = mem[t]
                                s = s + 1
                                t = t + 32
                                v = v + 32
                                continue 
                            _9369 = mem[_5609 + ceil32(return_data.size)]
                            s = 0
                            t = u
                            while s < _9369:
                                if s >= mem[_5609 + ceil32(return_data.size)]:
                                    revert with 0, 50
                                if t >= mem[_2240]:
                                    revert with 0, 50
                                mem[(32 * t) + _2240 + 32] = mem[(32 * s) + _5609 + ceil32(return_data.size) + 32]
                                if s >= mem[_7384]:
                                    revert with 0, 50
                                if t >= mem[_2328]:
                                    revert with 0, 50
                                mem[(32 * t) + _2328 + 32] = mem[(32 * s) + _7384 + 32]
                                if t == -1:
                                    revert with 0, 17
                                if s == -1:
                                    revert with 0, 17
                                _9369 = mem[_5609 + ceil32(return_data.size)]
                                s = s + 1
                                t = t + 1
                                continue 
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
                    if s > !t:
                        revert with 0, 17
                    if u != s + t:
                        revert with 0, 1
                    if 0 >= stor9.length:
                        revert with 0, 50
                    mem[0] = arg1
                    mem[32] = 1
                    mem[mem[64]] = 0x15d2cfca00000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 64
                    _5562 = mem[_2240]
                    mem[mem[64] + 68] = mem[_2240]
                    mem[mem[64] + 100 len 32 * _5562] = mem[_2240 + 32 len 32 * _5562]
                    idx = _5562
                    var62002 = _2240 + (32 * _5562) + 32
                    mem[mem[64] + 36] = stor1[arg1].field_512
                    require ext_code.size(address(stor9.field_0))
                    staticcall address(stor9.field_0).0x15d2cfca with:
                            gas gas_remaining wei
                           args 64, stor1[arg1].field_512, mem[mem[64] + 68 len (32 * _5562) + 32]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _7183 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _7301 = mem[_7183]
                    require mem[_7183] <= test266151307()
                    require _7183 + mem[_7183] + 31 < _7183 + return_data.size
                    _7455 = mem[_7183 + mem[_7183]]
                    if mem[_7183 + mem[_7183]] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[_7183 + mem[_7183]]) + 1 < 0 or _7183 + ceil32(return_data.size) + ceil32(32 * mem[_7183 + mem[_7183]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = _7183 + ceil32(return_data.size) + ceil32(32 * mem[_7183 + mem[_7183]]) + 1
                    mem[_7183 + ceil32(return_data.size)] = _7455
                    require _7301 + (32 * _7455) + 32 <= return_data.size
                    mem[_7183 + ceil32(return_data.size) + 32 len 32 * _7455] = mem[_7183 + _7301 + 32 len 32 * _7455]
                    mem[mem[64]] = 32
                    mem[mem[64] + 32] = _7455
                    mem[mem[64] + 64 len 32 * _7455] = mem[_7183 + ceil32(return_data.size) + 32 len 32 * _7455]
                    var89001 = _7455
                    var89002 = _7183 + ceil32(return_data.size) + (32 * _7455) + 32
                    return Array(len=_7455, data=mem[mem[64] + 64 len 32 * _7455])
                _3518 = mem[mem[ceil32(return_data.size) + 160]]
                idx = 0
                u = 0
                while idx < _3518:
                    mem[0] = arg1
                    mem[32] = 1
                    mem[mem[64] + 32] = idx
                    mem[mem[64] + 64] = stor1[arg1].field_512
                    mem[mem[64] + 96] = stor8
                    _3608 = mem[64]
                    mem[mem[64]] = 96
                    mem[64] = mem[64] + 128
                    if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                        revert with 0, 50
                    if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        revert with 0, 18
                    if sha3(mem[_3608 + 32 len mem[_3608]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        if idx == -1:
                            revert with 0, 17
                        _3518 = mem[mem[ceil32(return_data.size) + 160]]
                        idx = idx + 1
                        u = u
                        continue 
                    if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                        revert with 0, 50
                    if u >= mem[_2240]:
                        revert with 0, 50
                    mem[(32 * u) + _2240 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                    if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                        revert with 0, 50
                    if u >= mem[_2328]:
                        revert with 0, 50
                    mem[(32 * u) + _2328 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                    if u == -1:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _3518 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = idx + 1
                    u = u + 1
                    continue 
                idx = 0
                while idx < stor5.length:
                    mem[0] = 5
                    _5363 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5363] = address(stor5[idx].field_0)
                    mem[_5363 + 32] = address(stor5[idx].field_256)
                    mem[0] = address(stor5[idx].field_0)
                    mem[32] = sha3(arg1, 1) + 3
                    if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                        _5404 = mem[64]
                        mem[mem[64]] = 0
                        mem[mem[64] + 32] = 0
                        mem[64] = mem[64] + 64
                        _6880 = mem[_5404]
                        s = 0
                        t = u
                        while s < _6880:
                            if s >= mem[_5404]:
                                revert with 0, 50
                            if t >= mem[_2240]:
                                revert with 0, 50
                            mem[(32 * t) + _2240 + 32] = mem[(32 * s) + _5404 + 32]
                            if s >= mem[_5404 + 32]:
                                revert with 0, 50
                            if t >= mem[_2328]:
                                revert with 0, 50
                            mem[(32 * t) + _2328 + 32] = mem[(32 * s) + _5404 + 64]
                            if t == -1:
                                revert with 0, 17
                            if s == -1:
                                revert with 0, 17
                            _6880 = mem[_5404]
                            s = s + 1
                            t = t + 1
                            continue 
                    else:
                        mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = arg1
                        mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                        require ext_code.size(address(stor5[idx].field_256))
                        staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                                gas gas_remaining wei
                               args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _5606 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 64
                        _5680 = mem[_5606]
                        require mem[_5606] <= test266151307()
                        require _5606 + mem[_5606] + 31 < _5606 + return_data.size
                        _5823 = mem[_5606 + mem[_5606]]
                        if mem[_5606 + mem[_5606]] > test266151307():
                            revert with 0, 65
                        if ceil32(32 * mem[_5606 + mem[_5606]]) + 1 < 0 or _5606 + ceil32(return_data.size) + ceil32(32 * mem[_5606 + mem[_5606]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = _5606 + ceil32(return_data.size) + ceil32(32 * mem[_5606 + mem[_5606]]) + 1
                        mem[_5606 + ceil32(return_data.size)] = _5823
                        require _5680 + (32 * _5823) + 32 <= return_data.size
                        s = 0
                        t = _5606 + _5680 + 32
                        v = _5606 + ceil32(return_data.size) + 32
                        while s < _5823:
                            mem[v] = mem[t]
                            s = s + 1
                            t = t + 32
                            v = v + 32
                            continue 
                        _7077 = mem[_5606 + 32]
                        require mem[_5606 + 32] <= test266151307()
                        require _5606 + mem[_5606 + 32] + 31 < _5606 + return_data.size
                        _7182 = mem[_5606 + mem[_5606 + 32]]
                        if mem[_5606 + mem[_5606 + 32]] > test266151307():
                            revert with 0, 65
                        _7383 = mem[64]
                        if mem[64] + ceil32(32 * mem[_5606 + mem[_5606 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_5606 + mem[_5606 + 32]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = mem[64] + ceil32(32 * mem[_5606 + mem[_5606 + 32]]) + 1
                        mem[_7383] = _7182
                        require _7077 + (32 * _7182) + 32 <= return_data.size
                        s = 0
                        t = _5606 + _7077 + 32
                        v = _7383 + 32
                        while s < _7182:
                            mem[v] = mem[t]
                            s = s + 1
                            t = t + 32
                            v = v + 32
                            continue 
                        _9368 = mem[_5606 + ceil32(return_data.size)]
                        s = 0
                        t = u
                        while s < _9368:
                            if s >= mem[_5606 + ceil32(return_data.size)]:
                                revert with 0, 50
                            if t >= mem[_2240]:
                                revert with 0, 50
                            mem[(32 * t) + _2240 + 32] = mem[(32 * s) + _5606 + ceil32(return_data.size) + 32]
                            if s >= mem[_7383]:
                                revert with 0, 50
                            if t >= mem[_2328]:
                                revert with 0, 50
                            mem[(32 * t) + _2328 + 32] = mem[(32 * s) + _7383 + 32]
                            if t == -1:
                                revert with 0, 17
                            if s == -1:
                                revert with 0, 17
                            _9368 = mem[_5606 + ceil32(return_data.size)]
                            s = s + 1
                            t = t + 1
                            continue 
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                if s > !t:
                    revert with 0, 17
                if u != s + t:
                    revert with 0, 1
                if 0 >= stor9.length:
                    revert with 0, 50
                mem[0] = arg1
                mem[32] = 1
                mem[mem[64]] = 0x15d2cfca00000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 64
                _5560 = mem[_2240]
                mem[mem[64] + 68] = mem[_2240]
                mem[mem[64] + 100 len 32 * _5560] = mem[_2240 + 32 len 32 * _5560]
                idx = _5560
                mem[mem[64] + 36] = stor1[arg1].field_512
                require ext_code.size(address(stor9.field_0))
                staticcall address(stor9.field_0).0x15d2cfca with:
                        gas gas_remaining wei
                       args 64, stor1[arg1].field_512, mem[mem[64] + 68 len (32 * _5560) + 32]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _7181 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _7300 = mem[_7181]
                require mem[_7181] <= test266151307()
                require _7181 + mem[_7181] + 31 < _7181 + return_data.size
                _7454 = mem[_7181 + mem[_7181]]
                if mem[_7181 + mem[_7181]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_7181 + mem[_7181]]) + 1 < 0 or _7181 + ceil32(return_data.size) + ceil32(32 * mem[_7181 + mem[_7181]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _7181 + ceil32(return_data.size) + ceil32(32 * mem[_7181 + mem[_7181]]) + 1
                mem[_7181 + ceil32(return_data.size)] = _7454
                require _7300 + (32 * _7454) + 32 <= return_data.size
                mem[_7181 + ceil32(return_data.size) + 32 len 32 * _7454] = mem[_7181 + _7300 + 32 len 32 * _7454]
                var80001 = _7454
                var80002 = _7181 + _7300 + (32 * _7454) + 32
                var80004 = _7181 + ceil32(return_data.size) + (32 * _7454) + 32
                mem[mem[64]] = 32
                mem[mem[64] + 32] = _7454
                mem[mem[64] + 64 len 32 * _7454] = mem[_7181 + ceil32(return_data.size) + 32 len 32 * _7454]
                var88001 = _7454
                var88002 = _7181 + ceil32(return_data.size) + (32 * _7454) + 32
                return Array(len=_7454, data=mem[mem[64] + 64 len 32 * _7454])
            mem[mem[64] + 32 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
            if s > !t:
                revert with 0, 17
            if s + t > test266151307():
                revert with 0, 65
            mem[mem[64] + (32 * s + t) + 32] = s + t
            mem[64] = _2240 + (64 * s + t) + 64
            if not s + t:
                _3522 = mem[mem[ceil32(return_data.size) + 160]]
                idx = 0
                u = 0
                while idx < _3522:
                    mem[0] = arg1
                    mem[32] = 1
                    mem[mem[64] + 32] = idx
                    mem[mem[64] + 64] = stor1[arg1].field_512
                    mem[mem[64] + 96] = stor8
                    _3622 = mem[64]
                    mem[mem[64]] = 96
                    mem[64] = mem[64] + 128
                    if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                        revert with 0, 50
                    if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        revert with 0, 18
                    if sha3(mem[_3622 + 32 len mem[_3622]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        if idx == -1:
                            revert with 0, 17
                        _3522 = mem[mem[ceil32(return_data.size) + 160]]
                        idx = idx + 1
                        u = u
                        continue 
                    if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                        revert with 0, 50
                    if u >= mem[_2240]:
                        revert with 0, 50
                    mem[(32 * u) + _2240 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                    if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                        revert with 0, 50
                    if u >= mem[_2240 + (32 * s + t) + 32]:
                        revert with 0, 50
                    mem[(32 * u) + _2240 + (32 * s + t) + 64] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                    if u == -1:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _3522 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = idx + 1
                    u = u + 1
                    continue 
                idx = 0
                while idx < stor5.length:
                    mem[0] = 5
                    _5373 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5373] = address(stor5[idx].field_0)
                    mem[_5373 + 32] = address(stor5[idx].field_256)
                    mem[0] = address(stor5[idx].field_0)
                    mem[32] = sha3(arg1, 1) + 3
                    if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                        _5406 = mem[64]
                        mem[mem[64]] = 0
                        mem[mem[64] + 32] = 0
                        mem[64] = mem[64] + 64
                        _6882 = mem[_5406]
                        v = 0
                        w = u
                        while v < _6882:
                            if v >= mem[_5406]:
                                revert with 0, 50
                            if w >= mem[_2240]:
                                revert with 0, 50
                            mem[(32 * w) + _2240 + 32] = mem[(32 * v) + _5406 + 32]
                            if v >= mem[_5406 + 32]:
                                revert with 0, 50
                            if w >= mem[_2240 + (32 * s + t) + 32]:
                                revert with 0, 50
                            mem[(32 * w) + _2240 + (32 * s + t) + 64] = mem[(32 * v) + _5406 + 64]
                            if w == -1:
                                revert with 0, 17
                            if v == -1:
                                revert with 0, 17
                            _6882 = mem[_5406]
                            v = v + 1
                            w = w + 1
                            continue 
                    else:
                        mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = arg1
                        mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                        require ext_code.size(address(stor5[idx].field_256))
                        staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                                gas gas_remaining wei
                               args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _5612 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 64
                        _5686 = mem[_5612]
                        require mem[_5612] <= test266151307()
                        require _5612 + mem[_5612] + 31 < _5612 + return_data.size
                        _5827 = mem[_5612 + mem[_5612]]
                        if mem[_5612 + mem[_5612]] > test266151307():
                            revert with 0, 65
                        if ceil32(32 * mem[_5612 + mem[_5612]]) + 1 < 0 or _5612 + ceil32(return_data.size) + ceil32(32 * mem[_5612 + mem[_5612]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = _5612 + ceil32(return_data.size) + ceil32(32 * mem[_5612 + mem[_5612]]) + 1
                        mem[_5612 + ceil32(return_data.size)] = _5827
                        require _5686 + (32 * _5827) + 32 <= return_data.size
                        v = 0
                        w = _5612 + _5686 + 32
                        x = _5612 + ceil32(return_data.size) + 32
                        while v < _5827:
                            mem[x] = mem[w]
                            v = v + 1
                            w = w + 32
                            x = x + 32
                            continue 
                        _7083 = mem[_5612 + 32]
                        require mem[_5612 + 32] <= test266151307()
                        require _5612 + mem[_5612 + 32] + 31 < _5612 + return_data.size
                        _7186 = mem[_5612 + mem[_5612 + 32]]
                        if mem[_5612 + mem[_5612 + 32]] > test266151307():
                            revert with 0, 65
                        _7385 = mem[64]
                        if mem[64] + ceil32(32 * mem[_5612 + mem[_5612 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_5612 + mem[_5612 + 32]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = mem[64] + ceil32(32 * mem[_5612 + mem[_5612 + 32]]) + 1
                        mem[_7385] = _7186
                        require _7083 + (32 * _7186) + 32 <= return_data.size
                        v = 0
                        w = _5612 + _7083 + 32
                        x = _7385 + 32
                        while v < _7186:
                            mem[x] = mem[w]
                            v = v + 1
                            w = w + 32
                            x = x + 32
                            continue 
                        _9370 = mem[_5612 + ceil32(return_data.size)]
                        v = 0
                        w = u
                        while v < _9370:
                            if v >= mem[_5612 + ceil32(return_data.size)]:
                                revert with 0, 50
                            if w >= mem[_2240]:
                                revert with 0, 50
                            mem[(32 * w) + _2240 + 32] = mem[(32 * v) + _5612 + ceil32(return_data.size) + 32]
                            if v >= mem[_7385]:
                                revert with 0, 50
                            if w >= mem[_2240 + (32 * s + t) + 32]:
                                revert with 0, 50
                            mem[(32 * w) + _2240 + (32 * s + t) + 64] = mem[(32 * v) + _7385 + 32]
                            if w == -1:
                                revert with 0, 17
                            if v == -1:
                                revert with 0, 17
                            _9370 = mem[_5612 + ceil32(return_data.size)]
                            v = v + 1
                            w = w + 1
                            continue 
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                if s > !t:
                    revert with 0, 17
                if u != s + t:
                    revert with 0, 1
                if 0 >= stor9.length:
                    revert with 0, 50
                mem[0] = arg1
                mem[32] = 1
                mem[mem[64]] = 0x15d2cfca00000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 64
                _5564 = mem[_2240]
                mem[mem[64] + 68] = mem[_2240]
                mem[mem[64] + 100 len 32 * _5564] = mem[_2240 + 32 len 32 * _5564]
                idx = _5564
                var62002 = _2240 + (32 * _5564) + 32
                mem[mem[64] + 36] = stor1[arg1].field_512
                require ext_code.size(address(stor9.field_0))
                staticcall address(stor9.field_0).0x15d2cfca with:
                        gas gas_remaining wei
                       args 64, stor1[arg1].field_512, mem[mem[64] + 68 len (32 * _5564) + 32]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _7185 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _7302 = mem[_7185]
                require mem[_7185] <= test266151307()
                require _7185 + mem[_7185] + 31 < _7185 + return_data.size
                _7456 = mem[_7185 + mem[_7185]]
                if mem[_7185 + mem[_7185]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_7185 + mem[_7185]]) + 1 < 0 or _7185 + ceil32(return_data.size) + ceil32(32 * mem[_7185 + mem[_7185]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _7185 + ceil32(return_data.size) + ceil32(32 * mem[_7185 + mem[_7185]]) + 1
                mem[_7185 + ceil32(return_data.size)] = _7456
                require _7302 + (32 * _7456) + 32 <= return_data.size
                mem[_7185 + ceil32(return_data.size) + 32 len 32 * _7456] = mem[_7185 + _7302 + 32 len 32 * _7456]
                mem[mem[64]] = 32
                mem[mem[64] + 32] = _7456
                mem[mem[64] + 64 len 32 * _7456] = mem[_7185 + ceil32(return_data.size) + 32 len 32 * _7456]
                var89001 = _7456
                var89002 = _7185 + ceil32(return_data.size) + (32 * _7456) + 32
                return Array(len=_7456, data=mem[mem[64] + 64 len 32 * _7456])
            mem[_2240 + (32 * s + t) + 64 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
            _3524 = mem[mem[ceil32(return_data.size) + 160]]
            idx = 0
            u = 0
            while idx < _3524:
                mem[0] = arg1
                mem[32] = 1
                mem[mem[64] + 32] = idx
                mem[mem[64] + 64] = stor1[arg1].field_512
                mem[mem[64] + 96] = stor8
                _3629 = mem[64]
                mem[mem[64]] = 96
                mem[64] = mem[64] + 128
                if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                    revert with 0, 50
                if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    revert with 0, 18
                if sha3(mem[_3629 + 32 len mem[_3629]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    if idx == -1:
                        revert with 0, 17
                    _3524 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = idx + 1
                    u = u
                    continue 
                if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                    revert with 0, 50
                if u >= mem[_2240]:
                    revert with 0, 50
                mem[(32 * u) + _2240 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                    revert with 0, 50
                if u >= mem[_2240 + (32 * s + t) + 32]:
                    revert with 0, 50
                mem[(32 * u) + _2240 + (32 * s + t) + 64] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                if u == -1:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _3524 = mem[mem[ceil32(return_data.size) + 160]]
                idx = idx + 1
                u = u + 1
                continue 
            idx = 0
            while idx < stor5.length:
                mem[0] = 5
                _5378 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5378] = address(stor5[idx].field_0)
                mem[_5378 + 32] = address(stor5[idx].field_256)
                mem[0] = address(stor5[idx].field_0)
                mem[32] = sha3(arg1, 1) + 3
                if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                    _5407 = mem[64]
                    mem[mem[64]] = 0
                    mem[mem[64] + 32] = 0
                    mem[64] = mem[64] + 64
                    _6883 = mem[_5407]
                    v = 0
                    w = u
                    while v < _6883:
                        if v >= mem[_5407]:
                            revert with 0, 50
                        if w >= mem[_2240]:
                            revert with 0, 50
                        mem[(32 * w) + _2240 + 32] = mem[(32 * v) + _5407 + 32]
                        if v >= mem[_5407 + 32]:
                            revert with 0, 50
                        if w >= mem[_2240 + (32 * s + t) + 32]:
                            revert with 0, 50
                        mem[(32 * w) + _2240 + (32 * s + t) + 64] = mem[(32 * v) + _5407 + 64]
                        if w == -1:
                            revert with 0, 17
                        if v == -1:
                            revert with 0, 17
                        _6883 = mem[_5407]
                        v = v + 1
                        w = w + 1
                        continue 
                else:
                    mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = arg1
                    mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    require ext_code.size(address(stor5[idx].field_256))
                    staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                            gas gas_remaining wei
                           args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _5615 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 64
                    _5689 = mem[_5615]
                    require mem[_5615] <= test266151307()
                    require _5615 + mem[_5615] + 31 < _5615 + return_data.size
                    _5829 = mem[_5615 + mem[_5615]]
                    if mem[_5615 + mem[_5615]] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[_5615 + mem[_5615]]) + 1 < 0 or _5615 + ceil32(return_data.size) + ceil32(32 * mem[_5615 + mem[_5615]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = _5615 + ceil32(return_data.size) + ceil32(32 * mem[_5615 + mem[_5615]]) + 1
                    mem[_5615 + ceil32(return_data.size)] = _5829
                    require _5689 + (32 * _5829) + 32 <= return_data.size
                    v = 0
                    w = _5615 + _5689 + 32
                    x = _5615 + ceil32(return_data.size) + 32
                    while v < _5829:
                        mem[x] = mem[w]
                        v = v + 1
                        w = w + 32
                        x = x + 32
                        continue 
                    _7086 = mem[_5615 + 32]
                    require mem[_5615 + 32] <= test266151307()
                    require _5615 + mem[_5615 + 32] + 31 < _5615 + return_data.size
                    _7188 = mem[_5615 + mem[_5615 + 32]]
                    if mem[_5615 + mem[_5615 + 32]] > test266151307():
                        revert with 0, 65
                    _7386 = mem[64]
                    if mem[64] + ceil32(32 * mem[_5615 + mem[_5615 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_5615 + mem[_5615 + 32]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = mem[64] + ceil32(32 * mem[_5615 + mem[_5615 + 32]]) + 1
                    mem[_7386] = _7188
                    require _7086 + (32 * _7188) + 32 <= return_data.size
                    v = 0
                    w = _5615 + _7086 + 32
                    x = _7386 + 32
                    while v < _7188:
                        mem[x] = mem[w]
                        v = v + 1
                        w = w + 32
                        x = x + 32
                        continue 
                    _9371 = mem[_5615 + ceil32(return_data.size)]
                    v = 0
                    w = u
                    while v < _9371:
                        if v >= mem[_5615 + ceil32(return_data.size)]:
                            revert with 0, 50
                        if w >= mem[_2240]:
                            revert with 0, 50
                        mem[(32 * w) + _2240 + 32] = mem[(32 * v) + _5615 + ceil32(return_data.size) + 32]
                        if v >= mem[_7386]:
                            revert with 0, 50
                        if w >= mem[_2240 + (32 * s + t) + 32]:
                            revert with 0, 50
                        mem[(32 * w) + _2240 + (32 * s + t) + 64] = mem[(32 * v) + _7386 + 32]
                        if w == -1:
                            revert with 0, 17
                        if v == -1:
                            revert with 0, 17
                        _9371 = mem[_5615 + ceil32(return_data.size)]
                        v = v + 1
                        w = w + 1
                        continue 
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            if s > !t:
                revert with 0, 17
            if u != s + t:
                revert with 0, 1
            if 0 >= stor9.length:
                revert with 0, 50
            mem[0] = arg1
            mem[32] = 1
            mem[mem[64]] = 0x15d2cfca00000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 64
            _5566 = mem[_2240]
            mem[mem[64] + 68] = mem[_2240]
            mem[mem[64] + 100 len 32 * _5566] = mem[_2240 + 32 len 32 * _5566]
            idx = _5566
            var63002 = _2240 + (32 * _5566) + 32
            mem[mem[64] + 36] = stor1[arg1].field_512
            require ext_code.size(address(stor9.field_0))
            staticcall address(stor9.field_0).0x15d2cfca with:
                    gas gas_remaining wei
                   args 64, stor1[arg1].field_512, mem[mem[64] + 68 len (32 * _5566) + 32]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _7187 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _7303 = mem[_7187]
            require mem[_7187] <= test266151307()
            require _7187 + mem[_7187] + 31 < _7187 + return_data.size
            _7457 = mem[_7187 + mem[_7187]]
            if mem[_7187 + mem[_7187]] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[_7187 + mem[_7187]]) + 1 < 0 or _7187 + ceil32(return_data.size) + ceil32(32 * mem[_7187 + mem[_7187]]) + 1 > test266151307():
                revert with 0, 65
            mem[64] = _7187 + ceil32(return_data.size) + ceil32(32 * mem[_7187 + mem[_7187]]) + 1
            mem[_7187 + ceil32(return_data.size)] = _7457
            require _7303 + (32 * _7457) + 32 <= return_data.size
            mem[_7187 + ceil32(return_data.size) + 32 len 32 * _7457] = mem[_7187 + _7303 + 32 len 32 * _7457]
            var82001 = _7457
            var82002 = _7187 + _7303 + (32 * _7457) + 32
            var82004 = _7187 + ceil32(return_data.size) + (32 * _7457) + 32
            mem[mem[64]] = 32
            mem[mem[64] + 32] = _7457
            mem[mem[64] + 64 len 32 * _7457] = mem[_7187 + ceil32(return_data.size) + 32 len 32 * _7457]
            var90001 = _7457
            var90002 = _7187 + ceil32(return_data.size) + (32 * _7457) + 32
            return Array(len=_7457, data=mem[mem[64] + 64 len 32 * _7457])
        mem[0] = sha3(ext_call.return_data[31 len 1], 10) + 2
        mem[ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 288] = stor10[ext_call.return_data[31 len 1]][2].field_0
        idx = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 288
        s = 0
        while ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + (32 * stor10[ext_call.return_data[31 len 1]].field_512) + 256 > idx:
            mem[idx + 32] = stor10[ext_call.return_data[31 len 1]][s + 2].field_256
            idx = idx + 32
            s = s + 1
            continue 
        mem[ceil32(return_data.size) + 160] = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 256
        idx = 0
        s = 0
        while idx < stor10[ext_call.return_data[31 len 1]].field_512:
            mem[0] = arg1
            mem[32] = 1
            mem[mem[64] + 32] = idx
            mem[mem[64] + 64] = stor1[arg1].field_512
            mem[mem[64] + 96] = stor8
            _3637 = mem[64]
            mem[mem[64]] = 96
            mem[64] = mem[64] + 128
            if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                revert with 0, 50
            if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                revert with 0, 18
            if sha3(mem[_3637 + 32 len mem[_3637]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s
                continue 
            if s == -1:
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = s + 1
            continue 
        idx = 0
        t = 0
        while idx < stor5.length:
            mem[0] = 5
            _5383 = mem[64]
            mem[64] = mem[64] + 64
            mem[_5383] = address(stor5[idx].field_0)
            mem[_5383 + 32] = address(stor5[idx].field_256)
            mem[0] = address(stor5[idx].field_0)
            mem[32] = sha3(arg1, 1) + 3
            if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                _5410 = mem[64]
                mem[mem[64]] = 0
                mem[mem[64] + 32] = 0
                mem[64] = mem[64] + 64
                if t > !mem[_5410]:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                t = t + mem[_5410]
                continue 
            mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = arg1
            mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
            require ext_code.size(address(stor5[idx].field_256))
            staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                    gas gas_remaining wei
                   args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _5619 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 64
            _5694 = mem[_5619]
            require mem[_5619] <= test266151307()
            require _5619 + mem[_5619] + 31 < _5619 + return_data.size
            _5839 = mem[_5619 + mem[_5619]]
            if mem[_5619 + mem[_5619]] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[_5619 + mem[_5619]]) + 1 < 0 or _5619 + ceil32(return_data.size) + ceil32(32 * mem[_5619 + mem[_5619]]) + 1 > test266151307():
                revert with 0, 65
            mem[64] = _5619 + ceil32(return_data.size) + ceil32(32 * mem[_5619 + mem[_5619]]) + 1
            mem[_5619 + ceil32(return_data.size)] = _5839
            require _5694 + (32 * _5839) + 32 <= return_data.size
            s = 0
            u = _5619 + _5694 + 32
            v = _5619 + ceil32(return_data.size) + 32
            while s < _5839:
                mem[v] = mem[u]
                s = s + 1
                u = u + 32
                v = v + 32
                continue 
            _7093 = mem[_5619 + 32]
            require mem[_5619 + 32] <= test266151307()
            require _5619 + mem[_5619 + 32] + 31 < _5619 + return_data.size
            _7189 = mem[_5619 + mem[_5619 + 32]]
            if mem[_5619 + mem[_5619 + 32]] > test266151307():
                revert with 0, 65
            _7407 = mem[64]
            if mem[64] + ceil32(32 * mem[_5619 + mem[_5619 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_5619 + mem[_5619 + 32]]) + 1 > test266151307():
                revert with 0, 65
            mem[64] = mem[64] + ceil32(32 * mem[_5619 + mem[_5619 + 32]]) + 1
            mem[_7407] = _7189
            require _7093 + (32 * _7189) + 32 <= return_data.size
            s = 0
            u = _5619 + _7093 + 32
            v = _7407 + 32
            while s < _7189:
                mem[v] = mem[u]
                s = s + 1
                u = u + 32
                v = v + 32
                continue 
            if t > !mem[_5619 + ceil32(return_data.size)]:
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            t = t + mem[_5619 + ceil32(return_data.size)]
            continue 
        if s > !t:
            revert with 0, 17
        if s + t > test266151307():
            revert with 0, 65
        _5409 = mem[64]
        mem[mem[64]] = s + t
        if s + t:
            mem[mem[64] + 32 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
            if s > !t:
                revert with 0, 17
            if s + t > test266151307():
                revert with 0, 65
            mem[mem[64] + (32 * s + t) + 32] = s + t
            mem[64] = _5409 + (64 * s + t) + 64
            if not s + t:
                _6889 = mem[mem[ceil32(return_data.size) + 160]]
                idx = 0
                u = 0
                while idx < _6889:
                    mem[0] = arg1
                    mem[32] = 1
                    mem[mem[64] + 32] = idx
                    mem[mem[64] + 64] = stor1[arg1].field_512
                    mem[mem[64] + 96] = stor8
                    _6991 = mem[64]
                    mem[mem[64]] = 96
                    mem[64] = mem[64] + 128
                    if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                        revert with 0, 50
                    if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        revert with 0, 18
                    if sha3(mem[_6991 + 32 len mem[_6991]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        if idx == -1:
                            revert with 0, 17
                        _6889 = mem[mem[ceil32(return_data.size) + 160]]
                        idx = idx + 1
                        u = u
                        continue 
                    if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                        revert with 0, 50
                    if u >= mem[_5409]:
                        revert with 0, 50
                    mem[(32 * u) + _5409 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                    if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                        revert with 0, 50
                    if u >= mem[_5409 + (32 * s + t) + 32]:
                        revert with 0, 50
                    mem[(32 * u) + _5409 + (32 * s + t) + 64] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                    if u == -1:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _6889 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = idx + 1
                    u = u + 1
                    continue 
                idx = 0
                while idx < stor5.length:
                    mem[0] = 5
                    _8417 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_8417] = address(stor5[idx].field_0)
                    mem[_8417 + 32] = address(stor5[idx].field_256)
                    mem[0] = address(stor5[idx].field_0)
                    mem[32] = sha3(arg1, 1) + 3
                    if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                        _8458 = mem[64]
                        mem[mem[64]] = 0
                        mem[mem[64] + 32] = 0
                        mem[64] = mem[64] + 64
                        _9374 = mem[_8458]
                        v = 0
                        w = u
                        while v < _9374:
                            if v >= mem[_8458]:
                                revert with 0, 50
                            if w >= mem[_5409]:
                                revert with 0, 50
                            mem[(32 * w) + _5409 + 32] = mem[(32 * v) + _8458 + 32]
                            if v >= mem[_8458 + 32]:
                                revert with 0, 50
                            if w >= mem[_5409 + (32 * s + t) + 32]:
                                revert with 0, 50
                            mem[(32 * w) + _5409 + (32 * s + t) + 64] = mem[(32 * v) + _8458 + 64]
                            if w == -1:
                                revert with 0, 17
                            if v == -1:
                                revert with 0, 17
                            _9374 = mem[_8458]
                            v = v + 1
                            w = w + 1
                            continue 
                    else:
                        mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = arg1
                        mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                        require ext_code.size(address(stor5[idx].field_256))
                        staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                                gas gas_remaining wei
                               args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _8718 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 64
                        _8781 = mem[_8718]
                        require mem[_8718] <= test266151307()
                        require _8718 + mem[_8718] + 31 < _8718 + return_data.size
                        _8855 = mem[_8718 + mem[_8718]]
                        if mem[_8718 + mem[_8718]] > test266151307():
                            revert with 0, 65
                        if ceil32(32 * mem[_8718 + mem[_8718]]) + 1 < 0 or _8718 + ceil32(return_data.size) + ceil32(32 * mem[_8718 + mem[_8718]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = _8718 + ceil32(return_data.size) + ceil32(32 * mem[_8718 + mem[_8718]]) + 1
                        mem[_8718 + ceil32(return_data.size)] = _8855
                        require _8781 + (32 * _8855) + 32 <= return_data.size
                        v = 0
                        w = _8718 + _8781 + 32
                        x = _8718 + ceil32(return_data.size) + 32
                        while v < _8855:
                            mem[x] = mem[w]
                            v = v + 1
                            w = w + 32
                            x = x + 32
                            continue 
                        _9519 = mem[_8718 + 32]
                        require mem[_8718 + 32] <= test266151307()
                        require _8718 + mem[_8718 + 32] + 31 < _8718 + return_data.size
                        _9651 = mem[_8718 + mem[_8718 + 32]]
                        if mem[_8718 + mem[_8718 + 32]] > test266151307():
                            revert with 0, 65
                        _9729 = mem[64]
                        if mem[64] + ceil32(32 * mem[_8718 + mem[_8718 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_8718 + mem[_8718 + 32]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = mem[64] + ceil32(32 * mem[_8718 + mem[_8718 + 32]]) + 1
                        mem[_9729] = _9651
                        require _9519 + (32 * _9651) + 32 <= return_data.size
                        v = 0
                        w = _8718 + _9519 + 32
                        x = _9729 + 32
                        while v < _9651:
                            mem[x] = mem[w]
                            v = v + 1
                            w = w + 32
                            x = x + 32
                            continue 
                        _10442 = mem[_8718 + ceil32(return_data.size)]
                        v = 0
                        w = u
                        while v < _10442:
                            if v >= mem[_8718 + ceil32(return_data.size)]:
                                revert with 0, 50
                            if w >= mem[_5409]:
                                revert with 0, 50
                            mem[(32 * w) + _5409 + 32] = mem[(32 * v) + _8718 + ceil32(return_data.size) + 32]
                            if v >= mem[_9729]:
                                revert with 0, 50
                            if w >= mem[_5409 + (32 * s + t) + 32]:
                                revert with 0, 50
                            mem[(32 * w) + _5409 + (32 * s + t) + 64] = mem[(32 * v) + _9729 + 32]
                            if w == -1:
                                revert with 0, 17
                            if v == -1:
                                revert with 0, 17
                            _10442 = mem[_8718 + ceil32(return_data.size)]
                            v = v + 1
                            w = w + 1
                            continue 
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                if s > !t:
                    revert with 0, 17
                if u != s + t:
                    revert with 0, 1
                if 0 >= stor9.length:
                    revert with 0, 50
                mem[0] = arg1
                mem[32] = 1
                mem[mem[64]] = 0x15d2cfca00000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 64
                _8652 = mem[_5409]
                mem[mem[64] + 68] = mem[_5409]
                mem[mem[64] + 100 len 32 * _8652] = mem[_5409 + 32 len 32 * _8652]
                idx = _8652
                var66002 = _5409 + (32 * _8652) + 32
                mem[mem[64] + 36] = stor1[arg1].field_512
                require ext_code.size(address(stor9.field_0))
                staticcall address(stor9.field_0).0x15d2cfca with:
                        gas gas_remaining wei
                       args 64, stor1[arg1].field_512, mem[mem[64] + 68 len (32 * _8652) + 32]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _9650 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _9697 = mem[_9650]
                require mem[_9650] <= test266151307()
                require _9650 + mem[_9650] + 31 < _9650 + return_data.size
                _9762 = mem[_9650 + mem[_9650]]
                if mem[_9650 + mem[_9650]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_9650 + mem[_9650]]) + 1 < 0 or _9650 + ceil32(return_data.size) + ceil32(32 * mem[_9650 + mem[_9650]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _9650 + ceil32(return_data.size) + ceil32(32 * mem[_9650 + mem[_9650]]) + 1
                mem[_9650 + ceil32(return_data.size)] = _9762
                require _9697 + (32 * _9762) + 32 <= return_data.size
                mem[_9650 + ceil32(return_data.size) + 32 len 32 * _9762] = mem[_9650 + _9697 + 32 len 32 * _9762]
                mem[mem[64]] = 32
                mem[mem[64] + 32] = _9762
                mem[mem[64] + 64 len 32 * _9762] = mem[_9650 + ceil32(return_data.size) + 32 len 32 * _9762]
                var93001 = _9762
                var93002 = _9650 + ceil32(return_data.size) + (32 * _9762) + 32
                return Array(len=_9762, data=mem[mem[64] + 64 len 32 * _9762])
            mem[_5409 + (32 * s + t) + 64 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
            _6891 = mem[mem[ceil32(return_data.size) + 160]]
            idx = 0
            u = 0
            while idx < _6891:
                mem[0] = arg1
                mem[32] = 1
                mem[mem[64] + 32] = idx
                mem[mem[64] + 64] = stor1[arg1].field_512
                mem[mem[64] + 96] = stor8
                _6998 = mem[64]
                mem[mem[64]] = 96
                mem[64] = mem[64] + 128
                if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                    revert with 0, 50
                if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    revert with 0, 18
                if sha3(mem[_6998 + 32 len mem[_6998]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    if idx == -1:
                        revert with 0, 17
                    _6891 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = idx + 1
                    u = u
                    continue 
                if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                    revert with 0, 50
                if u >= mem[_5409]:
                    revert with 0, 50
                mem[(32 * u) + _5409 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                    revert with 0, 50
                if u >= mem[_5409 + (32 * s + t) + 32]:
                    revert with 0, 50
                mem[(32 * u) + _5409 + (32 * s + t) + 64] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                if u == -1:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _6891 = mem[mem[ceil32(return_data.size) + 160]]
                idx = idx + 1
                u = u + 1
                continue 
            idx = 0
            while idx < stor5.length:
                mem[0] = 5
                _8422 = mem[64]
                mem[64] = mem[64] + 64
                mem[_8422] = address(stor5[idx].field_0)
                mem[_8422 + 32] = address(stor5[idx].field_256)
                mem[0] = address(stor5[idx].field_0)
                mem[32] = sha3(arg1, 1) + 3
                if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                    _8459 = mem[64]
                    mem[mem[64]] = 0
                    mem[mem[64] + 32] = 0
                    mem[64] = mem[64] + 64
                    _9375 = mem[_8459]
                    v = 0
                    w = u
                    while v < _9375:
                        if v >= mem[_8459]:
                            revert with 0, 50
                        if w >= mem[_5409]:
                            revert with 0, 50
                        mem[(32 * w) + _5409 + 32] = mem[(32 * v) + _8459 + 32]
                        if v >= mem[_8459 + 32]:
                            revert with 0, 50
                        if w >= mem[_5409 + (32 * s + t) + 32]:
                            revert with 0, 50
                        mem[(32 * w) + _5409 + (32 * s + t) + 64] = mem[(32 * v) + _8459 + 64]
                        if w == -1:
                            revert with 0, 17
                        if v == -1:
                            revert with 0, 17
                        _9375 = mem[_8459]
                        v = v + 1
                        w = w + 1
                        continue 
                else:
                    mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = arg1
                    mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    require ext_code.size(address(stor5[idx].field_256))
                    staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                            gas gas_remaining wei
                           args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _8721 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 64
                    _8784 = mem[_8721]
                    require mem[_8721] <= test266151307()
                    require _8721 + mem[_8721] + 31 < _8721 + return_data.size
                    _8857 = mem[_8721 + mem[_8721]]
                    if mem[_8721 + mem[_8721]] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[_8721 + mem[_8721]]) + 1 < 0 or _8721 + ceil32(return_data.size) + ceil32(32 * mem[_8721 + mem[_8721]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = _8721 + ceil32(return_data.size) + ceil32(32 * mem[_8721 + mem[_8721]]) + 1
                    mem[_8721 + ceil32(return_data.size)] = _8857
                    require _8784 + (32 * _8857) + 32 <= return_data.size
                    v = 0
                    w = _8721 + _8784 + 32
                    x = _8721 + ceil32(return_data.size) + 32
                    while v < _8857:
                        mem[x] = mem[w]
                        v = v + 1
                        w = w + 32
                        x = x + 32
                        continue 
                    _9522 = mem[_8721 + 32]
                    require mem[_8721 + 32] <= test266151307()
                    require _8721 + mem[_8721 + 32] + 31 < _8721 + return_data.size
                    _9653 = mem[_8721 + mem[_8721 + 32]]
                    if mem[_8721 + mem[_8721 + 32]] > test266151307():
                        revert with 0, 65
                    _9730 = mem[64]
                    if mem[64] + ceil32(32 * mem[_8721 + mem[_8721 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_8721 + mem[_8721 + 32]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = mem[64] + ceil32(32 * mem[_8721 + mem[_8721 + 32]]) + 1
                    mem[_9730] = _9653
                    require _9522 + (32 * _9653) + 32 <= return_data.size
                    v = 0
                    w = _8721 + _9522 + 32
                    x = _9730 + 32
                    while v < _9653:
                        mem[x] = mem[w]
                        v = v + 1
                        w = w + 32
                        x = x + 32
                        continue 
                    _10443 = mem[_8721 + ceil32(return_data.size)]
                    v = 0
                    w = u
                    while v < _10443:
                        if v >= mem[_8721 + ceil32(return_data.size)]:
                            revert with 0, 50
                        if w >= mem[_5409]:
                            revert with 0, 50
                        mem[(32 * w) + _5409 + 32] = mem[(32 * v) + _8721 + ceil32(return_data.size) + 32]
                        if v >= mem[_9730]:
                            revert with 0, 50
                        if w >= mem[_5409 + (32 * s + t) + 32]:
                            revert with 0, 50
                        mem[(32 * w) + _5409 + (32 * s + t) + 64] = mem[(32 * v) + _9730 + 32]
                        if w == -1:
                            revert with 0, 17
                        if v == -1:
                            revert with 0, 17
                        _10443 = mem[_8721 + ceil32(return_data.size)]
                        v = v + 1
                        w = w + 1
                        continue 
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            if s > !t:
                revert with 0, 17
            if u != s + t:
                revert with 0, 1
            if 0 >= stor9.length:
                revert with 0, 50
            mem[0] = arg1
            mem[32] = 1
            mem[mem[64]] = 0x15d2cfca00000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 64
            _8654 = mem[_5409]
            mem[mem[64] + 68] = mem[_5409]
            mem[mem[64] + 100 len 32 * _8654] = mem[_5409 + 32 len 32 * _8654]
            idx = _8654
            var67002 = _5409 + (32 * _8654) + 32
            mem[mem[64] + 36] = stor1[arg1].field_512
            require ext_code.size(address(stor9.field_0))
            staticcall address(stor9.field_0).0x15d2cfca with:
                    gas gas_remaining wei
                   args 64, stor1[arg1].field_512, mem[mem[64] + 68 len (32 * _8654) + 32]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _9652 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _9698 = mem[_9652]
            require mem[_9652] <= test266151307()
            require _9652 + mem[_9652] + 31 < _9652 + return_data.size
            _9763 = mem[_9652 + mem[_9652]]
            if mem[_9652 + mem[_9652]] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[_9652 + mem[_9652]]) + 1 < 0 or _9652 + ceil32(return_data.size) + ceil32(32 * mem[_9652 + mem[_9652]]) + 1 > test266151307():
                revert with 0, 65
            mem[64] = _9652 + ceil32(return_data.size) + ceil32(32 * mem[_9652 + mem[_9652]]) + 1
            mem[_9652 + ceil32(return_data.size)] = _9763
            require _9698 + (32 * _9763) + 32 <= return_data.size
            mem[_9652 + ceil32(return_data.size) + 32 len 32 * _9763] = mem[_9652 + _9698 + 32 len 32 * _9763]
            mem[mem[64]] = 32
            mem[mem[64] + 32] = _9763
            mem[mem[64] + 64 len 32 * _9763] = mem[_9652 + ceil32(return_data.size) + 32 len 32 * _9763]
            var94001 = _9763
            var94002 = _9652 + ceil32(return_data.size) + (32 * _9763) + 32
            return Array(len=_9763, data=mem[mem[64] + 64 len 32 * _9763])
        if s > !t:
            revert with 0, 17
        if s + t > test266151307():
            revert with 0, 65
        _5618 = mem[64] + (32 * s + t) + 32
        mem[mem[64] + (32 * s + t) + 32] = s + t
        mem[64] = _5618 + (32 * s + t) + 32
        if s + t:
            mem[_5618 + 32 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
            _6887 = mem[mem[ceil32(return_data.size) + 160]]
            idx = 0
            u = 0
            while idx < _6887:
                mem[0] = arg1
                mem[32] = 1
                mem[mem[64] + 32] = idx
                mem[mem[64] + 64] = stor1[arg1].field_512
                mem[mem[64] + 96] = stor8
                _6984 = mem[64]
                mem[mem[64]] = 96
                mem[64] = mem[64] + 128
                if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                    revert with 0, 50
                if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    revert with 0, 18
                if sha3(mem[_6984 + 32 len mem[_6984]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    if idx == -1:
                        revert with 0, 17
                    _6887 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = idx + 1
                    u = u
                    continue 
                if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                    revert with 0, 50
                if u >= mem[_5409]:
                    revert with 0, 50
                mem[(32 * u) + _5409 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                    revert with 0, 50
                if u >= mem[_5618]:
                    revert with 0, 50
                mem[(32 * u) + _5618 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                if u == -1:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _6887 = mem[mem[ceil32(return_data.size) + 160]]
                idx = idx + 1
                u = u + 1
                continue 
            idx = 0
            while idx < stor5.length:
                mem[0] = 5
                _8412 = mem[64]
                mem[64] = mem[64] + 64
                mem[_8412] = address(stor5[idx].field_0)
                mem[_8412 + 32] = address(stor5[idx].field_256)
                mem[0] = address(stor5[idx].field_0)
                mem[32] = sha3(arg1, 1) + 3
                if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                    _8457 = mem[64]
                    mem[mem[64]] = 0
                    mem[mem[64] + 32] = 0
                    mem[64] = mem[64] + 64
                    _9373 = mem[_8457]
                    s = 0
                    t = u
                    while s < _9373:
                        if s >= mem[_8457]:
                            revert with 0, 50
                        if t >= mem[_5409]:
                            revert with 0, 50
                        mem[(32 * t) + _5409 + 32] = mem[(32 * s) + _8457 + 32]
                        if s >= mem[_8457 + 32]:
                            revert with 0, 50
                        if t >= mem[_5618]:
                            revert with 0, 50
                        mem[(32 * t) + _5618 + 32] = mem[(32 * s) + _8457 + 64]
                        if t == -1:
                            revert with 0, 17
                        if s == -1:
                            revert with 0, 17
                        _9373 = mem[_8457]
                        s = s + 1
                        t = t + 1
                        continue 
                else:
                    mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = arg1
                    mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    require ext_code.size(address(stor5[idx].field_256))
                    staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                            gas gas_remaining wei
                           args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _8715 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 64
                    _8778 = mem[_8715]
                    require mem[_8715] <= test266151307()
                    require _8715 + mem[_8715] + 31 < _8715 + return_data.size
                    _8853 = mem[_8715 + mem[_8715]]
                    if mem[_8715 + mem[_8715]] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[_8715 + mem[_8715]]) + 1 < 0 or _8715 + ceil32(return_data.size) + ceil32(32 * mem[_8715 + mem[_8715]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = _8715 + ceil32(return_data.size) + ceil32(32 * mem[_8715 + mem[_8715]]) + 1
                    mem[_8715 + ceil32(return_data.size)] = _8853
                    require _8778 + (32 * _8853) + 32 <= return_data.size
                    s = 0
                    t = _8715 + _8778 + 32
                    v = _8715 + ceil32(return_data.size) + 32
                    while s < _8853:
                        mem[v] = mem[t]
                        s = s + 1
                        t = t + 32
                        v = v + 32
                        continue 
                    _9516 = mem[_8715 + 32]
                    require mem[_8715 + 32] <= test266151307()
                    require _8715 + mem[_8715 + 32] + 31 < _8715 + return_data.size
                    _9649 = mem[_8715 + mem[_8715 + 32]]
                    if mem[_8715 + mem[_8715 + 32]] > test266151307():
                        revert with 0, 65
                    _9728 = mem[64]
                    if mem[64] + ceil32(32 * mem[_8715 + mem[_8715 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_8715 + mem[_8715 + 32]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = mem[64] + ceil32(32 * mem[_8715 + mem[_8715 + 32]]) + 1
                    mem[_9728] = _9649
                    require _9516 + (32 * _9649) + 32 <= return_data.size
                    s = 0
                    t = _8715 + _9516 + 32
                    v = _9728 + 32
                    while s < _9649:
                        mem[v] = mem[t]
                        s = s + 1
                        t = t + 32
                        v = v + 32
                        continue 
                    _10441 = mem[_8715 + ceil32(return_data.size)]
                    s = 0
                    t = u
                    while s < _10441:
                        if s >= mem[_8715 + ceil32(return_data.size)]:
                            revert with 0, 50
                        if t >= mem[_5409]:
                            revert with 0, 50
                        mem[(32 * t) + _5409 + 32] = mem[(32 * s) + _8715 + ceil32(return_data.size) + 32]
                        if s >= mem[_9728]:
                            revert with 0, 50
                        if t >= mem[_5618]:
                            revert with 0, 50
                        mem[(32 * t) + _5618 + 32] = mem[(32 * s) + _9728 + 32]
                        if t == -1:
                            revert with 0, 17
                        if s == -1:
                            revert with 0, 17
                        _10441 = mem[_8715 + ceil32(return_data.size)]
                        s = s + 1
                        t = t + 1
                        continue 
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            if s > !t:
                revert with 0, 17
            if u != s + t:
                revert with 0, 1
            if 0 >= stor9.length:
                revert with 0, 50
            mem[0] = arg1
            mem[32] = 1
            mem[mem[64]] = 0x15d2cfca00000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 64
            _8650 = mem[_5409]
            mem[mem[64] + 68] = mem[_5409]
            mem[mem[64] + 100 len 32 * _8650] = mem[_5409 + 32 len 32 * _8650]
            idx = _8650
            var66002 = _5409 + (32 * _8650) + 32
            mem[mem[64] + 36] = stor1[arg1].field_512
            require ext_code.size(address(stor9.field_0))
            staticcall address(stor9.field_0).0x15d2cfca with:
                    gas gas_remaining wei
                   args 64, stor1[arg1].field_512, mem[mem[64] + 68 len (32 * _8650) + 32]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _9648 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _9696 = mem[_9648]
            require mem[_9648] <= test266151307()
            require _9648 + mem[_9648] + 31 < _9648 + return_data.size
            _9761 = mem[_9648 + mem[_9648]]
            if mem[_9648 + mem[_9648]] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[_9648 + mem[_9648]]) + 1 < 0 or _9648 + ceil32(return_data.size) + ceil32(32 * mem[_9648 + mem[_9648]]) + 1 > test266151307():
                revert with 0, 65
            mem[64] = _9648 + ceil32(return_data.size) + ceil32(32 * mem[_9648 + mem[_9648]]) + 1
            mem[_9648 + ceil32(return_data.size)] = _9761
            require _9696 + (32 * _9761) + 32 <= return_data.size
            mem[_9648 + ceil32(return_data.size) + 32 len 32 * _9761] = mem[_9648 + _9696 + 32 len 32 * _9761]
            mem[mem[64]] = 32
            mem[mem[64] + 32] = _9761
            mem[mem[64] + 64 len 32 * _9761] = mem[_9648 + ceil32(return_data.size) + 32 len 32 * _9761]
            var93001 = _9761
            var93002 = _9648 + ceil32(return_data.size) + (32 * _9761) + 32
            return Array(len=_9761, data=mem[mem[64] + 64 len 32 * _9761])
        _6885 = mem[mem[ceil32(return_data.size) + 160]]
        idx = 0
        u = 0
        while idx < _6885:
            mem[0] = arg1
            mem[32] = 1
            mem[mem[64] + 32] = idx
            mem[mem[64] + 64] = stor1[arg1].field_512
            mem[mem[64] + 96] = stor8
            _6977 = mem[64]
            mem[mem[64]] = 96
            mem[64] = mem[64] + 128
            if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                revert with 0, 50
            if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                revert with 0, 18
            if sha3(mem[_6977 + 32 len mem[_6977]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                if idx == -1:
                    revert with 0, 17
                _6885 = mem[mem[ceil32(return_data.size) + 160]]
                idx = idx + 1
                u = u
                continue 
            if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                revert with 0, 50
            if u >= mem[_5409]:
                revert with 0, 50
            mem[(32 * u) + _5409 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
            if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                revert with 0, 50
            if u >= mem[_5618]:
                revert with 0, 50
            mem[(32 * u) + _5618 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
            if u == -1:
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            _6885 = mem[mem[ceil32(return_data.size) + 160]]
            idx = idx + 1
            u = u + 1
            continue 
        idx = 0
        while idx < stor5.length:
            mem[0] = 5
            _8407 = mem[64]
            mem[64] = mem[64] + 64
            mem[_8407] = address(stor5[idx].field_0)
            mem[_8407 + 32] = address(stor5[idx].field_256)
            mem[0] = address(stor5[idx].field_0)
            mem[32] = sha3(arg1, 1) + 3
            if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                _8456 = mem[64]
                mem[mem[64]] = 0
                mem[mem[64] + 32] = 0
                mem[64] = mem[64] + 64
                _9372 = mem[_8456]
                s = 0
                t = u
                while s < _9372:
                    if s >= mem[_8456]:
                        revert with 0, 50
                    if t >= mem[_5409]:
                        revert with 0, 50
                    mem[(32 * t) + _5409 + 32] = mem[(32 * s) + _8456 + 32]
                    if s >= mem[_8456 + 32]:
                        revert with 0, 50
                    if t >= mem[_5618]:
                        revert with 0, 50
                    mem[(32 * t) + _5618 + 32] = mem[(32 * s) + _8456 + 64]
                    if t == -1:
                        revert with 0, 17
                    if s == -1:
                        revert with 0, 17
                    _9372 = mem[_8456]
                    s = s + 1
                    t = t + 1
                    continue 
            else:
                mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = arg1
                mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                require ext_code.size(address(stor5[idx].field_256))
                staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                        gas gas_remaining wei
                       args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _8712 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 64
                _8775 = mem[_8712]
                require mem[_8712] <= test266151307()
                require _8712 + mem[_8712] + 31 < _8712 + return_data.size
                _8851 = mem[_8712 + mem[_8712]]
                if mem[_8712 + mem[_8712]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_8712 + mem[_8712]]) + 1 < 0 or _8712 + ceil32(return_data.size) + ceil32(32 * mem[_8712 + mem[_8712]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _8712 + ceil32(return_data.size) + ceil32(32 * mem[_8712 + mem[_8712]]) + 1
                mem[_8712 + ceil32(return_data.size)] = _8851
                require _8775 + (32 * _8851) + 32 <= return_data.size
                s = 0
                t = _8712 + _8775 + 32
                v = _8712 + ceil32(return_data.size) + 32
                while s < _8851:
                    mem[v] = mem[t]
                    s = s + 1
                    t = t + 32
                    v = v + 32
                    continue 
                _9513 = mem[_8712 + 32]
                require mem[_8712 + 32] <= test266151307()
                require _8712 + mem[_8712 + 32] + 31 < _8712 + return_data.size
                _9647 = mem[_8712 + mem[_8712 + 32]]
                if mem[_8712 + mem[_8712 + 32]] > test266151307():
                    revert with 0, 65
                _9727 = mem[64]
                if mem[64] + ceil32(32 * mem[_8712 + mem[_8712 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_8712 + mem[_8712 + 32]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = mem[64] + ceil32(32 * mem[_8712 + mem[_8712 + 32]]) + 1
                mem[_9727] = _9647
                require _9513 + (32 * _9647) + 32 <= return_data.size
                s = 0
                t = _8712 + _9513 + 32
                v = _9727 + 32
                while s < _9647:
                    mem[v] = mem[t]
                    s = s + 1
                    t = t + 32
                    v = v + 32
                    continue 
                _10440 = mem[_8712 + ceil32(return_data.size)]
                s = 0
                t = u
                while s < _10440:
                    if s >= mem[_8712 + ceil32(return_data.size)]:
                        revert with 0, 50
                    if t >= mem[_5409]:
                        revert with 0, 50
                    mem[(32 * t) + _5409 + 32] = mem[(32 * s) + _8712 + ceil32(return_data.size) + 32]
                    if s >= mem[_9727]:
                        revert with 0, 50
                    if t >= mem[_5618]:
                        revert with 0, 50
                    mem[(32 * t) + _5618 + 32] = mem[(32 * s) + _9727 + 32]
                    if t == -1:
                        revert with 0, 17
                    if s == -1:
                        revert with 0, 17
                    _10440 = mem[_8712 + ceil32(return_data.size)]
                    s = s + 1
                    t = t + 1
                    continue 
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        if s > !t:
            revert with 0, 17
        if u != s + t:
            revert with 0, 1
        if 0 >= stor9.length:
            revert with 0, 50
        mem[0] = arg1
        mem[32] = 1
        mem[mem[64]] = 0x15d2cfca00000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = 64
        _8648 = mem[_5409]
        mem[mem[64] + 68] = mem[_5409]
        mem[mem[64] + 100 len 32 * _8648] = mem[_5409 + 32 len 32 * _8648]
        idx = _8648
        var65002 = _5409 + (32 * _8648) + 32
        mem[mem[64] + 36] = stor1[arg1].field_512
        require ext_code.size(address(stor9.field_0))
        staticcall address(stor9.field_0).0x15d2cfca with:
                gas gas_remaining wei
               args 64, stor1[arg1].field_512, mem[mem[64] + 68 len (32 * _8648) + 32]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _9646 = mem[64]
        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _9695 = mem[_9646]
        require mem[_9646] <= test266151307()
        require _9646 + mem[_9646] + 31 < _9646 + return_data.size
        _9760 = mem[_9646 + mem[_9646]]
        if mem[_9646 + mem[_9646]] > test266151307():
            revert with 0, 65
        if ceil32(32 * mem[_9646 + mem[_9646]]) + 1 < 0 or _9646 + ceil32(return_data.size) + ceil32(32 * mem[_9646 + mem[_9646]]) + 1 > test266151307():
            revert with 0, 65
        mem[64] = _9646 + ceil32(return_data.size) + ceil32(32 * mem[_9646 + mem[_9646]]) + 1
        mem[_9646 + ceil32(return_data.size)] = _9760
        require _9695 + (32 * _9760) + 32 <= return_data.size
        mem[_9646 + ceil32(return_data.size) + 32 len 32 * _9760] = mem[_9646 + _9695 + 32 len 32 * _9760]
        var84001 = _9760
        var84002 = _9646 + _9695 + (32 * _9760) + 32
        var84004 = _9646 + ceil32(return_data.size) + (32 * _9760) + 32
        mem[mem[64]] = 32
        mem[mem[64] + 32] = _9760
        mem[mem[64] + 64 len 32 * _9760] = mem[_9646 + ceil32(return_data.size) + 32 len 32 * _9760]
        var92001 = _9760
        var92002 = _9646 + ceil32(return_data.size) + (32 * _9760) + 32
        return Array(len=_9760, data=mem[mem[64] + 64 len 32 * _9760])
    mem[0] = sha3(ext_call.return_data[31 len 1], 10) + 1
    mem[ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + 256] = stor10[ext_call.return_data[31 len 1]][1].field_0
    idx = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + 256
    s = 0
    while ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 224 > idx:
        mem[idx + 32] = stor10[ext_call.return_data[31 len 1]][s + 1].field_256
        idx = idx + 32
        s = s + 1
        continue 
    mem[ceil32(return_data.size) + 128] = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + 224
    mem[64] = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + (32 * stor10[ext_call.return_data[31 len 1]].field_512) + 288
    mem[ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 256] = stor10[ext_call.return_data[31 len 1]].field_512
    if not stor10[ext_call.return_data[31 len 1]].field_512:
        mem[ceil32(return_data.size) + 160] = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 256
        idx = 0
        s = 0
        while idx < stor10[ext_call.return_data[31 len 1]].field_512:
            mem[0] = arg1
            mem[32] = 1
            mem[mem[64] + 32] = idx
            mem[mem[64] + 64] = stor1[arg1].field_512
            mem[mem[64] + 96] = stor8
            _3644 = mem[64]
            mem[mem[64]] = 96
            mem[64] = mem[64] + 128
            if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                revert with 0, 50
            if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                revert with 0, 18
            if sha3(mem[_3644 + 32 len mem[_3644]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s
                continue 
            if s == -1:
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = s + 1
            continue 
        idx = 0
        t = 0
        while idx < stor5.length:
            mem[0] = 5
            _5388 = mem[64]
            mem[64] = mem[64] + 64
            mem[_5388] = address(stor5[idx].field_0)
            mem[_5388 + 32] = address(stor5[idx].field_256)
            mem[0] = address(stor5[idx].field_0)
            mem[32] = sha3(arg1, 1) + 3
            if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                _5412 = mem[64]
                mem[mem[64]] = 0
                mem[mem[64] + 32] = 0
                mem[64] = mem[64] + 64
                if t > !mem[_5412]:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                t = t + mem[_5412]
                continue 
            mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = arg1
            mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
            require ext_code.size(address(stor5[idx].field_256))
            staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                    gas gas_remaining wei
                   args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _5621 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 64
            _5697 = mem[_5621]
            require mem[_5621] <= test266151307()
            require _5621 + mem[_5621] + 31 < _5621 + return_data.size
            _5849 = mem[_5621 + mem[_5621]]
            if mem[_5621 + mem[_5621]] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[_5621 + mem[_5621]]) + 1 < 0 or _5621 + ceil32(return_data.size) + ceil32(32 * mem[_5621 + mem[_5621]]) + 1 > test266151307():
                revert with 0, 65
            mem[64] = _5621 + ceil32(return_data.size) + ceil32(32 * mem[_5621 + mem[_5621]]) + 1
            mem[_5621 + ceil32(return_data.size)] = _5849
            require _5697 + (32 * _5849) + 32 <= return_data.size
            s = 0
            u = _5621 + _5697 + 32
            v = _5621 + ceil32(return_data.size) + 32
            while s < _5849:
                mem[v] = mem[u]
                s = s + 1
                u = u + 32
                v = v + 32
                continue 
            _7098 = mem[_5621 + 32]
            require mem[_5621 + 32] <= test266151307()
            require _5621 + mem[_5621 + 32] + 31 < _5621 + return_data.size
            _7190 = mem[_5621 + mem[_5621 + 32]]
            if mem[_5621 + mem[_5621 + 32]] > test266151307():
                revert with 0, 65
            _7428 = mem[64]
            if mem[64] + ceil32(32 * mem[_5621 + mem[_5621 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_5621 + mem[_5621 + 32]]) + 1 > test266151307():
                revert with 0, 65
            mem[64] = mem[64] + ceil32(32 * mem[_5621 + mem[_5621 + 32]]) + 1
            mem[_7428] = _7190
            require _7098 + (32 * _7190) + 32 <= return_data.size
            s = 0
            u = _5621 + _7098 + 32
            v = _7428 + 32
            while s < _7190:
                mem[v] = mem[u]
                s = s + 1
                u = u + 32
                v = v + 32
                continue 
            if t > !mem[_5621 + ceil32(return_data.size)]:
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            t = t + mem[_5621 + ceil32(return_data.size)]
            continue 
        if s > !t:
            revert with 0, 17
        if s + t > test266151307():
            revert with 0, 65
        _5411 = mem[64]
        mem[mem[64]] = s + t
        if s + t:
            mem[mem[64] + 32 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
            if s > !t:
                revert with 0, 17
            if s + t > test266151307():
                revert with 0, 65
            mem[mem[64] + (32 * s + t) + 32] = s + t
            mem[64] = _5411 + (64 * s + t) + 64
            if not s + t:
                _6897 = mem[mem[ceil32(return_data.size) + 160]]
                idx = 0
                u = 0
                while idx < _6897:
                    mem[0] = arg1
                    mem[32] = 1
                    mem[mem[64] + 32] = idx
                    mem[mem[64] + 64] = stor1[arg1].field_512
                    mem[mem[64] + 96] = stor8
                    _7020 = mem[64]
                    mem[mem[64]] = 96
                    mem[64] = mem[64] + 128
                    if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                        revert with 0, 50
                    if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        revert with 0, 18
                    if sha3(mem[_7020 + 32 len mem[_7020]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        if idx == -1:
                            revert with 0, 17
                        _6897 = mem[mem[ceil32(return_data.size) + 160]]
                        idx = idx + 1
                        u = u
                        continue 
                    if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                        revert with 0, 50
                    if u >= mem[_5411]:
                        revert with 0, 50
                    mem[(32 * u) + _5411 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                    if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                        revert with 0, 50
                    if u >= mem[_5411 + (32 * s + t) + 32]:
                        revert with 0, 50
                    mem[(32 * u) + _5411 + (32 * s + t) + 64] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                    if u == -1:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _6897 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = idx + 1
                    u = u + 1
                    continue 
                idx = 0
                while idx < stor5.length:
                    mem[0] = 5
                    _8437 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_8437] = address(stor5[idx].field_0)
                    mem[_8437 + 32] = address(stor5[idx].field_256)
                    mem[0] = address(stor5[idx].field_0)
                    mem[32] = sha3(arg1, 1) + 3
                    if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                        _8463 = mem[64]
                        mem[mem[64]] = 0
                        mem[mem[64] + 32] = 0
                        mem[64] = mem[64] + 64
                        _9378 = mem[_8463]
                        v = 0
                        w = u
                        while v < _9378:
                            if v >= mem[_8463]:
                                revert with 0, 50
                            if w >= mem[_5411]:
                                revert with 0, 50
                            mem[(32 * w) + _5411 + 32] = mem[(32 * v) + _8463 + 32]
                            if v >= mem[_8463 + 32]:
                                revert with 0, 50
                            if w >= mem[_5411 + (32 * s + t) + 32]:
                                revert with 0, 50
                            mem[(32 * w) + _5411 + (32 * s + t) + 64] = mem[(32 * v) + _8463 + 64]
                            if w == -1:
                                revert with 0, 17
                            if v == -1:
                                revert with 0, 17
                            _9378 = mem[_8463]
                            v = v + 1
                            w = w + 1
                            continue 
                    else:
                        mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = arg1
                        mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                        require ext_code.size(address(stor5[idx].field_256))
                        staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                                gas gas_remaining wei
                               args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _8730 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 64
                        _8793 = mem[_8730]
                        require mem[_8730] <= test266151307()
                        require _8730 + mem[_8730] + 31 < _8730 + return_data.size
                        _8863 = mem[_8730 + mem[_8730]]
                        if mem[_8730 + mem[_8730]] > test266151307():
                            revert with 0, 65
                        if ceil32(32 * mem[_8730 + mem[_8730]]) + 1 < 0 or _8730 + ceil32(return_data.size) + ceil32(32 * mem[_8730 + mem[_8730]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = _8730 + ceil32(return_data.size) + ceil32(32 * mem[_8730 + mem[_8730]]) + 1
                        mem[_8730 + ceil32(return_data.size)] = _8863
                        require _8793 + (32 * _8863) + 32 <= return_data.size
                        v = 0
                        w = _8730 + _8793 + 32
                        x = _8730 + ceil32(return_data.size) + 32
                        while v < _8863:
                            mem[x] = mem[w]
                            v = v + 1
                            w = w + 32
                            x = x + 32
                            continue 
                        _9531 = mem[_8730 + 32]
                        require mem[_8730 + 32] <= test266151307()
                        require _8730 + mem[_8730 + 32] + 31 < _8730 + return_data.size
                        _9659 = mem[_8730 + mem[_8730 + 32]]
                        if mem[_8730 + mem[_8730 + 32]] > test266151307():
                            revert with 0, 65
                        _9733 = mem[64]
                        if mem[64] + ceil32(32 * mem[_8730 + mem[_8730 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_8730 + mem[_8730 + 32]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = mem[64] + ceil32(32 * mem[_8730 + mem[_8730 + 32]]) + 1
                        mem[_9733] = _9659
                        require _9531 + (32 * _9659) + 32 <= return_data.size
                        v = 0
                        w = _8730 + _9531 + 32
                        x = _9733 + 32
                        while v < _9659:
                            mem[x] = mem[w]
                            v = v + 1
                            w = w + 32
                            x = x + 32
                            continue 
                        _10446 = mem[_8730 + ceil32(return_data.size)]
                        v = 0
                        w = u
                        while v < _10446:
                            if v >= mem[_8730 + ceil32(return_data.size)]:
                                revert with 0, 50
                            if w >= mem[_5411]:
                                revert with 0, 50
                            mem[(32 * w) + _5411 + 32] = mem[(32 * v) + _8730 + ceil32(return_data.size) + 32]
                            if v >= mem[_9733]:
                                revert with 0, 50
                            if w >= mem[_5411 + (32 * s + t) + 32]:
                                revert with 0, 50
                            mem[(32 * w) + _5411 + (32 * s + t) + 64] = mem[(32 * v) + _9733 + 32]
                            if w == -1:
                                revert with 0, 17
                            if v == -1:
                                revert with 0, 17
                            _10446 = mem[_8730 + ceil32(return_data.size)]
                            v = v + 1
                            w = w + 1
                            continue 
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                if s > !t:
                    revert with 0, 17
                if u != s + t:
                    revert with 0, 1
                if 0 >= stor9.length:
                    revert with 0, 50
                mem[0] = arg1
                mem[32] = 1
                mem[mem[64]] = 0x15d2cfca00000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 64
                _8660 = mem[_5411]
                mem[mem[64] + 68] = mem[_5411]
                mem[mem[64] + 100 len 32 * _8660] = mem[_5411 + 32 len 32 * _8660]
                idx = _8660
                var66002 = _5411 + (32 * _8660) + 32
                mem[mem[64] + 36] = stor1[arg1].field_512
                require ext_code.size(address(stor9.field_0))
                staticcall address(stor9.field_0).0x15d2cfca with:
                        gas gas_remaining wei
                       args 64, stor1[arg1].field_512, mem[mem[64] + 68 len (32 * _8660) + 32]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _9658 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _9701 = mem[_9658]
                require mem[_9658] <= test266151307()
                require _9658 + mem[_9658] + 31 < _9658 + return_data.size
                _9766 = mem[_9658 + mem[_9658]]
                if mem[_9658 + mem[_9658]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_9658 + mem[_9658]]) + 1 < 0 or _9658 + ceil32(return_data.size) + ceil32(32 * mem[_9658 + mem[_9658]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _9658 + ceil32(return_data.size) + ceil32(32 * mem[_9658 + mem[_9658]]) + 1
                mem[_9658 + ceil32(return_data.size)] = _9766
                require _9701 + (32 * _9766) + 32 <= return_data.size
                mem[_9658 + ceil32(return_data.size) + 32 len 32 * _9766] = mem[_9658 + _9701 + 32 len 32 * _9766]
                mem[mem[64]] = 32
                mem[mem[64] + 32] = _9766
                mem[mem[64] + 64 len 32 * _9766] = mem[_9658 + ceil32(return_data.size) + 32 len 32 * _9766]
                var93001 = _9766
                var93002 = _9658 + ceil32(return_data.size) + (32 * _9766) + 32
                return Array(len=_9766, data=mem[mem[64] + 64 len 32 * _9766])
            mem[_5411 + (32 * s + t) + 64 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
            _6899 = mem[mem[ceil32(return_data.size) + 160]]
            idx = 0
            u = 0
            while idx < _6899:
                mem[0] = arg1
                mem[32] = 1
                mem[mem[64] + 32] = idx
                mem[mem[64] + 64] = stor1[arg1].field_512
                mem[mem[64] + 96] = stor8
                _7027 = mem[64]
                mem[mem[64]] = 96
                mem[64] = mem[64] + 128
                if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                    revert with 0, 50
                if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    revert with 0, 18
                if sha3(mem[_7027 + 32 len mem[_7027]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    if idx == -1:
                        revert with 0, 17
                    _6899 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = idx + 1
                    u = u
                    continue 
                if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                    revert with 0, 50
                if u >= mem[_5411]:
                    revert with 0, 50
                mem[(32 * u) + _5411 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                    revert with 0, 50
                if u >= mem[_5411 + (32 * s + t) + 32]:
                    revert with 0, 50
                mem[(32 * u) + _5411 + (32 * s + t) + 64] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                if u == -1:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _6899 = mem[mem[ceil32(return_data.size) + 160]]
                idx = idx + 1
                u = u + 1
                continue 
            idx = 0
            while idx < stor5.length:
                mem[0] = 5
                _8442 = mem[64]
                mem[64] = mem[64] + 64
                mem[_8442] = address(stor5[idx].field_0)
                mem[_8442 + 32] = address(stor5[idx].field_256)
                mem[0] = address(stor5[idx].field_0)
                mem[32] = sha3(arg1, 1) + 3
                if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                    _8464 = mem[64]
                    mem[mem[64]] = 0
                    mem[mem[64] + 32] = 0
                    mem[64] = mem[64] + 64
                    _9379 = mem[_8464]
                    v = 0
                    w = u
                    while v < _9379:
                        if v >= mem[_8464]:
                            revert with 0, 50
                        if w >= mem[_5411]:
                            revert with 0, 50
                        mem[(32 * w) + _5411 + 32] = mem[(32 * v) + _8464 + 32]
                        if v >= mem[_8464 + 32]:
                            revert with 0, 50
                        if w >= mem[_5411 + (32 * s + t) + 32]:
                            revert with 0, 50
                        mem[(32 * w) + _5411 + (32 * s + t) + 64] = mem[(32 * v) + _8464 + 64]
                        if w == -1:
                            revert with 0, 17
                        if v == -1:
                            revert with 0, 17
                        _9379 = mem[_8464]
                        v = v + 1
                        w = w + 1
                        continue 
                else:
                    mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = arg1
                    mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    require ext_code.size(address(stor5[idx].field_256))
                    staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                            gas gas_remaining wei
                           args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _8733 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 64
                    _8796 = mem[_8733]
                    require mem[_8733] <= test266151307()
                    require _8733 + mem[_8733] + 31 < _8733 + return_data.size
                    _8865 = mem[_8733 + mem[_8733]]
                    if mem[_8733 + mem[_8733]] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[_8733 + mem[_8733]]) + 1 < 0 or _8733 + ceil32(return_data.size) + ceil32(32 * mem[_8733 + mem[_8733]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = _8733 + ceil32(return_data.size) + ceil32(32 * mem[_8733 + mem[_8733]]) + 1
                    mem[_8733 + ceil32(return_data.size)] = _8865
                    require _8796 + (32 * _8865) + 32 <= return_data.size
                    v = 0
                    w = _8733 + _8796 + 32
                    x = _8733 + ceil32(return_data.size) + 32
                    while v < _8865:
                        mem[x] = mem[w]
                        v = v + 1
                        w = w + 32
                        x = x + 32
                        continue 
                    _9534 = mem[_8733 + 32]
                    require mem[_8733 + 32] <= test266151307()
                    require _8733 + mem[_8733 + 32] + 31 < _8733 + return_data.size
                    _9661 = mem[_8733 + mem[_8733 + 32]]
                    if mem[_8733 + mem[_8733 + 32]] > test266151307():
                        revert with 0, 65
                    _9734 = mem[64]
                    if mem[64] + ceil32(32 * mem[_8733 + mem[_8733 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_8733 + mem[_8733 + 32]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = mem[64] + ceil32(32 * mem[_8733 + mem[_8733 + 32]]) + 1
                    mem[_9734] = _9661
                    require _9534 + (32 * _9661) + 32 <= return_data.size
                    v = 0
                    w = _8733 + _9534 + 32
                    x = _9734 + 32
                    while v < _9661:
                        mem[x] = mem[w]
                        v = v + 1
                        w = w + 32
                        x = x + 32
                        continue 
                    _10447 = mem[_8733 + ceil32(return_data.size)]
                    v = 0
                    w = u
                    while v < _10447:
                        if v >= mem[_8733 + ceil32(return_data.size)]:
                            revert with 0, 50
                        if w >= mem[_5411]:
                            revert with 0, 50
                        mem[(32 * w) + _5411 + 32] = mem[(32 * v) + _8733 + ceil32(return_data.size) + 32]
                        if v >= mem[_9734]:
                            revert with 0, 50
                        if w >= mem[_5411 + (32 * s + t) + 32]:
                            revert with 0, 50
                        mem[(32 * w) + _5411 + (32 * s + t) + 64] = mem[(32 * v) + _9734 + 32]
                        if w == -1:
                            revert with 0, 17
                        if v == -1:
                            revert with 0, 17
                        _10447 = mem[_8733 + ceil32(return_data.size)]
                        v = v + 1
                        w = w + 1
                        continue 
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            if s > !t:
                revert with 0, 17
            if u != s + t:
                revert with 0, 1
            if 0 >= stor9.length:
                revert with 0, 50
            mem[0] = arg1
            mem[32] = 1
            mem[mem[64]] = 0x15d2cfca00000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 64
            _8662 = mem[_5411]
            mem[mem[64] + 68] = mem[_5411]
            mem[mem[64] + 100 len 32 * _8662] = mem[_5411 + 32 len 32 * _8662]
            idx = _8662
            var67002 = _5411 + (32 * _8662) + 32
            mem[mem[64] + 36] = stor1[arg1].field_512
            require ext_code.size(address(stor9.field_0))
            staticcall address(stor9.field_0).0x15d2cfca with:
                    gas gas_remaining wei
                   args 64, stor1[arg1].field_512, mem[mem[64] + 68 len (32 * _8662) + 32]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _9660 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _9702 = mem[_9660]
            require mem[_9660] <= test266151307()
            require _9660 + mem[_9660] + 31 < _9660 + return_data.size
            _9767 = mem[_9660 + mem[_9660]]
            if mem[_9660 + mem[_9660]] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[_9660 + mem[_9660]]) + 1 < 0 or _9660 + ceil32(return_data.size) + ceil32(32 * mem[_9660 + mem[_9660]]) + 1 > test266151307():
                revert with 0, 65
            mem[64] = _9660 + ceil32(return_data.size) + ceil32(32 * mem[_9660 + mem[_9660]]) + 1
            mem[_9660 + ceil32(return_data.size)] = _9767
            require _9702 + (32 * _9767) + 32 <= return_data.size
            mem[_9660 + ceil32(return_data.size) + 32 len 32 * _9767] = mem[_9660 + _9702 + 32 len 32 * _9767]
            mem[mem[64]] = 32
            mem[mem[64] + 32] = _9767
            mem[mem[64] + 64 len 32 * _9767] = mem[_9660 + ceil32(return_data.size) + 32 len 32 * _9767]
            var94001 = _9767
            var94002 = _9660 + ceil32(return_data.size) + (32 * _9767) + 32
            return Array(len=_9767, data=mem[mem[64] + 64 len 32 * _9767])
        if s > !t:
            revert with 0, 17
        if s + t > test266151307():
            revert with 0, 65
        _5620 = mem[64] + (32 * s + t) + 32
        mem[mem[64] + (32 * s + t) + 32] = s + t
        mem[64] = _5620 + (32 * s + t) + 32
        if s + t:
            mem[_5620 + 32 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
            _6895 = mem[mem[ceil32(return_data.size) + 160]]
            idx = 0
            u = 0
            while idx < _6895:
                mem[0] = arg1
                mem[32] = 1
                mem[mem[64] + 32] = idx
                mem[mem[64] + 64] = stor1[arg1].field_512
                mem[mem[64] + 96] = stor8
                _7013 = mem[64]
                mem[mem[64]] = 96
                mem[64] = mem[64] + 128
                if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                    revert with 0, 50
                if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    revert with 0, 18
                if sha3(mem[_7013 + 32 len mem[_7013]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    if idx == -1:
                        revert with 0, 17
                    _6895 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = idx + 1
                    u = u
                    continue 
                if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                    revert with 0, 50
                if u >= mem[_5411]:
                    revert with 0, 50
                mem[(32 * u) + _5411 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                    revert with 0, 50
                if u >= mem[_5620]:
                    revert with 0, 50
                mem[(32 * u) + _5620 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                if u == -1:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _6895 = mem[mem[ceil32(return_data.size) + 160]]
                idx = idx + 1
                u = u + 1
                continue 
            idx = 0
            while idx < stor5.length:
                mem[0] = 5
                _8432 = mem[64]
                mem[64] = mem[64] + 64
                mem[_8432] = address(stor5[idx].field_0)
                mem[_8432 + 32] = address(stor5[idx].field_256)
                mem[0] = address(stor5[idx].field_0)
                mem[32] = sha3(arg1, 1) + 3
                if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                    _8462 = mem[64]
                    mem[mem[64]] = 0
                    mem[mem[64] + 32] = 0
                    mem[64] = mem[64] + 64
                    _9377 = mem[_8462]
                    s = 0
                    t = u
                    while s < _9377:
                        if s >= mem[_8462]:
                            revert with 0, 50
                        if t >= mem[_5411]:
                            revert with 0, 50
                        mem[(32 * t) + _5411 + 32] = mem[(32 * s) + _8462 + 32]
                        if s >= mem[_8462 + 32]:
                            revert with 0, 50
                        if t >= mem[_5620]:
                            revert with 0, 50
                        mem[(32 * t) + _5620 + 32] = mem[(32 * s) + _8462 + 64]
                        if t == -1:
                            revert with 0, 17
                        if s == -1:
                            revert with 0, 17
                        _9377 = mem[_8462]
                        s = s + 1
                        t = t + 1
                        continue 
                else:
                    mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = arg1
                    mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    require ext_code.size(address(stor5[idx].field_256))
                    staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                            gas gas_remaining wei
                           args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _8727 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 64
                    _8790 = mem[_8727]
                    require mem[_8727] <= test266151307()
                    require _8727 + mem[_8727] + 31 < _8727 + return_data.size
                    _8861 = mem[_8727 + mem[_8727]]
                    if mem[_8727 + mem[_8727]] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[_8727 + mem[_8727]]) + 1 < 0 or _8727 + ceil32(return_data.size) + ceil32(32 * mem[_8727 + mem[_8727]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = _8727 + ceil32(return_data.size) + ceil32(32 * mem[_8727 + mem[_8727]]) + 1
                    mem[_8727 + ceil32(return_data.size)] = _8861
                    require _8790 + (32 * _8861) + 32 <= return_data.size
                    s = 0
                    t = _8727 + _8790 + 32
                    v = _8727 + ceil32(return_data.size) + 32
                    while s < _8861:
                        mem[v] = mem[t]
                        s = s + 1
                        t = t + 32
                        v = v + 32
                        continue 
                    _9528 = mem[_8727 + 32]
                    require mem[_8727 + 32] <= test266151307()
                    require _8727 + mem[_8727 + 32] + 31 < _8727 + return_data.size
                    _9657 = mem[_8727 + mem[_8727 + 32]]
                    if mem[_8727 + mem[_8727 + 32]] > test266151307():
                        revert with 0, 65
                    _9732 = mem[64]
                    if mem[64] + ceil32(32 * mem[_8727 + mem[_8727 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_8727 + mem[_8727 + 32]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = mem[64] + ceil32(32 * mem[_8727 + mem[_8727 + 32]]) + 1
                    mem[_9732] = _9657
                    require _9528 + (32 * _9657) + 32 <= return_data.size
                    s = 0
                    t = _8727 + _9528 + 32
                    v = _9732 + 32
                    while s < _9657:
                        mem[v] = mem[t]
                        s = s + 1
                        t = t + 32
                        v = v + 32
                        continue 
                    _10445 = mem[_8727 + ceil32(return_data.size)]
                    s = 0
                    t = u
                    while s < _10445:
                        if s >= mem[_8727 + ceil32(return_data.size)]:
                            revert with 0, 50
                        if t >= mem[_5411]:
                            revert with 0, 50
                        mem[(32 * t) + _5411 + 32] = mem[(32 * s) + _8727 + ceil32(return_data.size) + 32]
                        if s >= mem[_9732]:
                            revert with 0, 50
                        if t >= mem[_5620]:
                            revert with 0, 50
                        mem[(32 * t) + _5620 + 32] = mem[(32 * s) + _9732 + 32]
                        if t == -1:
                            revert with 0, 17
                        if s == -1:
                            revert with 0, 17
                        _10445 = mem[_8727 + ceil32(return_data.size)]
                        s = s + 1
                        t = t + 1
                        continue 
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            if s > !t:
                revert with 0, 17
            if u != s + t:
                revert with 0, 1
            if 0 >= stor9.length:
                revert with 0, 50
            mem[0] = arg1
            mem[32] = 1
            mem[mem[64]] = 0x15d2cfca00000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 64
            _8658 = mem[_5411]
            mem[mem[64] + 68] = mem[_5411]
            mem[mem[64] + 100 len 32 * _8658] = mem[_5411 + 32 len 32 * _8658]
            idx = _8658
            var66002 = _5411 + (32 * _8658) + 32
            mem[mem[64] + 36] = stor1[arg1].field_512
            require ext_code.size(address(stor9.field_0))
            staticcall address(stor9.field_0).0x15d2cfca with:
                    gas gas_remaining wei
                   args 64, stor1[arg1].field_512, mem[mem[64] + 68 len (32 * _8658) + 32]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _9656 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _9700 = mem[_9656]
            require mem[_9656] <= test266151307()
            require _9656 + mem[_9656] + 31 < _9656 + return_data.size
            _9765 = mem[_9656 + mem[_9656]]
            if mem[_9656 + mem[_9656]] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[_9656 + mem[_9656]]) + 1 < 0 or _9656 + ceil32(return_data.size) + ceil32(32 * mem[_9656 + mem[_9656]]) + 1 > test266151307():
                revert with 0, 65
            mem[64] = _9656 + ceil32(return_data.size) + ceil32(32 * mem[_9656 + mem[_9656]]) + 1
            mem[_9656 + ceil32(return_data.size)] = _9765
            require _9700 + (32 * _9765) + 32 <= return_data.size
            mem[_9656 + ceil32(return_data.size) + 32 len 32 * _9765] = mem[_9656 + _9700 + 32 len 32 * _9765]
            mem[mem[64]] = 32
            mem[mem[64] + 32] = _9765
            mem[mem[64] + 64 len 32 * _9765] = mem[_9656 + ceil32(return_data.size) + 32 len 32 * _9765]
            var93001 = _9765
            var93002 = _9656 + ceil32(return_data.size) + (32 * _9765) + 32
            return Array(len=_9765, data=mem[mem[64] + 64 len 32 * _9765])
        _6893 = mem[mem[ceil32(return_data.size) + 160]]
        idx = 0
        u = 0
        while idx < _6893:
            mem[0] = arg1
            mem[32] = 1
            mem[mem[64] + 32] = idx
            mem[mem[64] + 64] = stor1[arg1].field_512
            mem[mem[64] + 96] = stor8
            _7006 = mem[64]
            mem[mem[64]] = 96
            mem[64] = mem[64] + 128
            if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                revert with 0, 50
            if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                revert with 0, 18
            if sha3(mem[_7006 + 32 len mem[_7006]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                if idx == -1:
                    revert with 0, 17
                _6893 = mem[mem[ceil32(return_data.size) + 160]]
                idx = idx + 1
                u = u
                continue 
            if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                revert with 0, 50
            if u >= mem[_5411]:
                revert with 0, 50
            mem[(32 * u) + _5411 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
            if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                revert with 0, 50
            if u >= mem[_5620]:
                revert with 0, 50
            mem[(32 * u) + _5620 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
            if u == -1:
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            _6893 = mem[mem[ceil32(return_data.size) + 160]]
            idx = idx + 1
            u = u + 1
            continue 
        idx = 0
        while idx < stor5.length:
            mem[0] = 5
            _8427 = mem[64]
            mem[64] = mem[64] + 64
            mem[_8427] = address(stor5[idx].field_0)
            mem[_8427 + 32] = address(stor5[idx].field_256)
            mem[0] = address(stor5[idx].field_0)
            mem[32] = sha3(arg1, 1) + 3
            if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                _8461 = mem[64]
                mem[mem[64]] = 0
                mem[mem[64] + 32] = 0
                mem[64] = mem[64] + 64
                _9376 = mem[_8461]
                s = 0
                t = u
                while s < _9376:
                    if s >= mem[_8461]:
                        revert with 0, 50
                    if t >= mem[_5411]:
                        revert with 0, 50
                    mem[(32 * t) + _5411 + 32] = mem[(32 * s) + _8461 + 32]
                    if s >= mem[_8461 + 32]:
                        revert with 0, 50
                    if t >= mem[_5620]:
                        revert with 0, 50
                    mem[(32 * t) + _5620 + 32] = mem[(32 * s) + _8461 + 64]
                    if t == -1:
                        revert with 0, 17
                    if s == -1:
                        revert with 0, 17
                    _9376 = mem[_8461]
                    s = s + 1
                    t = t + 1
                    continue 
            else:
                mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = arg1
                mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                require ext_code.size(address(stor5[idx].field_256))
                staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                        gas gas_remaining wei
                       args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _8724 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 64
                _8787 = mem[_8724]
                require mem[_8724] <= test266151307()
                require _8724 + mem[_8724] + 31 < _8724 + return_data.size
                _8859 = mem[_8724 + mem[_8724]]
                if mem[_8724 + mem[_8724]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_8724 + mem[_8724]]) + 1 < 0 or _8724 + ceil32(return_data.size) + ceil32(32 * mem[_8724 + mem[_8724]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _8724 + ceil32(return_data.size) + ceil32(32 * mem[_8724 + mem[_8724]]) + 1
                mem[_8724 + ceil32(return_data.size)] = _8859
                require _8787 + (32 * _8859) + 32 <= return_data.size
                s = 0
                t = _8724 + _8787 + 32
                v = _8724 + ceil32(return_data.size) + 32
                while s < _8859:
                    mem[v] = mem[t]
                    s = s + 1
                    t = t + 32
                    v = v + 32
                    continue 
                _9525 = mem[_8724 + 32]
                require mem[_8724 + 32] <= test266151307()
                require _8724 + mem[_8724 + 32] + 31 < _8724 + return_data.size
                _9655 = mem[_8724 + mem[_8724 + 32]]
                if mem[_8724 + mem[_8724 + 32]] > test266151307():
                    revert with 0, 65
                _9731 = mem[64]
                if mem[64] + ceil32(32 * mem[_8724 + mem[_8724 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_8724 + mem[_8724 + 32]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = mem[64] + ceil32(32 * mem[_8724 + mem[_8724 + 32]]) + 1
                mem[_9731] = _9655
                require _9525 + (32 * _9655) + 32 <= return_data.size
                s = 0
                t = _8724 + _9525 + 32
                v = _9731 + 32
                while s < _9655:
                    mem[v] = mem[t]
                    s = s + 1
                    t = t + 32
                    v = v + 32
                    continue 
                _10444 = mem[_8724 + ceil32(return_data.size)]
                s = 0
                t = u
                while s < _10444:
                    if s >= mem[_8724 + ceil32(return_data.size)]:
                        revert with 0, 50
                    if t >= mem[_5411]:
                        revert with 0, 50
                    mem[(32 * t) + _5411 + 32] = mem[(32 * s) + _8724 + ceil32(return_data.size) + 32]
                    if s >= mem[_9731]:
                        revert with 0, 50
                    if t >= mem[_5620]:
                        revert with 0, 50
                    mem[(32 * t) + _5620 + 32] = mem[(32 * s) + _9731 + 32]
                    if t == -1:
                        revert with 0, 17
                    if s == -1:
                        revert with 0, 17
                    _10444 = mem[_8724 + ceil32(return_data.size)]
                    s = s + 1
                    t = t + 1
                    continue 
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        if s > !t:
            revert with 0, 17
        if u != s + t:
            revert with 0, 1
        if 0 >= stor9.length:
            revert with 0, 50
        mem[0] = arg1
        mem[32] = 1
        mem[mem[64]] = 0x15d2cfca00000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = 64
        _8656 = mem[_5411]
        mem[mem[64] + 68] = mem[_5411]
        mem[mem[64] + 100 len 32 * _8656] = mem[_5411 + 32 len 32 * _8656]
        idx = _8656
        var65002 = _5411 + (32 * _8656) + 32
        mem[mem[64] + 36] = stor1[arg1].field_512
        require ext_code.size(address(stor9.field_0))
        staticcall address(stor9.field_0).0x15d2cfca with:
                gas gas_remaining wei
               args 64, stor1[arg1].field_512, mem[mem[64] + 68 len (32 * _8656) + 32]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _9654 = mem[64]
        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _9699 = mem[_9654]
        require mem[_9654] <= test266151307()
        require _9654 + mem[_9654] + 31 < _9654 + return_data.size
        _9764 = mem[_9654 + mem[_9654]]
        if mem[_9654 + mem[_9654]] > test266151307():
            revert with 0, 65
        if ceil32(32 * mem[_9654 + mem[_9654]]) + 1 < 0 or _9654 + ceil32(return_data.size) + ceil32(32 * mem[_9654 + mem[_9654]]) + 1 > test266151307():
            revert with 0, 65
        mem[64] = _9654 + ceil32(return_data.size) + ceil32(32 * mem[_9654 + mem[_9654]]) + 1
        mem[_9654 + ceil32(return_data.size)] = _9764
        require _9699 + (32 * _9764) + 32 <= return_data.size
        mem[_9654 + ceil32(return_data.size) + 32 len 32 * _9764] = mem[_9654 + _9699 + 32 len 32 * _9764]
        var84001 = _9764
        var84002 = _9654 + _9699 + (32 * _9764) + 32
        var84004 = _9654 + ceil32(return_data.size) + (32 * _9764) + 32
        mem[mem[64]] = 32
        mem[mem[64] + 32] = _9764
        mem[mem[64] + 64 len 32 * _9764] = mem[_9654 + ceil32(return_data.size) + 32 len 32 * _9764]
        var92001 = _9764
        var92002 = _9654 + ceil32(return_data.size) + (32 * _9764) + 32
        return Array(len=_9764, data=mem[mem[64] + 64 len 32 * _9764])
    mem[0] = sha3(ext_call.return_data[31 len 1], 10) + 2
    mem[ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 288] = stor10[ext_call.return_data[31 len 1]][2].field_0
    idx = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 288
    s = 0
    while ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + (32 * stor10[ext_call.return_data[31 len 1]].field_512) + 256 > idx:
        mem[idx + 32] = stor10[ext_call.return_data[31 len 1]][s + 2].field_256
        idx = idx + 32
        s = s + 1
        continue 
    mem[ceil32(return_data.size) + 160] = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 256
    idx = 0
    s = 0
    while idx < stor10[ext_call.return_data[31 len 1]].field_512:
        mem[0] = arg1
        mem[32] = 1
        mem[mem[64] + 32] = idx
        mem[mem[64] + 64] = stor1[arg1].field_512
        mem[mem[64] + 96] = stor8
        _7035 = mem[64]
        mem[mem[64]] = 96
        mem[64] = mem[64] + 128
        if idx >= mem[mem[ceil32(return_data.size) + 160]]:
            revert with 0, 50
        if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
            revert with 0, 18
        if sha3(mem[_7035 + 32 len mem[_7035]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = s
            continue 
        if s == -1:
            revert with 0, 17
        if idx == -1:
            revert with 0, 17
        idx = idx + 1
        s = s + 1
        continue 
    idx = 0
    t = 0
    while idx < stor5.length:
        mem[0] = 5
        _8447 = mem[64]
        mem[64] = mem[64] + 64
        mem[_8447] = address(stor5[idx].field_0)
        mem[_8447 + 32] = address(stor5[idx].field_256)
        mem[0] = address(stor5[idx].field_0)
        mem[32] = sha3(arg1, 1) + 3
        if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
            _8467 = mem[64]
            mem[mem[64]] = 0
            mem[mem[64] + 32] = 0
            mem[64] = mem[64] + 64
            if t > !mem[_8467]:
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            t = t + mem[_8467]
            continue 
        mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = arg1
        mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
        require ext_code.size(address(stor5[idx].field_256))
        staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                gas gas_remaining wei
               args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _8737 = mem[64]
        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 64
        _8801 = mem[_8737]
        require mem[_8737] <= test266151307()
        require _8737 + mem[_8737] + 31 < _8737 + return_data.size
        _8875 = mem[_8737 + mem[_8737]]
        if mem[_8737 + mem[_8737]] > test266151307():
            revert with 0, 65
        if ceil32(32 * mem[_8737 + mem[_8737]]) + 1 < 0 or _8737 + ceil32(return_data.size) + ceil32(32 * mem[_8737 + mem[_8737]]) + 1 > test266151307():
            revert with 0, 65
        mem[64] = _8737 + ceil32(return_data.size) + ceil32(32 * mem[_8737 + mem[_8737]]) + 1
        mem[_8737 + ceil32(return_data.size)] = _8875
        require _8801 + (32 * _8875) + 32 <= return_data.size
        s = 0
        u = _8737 + _8801 + 32
        v = _8737 + ceil32(return_data.size) + 32
        while s < _8875:
            mem[v] = mem[u]
            s = s + 1
            u = u + 32
            v = v + 32
            continue 
        _9541 = mem[_8737 + 32]
        require mem[_8737 + 32] <= test266151307()
        require _8737 + mem[_8737 + 32] + 31 < _8737 + return_data.size
        _9662 = mem[_8737 + mem[_8737 + 32]]
        if mem[_8737 + mem[_8737 + 32]] > test266151307():
            revert with 0, 65
        _9755 = mem[64]
        if mem[64] + ceil32(32 * mem[_8737 + mem[_8737 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_8737 + mem[_8737 + 32]]) + 1 > test266151307():
            revert with 0, 65
        mem[64] = mem[64] + ceil32(32 * mem[_8737 + mem[_8737 + 32]]) + 1
        mem[_9755] = _9662
        require _9541 + (32 * _9662) + 32 <= return_data.size
        s = 0
        u = _8737 + _9541 + 32
        v = _9755 + 32
        while s < _9662:
            mem[v] = mem[u]
            s = s + 1
            u = u + 32
            v = v + 32
            continue 
        if t > !mem[_8737 + ceil32(return_data.size)]:
            revert with 0, 17
        if idx == -1:
            revert with 0, 17
        idx = idx + 1
        t = t + mem[_8737 + ceil32(return_data.size)]
        continue 
    if s > !t:
        revert with 0, 17
    if s + t > test266151307():
        revert with 0, 65
    _8466 = mem[64]
    mem[mem[64]] = s + t
    if not s + t:
        if s > !t:
            revert with 0, 17
        if s + t > test266151307():
            revert with 0, 65
        _8736 = mem[64] + (32 * s + t) + 32
        mem[mem[64] + (32 * s + t) + 32] = s + t
        mem[64] = _8736 + (32 * s + t) + 32
        if not s + t:
            _9381 = mem[mem[ceil32(return_data.size) + 160]]
            idx = 0
            u = 0
            while idx < _9381:
                mem[0] = arg1
                mem[32] = 1
                mem[mem[64] + 32] = idx
                mem[mem[64] + 64] = stor1[arg1].field_512
                mem[mem[64] + 96] = stor8
                _9450 = mem[64]
                mem[mem[64]] = 96
                mem[64] = mem[64] + 128
                if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                    revert with 0, 50
                if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    revert with 0, 18
                if sha3(mem[_9450 + 32 len mem[_9450]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    if idx == -1:
                        revert with 0, 17
                    _9381 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = idx + 1
                    u = u
                    continue 
                if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                    revert with 0, 50
                if u >= mem[_8466]:
                    revert with 0, 50
                mem[(32 * u) + _8466 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                    revert with 0, 50
                if u >= mem[_8736]:
                    revert with 0, 50
                mem[(32 * u) + _8736 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                if u == -1:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _9381 = mem[mem[ceil32(return_data.size) + 160]]
                idx = idx + 1
                u = u + 1
                continue 
            idx = 0
            while idx < stor5.length:
                mem[0] = 5
                _10128 = mem[64]
                mem[64] = mem[64] + 64
                mem[_10128] = address(stor5[idx].field_0)
                mem[_10128 + 32] = address(stor5[idx].field_256)
                mem[0] = address(stor5[idx].field_0)
                mem[32] = sha3(arg1, 1) + 3
                if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                    _10147 = mem[64]
                    mem[mem[64]] = 0
                    mem[mem[64] + 32] = 0
                    mem[64] = mem[64] + 64
                    _10448 = mem[_10147]
                    s = 0
                    t = u
                    while s < _10448:
                        if s >= mem[_10147]:
                            revert with 0, 50
                        if t >= mem[_8466]:
                            revert with 0, 50
                        mem[(32 * t) + _8466 + 32] = mem[(32 * s) + _10147 + 32]
                        if s >= mem[_10147 + 32]:
                            revert with 0, 50
                        if t >= mem[_8736]:
                            revert with 0, 50
                        mem[(32 * t) + _8736 + 32] = mem[(32 * s) + _10147 + 64]
                        if t == -1:
                            revert with 0, 17
                        if s == -1:
                            revert with 0, 17
                        _10448 = mem[_10147]
                        s = s + 1
                        t = t + 1
                        continue 
                else:
                    mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = arg1
                    mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    require ext_code.size(address(stor5[idx].field_256))
                    staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                            gas gas_remaining wei
                           args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _10308 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 64
                    _10328 = mem[_10308]
                    require mem[_10308] <= test266151307()
                    require _10308 + mem[_10308] + 31 < _10308 + return_data.size
                    _10345 = mem[_10308 + mem[_10308]]
                    if mem[_10308 + mem[_10308]] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[_10308 + mem[_10308]]) + 1 < 0 or _10308 + ceil32(return_data.size) + ceil32(32 * mem[_10308 + mem[_10308]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = _10308 + ceil32(return_data.size) + ceil32(32 * mem[_10308 + mem[_10308]]) + 1
                    mem[_10308 + ceil32(return_data.size)] = _10345
                    require _10328 + (32 * _10345) + 32 <= return_data.size
                    s = 0
                    t = _10308 + _10328 + 32
                    v = _10308 + ceil32(return_data.size) + 32
                    while s < _10345:
                        mem[v] = mem[t]
                        s = s + 1
                        t = t + 32
                        v = v + 32
                        continue 
                    _10512 = mem[_10308 + 32]
                    require mem[_10308 + 32] <= test266151307()
                    require _10308 + mem[_10308 + 32] + 31 < _10308 + return_data.size
                    _10589 = mem[_10308 + mem[_10308 + 32]]
                    if mem[_10308 + mem[_10308 + 32]] > test266151307():
                        revert with 0, 65
                    _10600 = mem[64]
                    if mem[64] + ceil32(32 * mem[_10308 + mem[_10308 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_10308 + mem[_10308 + 32]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = mem[64] + ceil32(32 * mem[_10308 + mem[_10308 + 32]]) + 1
                    mem[_10600] = _10589
                    require _10512 + (32 * _10589) + 32 <= return_data.size
                    s = 0
                    t = _10308 + _10512 + 32
                    v = _10600 + 32
                    while s < _10589:
                        mem[v] = mem[t]
                        s = s + 1
                        t = t + 32
                        v = v + 32
                        continue 
                    _10716 = mem[_10308 + ceil32(return_data.size)]
                    s = 0
                    t = u
                    while s < _10716:
                        if s >= mem[_10308 + ceil32(return_data.size)]:
                            revert with 0, 50
                        if t >= mem[_8466]:
                            revert with 0, 50
                        mem[(32 * t) + _8466 + 32] = mem[(32 * s) + _10308 + ceil32(return_data.size) + 32]
                        if s >= mem[_10600]:
                            revert with 0, 50
                        if t >= mem[_8736]:
                            revert with 0, 50
                        mem[(32 * t) + _8736 + 32] = mem[(32 * s) + _10600 + 32]
                        if t == -1:
                            revert with 0, 17
                        if s == -1:
                            revert with 0, 17
                        _10716 = mem[_10308 + ceil32(return_data.size)]
                        s = s + 1
                        t = t + 1
                        continue 
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            if s > !t:
                revert with 0, 17
            if u != s + t:
                revert with 0, 1
            if 0 >= stor9.length:
                revert with 0, 50
            mem[0] = arg1
            mem[32] = 1
            mem[mem[64]] = 0x15d2cfca00000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 64
            _10264 = mem[_8466]
            mem[mem[64] + 68] = mem[_8466]
            mem[mem[64] + 100 len 32 * _10264] = mem[_8466 + 32 len 32 * _10264]
            idx = _10264
            var69002 = _8466 + (32 * _10264) + 32
            mem[mem[64] + 36] = stor1[arg1].field_512
            require ext_code.size(address(stor9.field_0))
            staticcall address(stor9.field_0).0x15d2cfca with:
                    gas gas_remaining wei
                   args 64, stor1[arg1].field_512, mem[mem[64] + 68 len (32 * _10264) + 32]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _10588 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _10596 = mem[_10588]
            require mem[_10588] <= test266151307()
            require _10588 + mem[_10588] + 31 < _10588 + return_data.size
            _10604 = mem[_10588 + mem[_10588]]
            if mem[_10588 + mem[_10588]] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[_10588 + mem[_10588]]) + 1 < 0 or _10588 + ceil32(return_data.size) + ceil32(32 * mem[_10588 + mem[_10588]]) + 1 > test266151307():
                revert with 0, 65
            mem[64] = _10588 + ceil32(return_data.size) + ceil32(32 * mem[_10588 + mem[_10588]]) + 1
            mem[_10588 + ceil32(return_data.size)] = _10604
            require _10596 + (32 * _10604) + 32 <= return_data.size
            mem[_10588 + ceil32(return_data.size) + 32 len 32 * _10604] = mem[_10588 + _10596 + 32 len 32 * _10604]
            var88001 = _10604
            var88002 = _10588 + _10596 + (32 * _10604) + 32
            var88004 = _10588 + ceil32(return_data.size) + (32 * _10604) + 32
            mem[mem[64]] = 32
            mem[mem[64] + 32] = _10604
            mem[mem[64] + 64 len 32 * _10604] = mem[_10588 + ceil32(return_data.size) + 32 len 32 * _10604]
            var96001 = _10604
            var96002 = _10588 + ceil32(return_data.size) + (32 * _10604) + 32
            return Array(len=_10604, data=mem[mem[64] + 64 len 32 * _10604])
        mem[_8736 + 32 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
        _9383 = mem[mem[ceil32(return_data.size) + 160]]
        idx = 0
        u = 0
        while idx < _9383:
            mem[0] = arg1
            mem[32] = 1
            mem[mem[64] + 32] = idx
            mem[mem[64] + 64] = stor1[arg1].field_512
            mem[mem[64] + 96] = stor8
            _9457 = mem[64]
            mem[mem[64]] = 96
            mem[64] = mem[64] + 128
            if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                revert with 0, 50
            if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                revert with 0, 18
            if sha3(mem[_9457 + 32 len mem[_9457]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                if idx == -1:
                    revert with 0, 17
                _9383 = mem[mem[ceil32(return_data.size) + 160]]
                idx = idx + 1
                u = u
                continue 
            if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                revert with 0, 50
            if u >= mem[_8466]:
                revert with 0, 50
            mem[(32 * u) + _8466 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
            if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                revert with 0, 50
            if u >= mem[_8736]:
                revert with 0, 50
            mem[(32 * u) + _8736 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
            if u == -1:
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            _9383 = mem[mem[ceil32(return_data.size) + 160]]
            idx = idx + 1
            u = u + 1
            continue 
        idx = 0
        while idx < stor5.length:
            mem[0] = 5
            _10133 = mem[64]
            mem[64] = mem[64] + 64
            mem[_10133] = address(stor5[idx].field_0)
            mem[_10133 + 32] = address(stor5[idx].field_256)
            mem[0] = address(stor5[idx].field_0)
            mem[32] = sha3(arg1, 1) + 3
            if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                _10148 = mem[64]
                mem[mem[64]] = 0
                mem[mem[64] + 32] = 0
                mem[64] = mem[64] + 64
                _10449 = mem[_10148]
                s = 0
                t = u
                while s < _10449:
                    if s >= mem[_10148]:
                        revert with 0, 50
                    if t >= mem[_8466]:
                        revert with 0, 50
                    mem[(32 * t) + _8466 + 32] = mem[(32 * s) + _10148 + 32]
                    if s >= mem[_10148 + 32]:
                        revert with 0, 50
                    if t >= mem[_8736]:
                        revert with 0, 50
                    mem[(32 * t) + _8736 + 32] = mem[(32 * s) + _10148 + 64]
                    if t == -1:
                        revert with 0, 17
                    if s == -1:
                        revert with 0, 17
                    _10449 = mem[_10148]
                    s = s + 1
                    t = t + 1
                    continue 
            else:
                mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = arg1
                mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                require ext_code.size(address(stor5[idx].field_256))
                staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                        gas gas_remaining wei
                       args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _10311 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 64
                _10331 = mem[_10311]
                require mem[_10311] <= test266151307()
                require _10311 + mem[_10311] + 31 < _10311 + return_data.size
                _10347 = mem[_10311 + mem[_10311]]
                if mem[_10311 + mem[_10311]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_10311 + mem[_10311]]) + 1 < 0 or _10311 + ceil32(return_data.size) + ceil32(32 * mem[_10311 + mem[_10311]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _10311 + ceil32(return_data.size) + ceil32(32 * mem[_10311 + mem[_10311]]) + 1
                mem[_10311 + ceil32(return_data.size)] = _10347
                require _10331 + (32 * _10347) + 32 <= return_data.size
                s = 0
                t = _10311 + _10331 + 32
                v = _10311 + ceil32(return_data.size) + 32
                while s < _10347:
                    mem[v] = mem[t]
                    s = s + 1
                    t = t + 32
                    v = v + 32
                    continue 
                _10515 = mem[_10311 + 32]
                require mem[_10311 + 32] <= test266151307()
                require _10311 + mem[_10311 + 32] + 31 < _10311 + return_data.size
                _10591 = mem[_10311 + mem[_10311 + 32]]
                if mem[_10311 + mem[_10311 + 32]] > test266151307():
                    revert with 0, 65
                _10601 = mem[64]
                if mem[64] + ceil32(32 * mem[_10311 + mem[_10311 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_10311 + mem[_10311 + 32]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = mem[64] + ceil32(32 * mem[_10311 + mem[_10311 + 32]]) + 1
                mem[_10601] = _10591
                require _10515 + (32 * _10591) + 32 <= return_data.size
                s = 0
                t = _10311 + _10515 + 32
                v = _10601 + 32
                while s < _10591:
                    mem[v] = mem[t]
                    s = s + 1
                    t = t + 32
                    v = v + 32
                    continue 
                _10717 = mem[_10311 + ceil32(return_data.size)]
                s = 0
                t = u
                while s < _10717:
                    if s >= mem[_10311 + ceil32(return_data.size)]:
                        revert with 0, 50
                    if t >= mem[_8466]:
                        revert with 0, 50
                    mem[(32 * t) + _8466 + 32] = mem[(32 * s) + _10311 + ceil32(return_data.size) + 32]
                    if s >= mem[_10601]:
                        revert with 0, 50
                    if t >= mem[_8736]:
                        revert with 0, 50
                    mem[(32 * t) + _8736 + 32] = mem[(32 * s) + _10601 + 32]
                    if t == -1:
                        revert with 0, 17
                    if s == -1:
                        revert with 0, 17
                    _10717 = mem[_10311 + ceil32(return_data.size)]
                    s = s + 1
                    t = t + 1
                    continue 
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        if s > !t:
            revert with 0, 17
        if u != s + t:
            revert with 0, 1
        if 0 >= stor9.length:
            revert with 0, 50
        mem[0] = arg1
        mem[32] = 1
        mem[mem[64]] = 0x15d2cfca00000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = 64
        _10266 = mem[_8466]
        mem[mem[64] + 68] = mem[_8466]
        mem[mem[64] + 100 len 32 * _10266] = mem[_8466 + 32 len 32 * _10266]
        idx = _10266
        mem[mem[64] + 36] = stor1[arg1].field_512
        require ext_code.size(address(stor9.field_0))
        staticcall address(stor9.field_0).0x15d2cfca with:
                gas gas_remaining wei
               args 64, stor1[arg1].field_512, mem[mem[64] + 68 len (32 * _10266) + 32]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _10590 = mem[64]
        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _10597 = mem[_10590]
        require mem[_10590] <= test266151307()
        require _10590 + mem[_10590] + 31 < _10590 + return_data.size
        _10605 = mem[_10590 + mem[_10590]]
        if mem[_10590 + mem[_10590]] > test266151307():
            revert with 0, 65
        if ceil32(32 * mem[_10590 + mem[_10590]]) + 1 < 0 or _10590 + ceil32(return_data.size) + ceil32(32 * mem[_10590 + mem[_10590]]) + 1 > test266151307():
            revert with 0, 65
        mem[64] = _10590 + ceil32(return_data.size) + ceil32(32 * mem[_10590 + mem[_10590]]) + 1
        mem[_10590 + ceil32(return_data.size)] = _10605
        require _10597 + (32 * _10605) + 32 <= return_data.size
        mem[_10590 + ceil32(return_data.size) + 32 len 32 * _10605] = mem[_10590 + _10597 + 32 len 32 * _10605]
        var89001 = _10605
        var89002 = _10590 + _10597 + (32 * _10605) + 32
        var89004 = _10590 + ceil32(return_data.size) + (32 * _10605) + 32
        mem[mem[64]] = 32
        mem[mem[64] + 32] = _10605
        mem[mem[64] + 64 len 32 * _10605] = mem[_10590 + ceil32(return_data.size) + 32 len 32 * _10605]
        var97001 = _10605
        var97002 = _10590 + ceil32(return_data.size) + (32 * _10605) + 32
        return Array(len=_10605, data=mem[mem[64] + 64 len 32 * _10605])
    mem[mem[64] + 32 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
    if s > !t:
        revert with 0, 17
    if s + t > test266151307():
        revert with 0, 65
    mem[mem[64] + (32 * s + t) + 32] = s + t
    mem[64] = _8466 + (64 * s + t) + 64
    if not s + t:
        _9385 = mem[mem[ceil32(return_data.size) + 160]]
        idx = 0
        u = 0
        while idx < _9385:
            mem[0] = arg1
            mem[32] = 1
            mem[mem[64] + 32] = idx
            mem[mem[64] + 64] = stor1[arg1].field_512
            mem[mem[64] + 96] = stor8
            _9464 = mem[64]
            mem[mem[64]] = 96
            mem[64] = mem[64] + 128
            if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                revert with 0, 50
            if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                revert with 0, 18
            if sha3(mem[_9464 + 32 len mem[_9464]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                if idx == -1:
                    revert with 0, 17
                _9385 = mem[mem[ceil32(return_data.size) + 160]]
                idx = idx + 1
                u = u
                continue 
            if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                revert with 0, 50
            if u >= mem[_8466]:
                revert with 0, 50
            mem[(32 * u) + _8466 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
            if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                revert with 0, 50
            if u >= mem[_8466 + (32 * s + t) + 32]:
                revert with 0, 50
            mem[(32 * u) + _8466 + (32 * s + t) + 64] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
            if u == -1:
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            _9385 = mem[mem[ceil32(return_data.size) + 160]]
            idx = idx + 1
            u = u + 1
            continue 
        idx = 0
        while idx < stor5.length:
            mem[0] = 5
            _10138 = mem[64]
            mem[64] = mem[64] + 64
            mem[_10138] = address(stor5[idx].field_0)
            mem[_10138 + 32] = address(stor5[idx].field_256)
            mem[0] = address(stor5[idx].field_0)
            mem[32] = sha3(arg1, 1) + 3
            if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                _10149 = mem[64]
                mem[mem[64]] = 0
                mem[mem[64] + 32] = 0
                mem[64] = mem[64] + 64
                _10450 = mem[_10149]
                v = 0
                w = u
                while v < _10450:
                    if v >= mem[_10149]:
                        revert with 0, 50
                    if w >= mem[_8466]:
                        revert with 0, 50
                    mem[(32 * w) + _8466 + 32] = mem[(32 * v) + _10149 + 32]
                    if v >= mem[_10149 + 32]:
                        revert with 0, 50
                    if w >= mem[_8466 + (32 * s + t) + 32]:
                        revert with 0, 50
                    mem[(32 * w) + _8466 + (32 * s + t) + 64] = mem[(32 * v) + _10149 + 64]
                    if w == -1:
                        revert with 0, 17
                    if v == -1:
                        revert with 0, 17
                    _10450 = mem[_10149]
                    v = v + 1
                    w = w + 1
                    continue 
            else:
                mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = arg1
                mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                require ext_code.size(address(stor5[idx].field_256))
                staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                        gas gas_remaining wei
                       args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _10314 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 64
                _10334 = mem[_10314]
                require mem[_10314] <= test266151307()
                require _10314 + mem[_10314] + 31 < _10314 + return_data.size
                _10349 = mem[_10314 + mem[_10314]]
                if mem[_10314 + mem[_10314]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_10314 + mem[_10314]]) + 1 < 0 or _10314 + ceil32(return_data.size) + ceil32(32 * mem[_10314 + mem[_10314]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _10314 + ceil32(return_data.size) + ceil32(32 * mem[_10314 + mem[_10314]]) + 1
                mem[_10314 + ceil32(return_data.size)] = _10349
                require _10334 + (32 * _10349) + 32 <= return_data.size
                v = 0
                w = _10314 + _10334 + 32
                x = _10314 + ceil32(return_data.size) + 32
                while v < _10349:
                    mem[x] = mem[w]
                    v = v + 1
                    w = w + 32
                    x = x + 32
                    continue 
                _10518 = mem[_10314 + 32]
                require mem[_10314 + 32] <= test266151307()
                require _10314 + mem[_10314 + 32] + 31 < _10314 + return_data.size
                _10593 = mem[_10314 + mem[_10314 + 32]]
                if mem[_10314 + mem[_10314 + 32]] > test266151307():
                    revert with 0, 65
                _10602 = mem[64]
                if mem[64] + ceil32(32 * mem[_10314 + mem[_10314 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_10314 + mem[_10314 + 32]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = mem[64] + ceil32(32 * mem[_10314 + mem[_10314 + 32]]) + 1
                mem[_10602] = _10593
                require _10518 + (32 * _10593) + 32 <= return_data.size
                v = 0
                w = _10314 + _10518 + 32
                x = _10602 + 32
                while v < _10593:
                    mem[x] = mem[w]
                    v = v + 1
                    w = w + 32
                    x = x + 32
                    continue 
                _10718 = mem[_10314 + ceil32(return_data.size)]
                v = 0
                w = u
                while v < _10718:
                    if v >= mem[_10314 + ceil32(return_data.size)]:
                        revert with 0, 50
                    if w >= mem[_8466]:
                        revert with 0, 50
                    mem[(32 * w) + _8466 + 32] = mem[(32 * v) + _10314 + ceil32(return_data.size) + 32]
                    if v >= mem[_10602]:
                        revert with 0, 50
                    if w >= mem[_8466 + (32 * s + t) + 32]:
                        revert with 0, 50
                    mem[(32 * w) + _8466 + (32 * s + t) + 64] = mem[(32 * v) + _10602 + 32]
                    if w == -1:
                        revert with 0, 17
                    if v == -1:
                        revert with 0, 17
                    _10718 = mem[_10314 + ceil32(return_data.size)]
                    v = v + 1
                    w = w + 1
                    continue 
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        if s > !t:
            revert with 0, 17
        if u != s + t:
            revert with 0, 1
        if 0 >= stor9.length:
            revert with 0, 50
        mem[0] = arg1
        mem[32] = 1
        mem[mem[64]] = 0x15d2cfca00000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = 64
        _10268 = mem[_8466]
        mem[mem[64] + 68] = mem[_8466]
        mem[mem[64] + 100 len 32 * _10268] = mem[_8466 + 32 len 32 * _10268]
        idx = _10268
        mem[mem[64] + 36] = stor1[arg1].field_512
        require ext_code.size(address(stor9.field_0))
        staticcall address(stor9.field_0).0x15d2cfca with:
                gas gas_remaining wei
               args 64, stor1[arg1].field_512, mem[mem[64] + 68 len (32 * _10268) + 32]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _10592 = mem[64]
        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _10598 = mem[_10592]
        require mem[_10592] <= test266151307()
        require _10592 + mem[_10592] + 31 < _10592 + return_data.size
        _10606 = mem[_10592 + mem[_10592]]
        if mem[_10592 + mem[_10592]] > test266151307():
            revert with 0, 65
        if ceil32(32 * mem[_10592 + mem[_10592]]) + 1 < 0 or _10592 + ceil32(return_data.size) + ceil32(32 * mem[_10592 + mem[_10592]]) + 1 > test266151307():
            revert with 0, 65
        mem[64] = _10592 + ceil32(return_data.size) + ceil32(32 * mem[_10592 + mem[_10592]]) + 1
        mem[_10592 + ceil32(return_data.size)] = _10606
        require _10598 + (32 * _10606) + 32 <= return_data.size
        mem[_10592 + ceil32(return_data.size) + 32 len 32 * _10606] = mem[_10592 + _10598 + 32 len 32 * _10606]
        var89001 = _10606
        var89002 = _10592 + _10598 + (32 * _10606) + 32
        var89004 = _10592 + ceil32(return_data.size) + (32 * _10606) + 32
        mem[mem[64]] = 32
        mem[mem[64] + 32] = _10606
        mem[mem[64] + 64 len 32 * _10606] = mem[_10592 + ceil32(return_data.size) + 32 len 32 * _10606]
        var97001 = _10606
        var97002 = _10592 + ceil32(return_data.size) + (32 * _10606) + 32
        return Array(len=_10606, data=mem[mem[64] + 64 len 32 * _10606])
    mem[_8466 + (32 * s + t) + 64 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
    _9387 = mem[mem[ceil32(return_data.size) + 160]]
    idx = 0
    u = 0
    while idx < _9387:
        mem[0] = arg1
        mem[32] = 1
        mem[mem[64] + 32] = idx
        mem[mem[64] + 64] = stor1[arg1].field_512
        mem[mem[64] + 96] = stor8
        _9471 = mem[64]
        mem[mem[64]] = 96
        mem[64] = mem[64] + 128
        if idx >= mem[mem[ceil32(return_data.size) + 160]]:
            revert with 0, 50
        if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
            revert with 0, 18
        if sha3(mem[_9471 + 32 len mem[_9471]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
            if idx == -1:
                revert with 0, 17
            _9387 = mem[mem[ceil32(return_data.size) + 160]]
            idx = idx + 1
            u = u
            continue 
        if idx >= mem[mem[ceil32(return_data.size) + 96]]:
            revert with 0, 50
        if u >= mem[_8466]:
            revert with 0, 50
        mem[(32 * u) + _8466 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
        if idx >= mem[mem[ceil32(return_data.size) + 128]]:
            revert with 0, 50
        if u >= mem[_8466 + (32 * s + t) + 32]:
            revert with 0, 50
        mem[(32 * u) + _8466 + (32 * s + t) + 64] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
        if u == -1:
            revert with 0, 17
        if idx == -1:
            revert with 0, 17
        _9387 = mem[mem[ceil32(return_data.size) + 160]]
        idx = idx + 1
        u = u + 1
        continue 
    idx = 0
    while idx < stor5.length:
        mem[0] = 5
        _10143 = mem[64]
        mem[64] = mem[64] + 64
        mem[_10143] = address(stor5[idx].field_0)
        mem[_10143 + 32] = address(stor5[idx].field_256)
        mem[0] = address(stor5[idx].field_0)
        mem[32] = sha3(arg1, 1) + 3
        if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
            _10150 = mem[64]
            mem[mem[64]] = 0
            mem[mem[64] + 32] = 0
            mem[64] = mem[64] + 64
            _10451 = mem[_10150]
            v = 0
            w = u
            while v < _10451:
                if v >= mem[_10150]:
                    revert with 0, 50
                if w >= mem[_8466]:
                    revert with 0, 50
                mem[(32 * w) + _8466 + 32] = mem[(32 * v) + _10150 + 32]
                if v >= mem[_10150 + 32]:
                    revert with 0, 50
                if w >= mem[_8466 + (32 * s + t) + 32]:
                    revert with 0, 50
                mem[(32 * w) + _8466 + (32 * s + t) + 64] = mem[(32 * v) + _10150 + 64]
                if w == -1:
                    revert with 0, 17
                if v == -1:
                    revert with 0, 17
                _10451 = mem[_10150]
                v = v + 1
                w = w + 1
                continue 
        else:
            mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = arg1
            mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
            require ext_code.size(address(stor5[idx].field_256))
            staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                    gas gas_remaining wei
                   args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _10317 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 64
            _10337 = mem[_10317]
            require mem[_10317] <= test266151307()
            require _10317 + mem[_10317] + 31 < _10317 + return_data.size
            _10351 = mem[_10317 + mem[_10317]]
            if mem[_10317 + mem[_10317]] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[_10317 + mem[_10317]]) + 1 < 0 or _10317 + ceil32(return_data.size) + ceil32(32 * mem[_10317 + mem[_10317]]) + 1 > test266151307():
                revert with 0, 65
            mem[64] = _10317 + ceil32(return_data.size) + ceil32(32 * mem[_10317 + mem[_10317]]) + 1
            mem[_10317 + ceil32(return_data.size)] = _10351
            require _10337 + (32 * _10351) + 32 <= return_data.size
            v = 0
            w = _10317 + _10337 + 32
            x = _10317 + ceil32(return_data.size) + 32
            while v < _10351:
                mem[x] = mem[w]
                v = v + 1
                w = w + 32
                x = x + 32
                continue 
            _10521 = mem[_10317 + 32]
            require mem[_10317 + 32] <= test266151307()
            require _10317 + mem[_10317 + 32] + 31 < _10317 + return_data.size
            _10595 = mem[_10317 + mem[_10317 + 32]]
            if mem[_10317 + mem[_10317 + 32]] > test266151307():
                revert with 0, 65
            _10603 = mem[64]
            if mem[64] + ceil32(32 * mem[_10317 + mem[_10317 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_10317 + mem[_10317 + 32]]) + 1 > test266151307():
                revert with 0, 65
            mem[64] = mem[64] + ceil32(32 * mem[_10317 + mem[_10317 + 32]]) + 1
            mem[_10603] = _10595
            require _10521 + (32 * _10595) + 32 <= return_data.size
            v = 0
            w = _10317 + _10521 + 32
            x = _10603 + 32
            while v < _10595:
                mem[x] = mem[w]
                v = v + 1
                w = w + 32
                x = x + 32
                continue 
            _10719 = mem[_10317 + ceil32(return_data.size)]
            v = 0
            w = u
            while v < _10719:
                if v >= mem[_10317 + ceil32(return_data.size)]:
                    revert with 0, 50
                if w >= mem[_8466]:
                    revert with 0, 50
                mem[(32 * w) + _8466 + 32] = mem[(32 * v) + _10317 + ceil32(return_data.size) + 32]
                if v >= mem[_10603]:
                    revert with 0, 50
                if w >= mem[_8466 + (32 * s + t) + 32]:
                    revert with 0, 50
                mem[(32 * w) + _8466 + (32 * s + t) + 64] = mem[(32 * v) + _10603 + 32]
                if w == -1:
                    revert with 0, 17
                if v == -1:
                    revert with 0, 17
                _10719 = mem[_10317 + ceil32(return_data.size)]
                v = v + 1
                w = w + 1
                continue 
        if idx == -1:
            revert with 0, 17
        idx = idx + 1
        continue 
    if s > !t:
        revert with 0, 17
    if u != s + t:
        revert with 0, 1
    if 0 >= stor9.length:
        revert with 0, 50
    mem[0] = arg1
    mem[32] = 1
    mem[mem[64]] = 0x15d2cfca00000000000000000000000000000000000000000000000000000000
    mem[mem[64] + 4] = 64
    _10270 = mem[_8466]
    mem[mem[64] + 68] = mem[_8466]
    mem[mem[64] + 100 len 32 * _10270] = mem[_8466 + 32 len 32 * _10270]
    idx = _10270
    var71002 = _8466 + (32 * _10270) + 32
    mem[mem[64] + 36] = stor1[arg1].field_512
    require ext_code.size(address(stor9.field_0))
    staticcall address(stor9.field_0).0x15d2cfca with:
            gas gas_remaining wei
           args 64, stor1[arg1].field_512, mem[mem[64] + 68 len (32 * _10270) + 32]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _10594 = mem[64]
    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 32
    _10599 = mem[_10594]
    require mem[_10594] <= test266151307()
    require _10594 + mem[_10594] + 31 < _10594 + return_data.size
    _10607 = mem[_10594 + mem[_10594]]
    if mem[_10594 + mem[_10594]] > test266151307():
        revert with 0, 65
    if ceil32(32 * mem[_10594 + mem[_10594]]) + 1 < 0 or _10594 + ceil32(return_data.size) + ceil32(32 * mem[_10594 + mem[_10594]]) + 1 > test266151307():
        revert with 0, 65
    mem[64] = _10594 + ceil32(return_data.size) + ceil32(32 * mem[_10594 + mem[_10594]]) + 1
    mem[_10594 + ceil32(return_data.size)] = _10607
    require _10599 + (32 * _10607) + 32 <= return_data.size
    mem[_10594 + ceil32(return_data.size) + 32 len 32 * _10607] = mem[_10594 + _10599 + 32 len 32 * _10607]
    var90001 = _10607
    var90002 = _10594 + _10599 + (32 * _10607) + 32
    var90004 = _10594 + ceil32(return_data.size) + (32 * _10607) + 32
    mem[mem[64]] = 32
    mem[mem[64] + 32] = _10607
    mem[mem[64] + 64 len 32 * _10607] = mem[_10594 + ceil32(return_data.size) + 32 len 32 * _10607]
    var98001 = _10607
    var98002 = _10594 + ceil32(return_data.size) + (32 * _10607) + 32
    return Array(len=_10607, data=mem[mem[64] + 64 len 32 * _10607])
}

function sub_d29b478e(?) {
    require calldata.size - 4 >= 64
    require arg2 < stor5.length
    if not stor1[arg1].field_512:
        mem[96] = 0
        mem[128] = 0
        if arg2 >= stor5.length:
            revert with 0, 50
        mem[160] = address(stor5[arg2].field_0)
        mem[192] = address(stor5[arg2].field_256)
        mem[0] = address(stor5[arg2].field_0)
        if not stor1[arg1][3][address(stor5[arg2].field_0)].field_0:
            return ''
        if stor1[arg1][3][address(stor5[arg2].field_0)].field_0 < 1:
            revert with 0, 17
        mem[224] = 0x26148aa500000000000000000000000000000000000000000000000000000000
        mem[228] = 96
        mem[324] = 0
        mem[356 len 0] = None
        mem[260] = arg1
        mem[292] = stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1
        require ext_code.size(address(stor5[arg2].field_256))
        staticcall address(stor5[arg2].field_256).0x26148aa5 with:
                gas gas_remaining wei
               args 96, arg1, stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1, 0
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        mem[224 len return_data.size] = ext_call.return_data[0 len return_data.size]
        mem[64] = ceil32(return_data.size) + 224
        require return_data.size >= 32
        _167 = mem[224 len 4], 0
        require mem[224 len 4], 0 <= test266151307()
        require mem[224 len 4], 0 + 255 < return_data.size + 224
        _172 = mem[mem[224 len 4], 0 + 224]
        if mem[mem[224 len 4], 0 + 224] > test266151307():
            revert with 0, 65
        if ceil32(32 * mem[mem[224 len 4], 0 + 224]) + 1 < 0 or ceil32(return_data.size) + ceil32(32 * mem[mem[224 len 4], 0 + 224]) + 225 > test266151307():
            revert with 0, 65
        mem[64] = ceil32(return_data.size) + ceil32(32 * mem[mem[224 len 4], 0 + 224]) + 225
        mem[ceil32(return_data.size) + 224] = mem[mem[224 len 4], 0 + 224]
        require _167 + (32 * _172) + 32 <= return_data.size
        mem[ceil32(return_data.size) + 256 len 32 * _172] = mem[_167 + 256 len 32 * _172]
        mem[mem[64]] = 32
        mem[mem[64] + 32] = _172
        mem[mem[64] + 64 len 32 * _172] = mem[ceil32(return_data.size) + 256 len 32 * _172]
        return Array(len=_172, data=mem[mem[64] + 64 len 32 * _172])
    mem[100] = arg1
    require ext_code.size(stor11)
    staticcall stor11.0xe908c717 with:
            gas gas_remaining wei
           args arg1
    mem[96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[31 len 1]
    if ext_call.return_data[31 len 1] > 6:
        revert with 0, 33
    mem[0] = ext_call.return_data[31 len 1]
    mem[32] = 10
    mem[ceil32(return_data.size) + 192] = stor10[ext_call.return_data[31 len 1]].field_0
    if not stor10[ext_call.return_data[31 len 1]].field_0:
        mem[ceil32(return_data.size) + 96] = ceil32(return_data.size) + 192
        mem[ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + 224] = stor10[ext_call.return_data[31 len 1]].field_256
        if not stor10[ext_call.return_data[31 len 1]].field_256:
            mem[ceil32(return_data.size) + 128] = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + 224
            mem[64] = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + (32 * stor10[ext_call.return_data[31 len 1]].field_512) + 288
            mem[ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 256] = stor10[ext_call.return_data[31 len 1]].field_512
            if not stor10[ext_call.return_data[31 len 1]].field_512:
                mem[ceil32(return_data.size) + 160] = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 256
                idx = 0
                s = 0
                while idx < stor10[ext_call.return_data[31 len 1]].field_512:
                    mem[0] = arg1
                    mem[32] = 1
                    mem[mem[64] + 32] = idx
                    mem[mem[64] + 64] = stor1[arg1].field_512
                    mem[mem[64] + 96] = stor8
                    _149 = mem[64]
                    mem[mem[64]] = 96
                    mem[64] = mem[64] + 128
                    if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                        revert with 0, 50
                    if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        revert with 0, 18
                    if sha3(mem[_149 + 32 len mem[_149]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s
                        continue 
                    if s == -1:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + 1
                    continue 
                idx = 0
                t = 0
                while idx < stor5.length:
                    mem[0] = 5
                    _516 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_516] = address(stor5[idx].field_0)
                    mem[_516 + 32] = address(stor5[idx].field_256)
                    mem[0] = address(stor5[idx].field_0)
                    mem[32] = sha3(arg1, 1) + 3
                    if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                        _530 = mem[64]
                        mem[mem[64]] = 0
                        mem[mem[64] + 32] = 0
                        mem[64] = mem[64] + 64
                        if t > !mem[_530]:
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        t = t + mem[_530]
                        continue 
                    mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = arg1
                    mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    require ext_code.size(address(stor5[idx].field_256))
                    staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                            gas gas_remaining wei
                           args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _558 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 64
                    _570 = mem[_558]
                    require mem[_558] <= test266151307()
                    require _558 + mem[_558] + 31 < _558 + return_data.size
                    _619 = mem[_558 + mem[_558]]
                    if mem[_558 + mem[_558]] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[_558 + mem[_558]]) + 1 < 0 or _558 + ceil32(return_data.size) + ceil32(32 * mem[_558 + mem[_558]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = _558 + ceil32(return_data.size) + ceil32(32 * mem[_558 + mem[_558]]) + 1
                    mem[_558 + ceil32(return_data.size)] = _619
                    require _570 + (32 * _619) + 32 <= return_data.size
                    s = 0
                    u = _558 + _570 + 32
                    v = _558 + ceil32(return_data.size) + 32
                    while s < _619:
                        mem[v] = mem[u]
                        s = s + 1
                        u = u + 32
                        v = v + 32
                        continue 
                    _1204 = mem[_558 + 32]
                    require mem[_558 + 32] <= test266151307()
                    require _558 + mem[_558 + 32] + 31 < _558 + return_data.size
                    _1209 = mem[_558 + mem[_558 + 32]]
                    if mem[_558 + mem[_558 + 32]] > test266151307():
                        revert with 0, 65
                    _1307 = mem[64]
                    if mem[64] + ceil32(32 * mem[_558 + mem[_558 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_558 + mem[_558 + 32]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = mem[64] + ceil32(32 * mem[_558 + mem[_558 + 32]]) + 1
                    mem[_1307] = _1209
                    require _1204 + (32 * _1209) + 32 <= return_data.size
                    s = 0
                    u = _558 + _1204 + 32
                    v = _1307 + 32
                    while s < _1209:
                        mem[v] = mem[u]
                        s = s + 1
                        u = u + 32
                        v = v + 32
                        continue 
                    if t > !mem[_558 + ceil32(return_data.size)]:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    t = t + mem[_558 + ceil32(return_data.size)]
                    continue 
                if s > !t:
                    revert with 0, 17
                if s + t > test266151307():
                    revert with 0, 65
                _529 = mem[64]
                mem[mem[64]] = s + t
                if not s + t:
                    if s > !t:
                        revert with 0, 17
                    if s + t > test266151307():
                        revert with 0, 65
                    _557 = mem[64] + (32 * s + t) + 32
                    mem[mem[64] + (32 * s + t) + 32] = s + t
                    mem[64] = _557 + (32 * s + t) + 32
                    if not s + t:
                        _1136 = mem[mem[ceil32(return_data.size) + 160]]
                        idx = 0
                        u = 0
                        while idx < _1136:
                            mem[0] = arg1
                            mem[32] = 1
                            mem[mem[64] + 32] = idx
                            mem[mem[64] + 64] = stor1[arg1].field_512
                            mem[mem[64] + 96] = stor8
                            _1151 = mem[64]
                            mem[mem[64]] = 96
                            mem[64] = mem[64] + 128
                            if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                                revert with 0, 50
                            if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                                revert with 0, 18
                            if sha3(mem[_1151 + 32 len mem[_1151]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                u = u
                                continue 
                            if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                                revert with 0, 50
                            if u >= mem[_529]:
                                revert with 0, 50
                            mem[(32 * u) + _529 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                            if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                                revert with 0, 50
                            if u >= mem[_557]:
                                revert with 0, 50
                            mem[(32 * u) + _557 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                            if u == -1:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            u = u + 1
                            continue 
                        idx = 0
                        while idx < stor5.length:
                            mem[0] = 5
                            _2459 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2459] = address(stor5[idx].field_0)
                            mem[_2459 + 32] = address(stor5[idx].field_256)
                            mem[0] = address(stor5[idx].field_0)
                            mem[32] = sha3(arg1, 1) + 3
                            if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                                _2494 = mem[64]
                                mem[mem[64]] = 0
                                mem[mem[64] + 32] = 0
                                mem[64] = mem[64] + 64
                                _3929 = mem[_2494]
                                s = 0
                                t = u
                                while s < _3929:
                                    if s >= mem[_2494]:
                                        revert with 0, 50
                                    if t >= mem[_529]:
                                        revert with 0, 50
                                    mem[(32 * t) + _529 + 32] = mem[(32 * s) + _2494 + 32]
                                    if s >= mem[_2494 + 32]:
                                        revert with 0, 50
                                    if t >= mem[_557]:
                                        revert with 0, 50
                                    mem[(32 * t) + _557 + 32] = mem[(32 * s) + _2494 + 64]
                                    if t == -1:
                                        revert with 0, 17
                                    if s == -1:
                                        revert with 0, 17
                                    s = s + 1
                                    t = t + 1
                                    continue 
                            else:
                                mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = arg1
                                mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                                require ext_code.size(address(stor5[idx].field_256))
                                staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                                        gas gas_remaining wei
                                       args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _2587 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 64
                                _2629 = mem[_2587]
                                require mem[_2587] <= test266151307()
                                require _2587 + mem[_2587] + 31 < _2587 + return_data.size
                                _2755 = mem[_2587 + mem[_2587]]
                                if mem[_2587 + mem[_2587]] > test266151307():
                                    revert with 0, 65
                                if ceil32(32 * mem[_2587 + mem[_2587]]) + 1 < 0 or _2587 + ceil32(return_data.size) + ceil32(32 * mem[_2587 + mem[_2587]]) + 1 > test266151307():
                                    revert with 0, 65
                                mem[64] = _2587 + ceil32(return_data.size) + ceil32(32 * mem[_2587 + mem[_2587]]) + 1
                                mem[_2587 + ceil32(return_data.size)] = _2755
                                require _2629 + (32 * _2755) + 32 <= return_data.size
                                s = 0
                                t = _2587 + _2629 + 32
                                v = _2587 + ceil32(return_data.size) + 32
                                while s < _2755:
                                    mem[v] = mem[t]
                                    s = s + 1
                                    t = t + 32
                                    v = v + 32
                                    continue 
                                _4087 = mem[_2587 + 32]
                                require mem[_2587 + 32] <= test266151307()
                                require _2587 + mem[_2587 + 32] + 31 < _2587 + return_data.size
                                _4138 = mem[_2587 + mem[_2587 + 32]]
                                if mem[_2587 + mem[_2587 + 32]] > test266151307():
                                    revert with 0, 65
                                _4317 = mem[64]
                                if mem[64] + ceil32(32 * mem[_2587 + mem[_2587 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_2587 + mem[_2587 + 32]]) + 1 > test266151307():
                                    revert with 0, 65
                                mem[64] = mem[64] + ceil32(32 * mem[_2587 + mem[_2587 + 32]]) + 1
                                mem[_4317] = _4138
                                require _4087 + (32 * _4138) + 32 <= return_data.size
                                s = 0
                                t = _2587 + _4087 + 32
                                v = _4317 + 32
                                while s < _4138:
                                    mem[v] = mem[t]
                                    s = s + 1
                                    t = t + 32
                                    v = v + 32
                                    continue 
                                _7743 = mem[_2587 + ceil32(return_data.size)]
                                s = 0
                                t = u
                                while s < _7743:
                                    if s >= mem[_2587 + ceil32(return_data.size)]:
                                        revert with 0, 50
                                    if t >= mem[_529]:
                                        revert with 0, 50
                                    mem[(32 * t) + _529 + 32] = mem[(32 * s) + _2587 + ceil32(return_data.size) + 32]
                                    if s >= mem[_4317]:
                                        revert with 0, 50
                                    if t >= mem[_557]:
                                        revert with 0, 50
                                    mem[(32 * t) + _557 + 32] = mem[(32 * s) + _4317 + 32]
                                    if t == -1:
                                        revert with 0, 17
                                    if s == -1:
                                        revert with 0, 17
                                    _7743 = mem[_2587 + ceil32(return_data.size)]
                                    s = s + 1
                                    t = t + 1
                                    continue 
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            continue 
                        if s > !t:
                            revert with 0, 17
                        if u != s + t:
                            revert with 0, 1
                        if arg2 >= stor5.length:
                            revert with 0, 50
                        mem[0] = 5
                        _2506 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2506] = address(stor5[arg2].field_0)
                        mem[_2506 + 32] = address(stor5[arg2].field_256)
                        mem[0] = address(stor5[arg2].field_0)
                        mem[32] = sha3(arg1, 1) + 3
                        if not stor1[arg1][3][address(stor5[arg2].field_0)].field_0:
                            _2539 = mem[64]
                            mem[64] = mem[64] + 32
                            mem[_2539 + 32] = 32
                            mem[_2539 + 64] = mem[_2539]
                            mem[_2539 + 96 len 32 * mem[_2539]] = mem[_2539 + 32 len 32 * mem[_2539]]
                            return memory
                              from mem[64]
                               len _2539 + (32 * mem[_2539]) + -mem[64] + 96
                        if stor1[arg1][3][address(stor5[arg2].field_0)].field_0 < 1:
                            revert with 0, 17
                        mem[mem[64]] = 0x26148aa500000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 96
                        _2656 = mem[_529]
                        mem[mem[64] + 100] = mem[_529]
                        mem[mem[64] + 132 len 32 * _2656] = mem[_529 + 32 len 32 * _2656]
                        mem[mem[64] + 36] = arg1
                        mem[mem[64] + 68] = stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1
                        require ext_code.size(address(stor5[arg2].field_256))
                        staticcall address(stor5[arg2].field_256).0x26148aa5 with:
                                gas gas_remaining wei
                               args 96, arg1, stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1, mem[mem[64] + 100 len (32 * _2656) + 32]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _4137 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _4247 = mem[_4137]
                        require mem[_4137] <= test266151307()
                        require _4137 + mem[_4137] + 31 < _4137 + return_data.size
                        _4411 = mem[_4137 + mem[_4137]]
                        if mem[_4137 + mem[_4137]] > test266151307():
                            revert with 0, 65
                        if ceil32(32 * mem[_4137 + mem[_4137]]) + 1 < 0 or _4137 + ceil32(return_data.size) + ceil32(32 * mem[_4137 + mem[_4137]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = _4137 + ceil32(return_data.size) + ceil32(32 * mem[_4137 + mem[_4137]]) + 1
                        mem[_4137 + ceil32(return_data.size)] = _4411
                        require _4247 + (32 * _4411) + 32 <= return_data.size
                        mem[_4137 + ceil32(return_data.size) + 32 len 32 * _4411] = mem[_4137 + _4247 + 32 len 32 * _4411]
                        mem[mem[64]] = 32
                        mem[mem[64] + 32] = _4411
                        mem[mem[64] + 64 len 32 * _4411] = mem[_4137 + ceil32(return_data.size) + 32 len 32 * _4411]
                        return Array(len=_4411, data=mem[mem[64] + 64 len 32 * _4411])
                    mem[_557 + 32 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
                    _1138 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = 0
                    u = 0
                    while idx < _1138:
                        mem[0] = arg1
                        mem[32] = 1
                        mem[mem[64] + 32] = idx
                        mem[mem[64] + 64] = stor1[arg1].field_512
                        mem[mem[64] + 96] = stor8
                        _1158 = mem[64]
                        mem[mem[64]] = 96
                        mem[64] = mem[64] + 128
                        if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                            revert with 0, 50
                        if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                            revert with 0, 18
                        if sha3(mem[_1158 + 32 len mem[_1158]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            u = u
                            continue 
                        if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                            revert with 0, 50
                        if u >= mem[_529]:
                            revert with 0, 50
                        mem[(32 * u) + _529 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                        if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                            revert with 0, 50
                        if u >= mem[_557]:
                            revert with 0, 50
                        mem[(32 * u) + _557 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                        if u == -1:
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        u = u + 1
                        continue 
                    idx = 0
                    while idx < stor5.length:
                        mem[0] = 5
                        _2464 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2464] = address(stor5[idx].field_0)
                        mem[_2464 + 32] = address(stor5[idx].field_256)
                        mem[0] = address(stor5[idx].field_0)
                        mem[32] = sha3(arg1, 1) + 3
                        if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                            _2495 = mem[64]
                            mem[mem[64]] = 0
                            mem[mem[64] + 32] = 0
                            mem[64] = mem[64] + 64
                            _3930 = mem[_2495]
                            s = 0
                            t = u
                            while s < _3930:
                                if s >= mem[_2495]:
                                    revert with 0, 50
                                if t >= mem[_529]:
                                    revert with 0, 50
                                mem[(32 * t) + _529 + 32] = mem[(32 * s) + _2495 + 32]
                                if s >= mem[_2495 + 32]:
                                    revert with 0, 50
                                if t >= mem[_557]:
                                    revert with 0, 50
                                mem[(32 * t) + _557 + 32] = mem[(32 * s) + _2495 + 64]
                                if t == -1:
                                    revert with 0, 17
                                if s == -1:
                                    revert with 0, 17
                                s = s + 1
                                t = t + 1
                                continue 
                        else:
                            mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = arg1
                            mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                            require ext_code.size(address(stor5[idx].field_256))
                            staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                                    gas gas_remaining wei
                                   args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2591 = mem[64]
                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 64
                            _2633 = mem[_2591]
                            require mem[_2591] <= test266151307()
                            require _2591 + mem[_2591] + 31 < _2591 + return_data.size
                            _2757 = mem[_2591 + mem[_2591]]
                            if mem[_2591 + mem[_2591]] > test266151307():
                                revert with 0, 65
                            if ceil32(32 * mem[_2591 + mem[_2591]]) + 1 < 0 or _2591 + ceil32(return_data.size) + ceil32(32 * mem[_2591 + mem[_2591]]) + 1 > test266151307():
                                revert with 0, 65
                            mem[64] = _2591 + ceil32(return_data.size) + ceil32(32 * mem[_2591 + mem[_2591]]) + 1
                            mem[_2591 + ceil32(return_data.size)] = _2757
                            require _2633 + (32 * _2757) + 32 <= return_data.size
                            s = 0
                            t = _2591 + _2633 + 32
                            v = _2591 + ceil32(return_data.size) + 32
                            while s < _2757:
                                mem[v] = mem[t]
                                s = s + 1
                                t = t + 32
                                v = v + 32
                                continue 
                            _4090 = mem[_2591 + 32]
                            require mem[_2591 + 32] <= test266151307()
                            require _2591 + mem[_2591 + 32] + 31 < _2591 + return_data.size
                            _4140 = mem[_2591 + mem[_2591 + 32]]
                            if mem[_2591 + mem[_2591 + 32]] > test266151307():
                                revert with 0, 65
                            _4318 = mem[64]
                            if mem[64] + ceil32(32 * mem[_2591 + mem[_2591 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_2591 + mem[_2591 + 32]]) + 1 > test266151307():
                                revert with 0, 65
                            mem[64] = mem[64] + ceil32(32 * mem[_2591 + mem[_2591 + 32]]) + 1
                            mem[_4318] = _4140
                            require _4090 + (32 * _4140) + 32 <= return_data.size
                            s = 0
                            t = _2591 + _4090 + 32
                            v = _4318 + 32
                            while s < _4140:
                                mem[v] = mem[t]
                                s = s + 1
                                t = t + 32
                                v = v + 32
                                continue 
                            _7744 = mem[_2591 + ceil32(return_data.size)]
                            s = 0
                            t = u
                            while s < _7744:
                                if s >= mem[_2591 + ceil32(return_data.size)]:
                                    revert with 0, 50
                                if t >= mem[_529]:
                                    revert with 0, 50
                                mem[(32 * t) + _529 + 32] = mem[(32 * s) + _2591 + ceil32(return_data.size) + 32]
                                if s >= mem[_4318]:
                                    revert with 0, 50
                                if t >= mem[_557]:
                                    revert with 0, 50
                                mem[(32 * t) + _557 + 32] = mem[(32 * s) + _4318 + 32]
                                if t == -1:
                                    revert with 0, 17
                                if s == -1:
                                    revert with 0, 17
                                _7744 = mem[_2591 + ceil32(return_data.size)]
                                s = s + 1
                                t = t + 1
                                continue 
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
                    if s > !t:
                        revert with 0, 17
                    if u != s + t:
                        revert with 0, 1
                    if arg2 >= stor5.length:
                        revert with 0, 50
                    mem[0] = 5
                    _2511 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2511] = address(stor5[arg2].field_0)
                    mem[_2511 + 32] = address(stor5[arg2].field_256)
                    mem[0] = address(stor5[arg2].field_0)
                    mem[32] = sha3(arg1, 1) + 3
                    if not stor1[arg1][3][address(stor5[arg2].field_0)].field_0:
                        _2545 = mem[64]
                        mem[64] = mem[64] + 32
                        mem[_2545 + 32] = 32
                        mem[_2545 + 64] = mem[_2545]
                        mem[_2545 + 96 len 32 * mem[_2545]] = mem[_2545 + 32 len 32 * mem[_2545]]
                        return memory
                          from mem[64]
                           len _2545 + (32 * mem[_2545]) + -mem[64] + 96
                    if stor1[arg1][3][address(stor5[arg2].field_0)].field_0 < 1:
                        revert with 0, 17
                    mem[mem[64]] = 0x26148aa500000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 96
                    _2657 = mem[_529]
                    mem[mem[64] + 100] = mem[_529]
                    mem[mem[64] + 132 len 32 * _2657] = mem[_529 + 32 len 32 * _2657]
                    mem[mem[64] + 36] = arg1
                    mem[mem[64] + 68] = stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1
                    require ext_code.size(address(stor5[arg2].field_256))
                    staticcall address(stor5[arg2].field_256).0x26148aa5 with:
                            gas gas_remaining wei
                           args 96, arg1, stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1, mem[mem[64] + 100 len (32 * _2657) + 32]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _4139 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _4248 = mem[_4139]
                    require mem[_4139] <= test266151307()
                    require _4139 + mem[_4139] + 31 < _4139 + return_data.size
                    _4412 = mem[_4139 + mem[_4139]]
                    if mem[_4139 + mem[_4139]] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[_4139 + mem[_4139]]) + 1 < 0 or _4139 + ceil32(return_data.size) + ceil32(32 * mem[_4139 + mem[_4139]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = _4139 + ceil32(return_data.size) + ceil32(32 * mem[_4139 + mem[_4139]]) + 1
                    mem[_4139 + ceil32(return_data.size)] = _4412
                    require _4248 + (32 * _4412) + 32 <= return_data.size
                    mem[_4139 + ceil32(return_data.size) + 32 len 32 * _4412] = mem[_4139 + _4248 + 32 len 32 * _4412]
                    mem[mem[64]] = 32
                    mem[mem[64] + 32] = _4412
                    mem[mem[64] + 64 len 32 * _4412] = mem[_4139 + ceil32(return_data.size) + 32 len 32 * _4412]
                    return Array(len=_4412, data=mem[mem[64] + 64 len 32 * _4412])
                mem[mem[64] + 32 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
                if s > !t:
                    revert with 0, 17
                if s + t > test266151307():
                    revert with 0, 65
                mem[mem[64] + (32 * s + t) + 32] = s + t
                mem[64] = _529 + (64 * s + t) + 64
                if not s + t:
                    _1140 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = 0
                    u = 0
                    while idx < _1140:
                        mem[0] = arg1
                        mem[32] = 1
                        mem[mem[64] + 32] = idx
                        mem[mem[64] + 64] = stor1[arg1].field_512
                        mem[mem[64] + 96] = stor8
                        _1165 = mem[64]
                        mem[mem[64]] = 96
                        mem[64] = mem[64] + 128
                        if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                            revert with 0, 50
                        if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                            revert with 0, 18
                        if sha3(mem[_1165 + 32 len mem[_1165]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            u = u
                            continue 
                        if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                            revert with 0, 50
                        if u >= mem[_529]:
                            revert with 0, 50
                        mem[(32 * u) + _529 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                        if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                            revert with 0, 50
                        if u >= mem[_529 + (32 * s + t) + 32]:
                            revert with 0, 50
                        mem[(32 * u) + _529 + (32 * s + t) + 64] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                        if u == -1:
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        u = u + 1
                        continue 
                    idx = 0
                    while idx < stor5.length:
                        mem[0] = 5
                        _2469 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2469] = address(stor5[idx].field_0)
                        mem[_2469 + 32] = address(stor5[idx].field_256)
                        mem[0] = address(stor5[idx].field_0)
                        mem[32] = sha3(arg1, 1) + 3
                        if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                            _2496 = mem[64]
                            mem[mem[64]] = 0
                            mem[mem[64] + 32] = 0
                            mem[64] = mem[64] + 64
                            _3931 = mem[_2496]
                            v = 0
                            w = u
                            while v < _3931:
                                if v >= mem[_2496]:
                                    revert with 0, 50
                                if w >= mem[_529]:
                                    revert with 0, 50
                                mem[(32 * w) + _529 + 32] = mem[(32 * v) + _2496 + 32]
                                if v >= mem[_2496 + 32]:
                                    revert with 0, 50
                                if w >= mem[_529 + (32 * s + t) + 32]:
                                    revert with 0, 50
                                mem[(32 * w) + _529 + (32 * s + t) + 64] = mem[(32 * v) + _2496 + 64]
                                if w == -1:
                                    revert with 0, 17
                                if v == -1:
                                    revert with 0, 17
                                v = v + 1
                                w = w + 1
                                continue 
                        else:
                            mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = arg1
                            mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                            require ext_code.size(address(stor5[idx].field_256))
                            staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                                    gas gas_remaining wei
                                   args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2595 = mem[64]
                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 64
                            _2637 = mem[_2595]
                            require mem[_2595] <= test266151307()
                            require _2595 + mem[_2595] + 31 < _2595 + return_data.size
                            _2759 = mem[_2595 + mem[_2595]]
                            if mem[_2595 + mem[_2595]] > test266151307():
                                revert with 0, 65
                            if ceil32(32 * mem[_2595 + mem[_2595]]) + 1 < 0 or _2595 + ceil32(return_data.size) + ceil32(32 * mem[_2595 + mem[_2595]]) + 1 > test266151307():
                                revert with 0, 65
                            mem[64] = _2595 + ceil32(return_data.size) + ceil32(32 * mem[_2595 + mem[_2595]]) + 1
                            mem[_2595 + ceil32(return_data.size)] = _2759
                            require _2637 + (32 * _2759) + 32 <= return_data.size
                            v = 0
                            w = _2595 + _2637 + 32
                            x = _2595 + ceil32(return_data.size) + 32
                            while v < _2759:
                                mem[x] = mem[w]
                                v = v + 1
                                w = w + 32
                                x = x + 32
                                continue 
                            _4093 = mem[_2595 + 32]
                            require mem[_2595 + 32] <= test266151307()
                            require _2595 + mem[_2595 + 32] + 31 < _2595 + return_data.size
                            _4142 = mem[_2595 + mem[_2595 + 32]]
                            if mem[_2595 + mem[_2595 + 32]] > test266151307():
                                revert with 0, 65
                            _4319 = mem[64]
                            if mem[64] + ceil32(32 * mem[_2595 + mem[_2595 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_2595 + mem[_2595 + 32]]) + 1 > test266151307():
                                revert with 0, 65
                            mem[64] = mem[64] + ceil32(32 * mem[_2595 + mem[_2595 + 32]]) + 1
                            mem[_4319] = _4142
                            require _4093 + (32 * _4142) + 32 <= return_data.size
                            v = 0
                            w = _2595 + _4093 + 32
                            x = _4319 + 32
                            while v < _4142:
                                mem[x] = mem[w]
                                v = v + 1
                                w = w + 32
                                x = x + 32
                                continue 
                            _7745 = mem[_2595 + ceil32(return_data.size)]
                            v = 0
                            w = u
                            while v < _7745:
                                if v >= mem[_2595 + ceil32(return_data.size)]:
                                    revert with 0, 50
                                if w >= mem[_529]:
                                    revert with 0, 50
                                mem[(32 * w) + _529 + 32] = mem[(32 * v) + _2595 + ceil32(return_data.size) + 32]
                                if v >= mem[_4319]:
                                    revert with 0, 50
                                if w >= mem[_529 + (32 * s + t) + 32]:
                                    revert with 0, 50
                                mem[(32 * w) + _529 + (32 * s + t) + 64] = mem[(32 * v) + _4319 + 32]
                                if w == -1:
                                    revert with 0, 17
                                if v == -1:
                                    revert with 0, 17
                                _7745 = mem[_2595 + ceil32(return_data.size)]
                                v = v + 1
                                w = w + 1
                                continue 
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
                    if s > !t:
                        revert with 0, 17
                    if u != s + t:
                        revert with 0, 1
                    if arg2 >= stor5.length:
                        revert with 0, 50
                    mem[0] = 5
                    _2516 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2516] = address(stor5[arg2].field_0)
                    mem[_2516 + 32] = address(stor5[arg2].field_256)
                    mem[0] = address(stor5[arg2].field_0)
                    mem[32] = sha3(arg1, 1) + 3
                    if not stor1[arg1][3][address(stor5[arg2].field_0)].field_0:
                        _2551 = mem[64]
                        mem[64] = mem[64] + 32
                        mem[_2551 + 32] = 32
                        mem[_2551 + 64] = mem[_2551]
                        mem[_2551 + 96 len 32 * mem[_2551]] = mem[_2551 + 32 len 32 * mem[_2551]]
                        return memory
                          from mem[64]
                           len _2551 + (32 * mem[_2551]) + -mem[64] + 96
                    if stor1[arg1][3][address(stor5[arg2].field_0)].field_0 < 1:
                        revert with 0, 17
                    mem[mem[64]] = 0x26148aa500000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 96
                    _2658 = mem[_529]
                    mem[mem[64] + 100] = mem[_529]
                    mem[mem[64] + 132 len 32 * _2658] = mem[_529 + 32 len 32 * _2658]
                    mem[mem[64] + 36] = arg1
                    mem[mem[64] + 68] = stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1
                    require ext_code.size(address(stor5[arg2].field_256))
                    staticcall address(stor5[arg2].field_256).0x26148aa5 with:
                            gas gas_remaining wei
                           args 96, arg1, stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1, mem[mem[64] + 100 len (32 * _2658) + 32]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _4141 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _4249 = mem[_4141]
                    require mem[_4141] <= test266151307()
                    require _4141 + mem[_4141] + 31 < _4141 + return_data.size
                    _4413 = mem[_4141 + mem[_4141]]
                    if mem[_4141 + mem[_4141]] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[_4141 + mem[_4141]]) + 1 < 0 or _4141 + ceil32(return_data.size) + ceil32(32 * mem[_4141 + mem[_4141]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = _4141 + ceil32(return_data.size) + ceil32(32 * mem[_4141 + mem[_4141]]) + 1
                    mem[_4141 + ceil32(return_data.size)] = _4413
                    require _4249 + (32 * _4413) + 32 <= return_data.size
                    mem[_4141 + ceil32(return_data.size) + 32 len 32 * _4413] = mem[_4141 + _4249 + 32 len 32 * _4413]
                    mem[mem[64]] = 32
                    mem[mem[64] + 32] = _4413
                    mem[mem[64] + 64 len 32 * _4413] = mem[_4141 + ceil32(return_data.size) + 32 len 32 * _4413]
                    return Array(len=_4413, data=mem[mem[64] + 64 len 32 * _4413])
                mem[_529 + (32 * s + t) + 64 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
                _1142 = mem[mem[ceil32(return_data.size) + 160]]
                idx = 0
                u = 0
                while idx < _1142:
                    mem[0] = arg1
                    mem[32] = 1
                    mem[mem[64] + 32] = idx
                    mem[mem[64] + 64] = stor1[arg1].field_512
                    mem[mem[64] + 96] = stor8
                    _1172 = mem[64]
                    mem[mem[64]] = 96
                    mem[64] = mem[64] + 128
                    if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                        revert with 0, 50
                    if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        revert with 0, 18
                    if sha3(mem[_1172 + 32 len mem[_1172]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        u = u
                        continue 
                    if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                        revert with 0, 50
                    if u >= mem[_529]:
                        revert with 0, 50
                    mem[(32 * u) + _529 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                    if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                        revert with 0, 50
                    if u >= mem[_529 + (32 * s + t) + 32]:
                        revert with 0, 50
                    mem[(32 * u) + _529 + (32 * s + t) + 64] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                    if u == -1:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    u = u + 1
                    continue 
                idx = 0
                while idx < stor5.length:
                    mem[0] = 5
                    _2474 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2474] = address(stor5[idx].field_0)
                    mem[_2474 + 32] = address(stor5[idx].field_256)
                    mem[0] = address(stor5[idx].field_0)
                    mem[32] = sha3(arg1, 1) + 3
                    if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                        _2497 = mem[64]
                        mem[mem[64]] = 0
                        mem[mem[64] + 32] = 0
                        mem[64] = mem[64] + 64
                        _3932 = mem[_2497]
                        v = 0
                        w = u
                        while v < _3932:
                            if v >= mem[_2497]:
                                revert with 0, 50
                            if w >= mem[_529]:
                                revert with 0, 50
                            mem[(32 * w) + _529 + 32] = mem[(32 * v) + _2497 + 32]
                            if v >= mem[_2497 + 32]:
                                revert with 0, 50
                            if w >= mem[_529 + (32 * s + t) + 32]:
                                revert with 0, 50
                            mem[(32 * w) + _529 + (32 * s + t) + 64] = mem[(32 * v) + _2497 + 64]
                            if w == -1:
                                revert with 0, 17
                            if v == -1:
                                revert with 0, 17
                            v = v + 1
                            w = w + 1
                            continue 
                    else:
                        mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = arg1
                        mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                        require ext_code.size(address(stor5[idx].field_256))
                        staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                                gas gas_remaining wei
                               args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2599 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 64
                        _2641 = mem[_2599]
                        require mem[_2599] <= test266151307()
                        require _2599 + mem[_2599] + 31 < _2599 + return_data.size
                        _2761 = mem[_2599 + mem[_2599]]
                        if mem[_2599 + mem[_2599]] > test266151307():
                            revert with 0, 65
                        if ceil32(32 * mem[_2599 + mem[_2599]]) + 1 < 0 or _2599 + ceil32(return_data.size) + ceil32(32 * mem[_2599 + mem[_2599]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = _2599 + ceil32(return_data.size) + ceil32(32 * mem[_2599 + mem[_2599]]) + 1
                        mem[_2599 + ceil32(return_data.size)] = _2761
                        require _2641 + (32 * _2761) + 32 <= return_data.size
                        v = 0
                        w = _2599 + _2641 + 32
                        x = _2599 + ceil32(return_data.size) + 32
                        while v < _2761:
                            mem[x] = mem[w]
                            v = v + 1
                            w = w + 32
                            x = x + 32
                            continue 
                        _4096 = mem[_2599 + 32]
                        require mem[_2599 + 32] <= test266151307()
                        require _2599 + mem[_2599 + 32] + 31 < _2599 + return_data.size
                        _4144 = mem[_2599 + mem[_2599 + 32]]
                        if mem[_2599 + mem[_2599 + 32]] > test266151307():
                            revert with 0, 65
                        _4320 = mem[64]
                        if mem[64] + ceil32(32 * mem[_2599 + mem[_2599 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_2599 + mem[_2599 + 32]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = mem[64] + ceil32(32 * mem[_2599 + mem[_2599 + 32]]) + 1
                        mem[_4320] = _4144
                        require _4096 + (32 * _4144) + 32 <= return_data.size
                        v = 0
                        w = _2599 + _4096 + 32
                        x = _4320 + 32
                        while v < _4144:
                            mem[x] = mem[w]
                            v = v + 1
                            w = w + 32
                            x = x + 32
                            continue 
                        _7746 = mem[_2599 + ceil32(return_data.size)]
                        v = 0
                        w = u
                        while v < _7746:
                            if v >= mem[_2599 + ceil32(return_data.size)]:
                                revert with 0, 50
                            if w >= mem[_529]:
                                revert with 0, 50
                            mem[(32 * w) + _529 + 32] = mem[(32 * v) + _2599 + ceil32(return_data.size) + 32]
                            if v >= mem[_4320]:
                                revert with 0, 50
                            if w >= mem[_529 + (32 * s + t) + 32]:
                                revert with 0, 50
                            mem[(32 * w) + _529 + (32 * s + t) + 64] = mem[(32 * v) + _4320 + 32]
                            if w == -1:
                                revert with 0, 17
                            if v == -1:
                                revert with 0, 17
                            _7746 = mem[_2599 + ceil32(return_data.size)]
                            v = v + 1
                            w = w + 1
                            continue 
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                if s > !t:
                    revert with 0, 17
                if u != s + t:
                    revert with 0, 1
                if arg2 >= stor5.length:
                    revert with 0, 50
                mem[0] = 5
                _2521 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2521] = address(stor5[arg2].field_0)
                mem[_2521 + 32] = address(stor5[arg2].field_256)
                mem[0] = address(stor5[arg2].field_0)
                mem[32] = sha3(arg1, 1) + 3
                if not stor1[arg1][3][address(stor5[arg2].field_0)].field_0:
                    _2557 = mem[64]
                    mem[64] = mem[64] + 32
                    mem[_2557 + 32] = 32
                    mem[_2557 + 64] = mem[_2557]
                    mem[_2557 + 96 len 32 * mem[_2557]] = mem[_2557 + 32 len 32 * mem[_2557]]
                    return memory
                      from mem[64]
                       len _2557 + (32 * mem[_2557]) + -mem[64] + 96
                if stor1[arg1][3][address(stor5[arg2].field_0)].field_0 < 1:
                    revert with 0, 17
                mem[mem[64]] = 0x26148aa500000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 96
                _2659 = mem[_529]
                mem[mem[64] + 100] = mem[_529]
                mem[mem[64] + 132 len 32 * _2659] = mem[_529 + 32 len 32 * _2659]
                mem[mem[64] + 36] = arg1
                mem[mem[64] + 68] = stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1
                require ext_code.size(address(stor5[arg2].field_256))
                staticcall address(stor5[arg2].field_256).0x26148aa5 with:
                        gas gas_remaining wei
                       args 96, arg1, stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1, mem[mem[64] + 100 len (32 * _2659) + 32]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _4143 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _4250 = mem[_4143]
                require mem[_4143] <= test266151307()
                require _4143 + mem[_4143] + 31 < _4143 + return_data.size
                _4414 = mem[_4143 + mem[_4143]]
                if mem[_4143 + mem[_4143]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_4143 + mem[_4143]]) + 1 < 0 or _4143 + ceil32(return_data.size) + ceil32(32 * mem[_4143 + mem[_4143]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _4143 + ceil32(return_data.size) + ceil32(32 * mem[_4143 + mem[_4143]]) + 1
                mem[_4143 + ceil32(return_data.size)] = _4414
                require _4250 + (32 * _4414) + 32 <= return_data.size
                mem[_4143 + ceil32(return_data.size) + 32 len 32 * _4414] = mem[_4143 + _4250 + 32 len 32 * _4414]
                mem[mem[64]] = 32
                mem[mem[64] + 32] = _4414
                mem[mem[64] + 64 len 32 * _4414] = mem[_4143 + ceil32(return_data.size) + 32 len 32 * _4414]
                return Array(len=_4414, data=mem[mem[64] + 64 len 32 * _4414])
            mem[0] = sha3(ext_call.return_data[31 len 1], 10) + 2
            mem[ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 288] = stor10[ext_call.return_data[31 len 1]][2].field_0
            idx = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 288
            s = 0
            while ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + (32 * stor10[ext_call.return_data[31 len 1]].field_512) + 256 > idx:
                mem[idx + 32] = stor10[ext_call.return_data[31 len 1]][s + 2].field_256
                idx = idx + 32
                s = s + 1
                continue 
            mem[ceil32(return_data.size) + 160] = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 256
            idx = 0
            s = 0
            while idx < stor10[ext_call.return_data[31 len 1]].field_512:
                mem[0] = arg1
                mem[32] = 1
                mem[mem[64] + 32] = idx
                mem[mem[64] + 64] = stor1[arg1].field_512
                mem[mem[64] + 96] = stor8
                _1180 = mem[64]
                mem[mem[64]] = 96
                mem[64] = mem[64] + 128
                if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                    revert with 0, 50
                if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    revert with 0, 18
                if sha3(mem[_1180 + 32 len mem[_1180]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s
                    continue 
                if s == -1:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s + 1
                continue 
            idx = 0
            t = 0
            while idx < stor5.length:
                mem[0] = 5
                _2479 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2479] = address(stor5[idx].field_0)
                mem[_2479 + 32] = address(stor5[idx].field_256)
                mem[0] = address(stor5[idx].field_0)
                mem[32] = sha3(arg1, 1) + 3
                if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                    _2500 = mem[64]
                    mem[mem[64]] = 0
                    mem[mem[64] + 32] = 0
                    mem[64] = mem[64] + 64
                    if t > !mem[_2500]:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    t = t + mem[_2500]
                    continue 
                mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = arg1
                mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                require ext_code.size(address(stor5[idx].field_256))
                staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                        gas gas_remaining wei
                       args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _2603 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 64
                _2646 = mem[_2603]
                require mem[_2603] <= test266151307()
                require _2603 + mem[_2603] + 31 < _2603 + return_data.size
                _2771 = mem[_2603 + mem[_2603]]
                if mem[_2603 + mem[_2603]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_2603 + mem[_2603]]) + 1 < 0 or _2603 + ceil32(return_data.size) + ceil32(32 * mem[_2603 + mem[_2603]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _2603 + ceil32(return_data.size) + ceil32(32 * mem[_2603 + mem[_2603]]) + 1
                mem[_2603 + ceil32(return_data.size)] = _2771
                require _2646 + (32 * _2771) + 32 <= return_data.size
                s = 0
                u = _2603 + _2646 + 32
                v = _2603 + ceil32(return_data.size) + 32
                while s < _2771:
                    mem[v] = mem[u]
                    s = s + 1
                    u = u + 32
                    v = v + 32
                    continue 
                _4103 = mem[_2603 + 32]
                require mem[_2603 + 32] <= test266151307()
                require _2603 + mem[_2603 + 32] + 31 < _2603 + return_data.size
                _4145 = mem[_2603 + mem[_2603 + 32]]
                if mem[_2603 + mem[_2603 + 32]] > test266151307():
                    revert with 0, 65
                _4349 = mem[64]
                if mem[64] + ceil32(32 * mem[_2603 + mem[_2603 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_2603 + mem[_2603 + 32]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = mem[64] + ceil32(32 * mem[_2603 + mem[_2603 + 32]]) + 1
                mem[_4349] = _4145
                require _4103 + (32 * _4145) + 32 <= return_data.size
                s = 0
                u = _2603 + _4103 + 32
                v = _4349 + 32
                while s < _4145:
                    mem[v] = mem[u]
                    s = s + 1
                    u = u + 32
                    v = v + 32
                    continue 
                if t > !mem[_2603 + ceil32(return_data.size)]:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                t = t + mem[_2603 + ceil32(return_data.size)]
                continue 
            if s > !t:
                revert with 0, 17
            if s + t > test266151307():
                revert with 0, 65
            _2499 = mem[64]
            mem[mem[64]] = s + t
            if s + t:
                mem[mem[64] + 32 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
                if s > !t:
                    revert with 0, 17
                if s + t > test266151307():
                    revert with 0, 65
                mem[mem[64] + (32 * s + t) + 32] = s + t
                mem[64] = _2499 + (64 * s + t) + 64
                if not s + t:
                    _3938 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = 0
                    u = 0
                    while idx < _3938:
                        mem[0] = arg1
                        mem[32] = 1
                        mem[mem[64] + 32] = idx
                        mem[mem[64] + 64] = stor1[arg1].field_512
                        mem[mem[64] + 96] = stor8
                        _3995 = mem[64]
                        mem[mem[64]] = 96
                        mem[64] = mem[64] + 128
                        if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                            revert with 0, 50
                        if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                            revert with 0, 18
                        if sha3(mem[_3995 + 32 len mem[_3995]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                            if idx == -1:
                                revert with 0, 17
                            _3938 = mem[mem[ceil32(return_data.size) + 160]]
                            idx = idx + 1
                            u = u
                            continue 
                        if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                            revert with 0, 50
                        if u >= mem[_2499]:
                            revert with 0, 50
                        mem[(32 * u) + _2499 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                        if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                            revert with 0, 50
                        if u >= mem[_2499 + (32 * s + t) + 32]:
                            revert with 0, 50
                        mem[(32 * u) + _2499 + (32 * s + t) + 64] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                        if u == -1:
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        _3938 = mem[mem[ceil32(return_data.size) + 160]]
                        idx = idx + 1
                        u = u + 1
                        continue 
                    idx = 0
                    while idx < stor5.length:
                        mem[0] = 5
                        _5986 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5986] = address(stor5[idx].field_0)
                        mem[_5986 + 32] = address(stor5[idx].field_256)
                        mem[0] = address(stor5[idx].field_0)
                        mem[32] = sha3(arg1, 1) + 3
                        if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                            _6052 = mem[64]
                            mem[mem[64]] = 0
                            mem[mem[64] + 32] = 0
                            mem[64] = mem[64] + 64
                            _7749 = mem[_6052]
                            v = 0
                            w = u
                            while v < _7749:
                                if v >= mem[_6052]:
                                    revert with 0, 50
                                if w >= mem[_2499]:
                                    revert with 0, 50
                                mem[(32 * w) + _2499 + 32] = mem[(32 * v) + _6052 + 32]
                                if v >= mem[_6052 + 32]:
                                    revert with 0, 50
                                if w >= mem[_2499 + (32 * s + t) + 32]:
                                    revert with 0, 50
                                mem[(32 * w) + _2499 + (32 * s + t) + 64] = mem[(32 * v) + _6052 + 64]
                                if w == -1:
                                    revert with 0, 17
                                if v == -1:
                                    revert with 0, 17
                                _7749 = mem[_6052]
                                v = v + 1
                                w = w + 1
                                continue 
                        else:
                            mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = arg1
                            mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                            require ext_code.size(address(stor5[idx].field_256))
                            staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                                    gas gas_remaining wei
                                   args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _6283 = mem[64]
                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 64
                            _6368 = mem[_6283]
                            require mem[_6283] <= test266151307()
                            require _6283 + mem[_6283] + 31 < _6283 + return_data.size
                            _6531 = mem[_6283 + mem[_6283]]
                            if mem[_6283 + mem[_6283]] > test266151307():
                                revert with 0, 65
                            if ceil32(32 * mem[_6283 + mem[_6283]]) + 1 < 0 or _6283 + ceil32(return_data.size) + ceil32(32 * mem[_6283 + mem[_6283]]) + 1 > test266151307():
                                revert with 0, 65
                            mem[64] = _6283 + ceil32(return_data.size) + ceil32(32 * mem[_6283 + mem[_6283]]) + 1
                            mem[_6283 + ceil32(return_data.size)] = _6531
                            require _6368 + (32 * _6531) + 32 <= return_data.size
                            v = 0
                            w = _6283 + _6368 + 32
                            x = _6283 + ceil32(return_data.size) + 32
                            while v < _6531:
                                mem[x] = mem[w]
                                v = v + 1
                                w = w + 32
                                x = x + 32
                                continue 
                            _7949 = mem[_6283 + 32]
                            require mem[_6283 + 32] <= test266151307()
                            require _6283 + mem[_6283 + 32] + 31 < _6283 + return_data.size
                            _8076 = mem[_6283 + mem[_6283 + 32]]
                            if mem[_6283 + mem[_6283 + 32]] > test266151307():
                                revert with 0, 65
                            _8263 = mem[64]
                            if mem[64] + ceil32(32 * mem[_6283 + mem[_6283 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_6283 + mem[_6283 + 32]]) + 1 > test266151307():
                                revert with 0, 65
                            mem[64] = mem[64] + ceil32(32 * mem[_6283 + mem[_6283 + 32]]) + 1
                            mem[_8263] = _8076
                            require _7949 + (32 * _8076) + 32 <= return_data.size
                            v = 0
                            w = _6283 + _7949 + 32
                            x = _8263 + 32
                            while v < _8076:
                                mem[x] = mem[w]
                                v = v + 1
                                w = w + 32
                                x = x + 32
                                continue 
                            _10553 = mem[_6283 + ceil32(return_data.size)]
                            v = 0
                            w = u
                            while v < _10553:
                                if v >= mem[_6283 + ceil32(return_data.size)]:
                                    revert with 0, 50
                                if w >= mem[_2499]:
                                    revert with 0, 50
                                mem[(32 * w) + _2499 + 32] = mem[(32 * v) + _6283 + ceil32(return_data.size) + 32]
                                if v >= mem[_8263]:
                                    revert with 0, 50
                                if w >= mem[_2499 + (32 * s + t) + 32]:
                                    revert with 0, 50
                                mem[(32 * w) + _2499 + (32 * s + t) + 64] = mem[(32 * v) + _8263 + 32]
                                if w == -1:
                                    revert with 0, 17
                                if v == -1:
                                    revert with 0, 17
                                _10553 = mem[_6283 + ceil32(return_data.size)]
                                v = v + 1
                                w = w + 1
                                continue 
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
                    if s > !t:
                        revert with 0, 17
                    if u != s + t:
                        revert with 0, 1
                    if arg2 >= stor5.length:
                        revert with 0, 50
                    mem[0] = 5
                    _6094 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_6094] = address(stor5[arg2].field_0)
                    mem[_6094 + 32] = address(stor5[arg2].field_256)
                    mem[0] = address(stor5[arg2].field_0)
                    mem[32] = sha3(arg1, 1) + 3
                    if not stor1[arg1][3][address(stor5[arg2].field_0)].field_0:
                        _6176 = mem[64]
                        mem[64] = mem[64] + 32
                        mem[_6176 + 32] = 32
                        mem[_6176 + 64] = mem[_6176]
                        mem[_6176 + 96 len 32 * mem[_6176]] = mem[_6176 + 32 len 32 * mem[_6176]]
                        var66001 = mem[_6176]
                        var66002 = _6176 + (32 * mem[_6176]) + 32
                        return memory
                          from mem[64]
                           len _6176 + (32 * mem[_6176]) + -mem[64] + 96
                    if stor1[arg1][3][address(stor5[arg2].field_0)].field_0 < 1:
                        revert with 0, 17
                    mem[mem[64]] = 0x26148aa500000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 96
                    _6418 = mem[_2499]
                    mem[mem[64] + 100] = mem[_2499]
                    mem[mem[64] + 132 len 32 * _6418] = mem[_2499 + 32 len 32 * _6418]
                    mem[mem[64] + 36] = arg1
                    mem[mem[64] + 68] = stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1
                    require ext_code.size(address(stor5[arg2].field_256))
                    staticcall address(stor5[arg2].field_256).0x26148aa5 with:
                            gas gas_remaining wei
                           args 96, arg1, stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1, mem[mem[64] + 100 len (32 * _6418) + 32]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _8075 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _8189 = mem[_8075]
                    require mem[_8075] <= test266151307()
                    require _8075 + mem[_8075] + 31 < _8075 + return_data.size
                    _8363 = mem[_8075 + mem[_8075]]
                    if mem[_8075 + mem[_8075]] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[_8075 + mem[_8075]]) + 1 < 0 or _8075 + ceil32(return_data.size) + ceil32(32 * mem[_8075 + mem[_8075]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = _8075 + ceil32(return_data.size) + ceil32(32 * mem[_8075 + mem[_8075]]) + 1
                    mem[_8075 + ceil32(return_data.size)] = _8363
                    require _8189 + (32 * _8363) + 32 <= return_data.size
                    mem[_8075 + ceil32(return_data.size) + 32 len 32 * _8363] = mem[_8075 + _8189 + 32 len 32 * _8363]
                    mem[mem[64]] = 32
                    mem[mem[64] + 32] = _8363
                    mem[mem[64] + 64 len 32 * _8363] = mem[_8075 + ceil32(return_data.size) + 32 len 32 * _8363]
                    return Array(len=_8363, data=mem[mem[64] + 64 len 32 * _8363])
                mem[_2499 + (32 * s + t) + 64 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
                _3940 = mem[mem[ceil32(return_data.size) + 160]]
                idx = 0
                u = 0
                while idx < _3940:
                    mem[0] = arg1
                    mem[32] = 1
                    mem[mem[64] + 32] = idx
                    mem[mem[64] + 64] = stor1[arg1].field_512
                    mem[mem[64] + 96] = stor8
                    _4002 = mem[64]
                    mem[mem[64]] = 96
                    mem[64] = mem[64] + 128
                    if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                        revert with 0, 50
                    if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        revert with 0, 18
                    if sha3(mem[_4002 + 32 len mem[_4002]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        if idx == -1:
                            revert with 0, 17
                        _3940 = mem[mem[ceil32(return_data.size) + 160]]
                        idx = idx + 1
                        u = u
                        continue 
                    if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                        revert with 0, 50
                    if u >= mem[_2499]:
                        revert with 0, 50
                    mem[(32 * u) + _2499 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                    if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                        revert with 0, 50
                    if u >= mem[_2499 + (32 * s + t) + 32]:
                        revert with 0, 50
                    mem[(32 * u) + _2499 + (32 * s + t) + 64] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                    if u == -1:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _3940 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = idx + 1
                    u = u + 1
                    continue 
                idx = 0
                while idx < stor5.length:
                    mem[0] = 5
                    _5991 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5991] = address(stor5[idx].field_0)
                    mem[_5991 + 32] = address(stor5[idx].field_256)
                    mem[0] = address(stor5[idx].field_0)
                    mem[32] = sha3(arg1, 1) + 3
                    if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                        _6053 = mem[64]
                        mem[mem[64]] = 0
                        mem[mem[64] + 32] = 0
                        mem[64] = mem[64] + 64
                        _7750 = mem[_6053]
                        v = 0
                        w = u
                        while v < _7750:
                            if v >= mem[_6053]:
                                revert with 0, 50
                            if w >= mem[_2499]:
                                revert with 0, 50
                            mem[(32 * w) + _2499 + 32] = mem[(32 * v) + _6053 + 32]
                            if v >= mem[_6053 + 32]:
                                revert with 0, 50
                            if w >= mem[_2499 + (32 * s + t) + 32]:
                                revert with 0, 50
                            mem[(32 * w) + _2499 + (32 * s + t) + 64] = mem[(32 * v) + _6053 + 64]
                            if w == -1:
                                revert with 0, 17
                            if v == -1:
                                revert with 0, 17
                            _7750 = mem[_6053]
                            v = v + 1
                            w = w + 1
                            continue 
                    else:
                        mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = arg1
                        mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                        require ext_code.size(address(stor5[idx].field_256))
                        staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                                gas gas_remaining wei
                               args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _6287 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 64
                        _6372 = mem[_6287]
                        require mem[_6287] <= test266151307()
                        require _6287 + mem[_6287] + 31 < _6287 + return_data.size
                        _6533 = mem[_6287 + mem[_6287]]
                        if mem[_6287 + mem[_6287]] > test266151307():
                            revert with 0, 65
                        if ceil32(32 * mem[_6287 + mem[_6287]]) + 1 < 0 or _6287 + ceil32(return_data.size) + ceil32(32 * mem[_6287 + mem[_6287]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = _6287 + ceil32(return_data.size) + ceil32(32 * mem[_6287 + mem[_6287]]) + 1
                        mem[_6287 + ceil32(return_data.size)] = _6533
                        require _6372 + (32 * _6533) + 32 <= return_data.size
                        v = 0
                        w = _6287 + _6372 + 32
                        x = _6287 + ceil32(return_data.size) + 32
                        while v < _6533:
                            mem[x] = mem[w]
                            v = v + 1
                            w = w + 32
                            x = x + 32
                            continue 
                        _7952 = mem[_6287 + 32]
                        require mem[_6287 + 32] <= test266151307()
                        require _6287 + mem[_6287 + 32] + 31 < _6287 + return_data.size
                        _8078 = mem[_6287 + mem[_6287 + 32]]
                        if mem[_6287 + mem[_6287 + 32]] > test266151307():
                            revert with 0, 65
                        _8264 = mem[64]
                        if mem[64] + ceil32(32 * mem[_6287 + mem[_6287 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_6287 + mem[_6287 + 32]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = mem[64] + ceil32(32 * mem[_6287 + mem[_6287 + 32]]) + 1
                        mem[_8264] = _8078
                        require _7952 + (32 * _8078) + 32 <= return_data.size
                        v = 0
                        w = _6287 + _7952 + 32
                        x = _8264 + 32
                        while v < _8078:
                            mem[x] = mem[w]
                            v = v + 1
                            w = w + 32
                            x = x + 32
                            continue 
                        _10554 = mem[_6287 + ceil32(return_data.size)]
                        v = 0
                        w = u
                        while v < _10554:
                            if v >= mem[_6287 + ceil32(return_data.size)]:
                                revert with 0, 50
                            if w >= mem[_2499]:
                                revert with 0, 50
                            mem[(32 * w) + _2499 + 32] = mem[(32 * v) + _6287 + ceil32(return_data.size) + 32]
                            if v >= mem[_8264]:
                                revert with 0, 50
                            if w >= mem[_2499 + (32 * s + t) + 32]:
                                revert with 0, 50
                            mem[(32 * w) + _2499 + (32 * s + t) + 64] = mem[(32 * v) + _8264 + 32]
                            if w == -1:
                                revert with 0, 17
                            if v == -1:
                                revert with 0, 17
                            _10554 = mem[_6287 + ceil32(return_data.size)]
                            v = v + 1
                            w = w + 1
                            continue 
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                if s > !t:
                    revert with 0, 17
                if u != s + t:
                    revert with 0, 1
                if arg2 >= stor5.length:
                    revert with 0, 50
                mem[0] = 5
                _6099 = mem[64]
                mem[64] = mem[64] + 64
                mem[_6099] = address(stor5[arg2].field_0)
                mem[_6099 + 32] = address(stor5[arg2].field_256)
                mem[0] = address(stor5[arg2].field_0)
                mem[32] = sha3(arg1, 1) + 3
                if not stor1[arg1][3][address(stor5[arg2].field_0)].field_0:
                    _6182 = mem[64]
                    mem[64] = mem[64] + 32
                    mem[_6182 + 32] = 32
                    mem[_6182 + 64] = mem[_6182]
                    mem[_6182 + 96 len 32 * mem[_6182]] = mem[_6182 + 32 len 32 * mem[_6182]]
                    return memory
                      from mem[64]
                       len _6182 + (32 * mem[_6182]) + -mem[64] + 96
                if stor1[arg1][3][address(stor5[arg2].field_0)].field_0 < 1:
                    revert with 0, 17
                mem[mem[64]] = 0x26148aa500000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 96
                _6419 = mem[_2499]
                mem[mem[64] + 100] = mem[_2499]
                mem[mem[64] + 132 len 32 * _6419] = mem[_2499 + 32 len 32 * _6419]
                mem[mem[64] + 36] = arg1
                mem[mem[64] + 68] = stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1
                require ext_code.size(address(stor5[arg2].field_256))
                staticcall address(stor5[arg2].field_256).0x26148aa5 with:
                        gas gas_remaining wei
                       args 96, arg1, stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1, mem[mem[64] + 100 len (32 * _6419) + 32]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _8077 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _8190 = mem[_8077]
                require mem[_8077] <= test266151307()
                require _8077 + mem[_8077] + 31 < _8077 + return_data.size
                _8364 = mem[_8077 + mem[_8077]]
                if mem[_8077 + mem[_8077]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_8077 + mem[_8077]]) + 1 < 0 or _8077 + ceil32(return_data.size) + ceil32(32 * mem[_8077 + mem[_8077]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _8077 + ceil32(return_data.size) + ceil32(32 * mem[_8077 + mem[_8077]]) + 1
                mem[_8077 + ceil32(return_data.size)] = _8364
                require _8190 + (32 * _8364) + 32 <= return_data.size
                mem[_8077 + ceil32(return_data.size) + 32 len 32 * _8364] = mem[_8077 + _8190 + 32 len 32 * _8364]
                mem[mem[64]] = 32
                mem[mem[64] + 32] = _8364
                mem[mem[64] + 64 len 32 * _8364] = mem[_8077 + ceil32(return_data.size) + 32 len 32 * _8364]
                return Array(len=_8364, data=mem[mem[64] + 64 len 32 * _8364])
            if s > !t:
                revert with 0, 17
            if s + t > test266151307():
                revert with 0, 65
            _2602 = mem[64] + (32 * s + t) + 32
            mem[mem[64] + (32 * s + t) + 32] = s + t
            mem[64] = _2602 + (32 * s + t) + 32
            if s + t:
                mem[_2602 + 32 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
                _3936 = mem[mem[ceil32(return_data.size) + 160]]
                idx = 0
                u = 0
                while idx < _3936:
                    mem[0] = arg1
                    mem[32] = 1
                    mem[mem[64] + 32] = idx
                    mem[mem[64] + 64] = stor1[arg1].field_512
                    mem[mem[64] + 96] = stor8
                    _3988 = mem[64]
                    mem[mem[64]] = 96
                    mem[64] = mem[64] + 128
                    if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                        revert with 0, 50
                    if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        revert with 0, 18
                    if sha3(mem[_3988 + 32 len mem[_3988]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        if idx == -1:
                            revert with 0, 17
                        _3936 = mem[mem[ceil32(return_data.size) + 160]]
                        idx = idx + 1
                        u = u
                        continue 
                    if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                        revert with 0, 50
                    if u >= mem[_2499]:
                        revert with 0, 50
                    mem[(32 * u) + _2499 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                    if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                        revert with 0, 50
                    if u >= mem[_2602]:
                        revert with 0, 50
                    mem[(32 * u) + _2602 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                    if u == -1:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _3936 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = idx + 1
                    u = u + 1
                    continue 
                idx = 0
                while idx < stor5.length:
                    mem[0] = 5
                    _5981 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5981] = address(stor5[idx].field_0)
                    mem[_5981 + 32] = address(stor5[idx].field_256)
                    mem[0] = address(stor5[idx].field_0)
                    mem[32] = sha3(arg1, 1) + 3
                    if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                        _6051 = mem[64]
                        mem[mem[64]] = 0
                        mem[mem[64] + 32] = 0
                        mem[64] = mem[64] + 64
                        _7748 = mem[_6051]
                        s = 0
                        t = u
                        while s < _7748:
                            if s >= mem[_6051]:
                                revert with 0, 50
                            if t >= mem[_2499]:
                                revert with 0, 50
                            mem[(32 * t) + _2499 + 32] = mem[(32 * s) + _6051 + 32]
                            if s >= mem[_6051 + 32]:
                                revert with 0, 50
                            if t >= mem[_2602]:
                                revert with 0, 50
                            mem[(32 * t) + _2602 + 32] = mem[(32 * s) + _6051 + 64]
                            if t == -1:
                                revert with 0, 17
                            if s == -1:
                                revert with 0, 17
                            _7748 = mem[_6051]
                            s = s + 1
                            t = t + 1
                            continue 
                    else:
                        mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = arg1
                        mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                        require ext_code.size(address(stor5[idx].field_256))
                        staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                                gas gas_remaining wei
                               args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _6279 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 64
                        _6364 = mem[_6279]
                        require mem[_6279] <= test266151307()
                        require _6279 + mem[_6279] + 31 < _6279 + return_data.size
                        _6529 = mem[_6279 + mem[_6279]]
                        if mem[_6279 + mem[_6279]] > test266151307():
                            revert with 0, 65
                        if ceil32(32 * mem[_6279 + mem[_6279]]) + 1 < 0 or _6279 + ceil32(return_data.size) + ceil32(32 * mem[_6279 + mem[_6279]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = _6279 + ceil32(return_data.size) + ceil32(32 * mem[_6279 + mem[_6279]]) + 1
                        mem[_6279 + ceil32(return_data.size)] = _6529
                        require _6364 + (32 * _6529) + 32 <= return_data.size
                        s = 0
                        t = _6279 + _6364 + 32
                        v = _6279 + ceil32(return_data.size) + 32
                        while s < _6529:
                            mem[v] = mem[t]
                            s = s + 1
                            t = t + 32
                            v = v + 32
                            continue 
                        _7946 = mem[_6279 + 32]
                        require mem[_6279 + 32] <= test266151307()
                        require _6279 + mem[_6279 + 32] + 31 < _6279 + return_data.size
                        _8074 = mem[_6279 + mem[_6279 + 32]]
                        if mem[_6279 + mem[_6279 + 32]] > test266151307():
                            revert with 0, 65
                        _8262 = mem[64]
                        if mem[64] + ceil32(32 * mem[_6279 + mem[_6279 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_6279 + mem[_6279 + 32]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = mem[64] + ceil32(32 * mem[_6279 + mem[_6279 + 32]]) + 1
                        mem[_8262] = _8074
                        require _7946 + (32 * _8074) + 32 <= return_data.size
                        s = 0
                        t = _6279 + _7946 + 32
                        v = _8262 + 32
                        while s < _8074:
                            mem[v] = mem[t]
                            s = s + 1
                            t = t + 32
                            v = v + 32
                            continue 
                        _10552 = mem[_6279 + ceil32(return_data.size)]
                        s = 0
                        t = u
                        while s < _10552:
                            if s >= mem[_6279 + ceil32(return_data.size)]:
                                revert with 0, 50
                            if t >= mem[_2499]:
                                revert with 0, 50
                            mem[(32 * t) + _2499 + 32] = mem[(32 * s) + _6279 + ceil32(return_data.size) + 32]
                            if s >= mem[_8262]:
                                revert with 0, 50
                            if t >= mem[_2602]:
                                revert with 0, 50
                            mem[(32 * t) + _2602 + 32] = mem[(32 * s) + _8262 + 32]
                            if t == -1:
                                revert with 0, 17
                            if s == -1:
                                revert with 0, 17
                            _10552 = mem[_6279 + ceil32(return_data.size)]
                            s = s + 1
                            t = t + 1
                            continue 
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                if s > !t:
                    revert with 0, 17
                if u != s + t:
                    revert with 0, 1
                if arg2 >= stor5.length:
                    revert with 0, 50
                mem[0] = 5
                _6089 = mem[64]
                mem[64] = mem[64] + 64
                mem[_6089] = address(stor5[arg2].field_0)
                mem[_6089 + 32] = address(stor5[arg2].field_256)
                mem[0] = address(stor5[arg2].field_0)
                mem[32] = sha3(arg1, 1) + 3
                if not stor1[arg1][3][address(stor5[arg2].field_0)].field_0:
                    _6170 = mem[64]
                    mem[64] = mem[64] + 32
                    mem[_6170 + 32] = 32
                    mem[_6170 + 64] = mem[_6170]
                    mem[_6170 + 96 len 32 * mem[_6170]] = mem[_6170 + 32 len 32 * mem[_6170]]
                    var66001 = mem[_6170]
                    var66002 = _6170 + (32 * mem[_6170]) + 32
                    return memory
                      from mem[64]
                       len _6170 + (32 * mem[_6170]) + -mem[64] + 96
                if stor1[arg1][3][address(stor5[arg2].field_0)].field_0 < 1:
                    revert with 0, 17
                mem[mem[64]] = 0x26148aa500000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 96
                _6417 = mem[_2499]
                mem[mem[64] + 100] = mem[_2499]
                mem[mem[64] + 132 len 32 * _6417] = mem[_2499 + 32 len 32 * _6417]
                mem[mem[64] + 36] = arg1
                mem[mem[64] + 68] = stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1
                require ext_code.size(address(stor5[arg2].field_256))
                staticcall address(stor5[arg2].field_256).0x26148aa5 with:
                        gas gas_remaining wei
                       args 96, arg1, stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1, mem[mem[64] + 100 len (32 * _6417) + 32]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _8073 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _8188 = mem[_8073]
                require mem[_8073] <= test266151307()
                require _8073 + mem[_8073] + 31 < _8073 + return_data.size
                _8362 = mem[_8073 + mem[_8073]]
                if mem[_8073 + mem[_8073]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_8073 + mem[_8073]]) + 1 < 0 or _8073 + ceil32(return_data.size) + ceil32(32 * mem[_8073 + mem[_8073]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _8073 + ceil32(return_data.size) + ceil32(32 * mem[_8073 + mem[_8073]]) + 1
                mem[_8073 + ceil32(return_data.size)] = _8362
                require _8188 + (32 * _8362) + 32 <= return_data.size
                mem[_8073 + ceil32(return_data.size) + 32 len 32 * _8362] = mem[_8073 + _8188 + 32 len 32 * _8362]
                mem[mem[64]] = 32
                mem[mem[64] + 32] = _8362
                mem[mem[64] + 64 len 32 * _8362] = mem[_8073 + ceil32(return_data.size) + 32 len 32 * _8362]
                return Array(len=_8362, data=mem[mem[64] + 64 len 32 * _8362])
            _3934 = mem[mem[ceil32(return_data.size) + 160]]
            idx = 0
            u = 0
            while idx < _3934:
                mem[0] = arg1
                mem[32] = 1
                mem[mem[64] + 32] = idx
                mem[mem[64] + 64] = stor1[arg1].field_512
                mem[mem[64] + 96] = stor8
                _3981 = mem[64]
                mem[mem[64]] = 96
                mem[64] = mem[64] + 128
                if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                    revert with 0, 50
                if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    revert with 0, 18
                if sha3(mem[_3981 + 32 len mem[_3981]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    if idx == -1:
                        revert with 0, 17
                    _3934 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = idx + 1
                    u = u
                    continue 
                if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                    revert with 0, 50
                if u >= mem[_2499]:
                    revert with 0, 50
                mem[(32 * u) + _2499 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                    revert with 0, 50
                if u >= mem[_2602]:
                    revert with 0, 50
                mem[(32 * u) + _2602 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                if u == -1:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _3934 = mem[mem[ceil32(return_data.size) + 160]]
                idx = idx + 1
                u = u + 1
                continue 
            idx = 0
            while idx < stor5.length:
                mem[0] = 5
                _5976 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5976] = address(stor5[idx].field_0)
                mem[_5976 + 32] = address(stor5[idx].field_256)
                mem[0] = address(stor5[idx].field_0)
                mem[32] = sha3(arg1, 1) + 3
                if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                    _6050 = mem[64]
                    mem[mem[64]] = 0
                    mem[mem[64] + 32] = 0
                    mem[64] = mem[64] + 64
                    _7747 = mem[_6050]
                    s = 0
                    t = u
                    while s < _7747:
                        if s >= mem[_6050]:
                            revert with 0, 50
                        if t >= mem[_2499]:
                            revert with 0, 50
                        mem[(32 * t) + _2499 + 32] = mem[(32 * s) + _6050 + 32]
                        if s >= mem[_6050 + 32]:
                            revert with 0, 50
                        if t >= mem[_2602]:
                            revert with 0, 50
                        mem[(32 * t) + _2602 + 32] = mem[(32 * s) + _6050 + 64]
                        if t == -1:
                            revert with 0, 17
                        if s == -1:
                            revert with 0, 17
                        _7747 = mem[_6050]
                        s = s + 1
                        t = t + 1
                        continue 
                else:
                    mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = arg1
                    mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    require ext_code.size(address(stor5[idx].field_256))
                    staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                            gas gas_remaining wei
                           args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _6275 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 64
                    _6360 = mem[_6275]
                    require mem[_6275] <= test266151307()
                    require _6275 + mem[_6275] + 31 < _6275 + return_data.size
                    _6527 = mem[_6275 + mem[_6275]]
                    if mem[_6275 + mem[_6275]] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[_6275 + mem[_6275]]) + 1 < 0 or _6275 + ceil32(return_data.size) + ceil32(32 * mem[_6275 + mem[_6275]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = _6275 + ceil32(return_data.size) + ceil32(32 * mem[_6275 + mem[_6275]]) + 1
                    mem[_6275 + ceil32(return_data.size)] = _6527
                    require _6360 + (32 * _6527) + 32 <= return_data.size
                    s = 0
                    t = _6275 + _6360 + 32
                    v = _6275 + ceil32(return_data.size) + 32
                    while s < _6527:
                        mem[v] = mem[t]
                        s = s + 1
                        t = t + 32
                        v = v + 32
                        continue 
                    _7943 = mem[_6275 + 32]
                    require mem[_6275 + 32] <= test266151307()
                    require _6275 + mem[_6275 + 32] + 31 < _6275 + return_data.size
                    _8072 = mem[_6275 + mem[_6275 + 32]]
                    if mem[_6275 + mem[_6275 + 32]] > test266151307():
                        revert with 0, 65
                    _8261 = mem[64]
                    if mem[64] + ceil32(32 * mem[_6275 + mem[_6275 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_6275 + mem[_6275 + 32]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = mem[64] + ceil32(32 * mem[_6275 + mem[_6275 + 32]]) + 1
                    mem[_8261] = _8072
                    require _7943 + (32 * _8072) + 32 <= return_data.size
                    s = 0
                    t = _6275 + _7943 + 32
                    v = _8261 + 32
                    while s < _8072:
                        mem[v] = mem[t]
                        s = s + 1
                        t = t + 32
                        v = v + 32
                        continue 
                    _10551 = mem[_6275 + ceil32(return_data.size)]
                    s = 0
                    t = u
                    while s < _10551:
                        if s >= mem[_6275 + ceil32(return_data.size)]:
                            revert with 0, 50
                        if t >= mem[_2499]:
                            revert with 0, 50
                        mem[(32 * t) + _2499 + 32] = mem[(32 * s) + _6275 + ceil32(return_data.size) + 32]
                        if s >= mem[_8261]:
                            revert with 0, 50
                        if t >= mem[_2602]:
                            revert with 0, 50
                        mem[(32 * t) + _2602 + 32] = mem[(32 * s) + _8261 + 32]
                        if t == -1:
                            revert with 0, 17
                        if s == -1:
                            revert with 0, 17
                        _10551 = mem[_6275 + ceil32(return_data.size)]
                        s = s + 1
                        t = t + 1
                        continue 
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            if s > !t:
                revert with 0, 17
            if u != s + t:
                revert with 0, 1
            if arg2 >= stor5.length:
                revert with 0, 50
            mem[0] = 5
            _6084 = mem[64]
            mem[64] = mem[64] + 64
            mem[_6084] = address(stor5[arg2].field_0)
            mem[_6084 + 32] = address(stor5[arg2].field_256)
            mem[0] = address(stor5[arg2].field_0)
            mem[32] = sha3(arg1, 1) + 3
            if not stor1[arg1][3][address(stor5[arg2].field_0)].field_0:
                _6164 = mem[64]
                mem[64] = mem[64] + 32
                mem[_6164 + 32] = 32
                mem[_6164 + 64] = mem[_6164]
                mem[_6164 + 96 len 32 * mem[_6164]] = mem[_6164 + 32 len 32 * mem[_6164]]
                var65001 = mem[_6164]
                var65002 = _6164 + (32 * mem[_6164]) + 32
                return memory
                  from mem[64]
                   len _6164 + (32 * mem[_6164]) + -mem[64] + 96
            if stor1[arg1][3][address(stor5[arg2].field_0)].field_0 < 1:
                revert with 0, 17
            mem[mem[64]] = 0x26148aa500000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 96
            _6416 = mem[_2499]
            mem[mem[64] + 100] = mem[_2499]
            mem[mem[64] + 132 len 32 * _6416] = mem[_2499 + 32 len 32 * _6416]
            var66001 = _6416
            var66002 = _2499 + (32 * _6416) + 32
            mem[mem[64] + 36] = arg1
            mem[mem[64] + 68] = stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1
            require ext_code.size(address(stor5[arg2].field_256))
            staticcall address(stor5[arg2].field_256).0x26148aa5 with:
                    gas gas_remaining wei
                   args 96, arg1, stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1, mem[mem[64] + 100 len (32 * _6416) + 32]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _8071 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _8187 = mem[_8071]
            require mem[_8071] <= test266151307()
            require _8071 + mem[_8071] + 31 < _8071 + return_data.size
            _8361 = mem[_8071 + mem[_8071]]
            if mem[_8071 + mem[_8071]] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[_8071 + mem[_8071]]) + 1 < 0 or _8071 + ceil32(return_data.size) + ceil32(32 * mem[_8071 + mem[_8071]]) + 1 > test266151307():
                revert with 0, 65
            mem[64] = _8071 + ceil32(return_data.size) + ceil32(32 * mem[_8071 + mem[_8071]]) + 1
            mem[_8071 + ceil32(return_data.size)] = _8361
            require _8187 + (32 * _8361) + 32 <= return_data.size
            mem[_8071 + ceil32(return_data.size) + 32 len 32 * _8361] = mem[_8071 + _8187 + 32 len 32 * _8361]
            mem[mem[64]] = 32
            mem[mem[64] + 32] = _8361
            mem[mem[64] + 64 len 32 * _8361] = mem[_8071 + ceil32(return_data.size) + 32 len 32 * _8361]
            return Array(len=_8361, data=mem[mem[64] + 64 len 32 * _8361])
        mem[0] = sha3(ext_call.return_data[31 len 1], 10) + 1
        mem[ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + 256] = stor10[ext_call.return_data[31 len 1]][1].field_0
        idx = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + 256
        s = 0
        while ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 224 > idx:
            mem[idx + 32] = stor10[ext_call.return_data[31 len 1]][s + 1].field_256
            idx = idx + 32
            s = s + 1
            continue 
        mem[ceil32(return_data.size) + 128] = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + 224
        mem[64] = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + (32 * stor10[ext_call.return_data[31 len 1]].field_512) + 288
        mem[ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 256] = stor10[ext_call.return_data[31 len 1]].field_512
        if not stor10[ext_call.return_data[31 len 1]].field_512:
            mem[ceil32(return_data.size) + 160] = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 256
            idx = 0
            s = 0
            while idx < stor10[ext_call.return_data[31 len 1]].field_512:
                mem[0] = arg1
                mem[32] = 1
                mem[mem[64] + 32] = idx
                mem[mem[64] + 64] = stor1[arg1].field_512
                mem[mem[64] + 96] = stor8
                _1187 = mem[64]
                mem[mem[64]] = 96
                mem[64] = mem[64] + 128
                if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                    revert with 0, 50
                if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    revert with 0, 18
                if sha3(mem[_1187 + 32 len mem[_1187]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s
                    continue 
                if s == -1:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s + 1
                continue 
            idx = 0
            t = 0
            while idx < stor5.length:
                mem[0] = 5
                _2484 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2484] = address(stor5[idx].field_0)
                mem[_2484 + 32] = address(stor5[idx].field_256)
                mem[0] = address(stor5[idx].field_0)
                mem[32] = sha3(arg1, 1) + 3
                if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                    _2502 = mem[64]
                    mem[mem[64]] = 0
                    mem[mem[64] + 32] = 0
                    mem[64] = mem[64] + 64
                    if t > !mem[_2502]:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    t = t + mem[_2502]
                    continue 
                mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = arg1
                mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                require ext_code.size(address(stor5[idx].field_256))
                staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                        gas gas_remaining wei
                       args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _2605 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 64
                _2649 = mem[_2605]
                require mem[_2605] <= test266151307()
                require _2605 + mem[_2605] + 31 < _2605 + return_data.size
                _2781 = mem[_2605 + mem[_2605]]
                if mem[_2605 + mem[_2605]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_2605 + mem[_2605]]) + 1 < 0 or _2605 + ceil32(return_data.size) + ceil32(32 * mem[_2605 + mem[_2605]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _2605 + ceil32(return_data.size) + ceil32(32 * mem[_2605 + mem[_2605]]) + 1
                mem[_2605 + ceil32(return_data.size)] = _2781
                require _2649 + (32 * _2781) + 32 <= return_data.size
                s = 0
                u = _2605 + _2649 + 32
                v = _2605 + ceil32(return_data.size) + 32
                while s < _2781:
                    mem[v] = mem[u]
                    s = s + 1
                    u = u + 32
                    v = v + 32
                    continue 
                _4108 = mem[_2605 + 32]
                require mem[_2605 + 32] <= test266151307()
                require _2605 + mem[_2605 + 32] + 31 < _2605 + return_data.size
                _4146 = mem[_2605 + mem[_2605 + 32]]
                if mem[_2605 + mem[_2605 + 32]] > test266151307():
                    revert with 0, 65
                _4378 = mem[64]
                if mem[64] + ceil32(32 * mem[_2605 + mem[_2605 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_2605 + mem[_2605 + 32]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = mem[64] + ceil32(32 * mem[_2605 + mem[_2605 + 32]]) + 1
                mem[_4378] = _4146
                require _4108 + (32 * _4146) + 32 <= return_data.size
                s = 0
                u = _2605 + _4108 + 32
                v = _4378 + 32
                while s < _4146:
                    mem[v] = mem[u]
                    s = s + 1
                    u = u + 32
                    v = v + 32
                    continue 
                if t > !mem[_2605 + ceil32(return_data.size)]:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                t = t + mem[_2605 + ceil32(return_data.size)]
                continue 
            if s > !t:
                revert with 0, 17
            if s + t > test266151307():
                revert with 0, 65
            _2501 = mem[64]
            mem[mem[64]] = s + t
            if not s + t:
                if s > !t:
                    revert with 0, 17
                if s + t > test266151307():
                    revert with 0, 65
                _2604 = mem[64] + (32 * s + t) + 32
                mem[mem[64] + (32 * s + t) + 32] = s + t
                mem[64] = _2604 + (32 * s + t) + 32
                if not s + t:
                    _3942 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = 0
                    u = 0
                    while idx < _3942:
                        mem[0] = arg1
                        mem[32] = 1
                        mem[mem[64] + 32] = idx
                        mem[mem[64] + 64] = stor1[arg1].field_512
                        mem[mem[64] + 96] = stor8
                        _4010 = mem[64]
                        mem[mem[64]] = 96
                        mem[64] = mem[64] + 128
                        if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                            revert with 0, 50
                        if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                            revert with 0, 18
                        if sha3(mem[_4010 + 32 len mem[_4010]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                            if idx == -1:
                                revert with 0, 17
                            _3942 = mem[mem[ceil32(return_data.size) + 160]]
                            idx = idx + 1
                            u = u
                            continue 
                        if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                            revert with 0, 50
                        if u >= mem[_2501]:
                            revert with 0, 50
                        mem[(32 * u) + _2501 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                        if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                            revert with 0, 50
                        if u >= mem[_2604]:
                            revert with 0, 50
                        mem[(32 * u) + _2604 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                        if u == -1:
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        _3942 = mem[mem[ceil32(return_data.size) + 160]]
                        idx = idx + 1
                        u = u + 1
                        continue 
                    idx = 0
                    while idx < stor5.length:
                        mem[0] = 5
                        _5996 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5996] = address(stor5[idx].field_0)
                        mem[_5996 + 32] = address(stor5[idx].field_256)
                        mem[0] = address(stor5[idx].field_0)
                        mem[32] = sha3(arg1, 1) + 3
                        if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                            _6055 = mem[64]
                            mem[mem[64]] = 0
                            mem[mem[64] + 32] = 0
                            mem[64] = mem[64] + 64
                            _7751 = mem[_6055]
                            s = 0
                            t = u
                            while s < _7751:
                                if s >= mem[_6055]:
                                    revert with 0, 50
                                if t >= mem[_2501]:
                                    revert with 0, 50
                                mem[(32 * t) + _2501 + 32] = mem[(32 * s) + _6055 + 32]
                                if s >= mem[_6055 + 32]:
                                    revert with 0, 50
                                if t >= mem[_2604]:
                                    revert with 0, 50
                                mem[(32 * t) + _2604 + 32] = mem[(32 * s) + _6055 + 64]
                                if t == -1:
                                    revert with 0, 17
                                if s == -1:
                                    revert with 0, 17
                                _7751 = mem[_6055]
                                s = s + 1
                                t = t + 1
                                continue 
                        else:
                            mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = arg1
                            mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                            require ext_code.size(address(stor5[idx].field_256))
                            staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                                    gas gas_remaining wei
                                   args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _6291 = mem[64]
                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 64
                            _6376 = mem[_6291]
                            require mem[_6291] <= test266151307()
                            require _6291 + mem[_6291] + 31 < _6291 + return_data.size
                            _6535 = mem[_6291 + mem[_6291]]
                            if mem[_6291 + mem[_6291]] > test266151307():
                                revert with 0, 65
                            if ceil32(32 * mem[_6291 + mem[_6291]]) + 1 < 0 or _6291 + ceil32(return_data.size) + ceil32(32 * mem[_6291 + mem[_6291]]) + 1 > test266151307():
                                revert with 0, 65
                            mem[64] = _6291 + ceil32(return_data.size) + ceil32(32 * mem[_6291 + mem[_6291]]) + 1
                            mem[_6291 + ceil32(return_data.size)] = _6535
                            require _6376 + (32 * _6535) + 32 <= return_data.size
                            s = 0
                            t = _6291 + _6376 + 32
                            v = _6291 + ceil32(return_data.size) + 32
                            while s < _6535:
                                mem[v] = mem[t]
                                s = s + 1
                                t = t + 32
                                v = v + 32
                                continue 
                            _7955 = mem[_6291 + 32]
                            require mem[_6291 + 32] <= test266151307()
                            require _6291 + mem[_6291 + 32] + 31 < _6291 + return_data.size
                            _8080 = mem[_6291 + mem[_6291 + 32]]
                            if mem[_6291 + mem[_6291 + 32]] > test266151307():
                                revert with 0, 65
                            _8265 = mem[64]
                            if mem[64] + ceil32(32 * mem[_6291 + mem[_6291 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_6291 + mem[_6291 + 32]]) + 1 > test266151307():
                                revert with 0, 65
                            mem[64] = mem[64] + ceil32(32 * mem[_6291 + mem[_6291 + 32]]) + 1
                            mem[_8265] = _8080
                            require _7955 + (32 * _8080) + 32 <= return_data.size
                            s = 0
                            t = _6291 + _7955 + 32
                            v = _8265 + 32
                            while s < _8080:
                                mem[v] = mem[t]
                                s = s + 1
                                t = t + 32
                                v = v + 32
                                continue 
                            _10555 = mem[_6291 + ceil32(return_data.size)]
                            s = 0
                            t = u
                            while s < _10555:
                                if s >= mem[_6291 + ceil32(return_data.size)]:
                                    revert with 0, 50
                                if t >= mem[_2501]:
                                    revert with 0, 50
                                mem[(32 * t) + _2501 + 32] = mem[(32 * s) + _6291 + ceil32(return_data.size) + 32]
                                if s >= mem[_8265]:
                                    revert with 0, 50
                                if t >= mem[_2604]:
                                    revert with 0, 50
                                mem[(32 * t) + _2604 + 32] = mem[(32 * s) + _8265 + 32]
                                if t == -1:
                                    revert with 0, 17
                                if s == -1:
                                    revert with 0, 17
                                _10555 = mem[_6291 + ceil32(return_data.size)]
                                s = s + 1
                                t = t + 1
                                continue 
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
                    if s > !t:
                        revert with 0, 17
                    if u != s + t:
                        revert with 0, 1
                    if arg2 >= stor5.length:
                        revert with 0, 50
                    mem[0] = 5
                    _6104 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_6104] = address(stor5[arg2].field_0)
                    mem[_6104 + 32] = address(stor5[arg2].field_256)
                    mem[0] = address(stor5[arg2].field_0)
                    mem[32] = sha3(arg1, 1) + 3
                    if not stor1[arg1][3][address(stor5[arg2].field_0)].field_0:
                        _6188 = mem[64]
                        mem[64] = mem[64] + 32
                        mem[_6188 + 32] = 32
                        mem[_6188 + 64] = mem[_6188]
                        mem[_6188 + 96 len 32 * mem[_6188]] = mem[_6188 + 32 len 32 * mem[_6188]]
                        var65001 = mem[_6188]
                        var65002 = _6188 + (32 * mem[_6188]) + 32
                        return memory
                          from mem[64]
                           len _6188 + (32 * mem[_6188]) + -mem[64] + 96
                    if stor1[arg1][3][address(stor5[arg2].field_0)].field_0 < 1:
                        revert with 0, 17
                    mem[mem[64]] = 0x26148aa500000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 96
                    _6420 = mem[_2501]
                    mem[mem[64] + 100] = mem[_2501]
                    mem[mem[64] + 132 len 32 * _6420] = mem[_2501 + 32 len 32 * _6420]
                    var66001 = _6420
                    var66002 = _2501 + (32 * _6420) + 32
                    mem[mem[64] + 36] = arg1
                    mem[mem[64] + 68] = stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1
                    require ext_code.size(address(stor5[arg2].field_256))
                    staticcall address(stor5[arg2].field_256).0x26148aa5 with:
                            gas gas_remaining wei
                           args 96, arg1, stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1, mem[mem[64] + 100 len (32 * _6420) + 32]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _8079 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _8191 = mem[_8079]
                    require mem[_8079] <= test266151307()
                    require _8079 + mem[_8079] + 31 < _8079 + return_data.size
                    _8365 = mem[_8079 + mem[_8079]]
                    if mem[_8079 + mem[_8079]] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[_8079 + mem[_8079]]) + 1 < 0 or _8079 + ceil32(return_data.size) + ceil32(32 * mem[_8079 + mem[_8079]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = _8079 + ceil32(return_data.size) + ceil32(32 * mem[_8079 + mem[_8079]]) + 1
                    mem[_8079 + ceil32(return_data.size)] = _8365
                    require _8191 + (32 * _8365) + 32 <= return_data.size
                    mem[_8079 + ceil32(return_data.size) + 32 len 32 * _8365] = mem[_8079 + _8191 + 32 len 32 * _8365]
                    mem[mem[64]] = 32
                    mem[mem[64] + 32] = _8365
                    mem[mem[64] + 64 len 32 * _8365] = mem[_8079 + ceil32(return_data.size) + 32 len 32 * _8365]
                    var93001 = _8365
                    var93002 = _8079 + ceil32(return_data.size) + (32 * _8365) + 32
                    return Array(len=_8365, data=mem[mem[64] + 64 len 32 * _8365])
                mem[_2604 + 32 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
                _3944 = mem[mem[ceil32(return_data.size) + 160]]
                idx = 0
                u = 0
                while idx < _3944:
                    mem[0] = arg1
                    mem[32] = 1
                    mem[mem[64] + 32] = idx
                    mem[mem[64] + 64] = stor1[arg1].field_512
                    mem[mem[64] + 96] = stor8
                    _4017 = mem[64]
                    mem[mem[64]] = 96
                    mem[64] = mem[64] + 128
                    if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                        revert with 0, 50
                    if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        revert with 0, 18
                    if sha3(mem[_4017 + 32 len mem[_4017]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        if idx == -1:
                            revert with 0, 17
                        _3944 = mem[mem[ceil32(return_data.size) + 160]]
                        idx = idx + 1
                        u = u
                        continue 
                    if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                        revert with 0, 50
                    if u >= mem[_2501]:
                        revert with 0, 50
                    mem[(32 * u) + _2501 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                    if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                        revert with 0, 50
                    if u >= mem[_2604]:
                        revert with 0, 50
                    mem[(32 * u) + _2604 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                    if u == -1:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _3944 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = idx + 1
                    u = u + 1
                    continue 
                idx = 0
                while idx < stor5.length:
                    mem[0] = 5
                    _6001 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_6001] = address(stor5[idx].field_0)
                    mem[_6001 + 32] = address(stor5[idx].field_256)
                    mem[0] = address(stor5[idx].field_0)
                    mem[32] = sha3(arg1, 1) + 3
                    if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                        _6056 = mem[64]
                        mem[mem[64]] = 0
                        mem[mem[64] + 32] = 0
                        mem[64] = mem[64] + 64
                        _7752 = mem[_6056]
                        s = 0
                        t = u
                        while s < _7752:
                            if s >= mem[_6056]:
                                revert with 0, 50
                            if t >= mem[_2501]:
                                revert with 0, 50
                            mem[(32 * t) + _2501 + 32] = mem[(32 * s) + _6056 + 32]
                            if s >= mem[_6056 + 32]:
                                revert with 0, 50
                            if t >= mem[_2604]:
                                revert with 0, 50
                            mem[(32 * t) + _2604 + 32] = mem[(32 * s) + _6056 + 64]
                            if t == -1:
                                revert with 0, 17
                            if s == -1:
                                revert with 0, 17
                            _7752 = mem[_6056]
                            s = s + 1
                            t = t + 1
                            continue 
                    else:
                        mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = arg1
                        mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                        require ext_code.size(address(stor5[idx].field_256))
                        staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                                gas gas_remaining wei
                               args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _6295 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 64
                        _6380 = mem[_6295]
                        require mem[_6295] <= test266151307()
                        require _6295 + mem[_6295] + 31 < _6295 + return_data.size
                        _6537 = mem[_6295 + mem[_6295]]
                        if mem[_6295 + mem[_6295]] > test266151307():
                            revert with 0, 65
                        if ceil32(32 * mem[_6295 + mem[_6295]]) + 1 < 0 or _6295 + ceil32(return_data.size) + ceil32(32 * mem[_6295 + mem[_6295]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = _6295 + ceil32(return_data.size) + ceil32(32 * mem[_6295 + mem[_6295]]) + 1
                        mem[_6295 + ceil32(return_data.size)] = _6537
                        require _6380 + (32 * _6537) + 32 <= return_data.size
                        s = 0
                        t = _6295 + _6380 + 32
                        v = _6295 + ceil32(return_data.size) + 32
                        while s < _6537:
                            mem[v] = mem[t]
                            s = s + 1
                            t = t + 32
                            v = v + 32
                            continue 
                        _7958 = mem[_6295 + 32]
                        require mem[_6295 + 32] <= test266151307()
                        require _6295 + mem[_6295 + 32] + 31 < _6295 + return_data.size
                        _8082 = mem[_6295 + mem[_6295 + 32]]
                        if mem[_6295 + mem[_6295 + 32]] > test266151307():
                            revert with 0, 65
                        _8266 = mem[64]
                        if mem[64] + ceil32(32 * mem[_6295 + mem[_6295 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_6295 + mem[_6295 + 32]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = mem[64] + ceil32(32 * mem[_6295 + mem[_6295 + 32]]) + 1
                        mem[_8266] = _8082
                        require _7958 + (32 * _8082) + 32 <= return_data.size
                        s = 0
                        t = _6295 + _7958 + 32
                        v = _8266 + 32
                        while s < _8082:
                            mem[v] = mem[t]
                            s = s + 1
                            t = t + 32
                            v = v + 32
                            continue 
                        _10556 = mem[_6295 + ceil32(return_data.size)]
                        s = 0
                        t = u
                        while s < _10556:
                            if s >= mem[_6295 + ceil32(return_data.size)]:
                                revert with 0, 50
                            if t >= mem[_2501]:
                                revert with 0, 50
                            mem[(32 * t) + _2501 + 32] = mem[(32 * s) + _6295 + ceil32(return_data.size) + 32]
                            if s >= mem[_8266]:
                                revert with 0, 50
                            if t >= mem[_2604]:
                                revert with 0, 50
                            mem[(32 * t) + _2604 + 32] = mem[(32 * s) + _8266 + 32]
                            if t == -1:
                                revert with 0, 17
                            if s == -1:
                                revert with 0, 17
                            _10556 = mem[_6295 + ceil32(return_data.size)]
                            s = s + 1
                            t = t + 1
                            continue 
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                if s > !t:
                    revert with 0, 17
                if u != s + t:
                    revert with 0, 1
                if arg2 >= stor5.length:
                    revert with 0, 50
                mem[0] = 5
                _6109 = mem[64]
                mem[64] = mem[64] + 64
                mem[_6109] = address(stor5[arg2].field_0)
                mem[_6109 + 32] = address(stor5[arg2].field_256)
                mem[0] = address(stor5[arg2].field_0)
                mem[32] = sha3(arg1, 1) + 3
                if not stor1[arg1][3][address(stor5[arg2].field_0)].field_0:
                    _6194 = mem[64]
                    mem[64] = mem[64] + 32
                    mem[_6194 + 32] = 32
                    mem[_6194 + 64] = mem[_6194]
                    mem[_6194 + 96 len 32 * mem[_6194]] = mem[_6194 + 32 len 32 * mem[_6194]]
                    var66001 = mem[_6194]
                    var66002 = _6194 + (32 * mem[_6194]) + 32
                    return memory
                      from mem[64]
                       len _6194 + (32 * mem[_6194]) + -mem[64] + 96
                if stor1[arg1][3][address(stor5[arg2].field_0)].field_0 < 1:
                    revert with 0, 17
                mem[mem[64]] = 0x26148aa500000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 96
                _6421 = mem[_2501]
                mem[mem[64] + 100] = mem[_2501]
                mem[mem[64] + 132 len 32 * _6421] = mem[_2501 + 32 len 32 * _6421]
                var67001 = _6421
                mem[mem[64] + 36] = arg1
                mem[mem[64] + 68] = stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1
                require ext_code.size(address(stor5[arg2].field_256))
                staticcall address(stor5[arg2].field_256).0x26148aa5 with:
                        gas gas_remaining wei
                       args 96, arg1, stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1, mem[mem[64] + 100 len (32 * _6421) + 32]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _8081 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _8192 = mem[_8081]
                require mem[_8081] <= test266151307()
                require _8081 + mem[_8081] + 31 < _8081 + return_data.size
                _8366 = mem[_8081 + mem[_8081]]
                if mem[_8081 + mem[_8081]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_8081 + mem[_8081]]) + 1 < 0 or _8081 + ceil32(return_data.size) + ceil32(32 * mem[_8081 + mem[_8081]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _8081 + ceil32(return_data.size) + ceil32(32 * mem[_8081 + mem[_8081]]) + 1
                mem[_8081 + ceil32(return_data.size)] = _8366
                require _8192 + (32 * _8366) + 32 <= return_data.size
                mem[_8081 + ceil32(return_data.size) + 32 len 32 * _8366] = mem[_8081 + _8192 + 32 len 32 * _8366]
                mem[mem[64]] = 32
                mem[mem[64] + 32] = _8366
                mem[mem[64] + 64 len 32 * _8366] = mem[_8081 + ceil32(return_data.size) + 32 len 32 * _8366]
                var94001 = _8366
                var94002 = _8081 + ceil32(return_data.size) + (32 * _8366) + 32
                return Array(len=_8366, data=mem[mem[64] + 64 len 32 * _8366])
            mem[mem[64] + 32 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
            if s > !t:
                revert with 0, 17
            if s + t > test266151307():
                revert with 0, 65
            mem[mem[64] + (32 * s + t) + 32] = s + t
            mem[64] = _2501 + (64 * s + t) + 64
            if not s + t:
                _3946 = mem[mem[ceil32(return_data.size) + 160]]
                idx = 0
                u = 0
                while idx < _3946:
                    mem[0] = arg1
                    mem[32] = 1
                    mem[mem[64] + 32] = idx
                    mem[mem[64] + 64] = stor1[arg1].field_512
                    mem[mem[64] + 96] = stor8
                    _4024 = mem[64]
                    mem[mem[64]] = 96
                    mem[64] = mem[64] + 128
                    if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                        revert with 0, 50
                    if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        revert with 0, 18
                    if sha3(mem[_4024 + 32 len mem[_4024]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        if idx == -1:
                            revert with 0, 17
                        _3946 = mem[mem[ceil32(return_data.size) + 160]]
                        idx = idx + 1
                        u = u
                        continue 
                    if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                        revert with 0, 50
                    if u >= mem[_2501]:
                        revert with 0, 50
                    mem[(32 * u) + _2501 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                    if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                        revert with 0, 50
                    if u >= mem[_2501 + (32 * s + t) + 32]:
                        revert with 0, 50
                    mem[(32 * u) + _2501 + (32 * s + t) + 64] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                    if u == -1:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _3946 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = idx + 1
                    u = u + 1
                    continue 
                idx = 0
                while idx < stor5.length:
                    mem[0] = 5
                    _6006 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_6006] = address(stor5[idx].field_0)
                    mem[_6006 + 32] = address(stor5[idx].field_256)
                    mem[0] = address(stor5[idx].field_0)
                    mem[32] = sha3(arg1, 1) + 3
                    if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                        _6057 = mem[64]
                        mem[mem[64]] = 0
                        mem[mem[64] + 32] = 0
                        mem[64] = mem[64] + 64
                        _7753 = mem[_6057]
                        v = 0
                        w = u
                        while v < _7753:
                            if v >= mem[_6057]:
                                revert with 0, 50
                            if w >= mem[_2501]:
                                revert with 0, 50
                            mem[(32 * w) + _2501 + 32] = mem[(32 * v) + _6057 + 32]
                            if v >= mem[_6057 + 32]:
                                revert with 0, 50
                            if w >= mem[_2501 + (32 * s + t) + 32]:
                                revert with 0, 50
                            mem[(32 * w) + _2501 + (32 * s + t) + 64] = mem[(32 * v) + _6057 + 64]
                            if w == -1:
                                revert with 0, 17
                            if v == -1:
                                revert with 0, 17
                            _7753 = mem[_6057]
                            v = v + 1
                            w = w + 1
                            continue 
                    else:
                        mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = arg1
                        mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                        require ext_code.size(address(stor5[idx].field_256))
                        staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                                gas gas_remaining wei
                               args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _6299 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 64
                        _6384 = mem[_6299]
                        require mem[_6299] <= test266151307()
                        require _6299 + mem[_6299] + 31 < _6299 + return_data.size
                        _6539 = mem[_6299 + mem[_6299]]
                        if mem[_6299 + mem[_6299]] > test266151307():
                            revert with 0, 65
                        if ceil32(32 * mem[_6299 + mem[_6299]]) + 1 < 0 or _6299 + ceil32(return_data.size) + ceil32(32 * mem[_6299 + mem[_6299]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = _6299 + ceil32(return_data.size) + ceil32(32 * mem[_6299 + mem[_6299]]) + 1
                        mem[_6299 + ceil32(return_data.size)] = _6539
                        require _6384 + (32 * _6539) + 32 <= return_data.size
                        v = 0
                        w = _6299 + _6384 + 32
                        x = _6299 + ceil32(return_data.size) + 32
                        while v < _6539:
                            mem[x] = mem[w]
                            v = v + 1
                            w = w + 32
                            x = x + 32
                            continue 
                        _7961 = mem[_6299 + 32]
                        require mem[_6299 + 32] <= test266151307()
                        require _6299 + mem[_6299 + 32] + 31 < _6299 + return_data.size
                        _8084 = mem[_6299 + mem[_6299 + 32]]
                        if mem[_6299 + mem[_6299 + 32]] > test266151307():
                            revert with 0, 65
                        _8267 = mem[64]
                        if mem[64] + ceil32(32 * mem[_6299 + mem[_6299 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_6299 + mem[_6299 + 32]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = mem[64] + ceil32(32 * mem[_6299 + mem[_6299 + 32]]) + 1
                        mem[_8267] = _8084
                        require _7961 + (32 * _8084) + 32 <= return_data.size
                        v = 0
                        w = _6299 + _7961 + 32
                        x = _8267 + 32
                        while v < _8084:
                            mem[x] = mem[w]
                            v = v + 1
                            w = w + 32
                            x = x + 32
                            continue 
                        _10557 = mem[_6299 + ceil32(return_data.size)]
                        v = 0
                        w = u
                        while v < _10557:
                            if v >= mem[_6299 + ceil32(return_data.size)]:
                                revert with 0, 50
                            if w >= mem[_2501]:
                                revert with 0, 50
                            mem[(32 * w) + _2501 + 32] = mem[(32 * v) + _6299 + ceil32(return_data.size) + 32]
                            if v >= mem[_8267]:
                                revert with 0, 50
                            if w >= mem[_2501 + (32 * s + t) + 32]:
                                revert with 0, 50
                            mem[(32 * w) + _2501 + (32 * s + t) + 64] = mem[(32 * v) + _8267 + 32]
                            if w == -1:
                                revert with 0, 17
                            if v == -1:
                                revert with 0, 17
                            _10557 = mem[_6299 + ceil32(return_data.size)]
                            v = v + 1
                            w = w + 1
                            continue 
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                if s > !t:
                    revert with 0, 17
                if u != s + t:
                    revert with 0, 1
                if arg2 >= stor5.length:
                    revert with 0, 50
                mem[0] = 5
                _6114 = mem[64]
                mem[64] = mem[64] + 64
                mem[_6114] = address(stor5[arg2].field_0)
                mem[_6114 + 32] = address(stor5[arg2].field_256)
                mem[0] = address(stor5[arg2].field_0)
                mem[32] = sha3(arg1, 1) + 3
                if not stor1[arg1][3][address(stor5[arg2].field_0)].field_0:
                    _6200 = mem[64]
                    mem[64] = mem[64] + 32
                    mem[_6200 + 32] = 32
                    mem[_6200 + 64] = mem[_6200]
                    mem[_6200 + 96 len 32 * mem[_6200]] = mem[_6200 + 32 len 32 * mem[_6200]]
                    var66001 = mem[_6200]
                    var66002 = _6200 + (32 * mem[_6200]) + 32
                    return memory
                      from mem[64]
                       len _6200 + (32 * mem[_6200]) + -mem[64] + 96
                if stor1[arg1][3][address(stor5[arg2].field_0)].field_0 < 1:
                    revert with 0, 17
                mem[mem[64]] = 0x26148aa500000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 96
                _6422 = mem[_2501]
                mem[mem[64] + 100] = mem[_2501]
                mem[mem[64] + 132 len 32 * _6422] = mem[_2501 + 32 len 32 * _6422]
                var67001 = _6422
                mem[mem[64] + 36] = arg1
                mem[mem[64] + 68] = stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1
                require ext_code.size(address(stor5[arg2].field_256))
                staticcall address(stor5[arg2].field_256).0x26148aa5 with:
                        gas gas_remaining wei
                       args 96, arg1, stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1, mem[mem[64] + 100 len (32 * _6422) + 32]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _8083 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _8193 = mem[_8083]
                require mem[_8083] <= test266151307()
                require _8083 + mem[_8083] + 31 < _8083 + return_data.size
                _8367 = mem[_8083 + mem[_8083]]
                if mem[_8083 + mem[_8083]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_8083 + mem[_8083]]) + 1 < 0 or _8083 + ceil32(return_data.size) + ceil32(32 * mem[_8083 + mem[_8083]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _8083 + ceil32(return_data.size) + ceil32(32 * mem[_8083 + mem[_8083]]) + 1
                mem[_8083 + ceil32(return_data.size)] = _8367
                require _8193 + (32 * _8367) + 32 <= return_data.size
                mem[_8083 + ceil32(return_data.size) + 32 len 32 * _8367] = mem[_8083 + _8193 + 32 len 32 * _8367]
                mem[mem[64]] = 32
                mem[mem[64] + 32] = _8367
                mem[mem[64] + 64 len 32 * _8367] = mem[_8083 + ceil32(return_data.size) + 32 len 32 * _8367]
                var94001 = _8367
                var94002 = _8083 + ceil32(return_data.size) + (32 * _8367) + 32
                return Array(len=_8367, data=mem[mem[64] + 64 len 32 * _8367])
            mem[_2501 + (32 * s + t) + 64 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
            _3948 = mem[mem[ceil32(return_data.size) + 160]]
            idx = 0
            u = 0
            while idx < _3948:
                mem[0] = arg1
                mem[32] = 1
                mem[mem[64] + 32] = idx
                mem[mem[64] + 64] = stor1[arg1].field_512
                mem[mem[64] + 96] = stor8
                _4031 = mem[64]
                mem[mem[64]] = 96
                mem[64] = mem[64] + 128
                if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                    revert with 0, 50
                if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    revert with 0, 18
                if sha3(mem[_4031 + 32 len mem[_4031]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    if idx == -1:
                        revert with 0, 17
                    _3948 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = idx + 1
                    u = u
                    continue 
                if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                    revert with 0, 50
                if u >= mem[_2501]:
                    revert with 0, 50
                mem[(32 * u) + _2501 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                    revert with 0, 50
                if u >= mem[_2501 + (32 * s + t) + 32]:
                    revert with 0, 50
                mem[(32 * u) + _2501 + (32 * s + t) + 64] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                if u == -1:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _3948 = mem[mem[ceil32(return_data.size) + 160]]
                idx = idx + 1
                u = u + 1
                continue 
            idx = 0
            while idx < stor5.length:
                mem[0] = 5
                _6011 = mem[64]
                mem[64] = mem[64] + 64
                mem[_6011] = address(stor5[idx].field_0)
                mem[_6011 + 32] = address(stor5[idx].field_256)
                mem[0] = address(stor5[idx].field_0)
                mem[32] = sha3(arg1, 1) + 3
                if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                    _6058 = mem[64]
                    mem[mem[64]] = 0
                    mem[mem[64] + 32] = 0
                    mem[64] = mem[64] + 64
                    _7754 = mem[_6058]
                    v = 0
                    w = u
                    while v < _7754:
                        if v >= mem[_6058]:
                            revert with 0, 50
                        if w >= mem[_2501]:
                            revert with 0, 50
                        mem[(32 * w) + _2501 + 32] = mem[(32 * v) + _6058 + 32]
                        if v >= mem[_6058 + 32]:
                            revert with 0, 50
                        if w >= mem[_2501 + (32 * s + t) + 32]:
                            revert with 0, 50
                        mem[(32 * w) + _2501 + (32 * s + t) + 64] = mem[(32 * v) + _6058 + 64]
                        if w == -1:
                            revert with 0, 17
                        if v == -1:
                            revert with 0, 17
                        _7754 = mem[_6058]
                        v = v + 1
                        w = w + 1
                        continue 
                else:
                    mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = arg1
                    mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    require ext_code.size(address(stor5[idx].field_256))
                    staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                            gas gas_remaining wei
                           args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _6303 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 64
                    _6388 = mem[_6303]
                    require mem[_6303] <= test266151307()
                    require _6303 + mem[_6303] + 31 < _6303 + return_data.size
                    _6541 = mem[_6303 + mem[_6303]]
                    if mem[_6303 + mem[_6303]] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[_6303 + mem[_6303]]) + 1 < 0 or _6303 + ceil32(return_data.size) + ceil32(32 * mem[_6303 + mem[_6303]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = _6303 + ceil32(return_data.size) + ceil32(32 * mem[_6303 + mem[_6303]]) + 1
                    mem[_6303 + ceil32(return_data.size)] = _6541
                    require _6388 + (32 * _6541) + 32 <= return_data.size
                    v = 0
                    w = _6303 + _6388 + 32
                    x = _6303 + ceil32(return_data.size) + 32
                    while v < _6541:
                        mem[x] = mem[w]
                        v = v + 1
                        w = w + 32
                        x = x + 32
                        continue 
                    _7964 = mem[_6303 + 32]
                    require mem[_6303 + 32] <= test266151307()
                    require _6303 + mem[_6303 + 32] + 31 < _6303 + return_data.size
                    _8086 = mem[_6303 + mem[_6303 + 32]]
                    if mem[_6303 + mem[_6303 + 32]] > test266151307():
                        revert with 0, 65
                    _8268 = mem[64]
                    if mem[64] + ceil32(32 * mem[_6303 + mem[_6303 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_6303 + mem[_6303 + 32]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = mem[64] + ceil32(32 * mem[_6303 + mem[_6303 + 32]]) + 1
                    mem[_8268] = _8086
                    require _7964 + (32 * _8086) + 32 <= return_data.size
                    v = 0
                    w = _6303 + _7964 + 32
                    x = _8268 + 32
                    while v < _8086:
                        mem[x] = mem[w]
                        v = v + 1
                        w = w + 32
                        x = x + 32
                        continue 
                    _10558 = mem[_6303 + ceil32(return_data.size)]
                    v = 0
                    w = u
                    while v < _10558:
                        if v >= mem[_6303 + ceil32(return_data.size)]:
                            revert with 0, 50
                        if w >= mem[_2501]:
                            revert with 0, 50
                        mem[(32 * w) + _2501 + 32] = mem[(32 * v) + _6303 + ceil32(return_data.size) + 32]
                        if v >= mem[_8268]:
                            revert with 0, 50
                        if w >= mem[_2501 + (32 * s + t) + 32]:
                            revert with 0, 50
                        mem[(32 * w) + _2501 + (32 * s + t) + 64] = mem[(32 * v) + _8268 + 32]
                        if w == -1:
                            revert with 0, 17
                        if v == -1:
                            revert with 0, 17
                        _10558 = mem[_6303 + ceil32(return_data.size)]
                        v = v + 1
                        w = w + 1
                        continue 
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            if s > !t:
                revert with 0, 17
            if u != s + t:
                revert with 0, 1
            if arg2 >= stor5.length:
                revert with 0, 50
            mem[0] = 5
            _6119 = mem[64]
            mem[64] = mem[64] + 64
            mem[_6119] = address(stor5[arg2].field_0)
            mem[_6119 + 32] = address(stor5[arg2].field_256)
            mem[0] = address(stor5[arg2].field_0)
            mem[32] = sha3(arg1, 1) + 3
            if not stor1[arg1][3][address(stor5[arg2].field_0)].field_0:
                _6206 = mem[64]
                mem[64] = mem[64] + 32
                mem[_6206 + 32] = 32
                mem[_6206 + 64] = mem[_6206]
                mem[_6206 + 96 len 32 * mem[_6206]] = mem[_6206 + 32 len 32 * mem[_6206]]
                var67001 = mem[_6206]
                return memory
                  from mem[64]
                   len _6206 + (32 * mem[_6206]) + -mem[64] + 96
            if stor1[arg1][3][address(stor5[arg2].field_0)].field_0 < 1:
                revert with 0, 17
            mem[mem[64]] = 0x26148aa500000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 96
            _6423 = mem[_2501]
            mem[mem[64] + 100] = mem[_2501]
            mem[mem[64] + 132 len 32 * _6423] = mem[_2501 + 32 len 32 * _6423]
            var68001 = _6423
            var68002 = _2501 + (32 * _6423) + 32
            mem[mem[64] + 36] = arg1
            mem[mem[64] + 68] = stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1
            require ext_code.size(address(stor5[arg2].field_256))
            staticcall address(stor5[arg2].field_256).0x26148aa5 with:
                    gas gas_remaining wei
                   args 96, arg1, stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1, mem[mem[64] + 100 len (32 * _6423) + 32]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _8085 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _8194 = mem[_8085]
            require mem[_8085] <= test266151307()
            require _8085 + mem[_8085] + 31 < _8085 + return_data.size
            _8368 = mem[_8085 + mem[_8085]]
            if mem[_8085 + mem[_8085]] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[_8085 + mem[_8085]]) + 1 < 0 or _8085 + ceil32(return_data.size) + ceil32(32 * mem[_8085 + mem[_8085]]) + 1 > test266151307():
                revert with 0, 65
            mem[64] = _8085 + ceil32(return_data.size) + ceil32(32 * mem[_8085 + mem[_8085]]) + 1
            mem[_8085 + ceil32(return_data.size)] = _8368
            require _8194 + (32 * _8368) + 32 <= return_data.size
            mem[_8085 + ceil32(return_data.size) + 32 len 32 * _8368] = mem[_8085 + _8194 + 32 len 32 * _8368]
            mem[mem[64]] = 32
            mem[mem[64] + 32] = _8368
            mem[mem[64] + 64 len 32 * _8368] = mem[_8085 + ceil32(return_data.size) + 32 len 32 * _8368]
            var95001 = _8368
            var95002 = _8085 + ceil32(return_data.size) + (32 * _8368) + 32
            return Array(len=_8368, data=mem[mem[64] + 64 len 32 * _8368])
        mem[0] = sha3(ext_call.return_data[31 len 1], 10) + 2
        mem[ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 288] = stor10[ext_call.return_data[31 len 1]][2].field_0
        idx = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 288
        s = 0
        while ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + (32 * stor10[ext_call.return_data[31 len 1]].field_512) + 256 > idx:
            mem[idx + 32] = stor10[ext_call.return_data[31 len 1]][s + 2].field_256
            idx = idx + 32
            s = s + 1
            continue 
        mem[ceil32(return_data.size) + 160] = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 256
        idx = 0
        s = 0
        while idx < stor10[ext_call.return_data[31 len 1]].field_512:
            mem[0] = arg1
            mem[32] = 1
            mem[mem[64] + 32] = idx
            mem[mem[64] + 64] = stor1[arg1].field_512
            mem[mem[64] + 96] = stor8
            _4039 = mem[64]
            mem[mem[64]] = 96
            mem[64] = mem[64] + 128
            if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                revert with 0, 50
            if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                revert with 0, 18
            if sha3(mem[_4039 + 32 len mem[_4039]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s
                continue 
            if s == -1:
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = s + 1
            continue 
        idx = 0
        t = 0
        while idx < stor5.length:
            mem[0] = 5
            _6016 = mem[64]
            mem[64] = mem[64] + 64
            mem[_6016] = address(stor5[idx].field_0)
            mem[_6016 + 32] = address(stor5[idx].field_256)
            mem[0] = address(stor5[idx].field_0)
            mem[32] = sha3(arg1, 1) + 3
            if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                _6061 = mem[64]
                mem[mem[64]] = 0
                mem[mem[64] + 32] = 0
                mem[64] = mem[64] + 64
                if t > !mem[_6061]:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                t = t + mem[_6061]
                continue 
            mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = arg1
            mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
            require ext_code.size(address(stor5[idx].field_256))
            staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                    gas gas_remaining wei
                   args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _6307 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 64
            _6393 = mem[_6307]
            require mem[_6307] <= test266151307()
            require _6307 + mem[_6307] + 31 < _6307 + return_data.size
            _6551 = mem[_6307 + mem[_6307]]
            if mem[_6307 + mem[_6307]] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[_6307 + mem[_6307]]) + 1 < 0 or _6307 + ceil32(return_data.size) + ceil32(32 * mem[_6307 + mem[_6307]]) + 1 > test266151307():
                revert with 0, 65
            mem[64] = _6307 + ceil32(return_data.size) + ceil32(32 * mem[_6307 + mem[_6307]]) + 1
            mem[_6307 + ceil32(return_data.size)] = _6551
            require _6393 + (32 * _6551) + 32 <= return_data.size
            s = 0
            u = _6307 + _6393 + 32
            v = _6307 + ceil32(return_data.size) + 32
            while s < _6551:
                mem[v] = mem[u]
                s = s + 1
                u = u + 32
                v = v + 32
                continue 
            _7971 = mem[_6307 + 32]
            require mem[_6307 + 32] <= test266151307()
            require _6307 + mem[_6307 + 32] + 31 < _6307 + return_data.size
            _8087 = mem[_6307 + mem[_6307 + 32]]
            if mem[_6307 + mem[_6307 + 32]] > test266151307():
                revert with 0, 65
            _8297 = mem[64]
            if mem[64] + ceil32(32 * mem[_6307 + mem[_6307 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_6307 + mem[_6307 + 32]]) + 1 > test266151307():
                revert with 0, 65
            mem[64] = mem[64] + ceil32(32 * mem[_6307 + mem[_6307 + 32]]) + 1
            mem[_8297] = _8087
            require _7971 + (32 * _8087) + 32 <= return_data.size
            s = 0
            u = _6307 + _7971 + 32
            v = _8297 + 32
            while s < _8087:
                mem[v] = mem[u]
                s = s + 1
                u = u + 32
                v = v + 32
                continue 
            if t > !mem[_6307 + ceil32(return_data.size)]:
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            t = t + mem[_6307 + ceil32(return_data.size)]
            continue 
        if s > !t:
            revert with 0, 17
        if s + t > test266151307():
            revert with 0, 65
        _6060 = mem[64]
        mem[mem[64]] = s + t
        if not s + t:
            if s > !t:
                revert with 0, 17
            if s + t > test266151307():
                revert with 0, 65
            _6306 = mem[64] + (32 * s + t) + 32
            mem[mem[64] + (32 * s + t) + 32] = s + t
            mem[64] = _6306 + (32 * s + t) + 32
            if not s + t:
                _7756 = mem[mem[ceil32(return_data.size) + 160]]
                idx = 0
                u = 0
                while idx < _7756:
                    mem[0] = arg1
                    mem[32] = 1
                    mem[mem[64] + 32] = idx
                    mem[mem[64] + 64] = stor1[arg1].field_512
                    mem[mem[64] + 96] = stor8
                    _7827 = mem[64]
                    mem[mem[64]] = 96
                    mem[64] = mem[64] + 128
                    if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                        revert with 0, 50
                    if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        revert with 0, 18
                    if sha3(mem[_7827 + 32 len mem[_7827]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        if idx == -1:
                            revert with 0, 17
                        _7756 = mem[mem[ceil32(return_data.size) + 160]]
                        idx = idx + 1
                        u = u
                        continue 
                    if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                        revert with 0, 50
                    if u >= mem[_6060]:
                        revert with 0, 50
                    mem[(32 * u) + _6060 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                    if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                        revert with 0, 50
                    if u >= mem[_6306]:
                        revert with 0, 50
                    mem[(32 * u) + _6306 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                    if u == -1:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _7756 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = idx + 1
                    u = u + 1
                    continue 
                idx = 0
                while idx < stor5.length:
                    mem[0] = 5
                    _9434 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_9434] = address(stor5[idx].field_0)
                    mem[_9434 + 32] = address(stor5[idx].field_256)
                    mem[0] = address(stor5[idx].field_0)
                    mem[32] = sha3(arg1, 1) + 3
                    if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                        _9502 = mem[64]
                        mem[mem[64]] = 0
                        mem[mem[64] + 32] = 0
                        mem[64] = mem[64] + 64
                        _10559 = mem[_9502]
                        s = 0
                        t = u
                        while s < _10559:
                            if s >= mem[_9502]:
                                revert with 0, 50
                            if t >= mem[_6060]:
                                revert with 0, 50
                            mem[(32 * t) + _6060 + 32] = mem[(32 * s) + _9502 + 32]
                            if s >= mem[_9502 + 32]:
                                revert with 0, 50
                            if t >= mem[_6306]:
                                revert with 0, 50
                            mem[(32 * t) + _6306 + 32] = mem[(32 * s) + _9502 + 64]
                            if t == -1:
                                revert with 0, 17
                            if s == -1:
                                revert with 0, 17
                            _10559 = mem[_9502]
                            s = s + 1
                            t = t + 1
                            continue 
                    else:
                        mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = arg1
                        mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                        require ext_code.size(address(stor5[idx].field_256))
                        staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                                gas gas_remaining wei
                               args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _9776 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 64
                        _9863 = mem[_9776]
                        require mem[_9776] <= test266151307()
                        require _9776 + mem[_9776] + 31 < _9776 + return_data.size
                        _9966 = mem[_9776 + mem[_9776]]
                        if mem[_9776 + mem[_9776]] > test266151307():
                            revert with 0, 65
                        if ceil32(32 * mem[_9776 + mem[_9776]]) + 1 < 0 or _9776 + ceil32(return_data.size) + ceil32(32 * mem[_9776 + mem[_9776]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = _9776 + ceil32(return_data.size) + ceil32(32 * mem[_9776 + mem[_9776]]) + 1
                        mem[_9776 + ceil32(return_data.size)] = _9966
                        require _9863 + (32 * _9966) + 32 <= return_data.size
                        s = 0
                        t = _9776 + _9863 + 32
                        v = _9776 + ceil32(return_data.size) + 32
                        while s < _9966:
                            mem[v] = mem[t]
                            s = s + 1
                            t = t + 32
                            v = v + 32
                            continue 
                        _10700 = mem[_9776 + 32]
                        require mem[_9776 + 32] <= test266151307()
                        require _9776 + mem[_9776 + 32] + 31 < _9776 + return_data.size
                        _10858 = mem[_9776 + mem[_9776 + 32]]
                        if mem[_9776 + mem[_9776 + 32]] > test266151307():
                            revert with 0, 65
                        _10942 = mem[64]
                        if mem[64] + ceil32(32 * mem[_9776 + mem[_9776 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_9776 + mem[_9776 + 32]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = mem[64] + ceil32(32 * mem[_9776 + mem[_9776 + 32]]) + 1
                        mem[_10942] = _10858
                        require _10700 + (32 * _10858) + 32 <= return_data.size
                        s = 0
                        t = _9776 + _10700 + 32
                        v = _10942 + 32
                        while s < _10858:
                            mem[v] = mem[t]
                            s = s + 1
                            t = t + 32
                            v = v + 32
                            continue 
                        _11727 = mem[_9776 + ceil32(return_data.size)]
                        s = 0
                        t = u
                        while s < _11727:
                            if s >= mem[_9776 + ceil32(return_data.size)]:
                                revert with 0, 50
                            if t >= mem[_6060]:
                                revert with 0, 50
                            mem[(32 * t) + _6060 + 32] = mem[(32 * s) + _9776 + ceil32(return_data.size) + 32]
                            if s >= mem[_10942]:
                                revert with 0, 50
                            if t >= mem[_6306]:
                                revert with 0, 50
                            mem[(32 * t) + _6306 + 32] = mem[(32 * s) + _10942 + 32]
                            if t == -1:
                                revert with 0, 17
                            if s == -1:
                                revert with 0, 17
                            _11727 = mem[_9776 + ceil32(return_data.size)]
                            s = s + 1
                            t = t + 1
                            continue 
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                if s > !t:
                    revert with 0, 17
                if u != s + t:
                    revert with 0, 1
                if arg2 >= stor5.length:
                    revert with 0, 50
                mem[0] = 5
                _9552 = mem[64]
                mem[64] = mem[64] + 64
                mem[_9552] = address(stor5[arg2].field_0)
                mem[_9552 + 32] = address(stor5[arg2].field_256)
                mem[0] = address(stor5[arg2].field_0)
                mem[32] = sha3(arg1, 1) + 3
                if not stor1[arg1][3][address(stor5[arg2].field_0)].field_0:
                    _9641 = mem[64]
                    mem[64] = mem[64] + 32
                    mem[_9641 + 32] = 32
                    mem[_9641 + 64] = mem[_9641]
                    mem[_9641 + 96 len 32 * mem[_9641]] = mem[_9641 + 32 len 32 * mem[_9641]]
                    var69001 = mem[_9641]
                    var69002 = _9641 + (32 * mem[_9641]) + 32
                    return memory
                      from mem[64]
                       len _9641 + (32 * mem[_9641]) + -mem[64] + 96
                if stor1[arg1][3][address(stor5[arg2].field_0)].field_0 < 1:
                    revert with 0, 17
                mem[mem[64]] = 0x26148aa500000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 96
                _9913 = mem[_6060]
                mem[mem[64] + 100] = mem[_6060]
                mem[mem[64] + 132 len 32 * _9913] = mem[_6060 + 32 len 32 * _9913]
                var70001 = _9913
                var70002 = _6060 + (32 * _9913) + 32
                mem[mem[64] + 36] = arg1
                mem[mem[64] + 68] = stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1
                require ext_code.size(address(stor5[arg2].field_256))
                staticcall address(stor5[arg2].field_256).0x26148aa5 with:
                        gas gas_remaining wei
                       args 96, arg1, stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1, mem[mem[64] + 100 len (32 * _9913) + 32]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _10857 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _10910 = mem[_10857]
                require mem[_10857] <= test266151307()
                require _10857 + mem[_10857] + 31 < _10857 + return_data.size
                _10983 = mem[_10857 + mem[_10857]]
                if mem[_10857 + mem[_10857]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_10857 + mem[_10857]]) + 1 < 0 or _10857 + ceil32(return_data.size) + ceil32(32 * mem[_10857 + mem[_10857]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _10857 + ceil32(return_data.size) + ceil32(32 * mem[_10857 + mem[_10857]]) + 1
                mem[_10857 + ceil32(return_data.size)] = _10983
                require _10910 + (32 * _10983) + 32 <= return_data.size
                mem[_10857 + ceil32(return_data.size) + 32 len 32 * _10983] = mem[_10857 + _10910 + 32 len 32 * _10983]
                var89001 = _10983
                var89002 = _10857 + _10910 + (32 * _10983) + 32
                var89004 = _10857 + ceil32(return_data.size) + (32 * _10983) + 32
                mem[mem[64]] = 32
                mem[mem[64] + 32] = _10983
                mem[mem[64] + 64 len 32 * _10983] = mem[_10857 + ceil32(return_data.size) + 32 len 32 * _10983]
                return Array(len=_10983, data=mem[mem[64] + 64 len 32 * _10983])
            mem[_6306 + 32 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
            _7758 = mem[mem[ceil32(return_data.size) + 160]]
            idx = 0
            u = 0
            while idx < _7758:
                mem[0] = arg1
                mem[32] = 1
                mem[mem[64] + 32] = idx
                mem[mem[64] + 64] = stor1[arg1].field_512
                mem[mem[64] + 96] = stor8
                _7834 = mem[64]
                mem[mem[64]] = 96
                mem[64] = mem[64] + 128
                if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                    revert with 0, 50
                if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    revert with 0, 18
                if sha3(mem[_7834 + 32 len mem[_7834]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    if idx == -1:
                        revert with 0, 17
                    _7758 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = idx + 1
                    u = u
                    continue 
                if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                    revert with 0, 50
                if u >= mem[_6060]:
                    revert with 0, 50
                mem[(32 * u) + _6060 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                    revert with 0, 50
                if u >= mem[_6306]:
                    revert with 0, 50
                mem[(32 * u) + _6306 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                if u == -1:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _7758 = mem[mem[ceil32(return_data.size) + 160]]
                idx = idx + 1
                u = u + 1
                continue 
            idx = 0
            while idx < stor5.length:
                mem[0] = 5
                _9439 = mem[64]
                mem[64] = mem[64] + 64
                mem[_9439] = address(stor5[idx].field_0)
                mem[_9439 + 32] = address(stor5[idx].field_256)
                mem[0] = address(stor5[idx].field_0)
                mem[32] = sha3(arg1, 1) + 3
                if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                    _9503 = mem[64]
                    mem[mem[64]] = 0
                    mem[mem[64] + 32] = 0
                    mem[64] = mem[64] + 64
                    _10560 = mem[_9503]
                    s = 0
                    t = u
                    while s < _10560:
                        if s >= mem[_9503]:
                            revert with 0, 50
                        if t >= mem[_6060]:
                            revert with 0, 50
                        mem[(32 * t) + _6060 + 32] = mem[(32 * s) + _9503 + 32]
                        if s >= mem[_9503 + 32]:
                            revert with 0, 50
                        if t >= mem[_6306]:
                            revert with 0, 50
                        mem[(32 * t) + _6306 + 32] = mem[(32 * s) + _9503 + 64]
                        if t == -1:
                            revert with 0, 17
                        if s == -1:
                            revert with 0, 17
                        _10560 = mem[_9503]
                        s = s + 1
                        t = t + 1
                        continue 
                else:
                    mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = arg1
                    mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    require ext_code.size(address(stor5[idx].field_256))
                    staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                            gas gas_remaining wei
                           args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _9780 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 64
                    _9867 = mem[_9780]
                    require mem[_9780] <= test266151307()
                    require _9780 + mem[_9780] + 31 < _9780 + return_data.size
                    _9968 = mem[_9780 + mem[_9780]]
                    if mem[_9780 + mem[_9780]] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[_9780 + mem[_9780]]) + 1 < 0 or _9780 + ceil32(return_data.size) + ceil32(32 * mem[_9780 + mem[_9780]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = _9780 + ceil32(return_data.size) + ceil32(32 * mem[_9780 + mem[_9780]]) + 1
                    mem[_9780 + ceil32(return_data.size)] = _9968
                    require _9867 + (32 * _9968) + 32 <= return_data.size
                    s = 0
                    t = _9780 + _9867 + 32
                    v = _9780 + ceil32(return_data.size) + 32
                    while s < _9968:
                        mem[v] = mem[t]
                        s = s + 1
                        t = t + 32
                        v = v + 32
                        continue 
                    _10703 = mem[_9780 + 32]
                    require mem[_9780 + 32] <= test266151307()
                    require _9780 + mem[_9780 + 32] + 31 < _9780 + return_data.size
                    _10860 = mem[_9780 + mem[_9780 + 32]]
                    if mem[_9780 + mem[_9780 + 32]] > test266151307():
                        revert with 0, 65
                    _10943 = mem[64]
                    if mem[64] + ceil32(32 * mem[_9780 + mem[_9780 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_9780 + mem[_9780 + 32]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = mem[64] + ceil32(32 * mem[_9780 + mem[_9780 + 32]]) + 1
                    mem[_10943] = _10860
                    require _10703 + (32 * _10860) + 32 <= return_data.size
                    s = 0
                    t = _9780 + _10703 + 32
                    v = _10943 + 32
                    while s < _10860:
                        mem[v] = mem[t]
                        s = s + 1
                        t = t + 32
                        v = v + 32
                        continue 
                    _11728 = mem[_9780 + ceil32(return_data.size)]
                    s = 0
                    t = u
                    while s < _11728:
                        if s >= mem[_9780 + ceil32(return_data.size)]:
                            revert with 0, 50
                        if t >= mem[_6060]:
                            revert with 0, 50
                        mem[(32 * t) + _6060 + 32] = mem[(32 * s) + _9780 + ceil32(return_data.size) + 32]
                        if s >= mem[_10943]:
                            revert with 0, 50
                        if t >= mem[_6306]:
                            revert with 0, 50
                        mem[(32 * t) + _6306 + 32] = mem[(32 * s) + _10943 + 32]
                        if t == -1:
                            revert with 0, 17
                        if s == -1:
                            revert with 0, 17
                        _11728 = mem[_9780 + ceil32(return_data.size)]
                        s = s + 1
                        t = t + 1
                        continue 
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            if s > !t:
                revert with 0, 17
            if u != s + t:
                revert with 0, 1
            if arg2 >= stor5.length:
                revert with 0, 50
            mem[0] = 5
            _9557 = mem[64]
            mem[64] = mem[64] + 64
            mem[_9557] = address(stor5[arg2].field_0)
            mem[_9557 + 32] = address(stor5[arg2].field_256)
            mem[0] = address(stor5[arg2].field_0)
            mem[32] = sha3(arg1, 1) + 3
            if not stor1[arg1][3][address(stor5[arg2].field_0)].field_0:
                _9647 = mem[64]
                mem[64] = mem[64] + 32
                mem[_9647 + 32] = 32
                mem[_9647 + 64] = mem[_9647]
                mem[_9647 + 96 len 32 * mem[_9647]] = mem[_9647 + 32 len 32 * mem[_9647]]
                var70001 = mem[_9647]
                var70002 = _9647 + (32 * mem[_9647]) + 32
                return memory
                  from mem[64]
                   len _9647 + (32 * mem[_9647]) + -mem[64] + 96
            if stor1[arg1][3][address(stor5[arg2].field_0)].field_0 < 1:
                revert with 0, 17
            mem[mem[64]] = 0x26148aa500000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 96
            _9914 = mem[_6060]
            mem[mem[64] + 100] = mem[_6060]
            mem[mem[64] + 132 len 32 * _9914] = mem[_6060 + 32 len 32 * _9914]
            var71001 = _9914
            mem[mem[64] + 36] = arg1
            mem[mem[64] + 68] = stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1
            require ext_code.size(address(stor5[arg2].field_256))
            staticcall address(stor5[arg2].field_256).0x26148aa5 with:
                    gas gas_remaining wei
                   args 96, arg1, stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1, mem[mem[64] + 100 len (32 * _9914) + 32]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _10859 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _10911 = mem[_10859]
            require mem[_10859] <= test266151307()
            require _10859 + mem[_10859] + 31 < _10859 + return_data.size
            _10984 = mem[_10859 + mem[_10859]]
            if mem[_10859 + mem[_10859]] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[_10859 + mem[_10859]]) + 1 < 0 or _10859 + ceil32(return_data.size) + ceil32(32 * mem[_10859 + mem[_10859]]) + 1 > test266151307():
                revert with 0, 65
            mem[64] = _10859 + ceil32(return_data.size) + ceil32(32 * mem[_10859 + mem[_10859]]) + 1
            mem[_10859 + ceil32(return_data.size)] = _10984
            require _10911 + (32 * _10984) + 32 <= return_data.size
            mem[_10859 + ceil32(return_data.size) + 32 len 32 * _10984] = mem[_10859 + _10911 + 32 len 32 * _10984]
            var90001 = _10984
            var90002 = _10859 + _10911 + (32 * _10984) + 32
            var90004 = _10859 + ceil32(return_data.size) + (32 * _10984) + 32
            mem[mem[64]] = 32
            mem[mem[64] + 32] = _10984
            mem[mem[64] + 64 len 32 * _10984] = mem[_10859 + ceil32(return_data.size) + 32 len 32 * _10984]
            return Array(len=_10984, data=mem[mem[64] + 64 len 32 * _10984])
        mem[mem[64] + 32 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
        if s > !t:
            revert with 0, 17
        if s + t > test266151307():
            revert with 0, 65
        mem[mem[64] + (32 * s + t) + 32] = s + t
        mem[64] = _6060 + (64 * s + t) + 64
        if not s + t:
            _7760 = mem[mem[ceil32(return_data.size) + 160]]
            idx = 0
            u = 0
            while idx < _7760:
                mem[0] = arg1
                mem[32] = 1
                mem[mem[64] + 32] = idx
                mem[mem[64] + 64] = stor1[arg1].field_512
                mem[mem[64] + 96] = stor8
                _7841 = mem[64]
                mem[mem[64]] = 96
                mem[64] = mem[64] + 128
                if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                    revert with 0, 50
                if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    revert with 0, 18
                if sha3(mem[_7841 + 32 len mem[_7841]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    if idx == -1:
                        revert with 0, 17
                    _7760 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = idx + 1
                    u = u
                    continue 
                if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                    revert with 0, 50
                if u >= mem[_6060]:
                    revert with 0, 50
                mem[(32 * u) + _6060 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                    revert with 0, 50
                if u >= mem[_6060 + (32 * s + t) + 32]:
                    revert with 0, 50
                mem[(32 * u) + _6060 + (32 * s + t) + 64] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                if u == -1:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _7760 = mem[mem[ceil32(return_data.size) + 160]]
                idx = idx + 1
                u = u + 1
                continue 
            idx = 0
            while idx < stor5.length:
                mem[0] = 5
                _9444 = mem[64]
                mem[64] = mem[64] + 64
                mem[_9444] = address(stor5[idx].field_0)
                mem[_9444 + 32] = address(stor5[idx].field_256)
                mem[0] = address(stor5[idx].field_0)
                mem[32] = sha3(arg1, 1) + 3
                if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                    _9504 = mem[64]
                    mem[mem[64]] = 0
                    mem[mem[64] + 32] = 0
                    mem[64] = mem[64] + 64
                    _10561 = mem[_9504]
                    v = 0
                    w = u
                    while v < _10561:
                        if v >= mem[_9504]:
                            revert with 0, 50
                        if w >= mem[_6060]:
                            revert with 0, 50
                        mem[(32 * w) + _6060 + 32] = mem[(32 * v) + _9504 + 32]
                        if v >= mem[_9504 + 32]:
                            revert with 0, 50
                        if w >= mem[_6060 + (32 * s + t) + 32]:
                            revert with 0, 50
                        mem[(32 * w) + _6060 + (32 * s + t) + 64] = mem[(32 * v) + _9504 + 64]
                        if w == -1:
                            revert with 0, 17
                        if v == -1:
                            revert with 0, 17
                        _10561 = mem[_9504]
                        v = v + 1
                        w = w + 1
                        continue 
                else:
                    mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = arg1
                    mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    require ext_code.size(address(stor5[idx].field_256))
                    staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                            gas gas_remaining wei
                           args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _9784 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 64
                    _9871 = mem[_9784]
                    require mem[_9784] <= test266151307()
                    require _9784 + mem[_9784] + 31 < _9784 + return_data.size
                    _9970 = mem[_9784 + mem[_9784]]
                    if mem[_9784 + mem[_9784]] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[_9784 + mem[_9784]]) + 1 < 0 or _9784 + ceil32(return_data.size) + ceil32(32 * mem[_9784 + mem[_9784]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = _9784 + ceil32(return_data.size) + ceil32(32 * mem[_9784 + mem[_9784]]) + 1
                    mem[_9784 + ceil32(return_data.size)] = _9970
                    require _9871 + (32 * _9970) + 32 <= return_data.size
                    v = 0
                    w = _9784 + _9871 + 32
                    x = _9784 + ceil32(return_data.size) + 32
                    while v < _9970:
                        mem[x] = mem[w]
                        v = v + 1
                        w = w + 32
                        x = x + 32
                        continue 
                    _10706 = mem[_9784 + 32]
                    require mem[_9784 + 32] <= test266151307()
                    require _9784 + mem[_9784 + 32] + 31 < _9784 + return_data.size
                    _10862 = mem[_9784 + mem[_9784 + 32]]
                    if mem[_9784 + mem[_9784 + 32]] > test266151307():
                        revert with 0, 65
                    _10944 = mem[64]
                    if mem[64] + ceil32(32 * mem[_9784 + mem[_9784 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_9784 + mem[_9784 + 32]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = mem[64] + ceil32(32 * mem[_9784 + mem[_9784 + 32]]) + 1
                    mem[_10944] = _10862
                    require _10706 + (32 * _10862) + 32 <= return_data.size
                    v = 0
                    w = _9784 + _10706 + 32
                    x = _10944 + 32
                    while v < _10862:
                        mem[x] = mem[w]
                        v = v + 1
                        w = w + 32
                        x = x + 32
                        continue 
                    _11729 = mem[_9784 + ceil32(return_data.size)]
                    v = 0
                    w = u
                    while v < _11729:
                        if v >= mem[_9784 + ceil32(return_data.size)]:
                            revert with 0, 50
                        if w >= mem[_6060]:
                            revert with 0, 50
                        mem[(32 * w) + _6060 + 32] = mem[(32 * v) + _9784 + ceil32(return_data.size) + 32]
                        if v >= mem[_10944]:
                            revert with 0, 50
                        if w >= mem[_6060 + (32 * s + t) + 32]:
                            revert with 0, 50
                        mem[(32 * w) + _6060 + (32 * s + t) + 64] = mem[(32 * v) + _10944 + 32]
                        if w == -1:
                            revert with 0, 17
                        if v == -1:
                            revert with 0, 17
                        _11729 = mem[_9784 + ceil32(return_data.size)]
                        v = v + 1
                        w = w + 1
                        continue 
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            if s > !t:
                revert with 0, 17
            if u != s + t:
                revert with 0, 1
            if arg2 >= stor5.length:
                revert with 0, 50
            mem[0] = 5
            _9562 = mem[64]
            mem[64] = mem[64] + 64
            mem[_9562] = address(stor5[arg2].field_0)
            mem[_9562 + 32] = address(stor5[arg2].field_256)
            mem[0] = address(stor5[arg2].field_0)
            mem[32] = sha3(arg1, 1) + 3
            if not stor1[arg1][3][address(stor5[arg2].field_0)].field_0:
                _9653 = mem[64]
                mem[64] = mem[64] + 32
                mem[_9653 + 32] = 32
                mem[_9653 + 64] = mem[_9653]
                mem[_9653 + 96 len 32 * mem[_9653]] = mem[_9653 + 32 len 32 * mem[_9653]]
                var70001 = mem[_9653]
                var70002 = _9653 + (32 * mem[_9653]) + 32
                return memory
                  from mem[64]
                   len _9653 + (32 * mem[_9653]) + -mem[64] + 96
            if stor1[arg1][3][address(stor5[arg2].field_0)].field_0 < 1:
                revert with 0, 17
            mem[mem[64]] = 0x26148aa500000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 96
            _9915 = mem[_6060]
            mem[mem[64] + 100] = mem[_6060]
            mem[mem[64] + 132 len 32 * _9915] = mem[_6060 + 32 len 32 * _9915]
            var71001 = _9915
            mem[mem[64] + 36] = arg1
            mem[mem[64] + 68] = stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1
            require ext_code.size(address(stor5[arg2].field_256))
            staticcall address(stor5[arg2].field_256).0x26148aa5 with:
                    gas gas_remaining wei
                   args 96, arg1, stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1, mem[mem[64] + 100 len (32 * _9915) + 32]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _10861 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _10912 = mem[_10861]
            require mem[_10861] <= test266151307()
            require _10861 + mem[_10861] + 31 < _10861 + return_data.size
            _10985 = mem[_10861 + mem[_10861]]
            if mem[_10861 + mem[_10861]] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[_10861 + mem[_10861]]) + 1 < 0 or _10861 + ceil32(return_data.size) + ceil32(32 * mem[_10861 + mem[_10861]]) + 1 > test266151307():
                revert with 0, 65
            mem[64] = _10861 + ceil32(return_data.size) + ceil32(32 * mem[_10861 + mem[_10861]]) + 1
            mem[_10861 + ceil32(return_data.size)] = _10985
            require _10912 + (32 * _10985) + 32 <= return_data.size
            mem[_10861 + ceil32(return_data.size) + 32 len 32 * _10985] = mem[_10861 + _10912 + 32 len 32 * _10985]
            var90001 = _10985
            var90002 = _10861 + _10912 + (32 * _10985) + 32
            var90004 = _10861 + ceil32(return_data.size) + (32 * _10985) + 32
            mem[mem[64]] = 32
            mem[mem[64] + 32] = _10985
            mem[mem[64] + 64 len 32 * _10985] = mem[_10861 + ceil32(return_data.size) + 32 len 32 * _10985]
            return Array(len=_10985, data=mem[mem[64] + 64 len 32 * _10985])
        mem[_6060 + (32 * s + t) + 64 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
        _7762 = mem[mem[ceil32(return_data.size) + 160]]
        idx = 0
        u = 0
        while idx < _7762:
            mem[0] = arg1
            mem[32] = 1
            mem[mem[64] + 32] = idx
            mem[mem[64] + 64] = stor1[arg1].field_512
            mem[mem[64] + 96] = stor8
            _7848 = mem[64]
            mem[mem[64]] = 96
            mem[64] = mem[64] + 128
            if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                revert with 0, 50
            if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                revert with 0, 18
            if sha3(mem[_7848 + 32 len mem[_7848]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                if idx == -1:
                    revert with 0, 17
                _7762 = mem[mem[ceil32(return_data.size) + 160]]
                idx = idx + 1
                u = u
                continue 
            if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                revert with 0, 50
            if u >= mem[_6060]:
                revert with 0, 50
            mem[(32 * u) + _6060 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
            if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                revert with 0, 50
            if u >= mem[_6060 + (32 * s + t) + 32]:
                revert with 0, 50
            mem[(32 * u) + _6060 + (32 * s + t) + 64] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
            if u == -1:
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            _7762 = mem[mem[ceil32(return_data.size) + 160]]
            idx = idx + 1
            u = u + 1
            continue 
        idx = 0
        while idx < stor5.length:
            mem[0] = 5
            _9449 = mem[64]
            mem[64] = mem[64] + 64
            mem[_9449] = address(stor5[idx].field_0)
            mem[_9449 + 32] = address(stor5[idx].field_256)
            mem[0] = address(stor5[idx].field_0)
            mem[32] = sha3(arg1, 1) + 3
            if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                _9505 = mem[64]
                mem[mem[64]] = 0
                mem[mem[64] + 32] = 0
                mem[64] = mem[64] + 64
                _10562 = mem[_9505]
                v = 0
                w = u
                while v < _10562:
                    if v >= mem[_9505]:
                        revert with 0, 50
                    if w >= mem[_6060]:
                        revert with 0, 50
                    mem[(32 * w) + _6060 + 32] = mem[(32 * v) + _9505 + 32]
                    if v >= mem[_9505 + 32]:
                        revert with 0, 50
                    if w >= mem[_6060 + (32 * s + t) + 32]:
                        revert with 0, 50
                    mem[(32 * w) + _6060 + (32 * s + t) + 64] = mem[(32 * v) + _9505 + 64]
                    if w == -1:
                        revert with 0, 17
                    if v == -1:
                        revert with 0, 17
                    _10562 = mem[_9505]
                    v = v + 1
                    w = w + 1
                    continue 
            else:
                mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = arg1
                mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                require ext_code.size(address(stor5[idx].field_256))
                staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                        gas gas_remaining wei
                       args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _9788 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 64
                _9875 = mem[_9788]
                require mem[_9788] <= test266151307()
                require _9788 + mem[_9788] + 31 < _9788 + return_data.size
                _9972 = mem[_9788 + mem[_9788]]
                if mem[_9788 + mem[_9788]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_9788 + mem[_9788]]) + 1 < 0 or _9788 + ceil32(return_data.size) + ceil32(32 * mem[_9788 + mem[_9788]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _9788 + ceil32(return_data.size) + ceil32(32 * mem[_9788 + mem[_9788]]) + 1
                mem[_9788 + ceil32(return_data.size)] = _9972
                require _9875 + (32 * _9972) + 32 <= return_data.size
                v = 0
                w = _9788 + _9875 + 32
                x = _9788 + ceil32(return_data.size) + 32
                while v < _9972:
                    mem[x] = mem[w]
                    v = v + 1
                    w = w + 32
                    x = x + 32
                    continue 
                _10709 = mem[_9788 + 32]
                require mem[_9788 + 32] <= test266151307()
                require _9788 + mem[_9788 + 32] + 31 < _9788 + return_data.size
                _10864 = mem[_9788 + mem[_9788 + 32]]
                if mem[_9788 + mem[_9788 + 32]] > test266151307():
                    revert with 0, 65
                _10945 = mem[64]
                if mem[64] + ceil32(32 * mem[_9788 + mem[_9788 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_9788 + mem[_9788 + 32]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = mem[64] + ceil32(32 * mem[_9788 + mem[_9788 + 32]]) + 1
                mem[_10945] = _10864
                require _10709 + (32 * _10864) + 32 <= return_data.size
                v = 0
                w = _9788 + _10709 + 32
                x = _10945 + 32
                while v < _10864:
                    mem[x] = mem[w]
                    v = v + 1
                    w = w + 32
                    x = x + 32
                    continue 
                _11730 = mem[_9788 + ceil32(return_data.size)]
                v = 0
                w = u
                while v < _11730:
                    if v >= mem[_9788 + ceil32(return_data.size)]:
                        revert with 0, 50
                    if w >= mem[_6060]:
                        revert with 0, 50
                    mem[(32 * w) + _6060 + 32] = mem[(32 * v) + _9788 + ceil32(return_data.size) + 32]
                    if v >= mem[_10945]:
                        revert with 0, 50
                    if w >= mem[_6060 + (32 * s + t) + 32]:
                        revert with 0, 50
                    mem[(32 * w) + _6060 + (32 * s + t) + 64] = mem[(32 * v) + _10945 + 32]
                    if w == -1:
                        revert with 0, 17
                    if v == -1:
                        revert with 0, 17
                    _11730 = mem[_9788 + ceil32(return_data.size)]
                    v = v + 1
                    w = w + 1
                    continue 
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        if s > !t:
            revert with 0, 17
        if u != s + t:
            revert with 0, 1
        if arg2 >= stor5.length:
            revert with 0, 50
        mem[0] = 5
        _9567 = mem[64]
        mem[64] = mem[64] + 64
        mem[_9567] = address(stor5[arg2].field_0)
        mem[_9567 + 32] = address(stor5[arg2].field_256)
        mem[0] = address(stor5[arg2].field_0)
        mem[32] = sha3(arg1, 1) + 3
        if not stor1[arg1][3][address(stor5[arg2].field_0)].field_0:
            _9659 = mem[64]
            mem[64] = mem[64] + 32
            mem[_9659 + 32] = 32
            mem[_9659 + 64] = mem[_9659]
            mem[_9659 + 96 len 32 * mem[_9659]] = mem[_9659 + 32 len 32 * mem[_9659]]
            var71001 = mem[_9659]
            return memory
              from mem[64]
               len _9659 + (32 * mem[_9659]) + -mem[64] + 96
        if stor1[arg1][3][address(stor5[arg2].field_0)].field_0 < 1:
            revert with 0, 17
        mem[mem[64]] = 0x26148aa500000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = 96
        _9916 = mem[_6060]
        mem[mem[64] + 100] = mem[_6060]
        mem[mem[64] + 132 len 32 * _9916] = mem[_6060 + 32 len 32 * _9916]
        var72001 = _9916
        mem[mem[64] + 36] = arg1
        mem[mem[64] + 68] = stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1
        require ext_code.size(address(stor5[arg2].field_256))
        staticcall address(stor5[arg2].field_256).0x26148aa5 with:
                gas gas_remaining wei
               args 96, arg1, stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1, mem[mem[64] + 100 len (32 * _9916) + 32]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _10863 = mem[64]
        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _10913 = mem[_10863]
        require mem[_10863] <= test266151307()
        require _10863 + mem[_10863] + 31 < _10863 + return_data.size
        _10986 = mem[_10863 + mem[_10863]]
        if mem[_10863 + mem[_10863]] > test266151307():
            revert with 0, 65
        if ceil32(32 * mem[_10863 + mem[_10863]]) + 1 < 0 or _10863 + ceil32(return_data.size) + ceil32(32 * mem[_10863 + mem[_10863]]) + 1 > test266151307():
            revert with 0, 65
        mem[64] = _10863 + ceil32(return_data.size) + ceil32(32 * mem[_10863 + mem[_10863]]) + 1
        mem[_10863 + ceil32(return_data.size)] = _10986
        require _10913 + (32 * _10986) + 32 <= return_data.size
        mem[_10863 + ceil32(return_data.size) + 32 len 32 * _10986] = mem[_10863 + _10913 + 32 len 32 * _10986]
        var91001 = _10986
        var91002 = _10863 + _10913 + (32 * _10986) + 32
        var91004 = _10863 + ceil32(return_data.size) + (32 * _10986) + 32
        mem[mem[64]] = 32
        mem[mem[64] + 32] = _10986
        mem[mem[64] + 64 len 32 * _10986] = mem[_10863 + ceil32(return_data.size) + 32 len 32 * _10986]
        return Array(len=_10986, data=mem[mem[64] + 64 len 32 * _10986])
    mem[0] = sha3(ext_call.return_data[31 len 1], 10)
    mem[ceil32(return_data.size) + 224] = stor10[ext_call.return_data[31 len 1]].field_0
    idx = ceil32(return_data.size) + 224
    s = 0
    while ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + 192 > idx:
        mem[idx + 32] = stor10[ext_call.return_data[31 len 1]][s].field_256
        idx = idx + 32
        s = s + 1
        continue 
    mem[ceil32(return_data.size) + 96] = ceil32(return_data.size) + 192
    mem[ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + 224] = stor10[ext_call.return_data[31 len 1]].field_256
    if not stor10[ext_call.return_data[31 len 1]].field_256:
        mem[ceil32(return_data.size) + 128] = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + 224
        mem[64] = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + (32 * stor10[ext_call.return_data[31 len 1]].field_512) + 288
        mem[ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 256] = stor10[ext_call.return_data[31 len 1]].field_512
        if not stor10[ext_call.return_data[31 len 1]].field_512:
            mem[ceil32(return_data.size) + 160] = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 256
            idx = 0
            s = 0
            while idx < stor10[ext_call.return_data[31 len 1]].field_512:
                mem[0] = arg1
                mem[32] = 1
                mem[mem[64] + 32] = idx
                mem[mem[64] + 64] = stor1[arg1].field_512
                mem[mem[64] + 96] = stor8
                _1194 = mem[64]
                mem[mem[64]] = 96
                mem[64] = mem[64] + 128
                if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                    revert with 0, 50
                if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    revert with 0, 18
                if sha3(mem[_1194 + 32 len mem[_1194]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s
                    continue 
                if s == -1:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s + 1
                continue 
            idx = 0
            t = 0
            while idx < stor5.length:
                mem[0] = 5
                _2489 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2489] = address(stor5[idx].field_0)
                mem[_2489 + 32] = address(stor5[idx].field_256)
                mem[0] = address(stor5[idx].field_0)
                mem[32] = sha3(arg1, 1) + 3
                if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                    _2504 = mem[64]
                    mem[mem[64]] = 0
                    mem[mem[64] + 32] = 0
                    mem[64] = mem[64] + 64
                    if t > !mem[_2504]:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    t = t + mem[_2504]
                    continue 
                mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = arg1
                mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                require ext_code.size(address(stor5[idx].field_256))
                staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                        gas gas_remaining wei
                       args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _2608 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 64
                _2652 = mem[_2608]
                require mem[_2608] <= test266151307()
                require _2608 + mem[_2608] + 31 < _2608 + return_data.size
                _2794 = mem[_2608 + mem[_2608]]
                if mem[_2608 + mem[_2608]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_2608 + mem[_2608]]) + 1 < 0 or _2608 + ceil32(return_data.size) + ceil32(32 * mem[_2608 + mem[_2608]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _2608 + ceil32(return_data.size) + ceil32(32 * mem[_2608 + mem[_2608]]) + 1
                mem[_2608 + ceil32(return_data.size)] = _2794
                require _2652 + (32 * _2794) + 32 <= return_data.size
                s = 0
                u = _2608 + _2652 + 32
                v = _2608 + ceil32(return_data.size) + 32
                while s < _2794:
                    mem[v] = mem[u]
                    s = s + 1
                    u = u + 32
                    v = v + 32
                    continue 
                _4114 = mem[_2608 + 32]
                require mem[_2608 + 32] <= test266151307()
                require _2608 + mem[_2608 + 32] + 31 < _2608 + return_data.size
                _4147 = mem[_2608 + mem[_2608 + 32]]
                if mem[_2608 + mem[_2608 + 32]] > test266151307():
                    revert with 0, 65
                _4408 = mem[64]
                if mem[64] + ceil32(32 * mem[_2608 + mem[_2608 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_2608 + mem[_2608 + 32]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = mem[64] + ceil32(32 * mem[_2608 + mem[_2608 + 32]]) + 1
                mem[_4408] = _4147
                require _4114 + (32 * _4147) + 32 <= return_data.size
                s = 0
                u = _2608 + _4114 + 32
                v = _4408 + 32
                while s < _4147:
                    mem[v] = mem[u]
                    s = s + 1
                    u = u + 32
                    v = v + 32
                    continue 
                if t > !mem[_2608 + ceil32(return_data.size)]:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                t = t + mem[_2608 + ceil32(return_data.size)]
                continue 
            if s > !t:
                revert with 0, 17
            if s + t > test266151307():
                revert with 0, 65
            _2503 = mem[64]
            mem[mem[64]] = s + t
            if s + t:
                mem[mem[64] + 32 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
                if s > !t:
                    revert with 0, 17
                if s + t > test266151307():
                    revert with 0, 65
                mem[mem[64] + (32 * s + t) + 32] = s + t
                mem[64] = _2503 + (64 * s + t) + 64
                if not s + t:
                    _3956 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = 0
                    u = 0
                    while idx < _3956:
                        mem[0] = arg1
                        mem[32] = 1
                        mem[mem[64] + 32] = idx
                        mem[mem[64] + 64] = stor1[arg1].field_512
                        mem[mem[64] + 96] = stor8
                        _4060 = mem[64]
                        mem[mem[64]] = 96
                        mem[64] = mem[64] + 128
                        if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                            revert with 0, 50
                        if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                            revert with 0, 18
                        if sha3(mem[_4060 + 32 len mem[_4060]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                            if idx == -1:
                                revert with 0, 17
                            _3956 = mem[mem[ceil32(return_data.size) + 160]]
                            idx = idx + 1
                            u = u
                            continue 
                        if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                            revert with 0, 50
                        if u >= mem[_2503]:
                            revert with 0, 50
                        mem[(32 * u) + _2503 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                        if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                            revert with 0, 50
                        if u >= mem[_2503 + (32 * s + t) + 32]:
                            revert with 0, 50
                        mem[(32 * u) + _2503 + (32 * s + t) + 64] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                        if u == -1:
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        _3956 = mem[mem[ceil32(return_data.size) + 160]]
                        idx = idx + 1
                        u = u + 1
                        continue 
                    idx = 0
                    while idx < stor5.length:
                        mem[0] = 5
                        _6031 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_6031] = address(stor5[idx].field_0)
                        mem[_6031 + 32] = address(stor5[idx].field_256)
                        mem[0] = address(stor5[idx].field_0)
                        mem[32] = sha3(arg1, 1) + 3
                        if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                            _6064 = mem[64]
                            mem[mem[64]] = 0
                            mem[mem[64] + 32] = 0
                            mem[64] = mem[64] + 64
                            _7765 = mem[_6064]
                            v = 0
                            w = u
                            while v < _7765:
                                if v >= mem[_6064]:
                                    revert with 0, 50
                                if w >= mem[_2503]:
                                    revert with 0, 50
                                mem[(32 * w) + _2503 + 32] = mem[(32 * v) + _6064 + 32]
                                if v >= mem[_6064 + 32]:
                                    revert with 0, 50
                                if w >= mem[_2503 + (32 * s + t) + 32]:
                                    revert with 0, 50
                                mem[(32 * w) + _2503 + (32 * s + t) + 64] = mem[(32 * v) + _6064 + 64]
                                if w == -1:
                                    revert with 0, 17
                                if v == -1:
                                    revert with 0, 17
                                _7765 = mem[_6064]
                                v = v + 1
                                w = w + 1
                                continue 
                        else:
                            mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = arg1
                            mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                            require ext_code.size(address(stor5[idx].field_256))
                            staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                                    gas gas_remaining wei
                                   args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _6317 = mem[64]
                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 64
                            _6403 = mem[_6317]
                            require mem[_6317] <= test266151307()
                            require _6317 + mem[_6317] + 31 < _6317 + return_data.size
                            _6557 = mem[_6317 + mem[_6317]]
                            if mem[_6317 + mem[_6317]] > test266151307():
                                revert with 0, 65
                            if ceil32(32 * mem[_6317 + mem[_6317]]) + 1 < 0 or _6317 + ceil32(return_data.size) + ceil32(32 * mem[_6317 + mem[_6317]]) + 1 > test266151307():
                                revert with 0, 65
                            mem[64] = _6317 + ceil32(return_data.size) + ceil32(32 * mem[_6317 + mem[_6317]]) + 1
                            mem[_6317 + ceil32(return_data.size)] = _6557
                            require _6403 + (32 * _6557) + 32 <= return_data.size
                            v = 0
                            w = _6317 + _6403 + 32
                            x = _6317 + ceil32(return_data.size) + 32
                            while v < _6557:
                                mem[x] = mem[w]
                                v = v + 1
                                w = w + 32
                                x = x + 32
                                continue 
                            _7978 = mem[_6317 + 32]
                            require mem[_6317 + 32] <= test266151307()
                            require _6317 + mem[_6317 + 32] + 31 < _6317 + return_data.size
                            _8093 = mem[_6317 + mem[_6317 + 32]]
                            if mem[_6317 + mem[_6317 + 32]] > test266151307():
                                revert with 0, 65
                            _8300 = mem[64]
                            if mem[64] + ceil32(32 * mem[_6317 + mem[_6317 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_6317 + mem[_6317 + 32]]) + 1 > test266151307():
                                revert with 0, 65
                            mem[64] = mem[64] + ceil32(32 * mem[_6317 + mem[_6317 + 32]]) + 1
                            mem[_8300] = _8093
                            require _7978 + (32 * _8093) + 32 <= return_data.size
                            v = 0
                            w = _6317 + _7978 + 32
                            x = _8300 + 32
                            while v < _8093:
                                mem[x] = mem[w]
                                v = v + 1
                                w = w + 32
                                x = x + 32
                                continue 
                            _10565 = mem[_6317 + ceil32(return_data.size)]
                            v = 0
                            w = u
                            while v < _10565:
                                if v >= mem[_6317 + ceil32(return_data.size)]:
                                    revert with 0, 50
                                if w >= mem[_2503]:
                                    revert with 0, 50
                                mem[(32 * w) + _2503 + 32] = mem[(32 * v) + _6317 + ceil32(return_data.size) + 32]
                                if v >= mem[_8300]:
                                    revert with 0, 50
                                if w >= mem[_2503 + (32 * s + t) + 32]:
                                    revert with 0, 50
                                mem[(32 * w) + _2503 + (32 * s + t) + 64] = mem[(32 * v) + _8300 + 32]
                                if w == -1:
                                    revert with 0, 17
                                if v == -1:
                                    revert with 0, 17
                                _10565 = mem[_6317 + ceil32(return_data.size)]
                                v = v + 1
                                w = w + 1
                                continue 
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
                    if s > !t:
                        revert with 0, 17
                    if u != s + t:
                        revert with 0, 1
                    if arg2 >= stor5.length:
                        revert with 0, 50
                    mem[0] = 5
                    _6135 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_6135] = address(stor5[arg2].field_0)
                    mem[_6135 + 32] = address(stor5[arg2].field_256)
                    mem[0] = address(stor5[arg2].field_0)
                    mem[32] = sha3(arg1, 1) + 3
                    if not stor1[arg1][3][address(stor5[arg2].field_0)].field_0:
                        _6227 = mem[64]
                        mem[64] = mem[64] + 32
                        mem[_6227 + 32] = 32
                        mem[_6227 + 64] = mem[_6227]
                        mem[_6227 + 96 len 32 * mem[_6227]] = mem[_6227 + 32 len 32 * mem[_6227]]
                        var66001 = mem[_6227]
                        var66002 = _6227 + (32 * mem[_6227]) + 32
                        return memory
                          from mem[64]
                           len _6227 + (32 * mem[_6227]) + -mem[64] + 96
                    if stor1[arg1][3][address(stor5[arg2].field_0)].field_0 < 1:
                        revert with 0, 17
                    mem[mem[64]] = 0x26148aa500000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 96
                    _6437 = mem[_2503]
                    mem[mem[64] + 100] = mem[_2503]
                    mem[mem[64] + 132 len 32 * _6437] = mem[_2503 + 32 len 32 * _6437]
                    var67001 = _6437
                    var67002 = _2503 + (32 * _6437) + 32
                    mem[mem[64] + 36] = arg1
                    mem[mem[64] + 68] = stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1
                    require ext_code.size(address(stor5[arg2].field_256))
                    staticcall address(stor5[arg2].field_256).0x26148aa5 with:
                            gas gas_remaining wei
                           args 96, arg1, stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1, mem[mem[64] + 100 len (32 * _6437) + 32]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _8092 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _8209 = mem[_8092]
                    require mem[_8092] <= test266151307()
                    require _8092 + mem[_8092] + 31 < _8092 + return_data.size
                    _8395 = mem[_8092 + mem[_8092]]
                    if mem[_8092 + mem[_8092]] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[_8092 + mem[_8092]]) + 1 < 0 or _8092 + ceil32(return_data.size) + ceil32(32 * mem[_8092 + mem[_8092]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = _8092 + ceil32(return_data.size) + ceil32(32 * mem[_8092 + mem[_8092]]) + 1
                    mem[_8092 + ceil32(return_data.size)] = _8395
                    require _8209 + (32 * _8395) + 32 <= return_data.size
                    mem[_8092 + ceil32(return_data.size) + 32 len 32 * _8395] = mem[_8092 + _8209 + 32 len 32 * _8395]
                    mem[mem[64]] = 32
                    mem[mem[64] + 32] = _8395
                    mem[mem[64] + 64 len 32 * _8395] = mem[_8092 + ceil32(return_data.size) + 32 len 32 * _8395]
                    var94001 = _8395
                    var94002 = _8092 + ceil32(return_data.size) + (32 * _8395) + 32
                    return Array(len=_8395, data=mem[mem[64] + 64 len 32 * _8395])
                mem[_2503 + (32 * s + t) + 64 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
                _3958 = mem[mem[ceil32(return_data.size) + 160]]
                idx = 0
                u = 0
                while idx < _3958:
                    mem[0] = arg1
                    mem[32] = 1
                    mem[mem[64] + 32] = idx
                    mem[mem[64] + 64] = stor1[arg1].field_512
                    mem[mem[64] + 96] = stor8
                    _4067 = mem[64]
                    mem[mem[64]] = 96
                    mem[64] = mem[64] + 128
                    if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                        revert with 0, 50
                    if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        revert with 0, 18
                    if sha3(mem[_4067 + 32 len mem[_4067]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        if idx == -1:
                            revert with 0, 17
                        _3958 = mem[mem[ceil32(return_data.size) + 160]]
                        idx = idx + 1
                        u = u
                        continue 
                    if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                        revert with 0, 50
                    if u >= mem[_2503]:
                        revert with 0, 50
                    mem[(32 * u) + _2503 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                    if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                        revert with 0, 50
                    if u >= mem[_2503 + (32 * s + t) + 32]:
                        revert with 0, 50
                    mem[(32 * u) + _2503 + (32 * s + t) + 64] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                    if u == -1:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _3958 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = idx + 1
                    u = u + 1
                    continue 
                idx = 0
                while idx < stor5.length:
                    mem[0] = 5
                    _6036 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_6036] = address(stor5[idx].field_0)
                    mem[_6036 + 32] = address(stor5[idx].field_256)
                    mem[0] = address(stor5[idx].field_0)
                    mem[32] = sha3(arg1, 1) + 3
                    if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                        _6065 = mem[64]
                        mem[mem[64]] = 0
                        mem[mem[64] + 32] = 0
                        mem[64] = mem[64] + 64
                        _7766 = mem[_6065]
                        v = 0
                        w = u
                        while v < _7766:
                            if v >= mem[_6065]:
                                revert with 0, 50
                            if w >= mem[_2503]:
                                revert with 0, 50
                            mem[(32 * w) + _2503 + 32] = mem[(32 * v) + _6065 + 32]
                            if v >= mem[_6065 + 32]:
                                revert with 0, 50
                            if w >= mem[_2503 + (32 * s + t) + 32]:
                                revert with 0, 50
                            mem[(32 * w) + _2503 + (32 * s + t) + 64] = mem[(32 * v) + _6065 + 64]
                            if w == -1:
                                revert with 0, 17
                            if v == -1:
                                revert with 0, 17
                            _7766 = mem[_6065]
                            v = v + 1
                            w = w + 1
                            continue 
                    else:
                        mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = arg1
                        mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                        require ext_code.size(address(stor5[idx].field_256))
                        staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                                gas gas_remaining wei
                               args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _6321 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 64
                        _6407 = mem[_6321]
                        require mem[_6321] <= test266151307()
                        require _6321 + mem[_6321] + 31 < _6321 + return_data.size
                        _6559 = mem[_6321 + mem[_6321]]
                        if mem[_6321 + mem[_6321]] > test266151307():
                            revert with 0, 65
                        if ceil32(32 * mem[_6321 + mem[_6321]]) + 1 < 0 or _6321 + ceil32(return_data.size) + ceil32(32 * mem[_6321 + mem[_6321]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = _6321 + ceil32(return_data.size) + ceil32(32 * mem[_6321 + mem[_6321]]) + 1
                        mem[_6321 + ceil32(return_data.size)] = _6559
                        require _6407 + (32 * _6559) + 32 <= return_data.size
                        v = 0
                        w = _6321 + _6407 + 32
                        x = _6321 + ceil32(return_data.size) + 32
                        while v < _6559:
                            mem[x] = mem[w]
                            v = v + 1
                            w = w + 32
                            x = x + 32
                            continue 
                        _7981 = mem[_6321 + 32]
                        require mem[_6321 + 32] <= test266151307()
                        require _6321 + mem[_6321 + 32] + 31 < _6321 + return_data.size
                        _8095 = mem[_6321 + mem[_6321 + 32]]
                        if mem[_6321 + mem[_6321 + 32]] > test266151307():
                            revert with 0, 65
                        _8301 = mem[64]
                        if mem[64] + ceil32(32 * mem[_6321 + mem[_6321 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_6321 + mem[_6321 + 32]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = mem[64] + ceil32(32 * mem[_6321 + mem[_6321 + 32]]) + 1
                        mem[_8301] = _8095
                        require _7981 + (32 * _8095) + 32 <= return_data.size
                        v = 0
                        w = _6321 + _7981 + 32
                        x = _8301 + 32
                        while v < _8095:
                            mem[x] = mem[w]
                            v = v + 1
                            w = w + 32
                            x = x + 32
                            continue 
                        _10566 = mem[_6321 + ceil32(return_data.size)]
                        v = 0
                        w = u
                        while v < _10566:
                            if v >= mem[_6321 + ceil32(return_data.size)]:
                                revert with 0, 50
                            if w >= mem[_2503]:
                                revert with 0, 50
                            mem[(32 * w) + _2503 + 32] = mem[(32 * v) + _6321 + ceil32(return_data.size) + 32]
                            if v >= mem[_8301]:
                                revert with 0, 50
                            if w >= mem[_2503 + (32 * s + t) + 32]:
                                revert with 0, 50
                            mem[(32 * w) + _2503 + (32 * s + t) + 64] = mem[(32 * v) + _8301 + 32]
                            if w == -1:
                                revert with 0, 17
                            if v == -1:
                                revert with 0, 17
                            _10566 = mem[_6321 + ceil32(return_data.size)]
                            v = v + 1
                            w = w + 1
                            continue 
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                if s > !t:
                    revert with 0, 17
                if u != s + t:
                    revert with 0, 1
                if arg2 >= stor5.length:
                    revert with 0, 50
                mem[0] = 5
                _6140 = mem[64]
                mem[64] = mem[64] + 64
                mem[_6140] = address(stor5[arg2].field_0)
                mem[_6140 + 32] = address(stor5[arg2].field_256)
                mem[0] = address(stor5[arg2].field_0)
                mem[32] = sha3(arg1, 1) + 3
                if not stor1[arg1][3][address(stor5[arg2].field_0)].field_0:
                    _6233 = mem[64]
                    mem[64] = mem[64] + 32
                    mem[_6233 + 32] = 32
                    mem[_6233 + 64] = mem[_6233]
                    mem[_6233 + 96 len 32 * mem[_6233]] = mem[_6233 + 32 len 32 * mem[_6233]]
                    var67001 = mem[_6233]
                    var67002 = _6233 + (32 * mem[_6233]) + 32
                    return memory
                      from mem[64]
                       len _6233 + (32 * mem[_6233]) + -mem[64] + 96
                if stor1[arg1][3][address(stor5[arg2].field_0)].field_0 < 1:
                    revert with 0, 17
                mem[mem[64]] = 0x26148aa500000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 96
                _6438 = mem[_2503]
                mem[mem[64] + 100] = mem[_2503]
                mem[mem[64] + 132 len 32 * _6438] = mem[_2503 + 32 len 32 * _6438]
                var68001 = _6438
                var68002 = _2503 + (32 * _6438) + 32
                mem[mem[64] + 36] = arg1
                mem[mem[64] + 68] = stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1
                require ext_code.size(address(stor5[arg2].field_256))
                staticcall address(stor5[arg2].field_256).0x26148aa5 with:
                        gas gas_remaining wei
                       args 96, arg1, stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1, mem[mem[64] + 100 len (32 * _6438) + 32]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _8094 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _8210 = mem[_8094]
                require mem[_8094] <= test266151307()
                require _8094 + mem[_8094] + 31 < _8094 + return_data.size
                _8396 = mem[_8094 + mem[_8094]]
                if mem[_8094 + mem[_8094]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_8094 + mem[_8094]]) + 1 < 0 or _8094 + ceil32(return_data.size) + ceil32(32 * mem[_8094 + mem[_8094]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _8094 + ceil32(return_data.size) + ceil32(32 * mem[_8094 + mem[_8094]]) + 1
                mem[_8094 + ceil32(return_data.size)] = _8396
                require _8210 + (32 * _8396) + 32 <= return_data.size
                mem[_8094 + ceil32(return_data.size) + 32 len 32 * _8396] = mem[_8094 + _8210 + 32 len 32 * _8396]
                mem[mem[64]] = 32
                mem[mem[64] + 32] = _8396
                mem[mem[64] + 64 len 32 * _8396] = mem[_8094 + ceil32(return_data.size) + 32 len 32 * _8396]
                var95001 = _8396
                var95002 = _8094 + ceil32(return_data.size) + (32 * _8396) + 32
                return Array(len=_8396, data=mem[mem[64] + 64 len 32 * _8396])
            if s > !t:
                revert with 0, 17
            if s + t > test266151307():
                revert with 0, 65
            _2607 = mem[64] + (32 * s + t) + 32
            mem[mem[64] + (32 * s + t) + 32] = s + t
            mem[64] = _2607 + (32 * s + t) + 32
            if s + t:
                mem[_2607 + 32 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
                _3954 = mem[mem[ceil32(return_data.size) + 160]]
                idx = 0
                u = 0
                while idx < _3954:
                    mem[0] = arg1
                    mem[32] = 1
                    mem[mem[64] + 32] = idx
                    mem[mem[64] + 64] = stor1[arg1].field_512
                    mem[mem[64] + 96] = stor8
                    _4053 = mem[64]
                    mem[mem[64]] = 96
                    mem[64] = mem[64] + 128
                    if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                        revert with 0, 50
                    if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        revert with 0, 18
                    if sha3(mem[_4053 + 32 len mem[_4053]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        if idx == -1:
                            revert with 0, 17
                        _3954 = mem[mem[ceil32(return_data.size) + 160]]
                        idx = idx + 1
                        u = u
                        continue 
                    if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                        revert with 0, 50
                    if u >= mem[_2503]:
                        revert with 0, 50
                    mem[(32 * u) + _2503 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                    if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                        revert with 0, 50
                    if u >= mem[_2607]:
                        revert with 0, 50
                    mem[(32 * u) + _2607 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                    if u == -1:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _3954 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = idx + 1
                    u = u + 1
                    continue 
                idx = 0
                while idx < stor5.length:
                    mem[0] = 5
                    _6026 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_6026] = address(stor5[idx].field_0)
                    mem[_6026 + 32] = address(stor5[idx].field_256)
                    mem[0] = address(stor5[idx].field_0)
                    mem[32] = sha3(arg1, 1) + 3
                    if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                        _6063 = mem[64]
                        mem[mem[64]] = 0
                        mem[mem[64] + 32] = 0
                        mem[64] = mem[64] + 64
                        _7764 = mem[_6063]
                        s = 0
                        t = u
                        while s < _7764:
                            if s >= mem[_6063]:
                                revert with 0, 50
                            if t >= mem[_2503]:
                                revert with 0, 50
                            mem[(32 * t) + _2503 + 32] = mem[(32 * s) + _6063 + 32]
                            if s >= mem[_6063 + 32]:
                                revert with 0, 50
                            if t >= mem[_2607]:
                                revert with 0, 50
                            mem[(32 * t) + _2607 + 32] = mem[(32 * s) + _6063 + 64]
                            if t == -1:
                                revert with 0, 17
                            if s == -1:
                                revert with 0, 17
                            _7764 = mem[_6063]
                            s = s + 1
                            t = t + 1
                            continue 
                    else:
                        mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = arg1
                        mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                        require ext_code.size(address(stor5[idx].field_256))
                        staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                                gas gas_remaining wei
                               args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _6313 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 64
                        _6399 = mem[_6313]
                        require mem[_6313] <= test266151307()
                        require _6313 + mem[_6313] + 31 < _6313 + return_data.size
                        _6555 = mem[_6313 + mem[_6313]]
                        if mem[_6313 + mem[_6313]] > test266151307():
                            revert with 0, 65
                        if ceil32(32 * mem[_6313 + mem[_6313]]) + 1 < 0 or _6313 + ceil32(return_data.size) + ceil32(32 * mem[_6313 + mem[_6313]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = _6313 + ceil32(return_data.size) + ceil32(32 * mem[_6313 + mem[_6313]]) + 1
                        mem[_6313 + ceil32(return_data.size)] = _6555
                        require _6399 + (32 * _6555) + 32 <= return_data.size
                        s = 0
                        t = _6313 + _6399 + 32
                        v = _6313 + ceil32(return_data.size) + 32
                        while s < _6555:
                            mem[v] = mem[t]
                            s = s + 1
                            t = t + 32
                            v = v + 32
                            continue 
                        _7975 = mem[_6313 + 32]
                        require mem[_6313 + 32] <= test266151307()
                        require _6313 + mem[_6313 + 32] + 31 < _6313 + return_data.size
                        _8091 = mem[_6313 + mem[_6313 + 32]]
                        if mem[_6313 + mem[_6313 + 32]] > test266151307():
                            revert with 0, 65
                        _8299 = mem[64]
                        if mem[64] + ceil32(32 * mem[_6313 + mem[_6313 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_6313 + mem[_6313 + 32]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = mem[64] + ceil32(32 * mem[_6313 + mem[_6313 + 32]]) + 1
                        mem[_8299] = _8091
                        require _7975 + (32 * _8091) + 32 <= return_data.size
                        s = 0
                        t = _6313 + _7975 + 32
                        v = _8299 + 32
                        while s < _8091:
                            mem[v] = mem[t]
                            s = s + 1
                            t = t + 32
                            v = v + 32
                            continue 
                        _10564 = mem[_6313 + ceil32(return_data.size)]
                        s = 0
                        t = u
                        while s < _10564:
                            if s >= mem[_6313 + ceil32(return_data.size)]:
                                revert with 0, 50
                            if t >= mem[_2503]:
                                revert with 0, 50
                            mem[(32 * t) + _2503 + 32] = mem[(32 * s) + _6313 + ceil32(return_data.size) + 32]
                            if s >= mem[_8299]:
                                revert with 0, 50
                            if t >= mem[_2607]:
                                revert with 0, 50
                            mem[(32 * t) + _2607 + 32] = mem[(32 * s) + _8299 + 32]
                            if t == -1:
                                revert with 0, 17
                            if s == -1:
                                revert with 0, 17
                            _10564 = mem[_6313 + ceil32(return_data.size)]
                            s = s + 1
                            t = t + 1
                            continue 
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                if s > !t:
                    revert with 0, 17
                if u != s + t:
                    revert with 0, 1
                if arg2 >= stor5.length:
                    revert with 0, 50
                mem[0] = 5
                _6130 = mem[64]
                mem[64] = mem[64] + 64
                mem[_6130] = address(stor5[arg2].field_0)
                mem[_6130 + 32] = address(stor5[arg2].field_256)
                mem[0] = address(stor5[arg2].field_0)
                mem[32] = sha3(arg1, 1) + 3
                if not stor1[arg1][3][address(stor5[arg2].field_0)].field_0:
                    _6221 = mem[64]
                    mem[64] = mem[64] + 32
                    mem[_6221 + 32] = 32
                    mem[_6221 + 64] = mem[_6221]
                    mem[_6221 + 96 len 32 * mem[_6221]] = mem[_6221 + 32 len 32 * mem[_6221]]
                    var66001 = mem[_6221]
                    var66002 = _6221 + (32 * mem[_6221]) + 32
                    return memory
                      from mem[64]
                       len _6221 + (32 * mem[_6221]) + -mem[64] + 96
                if stor1[arg1][3][address(stor5[arg2].field_0)].field_0 < 1:
                    revert with 0, 17
                mem[mem[64]] = 0x26148aa500000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 96
                _6436 = mem[_2503]
                mem[mem[64] + 100] = mem[_2503]
                mem[mem[64] + 132 len 32 * _6436] = mem[_2503 + 32 len 32 * _6436]
                var67001 = _6436
                var67002 = _2503 + (32 * _6436) + 32
                mem[mem[64] + 36] = arg1
                mem[mem[64] + 68] = stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1
                require ext_code.size(address(stor5[arg2].field_256))
                staticcall address(stor5[arg2].field_256).0x26148aa5 with:
                        gas gas_remaining wei
                       args 96, arg1, stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1, mem[mem[64] + 100 len (32 * _6436) + 32]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _8090 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _8208 = mem[_8090]
                require mem[_8090] <= test266151307()
                require _8090 + mem[_8090] + 31 < _8090 + return_data.size
                _8394 = mem[_8090 + mem[_8090]]
                if mem[_8090 + mem[_8090]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_8090 + mem[_8090]]) + 1 < 0 or _8090 + ceil32(return_data.size) + ceil32(32 * mem[_8090 + mem[_8090]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _8090 + ceil32(return_data.size) + ceil32(32 * mem[_8090 + mem[_8090]]) + 1
                mem[_8090 + ceil32(return_data.size)] = _8394
                require _8208 + (32 * _8394) + 32 <= return_data.size
                mem[_8090 + ceil32(return_data.size) + 32 len 32 * _8394] = mem[_8090 + _8208 + 32 len 32 * _8394]
                mem[mem[64]] = 32
                mem[mem[64] + 32] = _8394
                mem[mem[64] + 64 len 32 * _8394] = mem[_8090 + ceil32(return_data.size) + 32 len 32 * _8394]
                var94001 = _8394
                var94002 = _8090 + ceil32(return_data.size) + (32 * _8394) + 32
                return Array(len=_8394, data=mem[mem[64] + 64 len 32 * _8394])
            _3952 = mem[mem[ceil32(return_data.size) + 160]]
            idx = 0
            u = 0
            while idx < _3952:
                mem[0] = arg1
                mem[32] = 1
                mem[mem[64] + 32] = idx
                mem[mem[64] + 64] = stor1[arg1].field_512
                mem[mem[64] + 96] = stor8
                _4046 = mem[64]
                mem[mem[64]] = 96
                mem[64] = mem[64] + 128
                if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                    revert with 0, 50
                if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    revert with 0, 18
                if sha3(mem[_4046 + 32 len mem[_4046]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    if idx == -1:
                        revert with 0, 17
                    _3952 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = idx + 1
                    u = u
                    continue 
                if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                    revert with 0, 50
                if u >= mem[_2503]:
                    revert with 0, 50
                mem[(32 * u) + _2503 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                    revert with 0, 50
                if u >= mem[_2607]:
                    revert with 0, 50
                mem[(32 * u) + _2607 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                if u == -1:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _3952 = mem[mem[ceil32(return_data.size) + 160]]
                idx = idx + 1
                u = u + 1
                continue 
            idx = 0
            while idx < stor5.length:
                mem[0] = 5
                _6021 = mem[64]
                mem[64] = mem[64] + 64
                mem[_6021] = address(stor5[idx].field_0)
                mem[_6021 + 32] = address(stor5[idx].field_256)
                mem[0] = address(stor5[idx].field_0)
                mem[32] = sha3(arg1, 1) + 3
                if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                    _6062 = mem[64]
                    mem[mem[64]] = 0
                    mem[mem[64] + 32] = 0
                    mem[64] = mem[64] + 64
                    _7763 = mem[_6062]
                    s = 0
                    t = u
                    while s < _7763:
                        if s >= mem[_6062]:
                            revert with 0, 50
                        if t >= mem[_2503]:
                            revert with 0, 50
                        mem[(32 * t) + _2503 + 32] = mem[(32 * s) + _6062 + 32]
                        if s >= mem[_6062 + 32]:
                            revert with 0, 50
                        if t >= mem[_2607]:
                            revert with 0, 50
                        mem[(32 * t) + _2607 + 32] = mem[(32 * s) + _6062 + 64]
                        if t == -1:
                            revert with 0, 17
                        if s == -1:
                            revert with 0, 17
                        _7763 = mem[_6062]
                        s = s + 1
                        t = t + 1
                        continue 
                else:
                    mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = arg1
                    mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    require ext_code.size(address(stor5[idx].field_256))
                    staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                            gas gas_remaining wei
                           args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _6309 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 64
                    _6395 = mem[_6309]
                    require mem[_6309] <= test266151307()
                    require _6309 + mem[_6309] + 31 < _6309 + return_data.size
                    _6553 = mem[_6309 + mem[_6309]]
                    if mem[_6309 + mem[_6309]] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[_6309 + mem[_6309]]) + 1 < 0 or _6309 + ceil32(return_data.size) + ceil32(32 * mem[_6309 + mem[_6309]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = _6309 + ceil32(return_data.size) + ceil32(32 * mem[_6309 + mem[_6309]]) + 1
                    mem[_6309 + ceil32(return_data.size)] = _6553
                    require _6395 + (32 * _6553) + 32 <= return_data.size
                    s = 0
                    t = _6309 + _6395 + 32
                    v = _6309 + ceil32(return_data.size) + 32
                    while s < _6553:
                        mem[v] = mem[t]
                        s = s + 1
                        t = t + 32
                        v = v + 32
                        continue 
                    _7972 = mem[_6309 + 32]
                    require mem[_6309 + 32] <= test266151307()
                    require _6309 + mem[_6309 + 32] + 31 < _6309 + return_data.size
                    _8089 = mem[_6309 + mem[_6309 + 32]]
                    if mem[_6309 + mem[_6309 + 32]] > test266151307():
                        revert with 0, 65
                    _8298 = mem[64]
                    if mem[64] + ceil32(32 * mem[_6309 + mem[_6309 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_6309 + mem[_6309 + 32]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = mem[64] + ceil32(32 * mem[_6309 + mem[_6309 + 32]]) + 1
                    mem[_8298] = _8089
                    require _7972 + (32 * _8089) + 32 <= return_data.size
                    s = 0
                    t = _6309 + _7972 + 32
                    v = _8298 + 32
                    while s < _8089:
                        mem[v] = mem[t]
                        s = s + 1
                        t = t + 32
                        v = v + 32
                        continue 
                    _10563 = mem[_6309 + ceil32(return_data.size)]
                    s = 0
                    t = u
                    while s < _10563:
                        if s >= mem[_6309 + ceil32(return_data.size)]:
                            revert with 0, 50
                        if t >= mem[_2503]:
                            revert with 0, 50
                        mem[(32 * t) + _2503 + 32] = mem[(32 * s) + _6309 + ceil32(return_data.size) + 32]
                        if s >= mem[_8298]:
                            revert with 0, 50
                        if t >= mem[_2607]:
                            revert with 0, 50
                        mem[(32 * t) + _2607 + 32] = mem[(32 * s) + _8298 + 32]
                        if t == -1:
                            revert with 0, 17
                        if s == -1:
                            revert with 0, 17
                        _10563 = mem[_6309 + ceil32(return_data.size)]
                        s = s + 1
                        t = t + 1
                        continue 
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            if s > !t:
                revert with 0, 17
            if u != s + t:
                revert with 0, 1
            if arg2 >= stor5.length:
                revert with 0, 50
            mem[0] = 5
            _6125 = mem[64]
            mem[64] = mem[64] + 64
            mem[_6125] = address(stor5[arg2].field_0)
            mem[_6125 + 32] = address(stor5[arg2].field_256)
            mem[0] = address(stor5[arg2].field_0)
            mem[32] = sha3(arg1, 1) + 3
            if not stor1[arg1][3][address(stor5[arg2].field_0)].field_0:
                _6215 = mem[64]
                mem[64] = mem[64] + 32
                mem[_6215 + 32] = 32
                mem[_6215 + 64] = mem[_6215]
                mem[_6215 + 96 len 32 * mem[_6215]] = mem[_6215 + 32 len 32 * mem[_6215]]
                var65001 = mem[_6215]
                var65002 = _6215 + (32 * mem[_6215]) + 32
                return memory
                  from mem[64]
                   len _6215 + (32 * mem[_6215]) + -mem[64] + 96
            if stor1[arg1][3][address(stor5[arg2].field_0)].field_0 < 1:
                revert with 0, 17
            mem[mem[64]] = 0x26148aa500000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 96
            _6435 = mem[_2503]
            mem[mem[64] + 100] = mem[_2503]
            mem[mem[64] + 132 len 32 * _6435] = mem[_2503 + 32 len 32 * _6435]
            var66001 = _6435
            var66002 = _2503 + (32 * _6435) + 32
            mem[mem[64] + 36] = arg1
            mem[mem[64] + 68] = stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1
            require ext_code.size(address(stor5[arg2].field_256))
            staticcall address(stor5[arg2].field_256).0x26148aa5 with:
                    gas gas_remaining wei
                   args 96, arg1, stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1, mem[mem[64] + 100 len (32 * _6435) + 32]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _8088 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _8207 = mem[_8088]
            require mem[_8088] <= test266151307()
            require _8088 + mem[_8088] + 31 < _8088 + return_data.size
            _8393 = mem[_8088 + mem[_8088]]
            if mem[_8088 + mem[_8088]] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[_8088 + mem[_8088]]) + 1 < 0 or _8088 + ceil32(return_data.size) + ceil32(32 * mem[_8088 + mem[_8088]]) + 1 > test266151307():
                revert with 0, 65
            mem[64] = _8088 + ceil32(return_data.size) + ceil32(32 * mem[_8088 + mem[_8088]]) + 1
            mem[_8088 + ceil32(return_data.size)] = _8393
            require _8207 + (32 * _8393) + 32 <= return_data.size
            mem[_8088 + ceil32(return_data.size) + 32 len 32 * _8393] = mem[_8088 + _8207 + 32 len 32 * _8393]
            var85001 = _8393
            var85002 = _8088 + _8207 + (32 * _8393) + 32
            var85004 = _8088 + ceil32(return_data.size) + (32 * _8393) + 32
            mem[mem[64]] = 32
            mem[mem[64] + 32] = _8393
            mem[mem[64] + 64 len 32 * _8393] = mem[_8088 + ceil32(return_data.size) + 32 len 32 * _8393]
            var93001 = _8393
            var93002 = _8088 + ceil32(return_data.size) + (32 * _8393) + 32
            return Array(len=_8393, data=mem[mem[64] + 64 len 32 * _8393])
        mem[0] = sha3(ext_call.return_data[31 len 1], 10) + 2
        mem[ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 288] = stor10[ext_call.return_data[31 len 1]][2].field_0
        idx = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 288
        s = 0
        while ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + (32 * stor10[ext_call.return_data[31 len 1]].field_512) + 256 > idx:
            mem[idx + 32] = stor10[ext_call.return_data[31 len 1]][s + 2].field_256
            idx = idx + 32
            s = s + 1
            continue 
        mem[ceil32(return_data.size) + 160] = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 256
        idx = 0
        s = 0
        while idx < stor10[ext_call.return_data[31 len 1]].field_512:
            mem[0] = arg1
            mem[32] = 1
            mem[mem[64] + 32] = idx
            mem[mem[64] + 64] = stor1[arg1].field_512
            mem[mem[64] + 96] = stor8
            _4075 = mem[64]
            mem[mem[64]] = 96
            mem[64] = mem[64] + 128
            if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                revert with 0, 50
            if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                revert with 0, 18
            if sha3(mem[_4075 + 32 len mem[_4075]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s
                continue 
            if s == -1:
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = s + 1
            continue 
        idx = 0
        t = 0
        while idx < stor5.length:
            mem[0] = 5
            _6041 = mem[64]
            mem[64] = mem[64] + 64
            mem[_6041] = address(stor5[idx].field_0)
            mem[_6041 + 32] = address(stor5[idx].field_256)
            mem[0] = address(stor5[idx].field_0)
            mem[32] = sha3(arg1, 1) + 3
            if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                _6068 = mem[64]
                mem[mem[64]] = 0
                mem[mem[64] + 32] = 0
                mem[64] = mem[64] + 64
                if t > !mem[_6068]:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                t = t + mem[_6068]
                continue 
            mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = arg1
            mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
            require ext_code.size(address(stor5[idx].field_256))
            staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                    gas gas_remaining wei
                   args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _6325 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 64
            _6412 = mem[_6325]
            require mem[_6325] <= test266151307()
            require _6325 + mem[_6325] + 31 < _6325 + return_data.size
            _6569 = mem[_6325 + mem[_6325]]
            if mem[_6325 + mem[_6325]] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[_6325 + mem[_6325]]) + 1 < 0 or _6325 + ceil32(return_data.size) + ceil32(32 * mem[_6325 + mem[_6325]]) + 1 > test266151307():
                revert with 0, 65
            mem[64] = _6325 + ceil32(return_data.size) + ceil32(32 * mem[_6325 + mem[_6325]]) + 1
            mem[_6325 + ceil32(return_data.size)] = _6569
            require _6412 + (32 * _6569) + 32 <= return_data.size
            s = 0
            u = _6325 + _6412 + 32
            v = _6325 + ceil32(return_data.size) + 32
            while s < _6569:
                mem[v] = mem[u]
                s = s + 1
                u = u + 32
                v = v + 32
                continue 
            _7988 = mem[_6325 + 32]
            require mem[_6325 + 32] <= test266151307()
            require _6325 + mem[_6325 + 32] + 31 < _6325 + return_data.size
            _8096 = mem[_6325 + mem[_6325 + 32]]
            if mem[_6325 + mem[_6325 + 32]] > test266151307():
                revert with 0, 65
            _8330 = mem[64]
            if mem[64] + ceil32(32 * mem[_6325 + mem[_6325 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_6325 + mem[_6325 + 32]]) + 1 > test266151307():
                revert with 0, 65
            mem[64] = mem[64] + ceil32(32 * mem[_6325 + mem[_6325 + 32]]) + 1
            mem[_8330] = _8096
            require _7988 + (32 * _8096) + 32 <= return_data.size
            s = 0
            u = _6325 + _7988 + 32
            v = _8330 + 32
            while s < _8096:
                mem[v] = mem[u]
                s = s + 1
                u = u + 32
                v = v + 32
                continue 
            if t > !mem[_6325 + ceil32(return_data.size)]:
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            t = t + mem[_6325 + ceil32(return_data.size)]
            continue 
        if s > !t:
            revert with 0, 17
        if s + t > test266151307():
            revert with 0, 65
        _6067 = mem[64]
        mem[mem[64]] = s + t
        if not s + t:
            if s > !t:
                revert with 0, 17
            if s + t > test266151307():
                revert with 0, 65
            _6324 = mem[64] + (32 * s + t) + 32
            mem[mem[64] + (32 * s + t) + 32] = s + t
            mem[64] = _6324 + (32 * s + t) + 32
            if not s + t:
                _7768 = mem[mem[ceil32(return_data.size) + 160]]
                idx = 0
                u = 0
                while idx < _7768:
                    mem[0] = arg1
                    mem[32] = 1
                    mem[mem[64] + 32] = idx
                    mem[mem[64] + 64] = stor1[arg1].field_512
                    mem[mem[64] + 96] = stor8
                    _7872 = mem[64]
                    mem[mem[64]] = 96
                    mem[64] = mem[64] + 128
                    if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                        revert with 0, 50
                    if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        revert with 0, 18
                    if sha3(mem[_7872 + 32 len mem[_7872]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        if idx == -1:
                            revert with 0, 17
                        _7768 = mem[mem[ceil32(return_data.size) + 160]]
                        idx = idx + 1
                        u = u
                        continue 
                    if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                        revert with 0, 50
                    if u >= mem[_6067]:
                        revert with 0, 50
                    mem[(32 * u) + _6067 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                    if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                        revert with 0, 50
                    if u >= mem[_6324]:
                        revert with 0, 50
                    mem[(32 * u) + _6324 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                    if u == -1:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _7768 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = idx + 1
                    u = u + 1
                    continue 
                idx = 0
                while idx < stor5.length:
                    mem[0] = 5
                    _9458 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_9458] = address(stor5[idx].field_0)
                    mem[_9458 + 32] = address(stor5[idx].field_256)
                    mem[0] = address(stor5[idx].field_0)
                    mem[32] = sha3(arg1, 1) + 3
                    if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                        _9507 = mem[64]
                        mem[mem[64]] = 0
                        mem[mem[64] + 32] = 0
                        mem[64] = mem[64] + 64
                        _10567 = mem[_9507]
                        s = 0
                        t = u
                        while s < _10567:
                            if s >= mem[_9507]:
                                revert with 0, 50
                            if t >= mem[_6067]:
                                revert with 0, 50
                            mem[(32 * t) + _6067 + 32] = mem[(32 * s) + _9507 + 32]
                            if s >= mem[_9507 + 32]:
                                revert with 0, 50
                            if t >= mem[_6324]:
                                revert with 0, 50
                            mem[(32 * t) + _6324 + 32] = mem[(32 * s) + _9507 + 64]
                            if t == -1:
                                revert with 0, 17
                            if s == -1:
                                revert with 0, 17
                            _10567 = mem[_9507]
                            s = s + 1
                            t = t + 1
                            continue 
                    else:
                        mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = arg1
                        mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                        require ext_code.size(address(stor5[idx].field_256))
                        staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                                gas gas_remaining wei
                               args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _9804 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 64
                        _9879 = mem[_9804]
                        require mem[_9804] <= test266151307()
                        require _9804 + mem[_9804] + 31 < _9804 + return_data.size
                        _9974 = mem[_9804 + mem[_9804]]
                        if mem[_9804 + mem[_9804]] > test266151307():
                            revert with 0, 65
                        if ceil32(32 * mem[_9804 + mem[_9804]]) + 1 < 0 or _9804 + ceil32(return_data.size) + ceil32(32 * mem[_9804 + mem[_9804]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = _9804 + ceil32(return_data.size) + ceil32(32 * mem[_9804 + mem[_9804]]) + 1
                        mem[_9804 + ceil32(return_data.size)] = _9974
                        require _9879 + (32 * _9974) + 32 <= return_data.size
                        s = 0
                        t = _9804 + _9879 + 32
                        v = _9804 + ceil32(return_data.size) + 32
                        while s < _9974:
                            mem[v] = mem[t]
                            s = s + 1
                            t = t + 32
                            v = v + 32
                            continue 
                        _10720 = mem[_9804 + 32]
                        require mem[_9804 + 32] <= test266151307()
                        require _9804 + mem[_9804 + 32] + 31 < _9804 + return_data.size
                        _10866 = mem[_9804 + mem[_9804 + 32]]
                        if mem[_9804 + mem[_9804 + 32]] > test266151307():
                            revert with 0, 65
                        _10946 = mem[64]
                        if mem[64] + ceil32(32 * mem[_9804 + mem[_9804 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_9804 + mem[_9804 + 32]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = mem[64] + ceil32(32 * mem[_9804 + mem[_9804 + 32]]) + 1
                        mem[_10946] = _10866
                        require _10720 + (32 * _10866) + 32 <= return_data.size
                        s = 0
                        t = _9804 + _10720 + 32
                        v = _10946 + 32
                        while s < _10866:
                            mem[v] = mem[t]
                            s = s + 1
                            t = t + 32
                            v = v + 32
                            continue 
                        _11731 = mem[_9804 + ceil32(return_data.size)]
                        s = 0
                        t = u
                        while s < _11731:
                            if s >= mem[_9804 + ceil32(return_data.size)]:
                                revert with 0, 50
                            if t >= mem[_6067]:
                                revert with 0, 50
                            mem[(32 * t) + _6067 + 32] = mem[(32 * s) + _9804 + ceil32(return_data.size) + 32]
                            if s >= mem[_10946]:
                                revert with 0, 50
                            if t >= mem[_6324]:
                                revert with 0, 50
                            mem[(32 * t) + _6324 + 32] = mem[(32 * s) + _10946 + 32]
                            if t == -1:
                                revert with 0, 17
                            if s == -1:
                                revert with 0, 17
                            _11731 = mem[_9804 + ceil32(return_data.size)]
                            s = s + 1
                            t = t + 1
                            continue 
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                if s > !t:
                    revert with 0, 17
                if u != s + t:
                    revert with 0, 1
                if arg2 >= stor5.length:
                    revert with 0, 50
                mem[0] = 5
                _9576 = mem[64]
                mem[64] = mem[64] + 64
                mem[_9576] = address(stor5[arg2].field_0)
                mem[_9576 + 32] = address(stor5[arg2].field_256)
                mem[0] = address(stor5[arg2].field_0)
                mem[32] = sha3(arg1, 1) + 3
                if not stor1[arg1][3][address(stor5[arg2].field_0)].field_0:
                    _9677 = mem[64]
                    mem[64] = mem[64] + 32
                    mem[_9677 + 32] = 32
                    mem[_9677 + 64] = mem[_9677]
                    mem[_9677 + 96 len 32 * mem[_9677]] = mem[_9677 + 32 len 32 * mem[_9677]]
                    var69001 = mem[_9677]
                    var69002 = _9677 + (32 * mem[_9677]) + 32
                    return memory
                      from mem[64]
                       len _9677 + (32 * mem[_9677]) + -mem[64] + 96
                if stor1[arg1][3][address(stor5[arg2].field_0)].field_0 < 1:
                    revert with 0, 17
                mem[mem[64]] = 0x26148aa500000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 96
                _9917 = mem[_6067]
                mem[mem[64] + 100] = mem[_6067]
                mem[mem[64] + 132 len 32 * _9917] = mem[_6067 + 32 len 32 * _9917]
                var70001 = _9917
                var70002 = _6067 + (32 * _9917) + 32
                mem[mem[64] + 36] = arg1
                mem[mem[64] + 68] = stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1
                require ext_code.size(address(stor5[arg2].field_256))
                staticcall address(stor5[arg2].field_256).0x26148aa5 with:
                        gas gas_remaining wei
                       args 96, arg1, stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1, mem[mem[64] + 100 len (32 * _9917) + 32]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _10865 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _10914 = mem[_10865]
                require mem[_10865] <= test266151307()
                require _10865 + mem[_10865] + 31 < _10865 + return_data.size
                _10987 = mem[_10865 + mem[_10865]]
                if mem[_10865 + mem[_10865]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_10865 + mem[_10865]]) + 1 < 0 or _10865 + ceil32(return_data.size) + ceil32(32 * mem[_10865 + mem[_10865]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _10865 + ceil32(return_data.size) + ceil32(32 * mem[_10865 + mem[_10865]]) + 1
                mem[_10865 + ceil32(return_data.size)] = _10987
                require _10914 + (32 * _10987) + 32 <= return_data.size
                mem[_10865 + ceil32(return_data.size) + 32 len 32 * _10987] = mem[_10865 + _10914 + 32 len 32 * _10987]
                var89001 = _10987
                var89002 = _10865 + _10914 + (32 * _10987) + 32
                var89004 = _10865 + ceil32(return_data.size) + (32 * _10987) + 32
                mem[mem[64]] = 32
                mem[mem[64] + 32] = _10987
                mem[mem[64] + 64 len 32 * _10987] = mem[_10865 + ceil32(return_data.size) + 32 len 32 * _10987]
                var97001 = _10987
                var97002 = _10865 + ceil32(return_data.size) + (32 * _10987) + 32
                return Array(len=_10987, data=mem[mem[64] + 64 len 32 * _10987])
            mem[_6324 + 32 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
            _7770 = mem[mem[ceil32(return_data.size) + 160]]
            idx = 0
            u = 0
            while idx < _7770:
                mem[0] = arg1
                mem[32] = 1
                mem[mem[64] + 32] = idx
                mem[mem[64] + 64] = stor1[arg1].field_512
                mem[mem[64] + 96] = stor8
                _7879 = mem[64]
                mem[mem[64]] = 96
                mem[64] = mem[64] + 128
                if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                    revert with 0, 50
                if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    revert with 0, 18
                if sha3(mem[_7879 + 32 len mem[_7879]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    if idx == -1:
                        revert with 0, 17
                    _7770 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = idx + 1
                    u = u
                    continue 
                if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                    revert with 0, 50
                if u >= mem[_6067]:
                    revert with 0, 50
                mem[(32 * u) + _6067 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                    revert with 0, 50
                if u >= mem[_6324]:
                    revert with 0, 50
                mem[(32 * u) + _6324 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                if u == -1:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _7770 = mem[mem[ceil32(return_data.size) + 160]]
                idx = idx + 1
                u = u + 1
                continue 
            idx = 0
            while idx < stor5.length:
                mem[0] = 5
                _9463 = mem[64]
                mem[64] = mem[64] + 64
                mem[_9463] = address(stor5[idx].field_0)
                mem[_9463 + 32] = address(stor5[idx].field_256)
                mem[0] = address(stor5[idx].field_0)
                mem[32] = sha3(arg1, 1) + 3
                if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                    _9508 = mem[64]
                    mem[mem[64]] = 0
                    mem[mem[64] + 32] = 0
                    mem[64] = mem[64] + 64
                    _10568 = mem[_9508]
                    s = 0
                    t = u
                    while s < _10568:
                        if s >= mem[_9508]:
                            revert with 0, 50
                        if t >= mem[_6067]:
                            revert with 0, 50
                        mem[(32 * t) + _6067 + 32] = mem[(32 * s) + _9508 + 32]
                        if s >= mem[_9508 + 32]:
                            revert with 0, 50
                        if t >= mem[_6324]:
                            revert with 0, 50
                        mem[(32 * t) + _6324 + 32] = mem[(32 * s) + _9508 + 64]
                        if t == -1:
                            revert with 0, 17
                        if s == -1:
                            revert with 0, 17
                        _10568 = mem[_9508]
                        s = s + 1
                        t = t + 1
                        continue 
                else:
                    mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = arg1
                    mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    require ext_code.size(address(stor5[idx].field_256))
                    staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                            gas gas_remaining wei
                           args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _9808 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 64
                    _9883 = mem[_9808]
                    require mem[_9808] <= test266151307()
                    require _9808 + mem[_9808] + 31 < _9808 + return_data.size
                    _9976 = mem[_9808 + mem[_9808]]
                    if mem[_9808 + mem[_9808]] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[_9808 + mem[_9808]]) + 1 < 0 or _9808 + ceil32(return_data.size) + ceil32(32 * mem[_9808 + mem[_9808]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = _9808 + ceil32(return_data.size) + ceil32(32 * mem[_9808 + mem[_9808]]) + 1
                    mem[_9808 + ceil32(return_data.size)] = _9976
                    require _9883 + (32 * _9976) + 32 <= return_data.size
                    s = 0
                    t = _9808 + _9883 + 32
                    v = _9808 + ceil32(return_data.size) + 32
                    while s < _9976:
                        mem[v] = mem[t]
                        s = s + 1
                        t = t + 32
                        v = v + 32
                        continue 
                    _10723 = mem[_9808 + 32]
                    require mem[_9808 + 32] <= test266151307()
                    require _9808 + mem[_9808 + 32] + 31 < _9808 + return_data.size
                    _10868 = mem[_9808 + mem[_9808 + 32]]
                    if mem[_9808 + mem[_9808 + 32]] > test266151307():
                        revert with 0, 65
                    _10947 = mem[64]
                    if mem[64] + ceil32(32 * mem[_9808 + mem[_9808 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_9808 + mem[_9808 + 32]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = mem[64] + ceil32(32 * mem[_9808 + mem[_9808 + 32]]) + 1
                    mem[_10947] = _10868
                    require _10723 + (32 * _10868) + 32 <= return_data.size
                    s = 0
                    t = _9808 + _10723 + 32
                    v = _10947 + 32
                    while s < _10868:
                        mem[v] = mem[t]
                        s = s + 1
                        t = t + 32
                        v = v + 32
                        continue 
                    _11732 = mem[_9808 + ceil32(return_data.size)]
                    s = 0
                    t = u
                    while s < _11732:
                        if s >= mem[_9808 + ceil32(return_data.size)]:
                            revert with 0, 50
                        if t >= mem[_6067]:
                            revert with 0, 50
                        mem[(32 * t) + _6067 + 32] = mem[(32 * s) + _9808 + ceil32(return_data.size) + 32]
                        if s >= mem[_10947]:
                            revert with 0, 50
                        if t >= mem[_6324]:
                            revert with 0, 50
                        mem[(32 * t) + _6324 + 32] = mem[(32 * s) + _10947 + 32]
                        if t == -1:
                            revert with 0, 17
                        if s == -1:
                            revert with 0, 17
                        _11732 = mem[_9808 + ceil32(return_data.size)]
                        s = s + 1
                        t = t + 1
                        continue 
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            if s > !t:
                revert with 0, 17
            if u != s + t:
                revert with 0, 1
            if arg2 >= stor5.length:
                revert with 0, 50
            mem[0] = 5
            _9581 = mem[64]
            mem[64] = mem[64] + 64
            mem[_9581] = address(stor5[arg2].field_0)
            mem[_9581 + 32] = address(stor5[arg2].field_256)
            mem[0] = address(stor5[arg2].field_0)
            mem[32] = sha3(arg1, 1) + 3
            if not stor1[arg1][3][address(stor5[arg2].field_0)].field_0:
                _9683 = mem[64]
                mem[64] = mem[64] + 32
                mem[_9683 + 32] = 32
                mem[_9683 + 64] = mem[_9683]
                mem[_9683 + 96 len 32 * mem[_9683]] = mem[_9683 + 32 len 32 * mem[_9683]]
                var70001 = mem[_9683]
                var70002 = _9683 + (32 * mem[_9683]) + 32
                return memory
                  from mem[64]
                   len _9683 + (32 * mem[_9683]) + -mem[64] + 96
            if stor1[arg1][3][address(stor5[arg2].field_0)].field_0 < 1:
                revert with 0, 17
            mem[mem[64]] = 0x26148aa500000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 96
            _9918 = mem[_6067]
            mem[mem[64] + 100] = mem[_6067]
            mem[mem[64] + 132 len 32 * _9918] = mem[_6067 + 32 len 32 * _9918]
            var71001 = _9918
            mem[mem[64] + 36] = arg1
            mem[mem[64] + 68] = stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1
            require ext_code.size(address(stor5[arg2].field_256))
            staticcall address(stor5[arg2].field_256).0x26148aa5 with:
                    gas gas_remaining wei
                   args 96, arg1, stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1, mem[mem[64] + 100 len (32 * _9918) + 32]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _10867 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _10915 = mem[_10867]
            require mem[_10867] <= test266151307()
            require _10867 + mem[_10867] + 31 < _10867 + return_data.size
            _10988 = mem[_10867 + mem[_10867]]
            if mem[_10867 + mem[_10867]] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[_10867 + mem[_10867]]) + 1 < 0 or _10867 + ceil32(return_data.size) + ceil32(32 * mem[_10867 + mem[_10867]]) + 1 > test266151307():
                revert with 0, 65
            mem[64] = _10867 + ceil32(return_data.size) + ceil32(32 * mem[_10867 + mem[_10867]]) + 1
            mem[_10867 + ceil32(return_data.size)] = _10988
            require _10915 + (32 * _10988) + 32 <= return_data.size
            mem[_10867 + ceil32(return_data.size) + 32 len 32 * _10988] = mem[_10867 + _10915 + 32 len 32 * _10988]
            var90001 = _10988
            var90002 = _10867 + _10915 + (32 * _10988) + 32
            var90004 = _10867 + ceil32(return_data.size) + (32 * _10988) + 32
            mem[mem[64]] = 32
            mem[mem[64] + 32] = _10988
            mem[mem[64] + 64 len 32 * _10988] = mem[_10867 + ceil32(return_data.size) + 32 len 32 * _10988]
            var98001 = _10988
            var98002 = _10867 + ceil32(return_data.size) + (32 * _10988) + 32
            return Array(len=_10988, data=mem[mem[64] + 64 len 32 * _10988])
        mem[mem[64] + 32 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
        if s > !t:
            revert with 0, 17
        if s + t > test266151307():
            revert with 0, 65
        mem[mem[64] + (32 * s + t) + 32] = s + t
        mem[64] = _6067 + (64 * s + t) + 64
        if not s + t:
            _7772 = mem[mem[ceil32(return_data.size) + 160]]
            idx = 0
            u = 0
            while idx < _7772:
                mem[0] = arg1
                mem[32] = 1
                mem[mem[64] + 32] = idx
                mem[mem[64] + 64] = stor1[arg1].field_512
                mem[mem[64] + 96] = stor8
                _7886 = mem[64]
                mem[mem[64]] = 96
                mem[64] = mem[64] + 128
                if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                    revert with 0, 50
                if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    revert with 0, 18
                if sha3(mem[_7886 + 32 len mem[_7886]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    if idx == -1:
                        revert with 0, 17
                    _7772 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = idx + 1
                    u = u
                    continue 
                if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                    revert with 0, 50
                if u >= mem[_6067]:
                    revert with 0, 50
                mem[(32 * u) + _6067 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                    revert with 0, 50
                if u >= mem[_6067 + (32 * s + t) + 32]:
                    revert with 0, 50
                mem[(32 * u) + _6067 + (32 * s + t) + 64] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                if u == -1:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _7772 = mem[mem[ceil32(return_data.size) + 160]]
                idx = idx + 1
                u = u + 1
                continue 
            idx = 0
            while idx < stor5.length:
                mem[0] = 5
                _9468 = mem[64]
                mem[64] = mem[64] + 64
                mem[_9468] = address(stor5[idx].field_0)
                mem[_9468 + 32] = address(stor5[idx].field_256)
                mem[0] = address(stor5[idx].field_0)
                mem[32] = sha3(arg1, 1) + 3
                if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                    _9509 = mem[64]
                    mem[mem[64]] = 0
                    mem[mem[64] + 32] = 0
                    mem[64] = mem[64] + 64
                    _10569 = mem[_9509]
                    v = 0
                    w = u
                    while v < _10569:
                        if v >= mem[_9509]:
                            revert with 0, 50
                        if w >= mem[_6067]:
                            revert with 0, 50
                        mem[(32 * w) + _6067 + 32] = mem[(32 * v) + _9509 + 32]
                        if v >= mem[_9509 + 32]:
                            revert with 0, 50
                        if w >= mem[_6067 + (32 * s + t) + 32]:
                            revert with 0, 50
                        mem[(32 * w) + _6067 + (32 * s + t) + 64] = mem[(32 * v) + _9509 + 64]
                        if w == -1:
                            revert with 0, 17
                        if v == -1:
                            revert with 0, 17
                        _10569 = mem[_9509]
                        v = v + 1
                        w = w + 1
                        continue 
                else:
                    mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = arg1
                    mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    require ext_code.size(address(stor5[idx].field_256))
                    staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                            gas gas_remaining wei
                           args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _9812 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 64
                    _9887 = mem[_9812]
                    require mem[_9812] <= test266151307()
                    require _9812 + mem[_9812] + 31 < _9812 + return_data.size
                    _9978 = mem[_9812 + mem[_9812]]
                    if mem[_9812 + mem[_9812]] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[_9812 + mem[_9812]]) + 1 < 0 or _9812 + ceil32(return_data.size) + ceil32(32 * mem[_9812 + mem[_9812]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = _9812 + ceil32(return_data.size) + ceil32(32 * mem[_9812 + mem[_9812]]) + 1
                    mem[_9812 + ceil32(return_data.size)] = _9978
                    require _9887 + (32 * _9978) + 32 <= return_data.size
                    v = 0
                    w = _9812 + _9887 + 32
                    x = _9812 + ceil32(return_data.size) + 32
                    while v < _9978:
                        mem[x] = mem[w]
                        v = v + 1
                        w = w + 32
                        x = x + 32
                        continue 
                    _10726 = mem[_9812 + 32]
                    require mem[_9812 + 32] <= test266151307()
                    require _9812 + mem[_9812 + 32] + 31 < _9812 + return_data.size
                    _10870 = mem[_9812 + mem[_9812 + 32]]
                    if mem[_9812 + mem[_9812 + 32]] > test266151307():
                        revert with 0, 65
                    _10948 = mem[64]
                    if mem[64] + ceil32(32 * mem[_9812 + mem[_9812 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_9812 + mem[_9812 + 32]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = mem[64] + ceil32(32 * mem[_9812 + mem[_9812 + 32]]) + 1
                    mem[_10948] = _10870
                    require _10726 + (32 * _10870) + 32 <= return_data.size
                    v = 0
                    w = _9812 + _10726 + 32
                    x = _10948 + 32
                    while v < _10870:
                        mem[x] = mem[w]
                        v = v + 1
                        w = w + 32
                        x = x + 32
                        continue 
                    _11733 = mem[_9812 + ceil32(return_data.size)]
                    v = 0
                    w = u
                    while v < _11733:
                        if v >= mem[_9812 + ceil32(return_data.size)]:
                            revert with 0, 50
                        if w >= mem[_6067]:
                            revert with 0, 50
                        mem[(32 * w) + _6067 + 32] = mem[(32 * v) + _9812 + ceil32(return_data.size) + 32]
                        if v >= mem[_10948]:
                            revert with 0, 50
                        if w >= mem[_6067 + (32 * s + t) + 32]:
                            revert with 0, 50
                        mem[(32 * w) + _6067 + (32 * s + t) + 64] = mem[(32 * v) + _10948 + 32]
                        if w == -1:
                            revert with 0, 17
                        if v == -1:
                            revert with 0, 17
                        _11733 = mem[_9812 + ceil32(return_data.size)]
                        v = v + 1
                        w = w + 1
                        continue 
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            if s > !t:
                revert with 0, 17
            if u != s + t:
                revert with 0, 1
            if arg2 >= stor5.length:
                revert with 0, 50
            mem[0] = 5
            _9586 = mem[64]
            mem[64] = mem[64] + 64
            mem[_9586] = address(stor5[arg2].field_0)
            mem[_9586 + 32] = address(stor5[arg2].field_256)
            mem[0] = address(stor5[arg2].field_0)
            mem[32] = sha3(arg1, 1) + 3
            if not stor1[arg1][3][address(stor5[arg2].field_0)].field_0:
                _9689 = mem[64]
                mem[64] = mem[64] + 32
                mem[_9689 + 32] = 32
                mem[_9689 + 64] = mem[_9689]
                mem[_9689 + 96 len 32 * mem[_9689]] = mem[_9689 + 32 len 32 * mem[_9689]]
                var70001 = mem[_9689]
                var70002 = _9689 + (32 * mem[_9689]) + 32
                return memory
                  from mem[64]
                   len _9689 + (32 * mem[_9689]) + -mem[64] + 96
            if stor1[arg1][3][address(stor5[arg2].field_0)].field_0 < 1:
                revert with 0, 17
            mem[mem[64]] = 0x26148aa500000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 96
            _9919 = mem[_6067]
            mem[mem[64] + 100] = mem[_6067]
            mem[mem[64] + 132 len 32 * _9919] = mem[_6067 + 32 len 32 * _9919]
            var71001 = _9919
            mem[mem[64] + 36] = arg1
            mem[mem[64] + 68] = stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1
            require ext_code.size(address(stor5[arg2].field_256))
            staticcall address(stor5[arg2].field_256).0x26148aa5 with:
                    gas gas_remaining wei
                   args 96, arg1, stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1, mem[mem[64] + 100 len (32 * _9919) + 32]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _10869 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _10916 = mem[_10869]
            require mem[_10869] <= test266151307()
            require _10869 + mem[_10869] + 31 < _10869 + return_data.size
            _10989 = mem[_10869 + mem[_10869]]
            if mem[_10869 + mem[_10869]] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[_10869 + mem[_10869]]) + 1 < 0 or _10869 + ceil32(return_data.size) + ceil32(32 * mem[_10869 + mem[_10869]]) + 1 > test266151307():
                revert with 0, 65
            mem[64] = _10869 + ceil32(return_data.size) + ceil32(32 * mem[_10869 + mem[_10869]]) + 1
            mem[_10869 + ceil32(return_data.size)] = _10989
            require _10916 + (32 * _10989) + 32 <= return_data.size
            mem[_10869 + ceil32(return_data.size) + 32 len 32 * _10989] = mem[_10869 + _10916 + 32 len 32 * _10989]
            var90001 = _10989
            var90002 = _10869 + _10916 + (32 * _10989) + 32
            var90004 = _10869 + ceil32(return_data.size) + (32 * _10989) + 32
            mem[mem[64]] = 32
            mem[mem[64] + 32] = _10989
            mem[mem[64] + 64 len 32 * _10989] = mem[_10869 + ceil32(return_data.size) + 32 len 32 * _10989]
            var98001 = _10989
            var98002 = _10869 + ceil32(return_data.size) + (32 * _10989) + 32
            return Array(len=_10989, data=mem[mem[64] + 64 len 32 * _10989])
        mem[_6067 + (32 * s + t) + 64 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
        _7774 = mem[mem[ceil32(return_data.size) + 160]]
        idx = 0
        u = 0
        while idx < _7774:
            mem[0] = arg1
            mem[32] = 1
            mem[mem[64] + 32] = idx
            mem[mem[64] + 64] = stor1[arg1].field_512
            mem[mem[64] + 96] = stor8
            _7893 = mem[64]
            mem[mem[64]] = 96
            mem[64] = mem[64] + 128
            if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                revert with 0, 50
            if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                revert with 0, 18
            if sha3(mem[_7893 + 32 len mem[_7893]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                if idx == -1:
                    revert with 0, 17
                _7774 = mem[mem[ceil32(return_data.size) + 160]]
                idx = idx + 1
                u = u
                continue 
            if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                revert with 0, 50
            if u >= mem[_6067]:
                revert with 0, 50
            mem[(32 * u) + _6067 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
            if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                revert with 0, 50
            if u >= mem[_6067 + (32 * s + t) + 32]:
                revert with 0, 50
            mem[(32 * u) + _6067 + (32 * s + t) + 64] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
            if u == -1:
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            _7774 = mem[mem[ceil32(return_data.size) + 160]]
            idx = idx + 1
            u = u + 1
            continue 
        idx = 0
        while idx < stor5.length:
            mem[0] = 5
            _9473 = mem[64]
            mem[64] = mem[64] + 64
            mem[_9473] = address(stor5[idx].field_0)
            mem[_9473 + 32] = address(stor5[idx].field_256)
            mem[0] = address(stor5[idx].field_0)
            mem[32] = sha3(arg1, 1) + 3
            if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                _9510 = mem[64]
                mem[mem[64]] = 0
                mem[mem[64] + 32] = 0
                mem[64] = mem[64] + 64
                _10570 = mem[_9510]
                v = 0
                w = u
                while v < _10570:
                    if v >= mem[_9510]:
                        revert with 0, 50
                    if w >= mem[_6067]:
                        revert with 0, 50
                    mem[(32 * w) + _6067 + 32] = mem[(32 * v) + _9510 + 32]
                    if v >= mem[_9510 + 32]:
                        revert with 0, 50
                    if w >= mem[_6067 + (32 * s + t) + 32]:
                        revert with 0, 50
                    mem[(32 * w) + _6067 + (32 * s + t) + 64] = mem[(32 * v) + _9510 + 64]
                    if w == -1:
                        revert with 0, 17
                    if v == -1:
                        revert with 0, 17
                    _10570 = mem[_9510]
                    v = v + 1
                    w = w + 1
                    continue 
            else:
                mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = arg1
                mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                require ext_code.size(address(stor5[idx].field_256))
                staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                        gas gas_remaining wei
                       args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _9816 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 64
                _9891 = mem[_9816]
                require mem[_9816] <= test266151307()
                require _9816 + mem[_9816] + 31 < _9816 + return_data.size
                _9980 = mem[_9816 + mem[_9816]]
                if mem[_9816 + mem[_9816]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_9816 + mem[_9816]]) + 1 < 0 or _9816 + ceil32(return_data.size) + ceil32(32 * mem[_9816 + mem[_9816]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _9816 + ceil32(return_data.size) + ceil32(32 * mem[_9816 + mem[_9816]]) + 1
                mem[_9816 + ceil32(return_data.size)] = _9980
                require _9891 + (32 * _9980) + 32 <= return_data.size
                v = 0
                w = _9816 + _9891 + 32
                x = _9816 + ceil32(return_data.size) + 32
                while v < _9980:
                    mem[x] = mem[w]
                    v = v + 1
                    w = w + 32
                    x = x + 32
                    continue 
                _10729 = mem[_9816 + 32]
                require mem[_9816 + 32] <= test266151307()
                require _9816 + mem[_9816 + 32] + 31 < _9816 + return_data.size
                _10872 = mem[_9816 + mem[_9816 + 32]]
                if mem[_9816 + mem[_9816 + 32]] > test266151307():
                    revert with 0, 65
                _10949 = mem[64]
                if mem[64] + ceil32(32 * mem[_9816 + mem[_9816 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_9816 + mem[_9816 + 32]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = mem[64] + ceil32(32 * mem[_9816 + mem[_9816 + 32]]) + 1
                mem[_10949] = _10872
                require _10729 + (32 * _10872) + 32 <= return_data.size
                v = 0
                w = _9816 + _10729 + 32
                x = _10949 + 32
                while v < _10872:
                    mem[x] = mem[w]
                    v = v + 1
                    w = w + 32
                    x = x + 32
                    continue 
                _11734 = mem[_9816 + ceil32(return_data.size)]
                v = 0
                w = u
                while v < _11734:
                    if v >= mem[_9816 + ceil32(return_data.size)]:
                        revert with 0, 50
                    if w >= mem[_6067]:
                        revert with 0, 50
                    mem[(32 * w) + _6067 + 32] = mem[(32 * v) + _9816 + ceil32(return_data.size) + 32]
                    if v >= mem[_10949]:
                        revert with 0, 50
                    if w >= mem[_6067 + (32 * s + t) + 32]:
                        revert with 0, 50
                    mem[(32 * w) + _6067 + (32 * s + t) + 64] = mem[(32 * v) + _10949 + 32]
                    if w == -1:
                        revert with 0, 17
                    if v == -1:
                        revert with 0, 17
                    _11734 = mem[_9816 + ceil32(return_data.size)]
                    v = v + 1
                    w = w + 1
                    continue 
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        if s > !t:
            revert with 0, 17
        if u != s + t:
            revert with 0, 1
        if arg2 >= stor5.length:
            revert with 0, 50
        mem[0] = 5
        _9591 = mem[64]
        mem[64] = mem[64] + 64
        mem[_9591] = address(stor5[arg2].field_0)
        mem[_9591 + 32] = address(stor5[arg2].field_256)
        mem[0] = address(stor5[arg2].field_0)
        mem[32] = sha3(arg1, 1) + 3
        if not stor1[arg1][3][address(stor5[arg2].field_0)].field_0:
            _9695 = mem[64]
            mem[64] = mem[64] + 32
            mem[_9695 + 32] = 32
            mem[_9695 + 64] = mem[_9695]
            mem[_9695 + 96 len 32 * mem[_9695]] = mem[_9695 + 32 len 32 * mem[_9695]]
            var71001 = mem[_9695]
            return memory
              from mem[64]
               len _9695 + (32 * mem[_9695]) + -mem[64] + 96
        if stor1[arg1][3][address(stor5[arg2].field_0)].field_0 < 1:
            revert with 0, 17
        mem[mem[64]] = 0x26148aa500000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = 96
        _9920 = mem[_6067]
        mem[mem[64] + 100] = mem[_6067]
        mem[mem[64] + 132 len 32 * _9920] = mem[_6067 + 32 len 32 * _9920]
        var72001 = _9920
        var72002 = _6067 + (32 * _9920) + 32
        mem[mem[64] + 36] = arg1
        mem[mem[64] + 68] = stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1
        require ext_code.size(address(stor5[arg2].field_256))
        staticcall address(stor5[arg2].field_256).0x26148aa5 with:
                gas gas_remaining wei
               args 96, arg1, stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1, mem[mem[64] + 100 len (32 * _9920) + 32]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _10871 = mem[64]
        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _10917 = mem[_10871]
        require mem[_10871] <= test266151307()
        require _10871 + mem[_10871] + 31 < _10871 + return_data.size
        _10990 = mem[_10871 + mem[_10871]]
        if mem[_10871 + mem[_10871]] > test266151307():
            revert with 0, 65
        if ceil32(32 * mem[_10871 + mem[_10871]]) + 1 < 0 or _10871 + ceil32(return_data.size) + ceil32(32 * mem[_10871 + mem[_10871]]) + 1 > test266151307():
            revert with 0, 65
        mem[64] = _10871 + ceil32(return_data.size) + ceil32(32 * mem[_10871 + mem[_10871]]) + 1
        mem[_10871 + ceil32(return_data.size)] = _10990
        require _10917 + (32 * _10990) + 32 <= return_data.size
        mem[_10871 + ceil32(return_data.size) + 32 len 32 * _10990] = mem[_10871 + _10917 + 32 len 32 * _10990]
        var91001 = _10990
        var91002 = _10871 + _10917 + (32 * _10990) + 32
        var91004 = _10871 + ceil32(return_data.size) + (32 * _10990) + 32
        mem[mem[64]] = 32
        mem[mem[64] + 32] = _10990
        mem[mem[64] + 64 len 32 * _10990] = mem[_10871 + ceil32(return_data.size) + 32 len 32 * _10990]
        var99001 = _10990
        var99002 = _10871 + ceil32(return_data.size) + (32 * _10990) + 32
        return Array(len=_10990, data=mem[mem[64] + 64 len 32 * _10990])
    mem[0] = sha3(ext_call.return_data[31 len 1], 10) + 1
    mem[ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + 256] = stor10[ext_call.return_data[31 len 1]][1].field_0
    idx = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + 256
    s = 0
    while ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 224 > idx:
        mem[idx + 32] = stor10[ext_call.return_data[31 len 1]][s + 1].field_256
        idx = idx + 32
        s = s + 1
        continue 
    mem[ceil32(return_data.size) + 128] = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + 224
    mem[64] = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + (32 * stor10[ext_call.return_data[31 len 1]].field_512) + 288
    mem[ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 256] = stor10[ext_call.return_data[31 len 1]].field_512
    if not stor10[ext_call.return_data[31 len 1]].field_512:
        mem[ceil32(return_data.size) + 160] = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 256
        idx = 0
        s = 0
        while idx < stor10[ext_call.return_data[31 len 1]].field_512:
            mem[0] = arg1
            mem[32] = 1
            mem[mem[64] + 32] = idx
            mem[mem[64] + 64] = stor1[arg1].field_512
            mem[mem[64] + 96] = stor8
            _4082 = mem[64]
            mem[mem[64]] = 96
            mem[64] = mem[64] + 128
            if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                revert with 0, 50
            if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                revert with 0, 18
            if sha3(mem[_4082 + 32 len mem[_4082]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s
                continue 
            if s == -1:
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = s + 1
            continue 
        idx = 0
        t = 0
        while idx < stor5.length:
            mem[0] = 5
            _6046 = mem[64]
            mem[64] = mem[64] + 64
            mem[_6046] = address(stor5[idx].field_0)
            mem[_6046 + 32] = address(stor5[idx].field_256)
            mem[0] = address(stor5[idx].field_0)
            mem[32] = sha3(arg1, 1) + 3
            if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                _6070 = mem[64]
                mem[mem[64]] = 0
                mem[mem[64] + 32] = 0
                mem[64] = mem[64] + 64
                if t > !mem[_6070]:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                t = t + mem[_6070]
                continue 
            mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = arg1
            mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
            require ext_code.size(address(stor5[idx].field_256))
            staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                    gas gas_remaining wei
                   args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _6327 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 64
            _6415 = mem[_6327]
            require mem[_6327] <= test266151307()
            require _6327 + mem[_6327] + 31 < _6327 + return_data.size
            _6579 = mem[_6327 + mem[_6327]]
            if mem[_6327 + mem[_6327]] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[_6327 + mem[_6327]]) + 1 < 0 or _6327 + ceil32(return_data.size) + ceil32(32 * mem[_6327 + mem[_6327]]) + 1 > test266151307():
                revert with 0, 65
            mem[64] = _6327 + ceil32(return_data.size) + ceil32(32 * mem[_6327 + mem[_6327]]) + 1
            mem[_6327 + ceil32(return_data.size)] = _6579
            require _6415 + (32 * _6579) + 32 <= return_data.size
            s = 0
            u = _6327 + _6415 + 32
            v = _6327 + ceil32(return_data.size) + 32
            while s < _6579:
                mem[v] = mem[u]
                s = s + 1
                u = u + 32
                v = v + 32
                continue 
            _7993 = mem[_6327 + 32]
            require mem[_6327 + 32] <= test266151307()
            require _6327 + mem[_6327 + 32] + 31 < _6327 + return_data.size
            _8097 = mem[_6327 + mem[_6327 + 32]]
            if mem[_6327 + mem[_6327 + 32]] > test266151307():
                revert with 0, 65
            _8359 = mem[64]
            if mem[64] + ceil32(32 * mem[_6327 + mem[_6327 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_6327 + mem[_6327 + 32]]) + 1 > test266151307():
                revert with 0, 65
            mem[64] = mem[64] + ceil32(32 * mem[_6327 + mem[_6327 + 32]]) + 1
            mem[_8359] = _8097
            require _7993 + (32 * _8097) + 32 <= return_data.size
            s = 0
            u = _6327 + _7993 + 32
            v = _8359 + 32
            while s < _8097:
                mem[v] = mem[u]
                s = s + 1
                u = u + 32
                v = v + 32
                continue 
            if t > !mem[_6327 + ceil32(return_data.size)]:
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            t = t + mem[_6327 + ceil32(return_data.size)]
            continue 
        if s > !t:
            revert with 0, 17
        if s + t > test266151307():
            revert with 0, 65
        _6069 = mem[64]
        mem[mem[64]] = s + t
        if not s + t:
            if s > !t:
                revert with 0, 17
            if s + t > test266151307():
                revert with 0, 65
            _6326 = mem[64] + (32 * s + t) + 32
            mem[mem[64] + (32 * s + t) + 32] = s + t
            mem[64] = _6326 + (32 * s + t) + 32
            if not s + t:
                _7776 = mem[mem[ceil32(return_data.size) + 160]]
                idx = 0
                u = 0
                while idx < _7776:
                    mem[0] = arg1
                    mem[32] = 1
                    mem[mem[64] + 32] = idx
                    mem[mem[64] + 64] = stor1[arg1].field_512
                    mem[mem[64] + 96] = stor8
                    _7901 = mem[64]
                    mem[mem[64]] = 96
                    mem[64] = mem[64] + 128
                    if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                        revert with 0, 50
                    if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        revert with 0, 18
                    if sha3(mem[_7901 + 32 len mem[_7901]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                        if idx == -1:
                            revert with 0, 17
                        _7776 = mem[mem[ceil32(return_data.size) + 160]]
                        idx = idx + 1
                        u = u
                        continue 
                    if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                        revert with 0, 50
                    if u >= mem[_6069]:
                        revert with 0, 50
                    mem[(32 * u) + _6069 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                    if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                        revert with 0, 50
                    if u >= mem[_6326]:
                        revert with 0, 50
                    mem[(32 * u) + _6326 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                    if u == -1:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _7776 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = idx + 1
                    u = u + 1
                    continue 
                idx = 0
                while idx < stor5.length:
                    mem[0] = 5
                    _9478 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_9478] = address(stor5[idx].field_0)
                    mem[_9478 + 32] = address(stor5[idx].field_256)
                    mem[0] = address(stor5[idx].field_0)
                    mem[32] = sha3(arg1, 1) + 3
                    if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                        _9512 = mem[64]
                        mem[mem[64]] = 0
                        mem[mem[64] + 32] = 0
                        mem[64] = mem[64] + 64
                        _10571 = mem[_9512]
                        s = 0
                        t = u
                        while s < _10571:
                            if s >= mem[_9512]:
                                revert with 0, 50
                            if t >= mem[_6069]:
                                revert with 0, 50
                            mem[(32 * t) + _6069 + 32] = mem[(32 * s) + _9512 + 32]
                            if s >= mem[_9512 + 32]:
                                revert with 0, 50
                            if t >= mem[_6326]:
                                revert with 0, 50
                            mem[(32 * t) + _6326 + 32] = mem[(32 * s) + _9512 + 64]
                            if t == -1:
                                revert with 0, 17
                            if s == -1:
                                revert with 0, 17
                            _10571 = mem[_9512]
                            s = s + 1
                            t = t + 1
                            continue 
                    else:
                        mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = arg1
                        mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                        require ext_code.size(address(stor5[idx].field_256))
                        staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                                gas gas_remaining wei
                               args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _9820 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 64
                        _9895 = mem[_9820]
                        require mem[_9820] <= test266151307()
                        require _9820 + mem[_9820] + 31 < _9820 + return_data.size
                        _9982 = mem[_9820 + mem[_9820]]
                        if mem[_9820 + mem[_9820]] > test266151307():
                            revert with 0, 65
                        if ceil32(32 * mem[_9820 + mem[_9820]]) + 1 < 0 or _9820 + ceil32(return_data.size) + ceil32(32 * mem[_9820 + mem[_9820]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = _9820 + ceil32(return_data.size) + ceil32(32 * mem[_9820 + mem[_9820]]) + 1
                        mem[_9820 + ceil32(return_data.size)] = _9982
                        require _9895 + (32 * _9982) + 32 <= return_data.size
                        s = 0
                        t = _9820 + _9895 + 32
                        v = _9820 + ceil32(return_data.size) + 32
                        while s < _9982:
                            mem[v] = mem[t]
                            s = s + 1
                            t = t + 32
                            v = v + 32
                            continue 
                        _10732 = mem[_9820 + 32]
                        require mem[_9820 + 32] <= test266151307()
                        require _9820 + mem[_9820 + 32] + 31 < _9820 + return_data.size
                        _10874 = mem[_9820 + mem[_9820 + 32]]
                        if mem[_9820 + mem[_9820 + 32]] > test266151307():
                            revert with 0, 65
                        _10950 = mem[64]
                        if mem[64] + ceil32(32 * mem[_9820 + mem[_9820 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_9820 + mem[_9820 + 32]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = mem[64] + ceil32(32 * mem[_9820 + mem[_9820 + 32]]) + 1
                        mem[_10950] = _10874
                        require _10732 + (32 * _10874) + 32 <= return_data.size
                        s = 0
                        t = _9820 + _10732 + 32
                        v = _10950 + 32
                        while s < _10874:
                            mem[v] = mem[t]
                            s = s + 1
                            t = t + 32
                            v = v + 32
                            continue 
                        _11735 = mem[_9820 + ceil32(return_data.size)]
                        s = 0
                        t = u
                        while s < _11735:
                            if s >= mem[_9820 + ceil32(return_data.size)]:
                                revert with 0, 50
                            if t >= mem[_6069]:
                                revert with 0, 50
                            mem[(32 * t) + _6069 + 32] = mem[(32 * s) + _9820 + ceil32(return_data.size) + 32]
                            if s >= mem[_10950]:
                                revert with 0, 50
                            if t >= mem[_6326]:
                                revert with 0, 50
                            mem[(32 * t) + _6326 + 32] = mem[(32 * s) + _10950 + 32]
                            if t == -1:
                                revert with 0, 17
                            if s == -1:
                                revert with 0, 17
                            _11735 = mem[_9820 + ceil32(return_data.size)]
                            s = s + 1
                            t = t + 1
                            continue 
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                if s > !t:
                    revert with 0, 17
                if u != s + t:
                    revert with 0, 1
                if arg2 >= stor5.length:
                    revert with 0, 50
                mem[0] = 5
                _9596 = mem[64]
                mem[64] = mem[64] + 64
                mem[_9596] = address(stor5[arg2].field_0)
                mem[_9596 + 32] = address(stor5[arg2].field_256)
                mem[0] = address(stor5[arg2].field_0)
                mem[32] = sha3(arg1, 1) + 3
                if not stor1[arg1][3][address(stor5[arg2].field_0)].field_0:
                    _9701 = mem[64]
                    mem[64] = mem[64] + 32
                    mem[_9701 + 32] = 32
                    mem[_9701 + 64] = mem[_9701]
                    mem[_9701 + 96 len 32 * mem[_9701]] = mem[_9701 + 32 len 32 * mem[_9701]]
                    var69001 = mem[_9701]
                    var69002 = _9701 + (32 * mem[_9701]) + 32
                    return memory
                      from mem[64]
                       len _9701 + (32 * mem[_9701]) + -mem[64] + 96
                if stor1[arg1][3][address(stor5[arg2].field_0)].field_0 < 1:
                    revert with 0, 17
                mem[mem[64]] = 0x26148aa500000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 96
                _9921 = mem[_6069]
                mem[mem[64] + 100] = mem[_6069]
                mem[mem[64] + 132 len 32 * _9921] = mem[_6069 + 32 len 32 * _9921]
                var70001 = _9921
                var70002 = _6069 + (32 * _9921) + 32
                mem[mem[64] + 36] = arg1
                mem[mem[64] + 68] = stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1
                require ext_code.size(address(stor5[arg2].field_256))
                staticcall address(stor5[arg2].field_256).0x26148aa5 with:
                        gas gas_remaining wei
                       args 96, arg1, stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1, mem[mem[64] + 100 len (32 * _9921) + 32]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _10873 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _10918 = mem[_10873]
                require mem[_10873] <= test266151307()
                require _10873 + mem[_10873] + 31 < _10873 + return_data.size
                _10991 = mem[_10873 + mem[_10873]]
                if mem[_10873 + mem[_10873]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_10873 + mem[_10873]]) + 1 < 0 or _10873 + ceil32(return_data.size) + ceil32(32 * mem[_10873 + mem[_10873]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _10873 + ceil32(return_data.size) + ceil32(32 * mem[_10873 + mem[_10873]]) + 1
                mem[_10873 + ceil32(return_data.size)] = _10991
                require _10918 + (32 * _10991) + 32 <= return_data.size
                mem[_10873 + ceil32(return_data.size) + 32 len 32 * _10991] = mem[_10873 + _10918 + 32 len 32 * _10991]
                var89001 = _10991
                var89002 = _10873 + _10918 + (32 * _10991) + 32
                var89004 = _10873 + ceil32(return_data.size) + (32 * _10991) + 32
                mem[mem[64]] = 32
                mem[mem[64] + 32] = _10991
                mem[mem[64] + 64 len 32 * _10991] = mem[_10873 + ceil32(return_data.size) + 32 len 32 * _10991]
                var97001 = _10991
                var97002 = _10873 + ceil32(return_data.size) + (32 * _10991) + 32
                return Array(len=_10991, data=mem[mem[64] + 64 len 32 * _10991])
            mem[_6326 + 32 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
            _7778 = mem[mem[ceil32(return_data.size) + 160]]
            idx = 0
            u = 0
            while idx < _7778:
                mem[0] = arg1
                mem[32] = 1
                mem[mem[64] + 32] = idx
                mem[mem[64] + 64] = stor1[arg1].field_512
                mem[mem[64] + 96] = stor8
                _7908 = mem[64]
                mem[mem[64]] = 96
                mem[64] = mem[64] + 128
                if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                    revert with 0, 50
                if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    revert with 0, 18
                if sha3(mem[_7908 + 32 len mem[_7908]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    if idx == -1:
                        revert with 0, 17
                    _7778 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = idx + 1
                    u = u
                    continue 
                if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                    revert with 0, 50
                if u >= mem[_6069]:
                    revert with 0, 50
                mem[(32 * u) + _6069 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                    revert with 0, 50
                if u >= mem[_6326]:
                    revert with 0, 50
                mem[(32 * u) + _6326 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                if u == -1:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _7778 = mem[mem[ceil32(return_data.size) + 160]]
                idx = idx + 1
                u = u + 1
                continue 
            idx = 0
            while idx < stor5.length:
                mem[0] = 5
                _9483 = mem[64]
                mem[64] = mem[64] + 64
                mem[_9483] = address(stor5[idx].field_0)
                mem[_9483 + 32] = address(stor5[idx].field_256)
                mem[0] = address(stor5[idx].field_0)
                mem[32] = sha3(arg1, 1) + 3
                if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                    _9513 = mem[64]
                    mem[mem[64]] = 0
                    mem[mem[64] + 32] = 0
                    mem[64] = mem[64] + 64
                    _10572 = mem[_9513]
                    s = 0
                    t = u
                    while s < _10572:
                        if s >= mem[_9513]:
                            revert with 0, 50
                        if t >= mem[_6069]:
                            revert with 0, 50
                        mem[(32 * t) + _6069 + 32] = mem[(32 * s) + _9513 + 32]
                        if s >= mem[_9513 + 32]:
                            revert with 0, 50
                        if t >= mem[_6326]:
                            revert with 0, 50
                        mem[(32 * t) + _6326 + 32] = mem[(32 * s) + _9513 + 64]
                        if t == -1:
                            revert with 0, 17
                        if s == -1:
                            revert with 0, 17
                        _10572 = mem[_9513]
                        s = s + 1
                        t = t + 1
                        continue 
                else:
                    mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = arg1
                    mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    require ext_code.size(address(stor5[idx].field_256))
                    staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                            gas gas_remaining wei
                           args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _9824 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 64
                    _9899 = mem[_9824]
                    require mem[_9824] <= test266151307()
                    require _9824 + mem[_9824] + 31 < _9824 + return_data.size
                    _9984 = mem[_9824 + mem[_9824]]
                    if mem[_9824 + mem[_9824]] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[_9824 + mem[_9824]]) + 1 < 0 or _9824 + ceil32(return_data.size) + ceil32(32 * mem[_9824 + mem[_9824]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = _9824 + ceil32(return_data.size) + ceil32(32 * mem[_9824 + mem[_9824]]) + 1
                    mem[_9824 + ceil32(return_data.size)] = _9984
                    require _9899 + (32 * _9984) + 32 <= return_data.size
                    s = 0
                    t = _9824 + _9899 + 32
                    v = _9824 + ceil32(return_data.size) + 32
                    while s < _9984:
                        mem[v] = mem[t]
                        s = s + 1
                        t = t + 32
                        v = v + 32
                        continue 
                    _10735 = mem[_9824 + 32]
                    require mem[_9824 + 32] <= test266151307()
                    require _9824 + mem[_9824 + 32] + 31 < _9824 + return_data.size
                    _10876 = mem[_9824 + mem[_9824 + 32]]
                    if mem[_9824 + mem[_9824 + 32]] > test266151307():
                        revert with 0, 65
                    _10951 = mem[64]
                    if mem[64] + ceil32(32 * mem[_9824 + mem[_9824 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_9824 + mem[_9824 + 32]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = mem[64] + ceil32(32 * mem[_9824 + mem[_9824 + 32]]) + 1
                    mem[_10951] = _10876
                    require _10735 + (32 * _10876) + 32 <= return_data.size
                    s = 0
                    t = _9824 + _10735 + 32
                    v = _10951 + 32
                    while s < _10876:
                        mem[v] = mem[t]
                        s = s + 1
                        t = t + 32
                        v = v + 32
                        continue 
                    _11736 = mem[_9824 + ceil32(return_data.size)]
                    s = 0
                    t = u
                    while s < _11736:
                        if s >= mem[_9824 + ceil32(return_data.size)]:
                            revert with 0, 50
                        if t >= mem[_6069]:
                            revert with 0, 50
                        mem[(32 * t) + _6069 + 32] = mem[(32 * s) + _9824 + ceil32(return_data.size) + 32]
                        if s >= mem[_10951]:
                            revert with 0, 50
                        if t >= mem[_6326]:
                            revert with 0, 50
                        mem[(32 * t) + _6326 + 32] = mem[(32 * s) + _10951 + 32]
                        if t == -1:
                            revert with 0, 17
                        if s == -1:
                            revert with 0, 17
                        _11736 = mem[_9824 + ceil32(return_data.size)]
                        s = s + 1
                        t = t + 1
                        continue 
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            if s > !t:
                revert with 0, 17
            if u != s + t:
                revert with 0, 1
            if arg2 >= stor5.length:
                revert with 0, 50
            mem[0] = 5
            _9601 = mem[64]
            mem[64] = mem[64] + 64
            mem[_9601] = address(stor5[arg2].field_0)
            mem[_9601 + 32] = address(stor5[arg2].field_256)
            mem[0] = address(stor5[arg2].field_0)
            mem[32] = sha3(arg1, 1) + 3
            if not stor1[arg1][3][address(stor5[arg2].field_0)].field_0:
                _9707 = mem[64]
                mem[64] = mem[64] + 32
                mem[_9707 + 32] = 32
                mem[_9707 + 64] = mem[_9707]
                mem[_9707 + 96 len 32 * mem[_9707]] = mem[_9707 + 32 len 32 * mem[_9707]]
                var70001 = mem[_9707]
                var70002 = _9707 + (32 * mem[_9707]) + 32
                return memory
                  from mem[64]
                   len _9707 + (32 * mem[_9707]) + -mem[64] + 96
            if stor1[arg1][3][address(stor5[arg2].field_0)].field_0 < 1:
                revert with 0, 17
            mem[mem[64]] = 0x26148aa500000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 96
            _9922 = mem[_6069]
            mem[mem[64] + 100] = mem[_6069]
            mem[mem[64] + 132 len 32 * _9922] = mem[_6069 + 32 len 32 * _9922]
            var71001 = _9922
            mem[mem[64] + 36] = arg1
            mem[mem[64] + 68] = stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1
            require ext_code.size(address(stor5[arg2].field_256))
            staticcall address(stor5[arg2].field_256).0x26148aa5 with:
                    gas gas_remaining wei
                   args 96, arg1, stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1, mem[mem[64] + 100 len (32 * _9922) + 32]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _10875 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _10919 = mem[_10875]
            require mem[_10875] <= test266151307()
            require _10875 + mem[_10875] + 31 < _10875 + return_data.size
            _10992 = mem[_10875 + mem[_10875]]
            if mem[_10875 + mem[_10875]] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[_10875 + mem[_10875]]) + 1 < 0 or _10875 + ceil32(return_data.size) + ceil32(32 * mem[_10875 + mem[_10875]]) + 1 > test266151307():
                revert with 0, 65
            mem[64] = _10875 + ceil32(return_data.size) + ceil32(32 * mem[_10875 + mem[_10875]]) + 1
            mem[_10875 + ceil32(return_data.size)] = _10992
            require _10919 + (32 * _10992) + 32 <= return_data.size
            mem[_10875 + ceil32(return_data.size) + 32 len 32 * _10992] = mem[_10875 + _10919 + 32 len 32 * _10992]
            var90001 = _10992
            var90002 = _10875 + _10919 + (32 * _10992) + 32
            var90004 = _10875 + ceil32(return_data.size) + (32 * _10992) + 32
            mem[mem[64]] = 32
            mem[mem[64] + 32] = _10992
            mem[mem[64] + 64 len 32 * _10992] = mem[_10875 + ceil32(return_data.size) + 32 len 32 * _10992]
            var98001 = _10992
            var98002 = _10875 + ceil32(return_data.size) + (32 * _10992) + 32
            return Array(len=_10992, data=mem[mem[64] + 64 len 32 * _10992])
        mem[mem[64] + 32 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
        if s > !t:
            revert with 0, 17
        if s + t > test266151307():
            revert with 0, 65
        mem[mem[64] + (32 * s + t) + 32] = s + t
        mem[64] = _6069 + (64 * s + t) + 64
        if not s + t:
            _7780 = mem[mem[ceil32(return_data.size) + 160]]
            idx = 0
            u = 0
            while idx < _7780:
                mem[0] = arg1
                mem[32] = 1
                mem[mem[64] + 32] = idx
                mem[mem[64] + 64] = stor1[arg1].field_512
                mem[mem[64] + 96] = stor8
                _7915 = mem[64]
                mem[mem[64]] = 96
                mem[64] = mem[64] + 128
                if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                    revert with 0, 50
                if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    revert with 0, 18
                if sha3(mem[_7915 + 32 len mem[_7915]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    if idx == -1:
                        revert with 0, 17
                    _7780 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = idx + 1
                    u = u
                    continue 
                if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                    revert with 0, 50
                if u >= mem[_6069]:
                    revert with 0, 50
                mem[(32 * u) + _6069 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                    revert with 0, 50
                if u >= mem[_6069 + (32 * s + t) + 32]:
                    revert with 0, 50
                mem[(32 * u) + _6069 + (32 * s + t) + 64] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                if u == -1:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _7780 = mem[mem[ceil32(return_data.size) + 160]]
                idx = idx + 1
                u = u + 1
                continue 
            idx = 0
            while idx < stor5.length:
                mem[0] = 5
                _9488 = mem[64]
                mem[64] = mem[64] + 64
                mem[_9488] = address(stor5[idx].field_0)
                mem[_9488 + 32] = address(stor5[idx].field_256)
                mem[0] = address(stor5[idx].field_0)
                mem[32] = sha3(arg1, 1) + 3
                if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                    _9514 = mem[64]
                    mem[mem[64]] = 0
                    mem[mem[64] + 32] = 0
                    mem[64] = mem[64] + 64
                    _10573 = mem[_9514]
                    v = 0
                    w = u
                    while v < _10573:
                        if v >= mem[_9514]:
                            revert with 0, 50
                        if w >= mem[_6069]:
                            revert with 0, 50
                        mem[(32 * w) + _6069 + 32] = mem[(32 * v) + _9514 + 32]
                        if v >= mem[_9514 + 32]:
                            revert with 0, 50
                        if w >= mem[_6069 + (32 * s + t) + 32]:
                            revert with 0, 50
                        mem[(32 * w) + _6069 + (32 * s + t) + 64] = mem[(32 * v) + _9514 + 64]
                        if w == -1:
                            revert with 0, 17
                        if v == -1:
                            revert with 0, 17
                        _10573 = mem[_9514]
                        v = v + 1
                        w = w + 1
                        continue 
                else:
                    mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = arg1
                    mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    require ext_code.size(address(stor5[idx].field_256))
                    staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                            gas gas_remaining wei
                           args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _9828 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 64
                    _9903 = mem[_9828]
                    require mem[_9828] <= test266151307()
                    require _9828 + mem[_9828] + 31 < _9828 + return_data.size
                    _9986 = mem[_9828 + mem[_9828]]
                    if mem[_9828 + mem[_9828]] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[_9828 + mem[_9828]]) + 1 < 0 or _9828 + ceil32(return_data.size) + ceil32(32 * mem[_9828 + mem[_9828]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = _9828 + ceil32(return_data.size) + ceil32(32 * mem[_9828 + mem[_9828]]) + 1
                    mem[_9828 + ceil32(return_data.size)] = _9986
                    require _9903 + (32 * _9986) + 32 <= return_data.size
                    v = 0
                    w = _9828 + _9903 + 32
                    x = _9828 + ceil32(return_data.size) + 32
                    while v < _9986:
                        mem[x] = mem[w]
                        v = v + 1
                        w = w + 32
                        x = x + 32
                        continue 
                    _10738 = mem[_9828 + 32]
                    require mem[_9828 + 32] <= test266151307()
                    require _9828 + mem[_9828 + 32] + 31 < _9828 + return_data.size
                    _10878 = mem[_9828 + mem[_9828 + 32]]
                    if mem[_9828 + mem[_9828 + 32]] > test266151307():
                        revert with 0, 65
                    _10952 = mem[64]
                    if mem[64] + ceil32(32 * mem[_9828 + mem[_9828 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_9828 + mem[_9828 + 32]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = mem[64] + ceil32(32 * mem[_9828 + mem[_9828 + 32]]) + 1
                    mem[_10952] = _10878
                    require _10738 + (32 * _10878) + 32 <= return_data.size
                    v = 0
                    w = _9828 + _10738 + 32
                    x = _10952 + 32
                    while v < _10878:
                        mem[x] = mem[w]
                        v = v + 1
                        w = w + 32
                        x = x + 32
                        continue 
                    _11737 = mem[_9828 + ceil32(return_data.size)]
                    v = 0
                    w = u
                    while v < _11737:
                        if v >= mem[_9828 + ceil32(return_data.size)]:
                            revert with 0, 50
                        if w >= mem[_6069]:
                            revert with 0, 50
                        mem[(32 * w) + _6069 + 32] = mem[(32 * v) + _9828 + ceil32(return_data.size) + 32]
                        if v >= mem[_10952]:
                            revert with 0, 50
                        if w >= mem[_6069 + (32 * s + t) + 32]:
                            revert with 0, 50
                        mem[(32 * w) + _6069 + (32 * s + t) + 64] = mem[(32 * v) + _10952 + 32]
                        if w == -1:
                            revert with 0, 17
                        if v == -1:
                            revert with 0, 17
                        _11737 = mem[_9828 + ceil32(return_data.size)]
                        v = v + 1
                        w = w + 1
                        continue 
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            if s > !t:
                revert with 0, 17
            if u != s + t:
                revert with 0, 1
            if arg2 >= stor5.length:
                revert with 0, 50
            mem[0] = 5
            _9606 = mem[64]
            mem[64] = mem[64] + 64
            mem[_9606] = address(stor5[arg2].field_0)
            mem[_9606 + 32] = address(stor5[arg2].field_256)
            mem[0] = address(stor5[arg2].field_0)
            mem[32] = sha3(arg1, 1) + 3
            if not stor1[arg1][3][address(stor5[arg2].field_0)].field_0:
                _9713 = mem[64]
                mem[64] = mem[64] + 32
                mem[_9713 + 32] = 32
                mem[_9713 + 64] = mem[_9713]
                mem[_9713 + 96 len 32 * mem[_9713]] = mem[_9713 + 32 len 32 * mem[_9713]]
                var70001 = mem[_9713]
                var70002 = _9713 + (32 * mem[_9713]) + 32
                return memory
                  from mem[64]
                   len _9713 + (32 * mem[_9713]) + -mem[64] + 96
            if stor1[arg1][3][address(stor5[arg2].field_0)].field_0 < 1:
                revert with 0, 17
            mem[mem[64]] = 0x26148aa500000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 96
            _9923 = mem[_6069]
            mem[mem[64] + 100] = mem[_6069]
            mem[mem[64] + 132 len 32 * _9923] = mem[_6069 + 32 len 32 * _9923]
            var71001 = _9923
            mem[mem[64] + 36] = arg1
            mem[mem[64] + 68] = stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1
            require ext_code.size(address(stor5[arg2].field_256))
            staticcall address(stor5[arg2].field_256).0x26148aa5 with:
                    gas gas_remaining wei
                   args 96, arg1, stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1, mem[mem[64] + 100 len (32 * _9923) + 32]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _10877 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _10920 = mem[_10877]
            require mem[_10877] <= test266151307()
            require _10877 + mem[_10877] + 31 < _10877 + return_data.size
            _10993 = mem[_10877 + mem[_10877]]
            if mem[_10877 + mem[_10877]] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[_10877 + mem[_10877]]) + 1 < 0 or _10877 + ceil32(return_data.size) + ceil32(32 * mem[_10877 + mem[_10877]]) + 1 > test266151307():
                revert with 0, 65
            mem[64] = _10877 + ceil32(return_data.size) + ceil32(32 * mem[_10877 + mem[_10877]]) + 1
            mem[_10877 + ceil32(return_data.size)] = _10993
            require _10920 + (32 * _10993) + 32 <= return_data.size
            mem[_10877 + ceil32(return_data.size) + 32 len 32 * _10993] = mem[_10877 + _10920 + 32 len 32 * _10993]
            var90001 = _10993
            var90002 = _10877 + _10920 + (32 * _10993) + 32
            var90004 = _10877 + ceil32(return_data.size) + (32 * _10993) + 32
            mem[mem[64]] = 32
            mem[mem[64] + 32] = _10993
            mem[mem[64] + 64 len 32 * _10993] = mem[_10877 + ceil32(return_data.size) + 32 len 32 * _10993]
            var98001 = _10993
            var98002 = _10877 + ceil32(return_data.size) + (32 * _10993) + 32
            return Array(len=_10993, data=mem[mem[64] + 64 len 32 * _10993])
        mem[_6069 + (32 * s + t) + 64 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
        _7782 = mem[mem[ceil32(return_data.size) + 160]]
        idx = 0
        u = 0
        while idx < _7782:
            mem[0] = arg1
            mem[32] = 1
            mem[mem[64] + 32] = idx
            mem[mem[64] + 64] = stor1[arg1].field_512
            mem[mem[64] + 96] = stor8
            _7922 = mem[64]
            mem[mem[64]] = 96
            mem[64] = mem[64] + 128
            if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                revert with 0, 50
            if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                revert with 0, 18
            if sha3(mem[_7922 + 32 len mem[_7922]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                if idx == -1:
                    revert with 0, 17
                _7782 = mem[mem[ceil32(return_data.size) + 160]]
                idx = idx + 1
                u = u
                continue 
            if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                revert with 0, 50
            if u >= mem[_6069]:
                revert with 0, 50
            mem[(32 * u) + _6069 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
            if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                revert with 0, 50
            if u >= mem[_6069 + (32 * s + t) + 32]:
                revert with 0, 50
            mem[(32 * u) + _6069 + (32 * s + t) + 64] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
            if u == -1:
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            _7782 = mem[mem[ceil32(return_data.size) + 160]]
            idx = idx + 1
            u = u + 1
            continue 
        idx = 0
        while idx < stor5.length:
            mem[0] = 5
            _9493 = mem[64]
            mem[64] = mem[64] + 64
            mem[_9493] = address(stor5[idx].field_0)
            mem[_9493 + 32] = address(stor5[idx].field_256)
            mem[0] = address(stor5[idx].field_0)
            mem[32] = sha3(arg1, 1) + 3
            if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                _9515 = mem[64]
                mem[mem[64]] = 0
                mem[mem[64] + 32] = 0
                mem[64] = mem[64] + 64
                _10574 = mem[_9515]
                v = 0
                w = u
                while v < _10574:
                    if v >= mem[_9515]:
                        revert with 0, 50
                    if w >= mem[_6069]:
                        revert with 0, 50
                    mem[(32 * w) + _6069 + 32] = mem[(32 * v) + _9515 + 32]
                    if v >= mem[_9515 + 32]:
                        revert with 0, 50
                    if w >= mem[_6069 + (32 * s + t) + 32]:
                        revert with 0, 50
                    mem[(32 * w) + _6069 + (32 * s + t) + 64] = mem[(32 * v) + _9515 + 64]
                    if w == -1:
                        revert with 0, 17
                    if v == -1:
                        revert with 0, 17
                    _10574 = mem[_9515]
                    v = v + 1
                    w = w + 1
                    continue 
            else:
                mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = arg1
                mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                require ext_code.size(address(stor5[idx].field_256))
                staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                        gas gas_remaining wei
                       args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _9832 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 64
                _9907 = mem[_9832]
                require mem[_9832] <= test266151307()
                require _9832 + mem[_9832] + 31 < _9832 + return_data.size
                _9988 = mem[_9832 + mem[_9832]]
                if mem[_9832 + mem[_9832]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_9832 + mem[_9832]]) + 1 < 0 or _9832 + ceil32(return_data.size) + ceil32(32 * mem[_9832 + mem[_9832]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _9832 + ceil32(return_data.size) + ceil32(32 * mem[_9832 + mem[_9832]]) + 1
                mem[_9832 + ceil32(return_data.size)] = _9988
                require _9907 + (32 * _9988) + 32 <= return_data.size
                v = 0
                w = _9832 + _9907 + 32
                x = _9832 + ceil32(return_data.size) + 32
                while v < _9988:
                    mem[x] = mem[w]
                    v = v + 1
                    w = w + 32
                    x = x + 32
                    continue 
                _10741 = mem[_9832 + 32]
                require mem[_9832 + 32] <= test266151307()
                require _9832 + mem[_9832 + 32] + 31 < _9832 + return_data.size
                _10880 = mem[_9832 + mem[_9832 + 32]]
                if mem[_9832 + mem[_9832 + 32]] > test266151307():
                    revert with 0, 65
                _10953 = mem[64]
                if mem[64] + ceil32(32 * mem[_9832 + mem[_9832 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_9832 + mem[_9832 + 32]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = mem[64] + ceil32(32 * mem[_9832 + mem[_9832 + 32]]) + 1
                mem[_10953] = _10880
                require _10741 + (32 * _10880) + 32 <= return_data.size
                v = 0
                w = _9832 + _10741 + 32
                x = _10953 + 32
                while v < _10880:
                    mem[x] = mem[w]
                    v = v + 1
                    w = w + 32
                    x = x + 32
                    continue 
                _11738 = mem[_9832 + ceil32(return_data.size)]
                v = 0
                w = u
                while v < _11738:
                    if v >= mem[_9832 + ceil32(return_data.size)]:
                        revert with 0, 50
                    if w >= mem[_6069]:
                        revert with 0, 50
                    mem[(32 * w) + _6069 + 32] = mem[(32 * v) + _9832 + ceil32(return_data.size) + 32]
                    if v >= mem[_10953]:
                        revert with 0, 50
                    if w >= mem[_6069 + (32 * s + t) + 32]:
                        revert with 0, 50
                    mem[(32 * w) + _6069 + (32 * s + t) + 64] = mem[(32 * v) + _10953 + 32]
                    if w == -1:
                        revert with 0, 17
                    if v == -1:
                        revert with 0, 17
                    _11738 = mem[_9832 + ceil32(return_data.size)]
                    v = v + 1
                    w = w + 1
                    continue 
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        if s > !t:
            revert with 0, 17
        if u != s + t:
            revert with 0, 1
        if arg2 >= stor5.length:
            revert with 0, 50
        mem[0] = 5
        _9611 = mem[64]
        mem[64] = mem[64] + 64
        mem[_9611] = address(stor5[arg2].field_0)
        mem[_9611 + 32] = address(stor5[arg2].field_256)
        mem[0] = address(stor5[arg2].field_0)
        mem[32] = sha3(arg1, 1) + 3
        if not stor1[arg1][3][address(stor5[arg2].field_0)].field_0:
            _9719 = mem[64]
            mem[64] = mem[64] + 32
            mem[_9719 + 32] = 32
            mem[_9719 + 64] = mem[_9719]
            mem[_9719 + 96 len 32 * mem[_9719]] = mem[_9719 + 32 len 32 * mem[_9719]]
            var71001 = mem[_9719]
            return memory
              from mem[64]
               len _9719 + (32 * mem[_9719]) + -mem[64] + 96
        if stor1[arg1][3][address(stor5[arg2].field_0)].field_0 < 1:
            revert with 0, 17
        mem[mem[64]] = 0x26148aa500000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = 96
        _9924 = mem[_6069]
        mem[mem[64] + 100] = mem[_6069]
        mem[mem[64] + 132 len 32 * _9924] = mem[_6069 + 32 len 32 * _9924]
        var72001 = _9924
        var72002 = _6069 + (32 * _9924) + 32
        mem[mem[64] + 36] = arg1
        mem[mem[64] + 68] = stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1
        require ext_code.size(address(stor5[arg2].field_256))
        staticcall address(stor5[arg2].field_256).0x26148aa5 with:
                gas gas_remaining wei
               args 96, arg1, stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1, mem[mem[64] + 100 len (32 * _9924) + 32]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _10879 = mem[64]
        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _10921 = mem[_10879]
        require mem[_10879] <= test266151307()
        require _10879 + mem[_10879] + 31 < _10879 + return_data.size
        _10994 = mem[_10879 + mem[_10879]]
        if mem[_10879 + mem[_10879]] > test266151307():
            revert with 0, 65
        if ceil32(32 * mem[_10879 + mem[_10879]]) + 1 < 0 or _10879 + ceil32(return_data.size) + ceil32(32 * mem[_10879 + mem[_10879]]) + 1 > test266151307():
            revert with 0, 65
        mem[64] = _10879 + ceil32(return_data.size) + ceil32(32 * mem[_10879 + mem[_10879]]) + 1
        mem[_10879 + ceil32(return_data.size)] = _10994
        require _10921 + (32 * _10994) + 32 <= return_data.size
        mem[_10879 + ceil32(return_data.size) + 32 len 32 * _10994] = mem[_10879 + _10921 + 32 len 32 * _10994]
        var91001 = _10994
        var91002 = _10879 + _10921 + (32 * _10994) + 32
        var91004 = _10879 + ceil32(return_data.size) + (32 * _10994) + 32
        mem[mem[64]] = 32
        mem[mem[64] + 32] = _10994
        mem[mem[64] + 64 len 32 * _10994] = mem[_10879 + ceil32(return_data.size) + 32 len 32 * _10994]
        var99001 = _10994
        var99002 = _10879 + ceil32(return_data.size) + (32 * _10994) + 32
        return Array(len=_10994, data=mem[mem[64] + 64 len 32 * _10994])
    mem[0] = sha3(ext_call.return_data[31 len 1], 10) + 2
    mem[ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 288] = stor10[ext_call.return_data[31 len 1]][2].field_0
    idx = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 288
    s = 0
    while ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + (32 * stor10[ext_call.return_data[31 len 1]].field_512) + 256 > idx:
        mem[idx + 32] = stor10[ext_call.return_data[31 len 1]][s + 2].field_256
        idx = idx + 32
        s = s + 1
        continue 
    mem[ceil32(return_data.size) + 160] = ceil32(return_data.size) + (32 * stor10[ext_call.return_data[31 len 1]].field_0) + (32 * stor10[ext_call.return_data[31 len 1]].field_256) + 256
    idx = 0
    s = 0
    while idx < stor10[ext_call.return_data[31 len 1]].field_512:
        mem[0] = arg1
        mem[32] = 1
        mem[mem[64] + 32] = idx
        mem[mem[64] + 64] = stor1[arg1].field_512
        mem[mem[64] + 96] = stor8
        _7930 = mem[64]
        mem[mem[64]] = 96
        mem[64] = mem[64] + 128
        if idx >= mem[mem[ceil32(return_data.size) + 160]]:
            revert with 0, 50
        if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
            revert with 0, 18
        if sha3(mem[_7930 + 32 len mem[_7930]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = s
            continue 
        if s == -1:
            revert with 0, 17
        if idx == -1:
            revert with 0, 17
        idx = idx + 1
        s = s + 1
        continue 
    idx = 0
    t = 0
    while idx < stor5.length:
        mem[0] = 5
        _9498 = mem[64]
        mem[64] = mem[64] + 64
        mem[_9498] = address(stor5[idx].field_0)
        mem[_9498 + 32] = address(stor5[idx].field_256)
        mem[0] = address(stor5[idx].field_0)
        mem[32] = sha3(arg1, 1) + 3
        if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
            _9518 = mem[64]
            mem[mem[64]] = 0
            mem[mem[64] + 32] = 0
            mem[64] = mem[64] + 64
            if t > !mem[_9518]:
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            t = t + mem[_9518]
            continue 
        mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = arg1
        mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
        require ext_code.size(address(stor5[idx].field_256))
        staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                gas gas_remaining wei
               args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _9836 = mem[64]
        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 64
        _9912 = mem[_9836]
        require mem[_9836] <= test266151307()
        require _9836 + mem[_9836] + 31 < _9836 + return_data.size
        _9998 = mem[_9836 + mem[_9836]]
        if mem[_9836 + mem[_9836]] > test266151307():
            revert with 0, 65
        if ceil32(32 * mem[_9836 + mem[_9836]]) + 1 < 0 or _9836 + ceil32(return_data.size) + ceil32(32 * mem[_9836 + mem[_9836]]) + 1 > test266151307():
            revert with 0, 65
        mem[64] = _9836 + ceil32(return_data.size) + ceil32(32 * mem[_9836 + mem[_9836]]) + 1
        mem[_9836 + ceil32(return_data.size)] = _9998
        require _9912 + (32 * _9998) + 32 <= return_data.size
        s = 0
        u = _9836 + _9912 + 32
        v = _9836 + ceil32(return_data.size) + 32
        while s < _9998:
            mem[v] = mem[u]
            s = s + 1
            u = u + 32
            v = v + 32
            continue 
        _10748 = mem[_9836 + 32]
        require mem[_9836 + 32] <= test266151307()
        require _9836 + mem[_9836 + 32] + 31 < _9836 + return_data.size
        _10881 = mem[_9836 + mem[_9836 + 32]]
        if mem[_9836 + mem[_9836 + 32]] > test266151307():
            revert with 0, 65
        _10982 = mem[64]
        if mem[64] + ceil32(32 * mem[_9836 + mem[_9836 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_9836 + mem[_9836 + 32]]) + 1 > test266151307():
            revert with 0, 65
        mem[64] = mem[64] + ceil32(32 * mem[_9836 + mem[_9836 + 32]]) + 1
        mem[_10982] = _10881
        require _10748 + (32 * _10881) + 32 <= return_data.size
        s = 0
        u = _9836 + _10748 + 32
        v = _10982 + 32
        while s < _10881:
            mem[v] = mem[u]
            s = s + 1
            u = u + 32
            v = v + 32
            continue 
        if t > !mem[_9836 + ceil32(return_data.size)]:
            revert with 0, 17
        if idx == -1:
            revert with 0, 17
        idx = idx + 1
        t = t + mem[_9836 + ceil32(return_data.size)]
        continue 
    if s > !t:
        revert with 0, 17
    if s + t > test266151307():
        revert with 0, 65
    _9517 = mem[64]
    mem[mem[64]] = s + t
    if not s + t:
        if s > !t:
            revert with 0, 17
        if s + t > test266151307():
            revert with 0, 65
        _9835 = mem[64] + (32 * s + t) + 32
        mem[mem[64] + (32 * s + t) + 32] = s + t
        mem[64] = _9835 + (32 * s + t) + 32
        if not s + t:
            _10576 = mem[mem[ceil32(return_data.size) + 160]]
            idx = 0
            u = 0
            while idx < _10576:
                mem[0] = arg1
                mem[32] = 1
                mem[mem[64] + 32] = idx
                mem[mem[64] + 64] = stor1[arg1].field_512
                mem[mem[64] + 96] = stor8
                _10657 = mem[64]
                mem[mem[64]] = 96
                mem[64] = mem[64] + 128
                if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                    revert with 0, 50
                if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    revert with 0, 18
                if sha3(mem[_10657 + 32 len mem[_10657]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                    if idx == -1:
                        revert with 0, 17
                    _10576 = mem[mem[ceil32(return_data.size) + 160]]
                    idx = idx + 1
                    u = u
                    continue 
                if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                    revert with 0, 50
                if u >= mem[_9517]:
                    revert with 0, 50
                mem[(32 * u) + _9517 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
                if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                    revert with 0, 50
                if u >= mem[_9835]:
                    revert with 0, 50
                mem[(32 * u) + _9835 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
                if u == -1:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _10576 = mem[mem[ceil32(return_data.size) + 160]]
                idx = idx + 1
                u = u + 1
                continue 
            idx = 0
            while idx < stor5.length:
                mem[0] = 5
                _11383 = mem[64]
                mem[64] = mem[64] + 64
                mem[_11383] = address(stor5[idx].field_0)
                mem[_11383 + 32] = address(stor5[idx].field_256)
                mem[0] = address(stor5[idx].field_0)
                mem[32] = sha3(arg1, 1) + 3
                if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                    _11402 = mem[64]
                    mem[mem[64]] = 0
                    mem[mem[64] + 32] = 0
                    mem[64] = mem[64] + 64
                    _11739 = mem[_11402]
                    s = 0
                    t = u
                    while s < _11739:
                        if s >= mem[_11402]:
                            revert with 0, 50
                        if t >= mem[_9517]:
                            revert with 0, 50
                        mem[(32 * t) + _9517 + 32] = mem[(32 * s) + _11402 + 32]
                        if s >= mem[_11402 + 32]:
                            revert with 0, 50
                        if t >= mem[_9835]:
                            revert with 0, 50
                        mem[(32 * t) + _9835 + 32] = mem[(32 * s) + _11402 + 64]
                        if t == -1:
                            revert with 0, 17
                        if s == -1:
                            revert with 0, 17
                        _11739 = mem[_11402]
                        s = s + 1
                        t = t + 1
                        continue 
                else:
                    mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = arg1
                    mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    require ext_code.size(address(stor5[idx].field_256))
                    staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                            gas gas_remaining wei
                           args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _11576 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 64
                    _11600 = mem[_11576]
                    require mem[_11576] <= test266151307()
                    require _11576 + mem[_11576] + 31 < _11576 + return_data.size
                    _11624 = mem[_11576 + mem[_11576]]
                    if mem[_11576 + mem[_11576]] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[_11576 + mem[_11576]]) + 1 < 0 or _11576 + ceil32(return_data.size) + ceil32(32 * mem[_11576 + mem[_11576]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = _11576 + ceil32(return_data.size) + ceil32(32 * mem[_11576 + mem[_11576]]) + 1
                    mem[_11576 + ceil32(return_data.size)] = _11624
                    require _11600 + (32 * _11624) + 32 <= return_data.size
                    s = 0
                    t = _11576 + _11600 + 32
                    v = _11576 + ceil32(return_data.size) + 32
                    while s < _11624:
                        mem[v] = mem[t]
                        s = s + 1
                        t = t + 32
                        v = v + 32
                        continue 
                    _11807 = mem[_11576 + 32]
                    require mem[_11576 + 32] <= test266151307()
                    require _11576 + mem[_11576 + 32] + 31 < _11576 + return_data.size
                    _11888 = mem[_11576 + mem[_11576 + 32]]
                    if mem[_11576 + mem[_11576 + 32]] > test266151307():
                        revert with 0, 65
                    _11899 = mem[64]
                    if mem[64] + ceil32(32 * mem[_11576 + mem[_11576 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_11576 + mem[_11576 + 32]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = mem[64] + ceil32(32 * mem[_11576 + mem[_11576 + 32]]) + 1
                    mem[_11899] = _11888
                    require _11807 + (32 * _11888) + 32 <= return_data.size
                    s = 0
                    t = _11576 + _11807 + 32
                    v = _11899 + 32
                    while s < _11888:
                        mem[v] = mem[t]
                        s = s + 1
                        t = t + 32
                        v = v + 32
                        continue 
                    _12015 = mem[_11576 + ceil32(return_data.size)]
                    s = 0
                    t = u
                    while s < _12015:
                        if s >= mem[_11576 + ceil32(return_data.size)]:
                            revert with 0, 50
                        if t >= mem[_9517]:
                            revert with 0, 50
                        mem[(32 * t) + _9517 + 32] = mem[(32 * s) + _11576 + ceil32(return_data.size) + 32]
                        if s >= mem[_11899]:
                            revert with 0, 50
                        if t >= mem[_9835]:
                            revert with 0, 50
                        mem[(32 * t) + _9835 + 32] = mem[(32 * s) + _11899 + 32]
                        if t == -1:
                            revert with 0, 17
                        if s == -1:
                            revert with 0, 17
                        _12015 = mem[_11576 + ceil32(return_data.size)]
                        s = s + 1
                        t = t + 1
                        continue 
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            if s > !t:
                revert with 0, 17
            if u != s + t:
                revert with 0, 1
            if arg2 >= stor5.length:
                revert with 0, 50
            mem[0] = 5
            _11444 = mem[64]
            mem[64] = mem[64] + 64
            mem[_11444] = address(stor5[arg2].field_0)
            mem[_11444 + 32] = address(stor5[arg2].field_256)
            mem[0] = address(stor5[arg2].field_0)
            mem[32] = sha3(arg1, 1) + 3
            if not stor1[arg1][3][address(stor5[arg2].field_0)].field_0:
                _11500 = mem[64]
                mem[64] = mem[64] + 32
                mem[_11500 + 32] = 32
                mem[_11500 + 64] = mem[_11500]
                mem[_11500 + 96 len 32 * mem[_11500]] = mem[_11500 + 32 len 32 * mem[_11500]]
                var73001 = mem[_11500]
                var73002 = _11500 + (32 * mem[_11500]) + 32
                return memory
                  from mem[64]
                   len _11500 + (32 * mem[_11500]) + -mem[64] + 96
            if stor1[arg1][3][address(stor5[arg2].field_0)].field_0 < 1:
                revert with 0, 17
            mem[mem[64]] = 0x26148aa500000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 96
            _11615 = mem[_9517]
            mem[mem[64] + 100] = mem[_9517]
            mem[mem[64] + 132 len 32 * _11615] = mem[_9517 + 32 len 32 * _11615]
            var74001 = _11615
            var74002 = _9517 + (32 * _11615) + 32
            mem[mem[64] + 36] = arg1
            mem[mem[64] + 68] = stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1
            require ext_code.size(address(stor5[arg2].field_256))
            staticcall address(stor5[arg2].field_256).0x26148aa5 with:
                    gas gas_remaining wei
                   args 96, arg1, stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1, mem[mem[64] + 100 len (32 * _11615) + 32]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _11887 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _11895 = mem[_11887]
            require mem[_11887] <= test266151307()
            require _11887 + mem[_11887] + 31 < _11887 + return_data.size
            _11903 = mem[_11887 + mem[_11887]]
            if mem[_11887 + mem[_11887]] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[_11887 + mem[_11887]]) + 1 < 0 or _11887 + ceil32(return_data.size) + ceil32(32 * mem[_11887 + mem[_11887]]) + 1 > test266151307():
                revert with 0, 65
            mem[64] = _11887 + ceil32(return_data.size) + ceil32(32 * mem[_11887 + mem[_11887]]) + 1
            mem[_11887 + ceil32(return_data.size)] = _11903
            require _11895 + (32 * _11903) + 32 <= return_data.size
            mem[_11887 + ceil32(return_data.size) + 32 len 32 * _11903] = mem[_11887 + _11895 + 32 len 32 * _11903]
            var93001 = _11903
            var93002 = _11887 + _11895 + (32 * _11903) + 32
            var93004 = _11887 + ceil32(return_data.size) + (32 * _11903) + 32
            mem[mem[64]] = 32
            mem[mem[64] + 32] = _11903
            mem[mem[64] + 64 len 32 * _11903] = mem[_11887 + ceil32(return_data.size) + 32 len 32 * _11903]
            return Array(len=_11903, data=mem[mem[64] + 64 len 32 * _11903])
        mem[_9835 + 32 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
        _10578 = mem[mem[ceil32(return_data.size) + 160]]
        idx = 0
        u = 0
        while idx < _10578:
            mem[0] = arg1
            mem[32] = 1
            mem[mem[64] + 32] = idx
            mem[mem[64] + 64] = stor1[arg1].field_512
            mem[mem[64] + 96] = stor8
            _10664 = mem[64]
            mem[mem[64]] = 96
            mem[64] = mem[64] + 128
            if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                revert with 0, 50
            if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                revert with 0, 18
            if sha3(mem[_10664 + 32 len mem[_10664]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                if idx == -1:
                    revert with 0, 17
                _10578 = mem[mem[ceil32(return_data.size) + 160]]
                idx = idx + 1
                u = u
                continue 
            if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                revert with 0, 50
            if u >= mem[_9517]:
                revert with 0, 50
            mem[(32 * u) + _9517 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
            if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                revert with 0, 50
            if u >= mem[_9835]:
                revert with 0, 50
            mem[(32 * u) + _9835 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
            if u == -1:
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            _10578 = mem[mem[ceil32(return_data.size) + 160]]
            idx = idx + 1
            u = u + 1
            continue 
        idx = 0
        while idx < stor5.length:
            mem[0] = 5
            _11388 = mem[64]
            mem[64] = mem[64] + 64
            mem[_11388] = address(stor5[idx].field_0)
            mem[_11388 + 32] = address(stor5[idx].field_256)
            mem[0] = address(stor5[idx].field_0)
            mem[32] = sha3(arg1, 1) + 3
            if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                _11403 = mem[64]
                mem[mem[64]] = 0
                mem[mem[64] + 32] = 0
                mem[64] = mem[64] + 64
                _11740 = mem[_11403]
                s = 0
                t = u
                while s < _11740:
                    if s >= mem[_11403]:
                        revert with 0, 50
                    if t >= mem[_9517]:
                        revert with 0, 50
                    mem[(32 * t) + _9517 + 32] = mem[(32 * s) + _11403 + 32]
                    if s >= mem[_11403 + 32]:
                        revert with 0, 50
                    if t >= mem[_9835]:
                        revert with 0, 50
                    mem[(32 * t) + _9835 + 32] = mem[(32 * s) + _11403 + 64]
                    if t == -1:
                        revert with 0, 17
                    if s == -1:
                        revert with 0, 17
                    _11740 = mem[_11403]
                    s = s + 1
                    t = t + 1
                    continue 
            else:
                mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = arg1
                mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                require ext_code.size(address(stor5[idx].field_256))
                staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                        gas gas_remaining wei
                       args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _11580 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 64
                _11604 = mem[_11580]
                require mem[_11580] <= test266151307()
                require _11580 + mem[_11580] + 31 < _11580 + return_data.size
                _11626 = mem[_11580 + mem[_11580]]
                if mem[_11580 + mem[_11580]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_11580 + mem[_11580]]) + 1 < 0 or _11580 + ceil32(return_data.size) + ceil32(32 * mem[_11580 + mem[_11580]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _11580 + ceil32(return_data.size) + ceil32(32 * mem[_11580 + mem[_11580]]) + 1
                mem[_11580 + ceil32(return_data.size)] = _11626
                require _11604 + (32 * _11626) + 32 <= return_data.size
                s = 0
                t = _11580 + _11604 + 32
                v = _11580 + ceil32(return_data.size) + 32
                while s < _11626:
                    mem[v] = mem[t]
                    s = s + 1
                    t = t + 32
                    v = v + 32
                    continue 
                _11810 = mem[_11580 + 32]
                require mem[_11580 + 32] <= test266151307()
                require _11580 + mem[_11580 + 32] + 31 < _11580 + return_data.size
                _11890 = mem[_11580 + mem[_11580 + 32]]
                if mem[_11580 + mem[_11580 + 32]] > test266151307():
                    revert with 0, 65
                _11900 = mem[64]
                if mem[64] + ceil32(32 * mem[_11580 + mem[_11580 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_11580 + mem[_11580 + 32]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = mem[64] + ceil32(32 * mem[_11580 + mem[_11580 + 32]]) + 1
                mem[_11900] = _11890
                require _11810 + (32 * _11890) + 32 <= return_data.size
                s = 0
                t = _11580 + _11810 + 32
                v = _11900 + 32
                while s < _11890:
                    mem[v] = mem[t]
                    s = s + 1
                    t = t + 32
                    v = v + 32
                    continue 
                _12016 = mem[_11580 + ceil32(return_data.size)]
                s = 0
                t = u
                while s < _12016:
                    if s >= mem[_11580 + ceil32(return_data.size)]:
                        revert with 0, 50
                    if t >= mem[_9517]:
                        revert with 0, 50
                    mem[(32 * t) + _9517 + 32] = mem[(32 * s) + _11580 + ceil32(return_data.size) + 32]
                    if s >= mem[_11900]:
                        revert with 0, 50
                    if t >= mem[_9835]:
                        revert with 0, 50
                    mem[(32 * t) + _9835 + 32] = mem[(32 * s) + _11900 + 32]
                    if t == -1:
                        revert with 0, 17
                    if s == -1:
                        revert with 0, 17
                    _12016 = mem[_11580 + ceil32(return_data.size)]
                    s = s + 1
                    t = t + 1
                    continue 
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        if s > !t:
            revert with 0, 17
        if u != s + t:
            revert with 0, 1
        if arg2 >= stor5.length:
            revert with 0, 50
        mem[0] = 5
        _11449 = mem[64]
        mem[64] = mem[64] + 64
        mem[_11449] = address(stor5[arg2].field_0)
        mem[_11449 + 32] = address(stor5[arg2].field_256)
        mem[0] = address(stor5[arg2].field_0)
        mem[32] = sha3(arg1, 1) + 3
        if not stor1[arg1][3][address(stor5[arg2].field_0)].field_0:
            _11506 = mem[64]
            mem[64] = mem[64] + 32
            mem[_11506 + 32] = 32
            mem[_11506 + 64] = mem[_11506]
            mem[_11506 + 96 len 32 * mem[_11506]] = mem[_11506 + 32 len 32 * mem[_11506]]
            var74001 = mem[_11506]
            var74002 = _11506 + (32 * mem[_11506]) + 32
            return memory
              from mem[64]
               len _11506 + (32 * mem[_11506]) + -mem[64] + 96
        if stor1[arg1][3][address(stor5[arg2].field_0)].field_0 < 1:
            revert with 0, 17
        mem[mem[64]] = 0x26148aa500000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = 96
        _11616 = mem[_9517]
        mem[mem[64] + 100] = mem[_9517]
        mem[mem[64] + 132 len 32 * _11616] = mem[_9517 + 32 len 32 * _11616]
        var75001 = _11616
        var75002 = _9517 + (32 * _11616) + 32
        mem[mem[64] + 36] = arg1
        mem[mem[64] + 68] = stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1
        require ext_code.size(address(stor5[arg2].field_256))
        staticcall address(stor5[arg2].field_256).0x26148aa5 with:
                gas gas_remaining wei
               args 96, arg1, stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1, mem[mem[64] + 100 len (32 * _11616) + 32]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _11889 = mem[64]
        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _11896 = mem[_11889]
        require mem[_11889] <= test266151307()
        require _11889 + mem[_11889] + 31 < _11889 + return_data.size
        _11904 = mem[_11889 + mem[_11889]]
        if mem[_11889 + mem[_11889]] > test266151307():
            revert with 0, 65
        if ceil32(32 * mem[_11889 + mem[_11889]]) + 1 < 0 or _11889 + ceil32(return_data.size) + ceil32(32 * mem[_11889 + mem[_11889]]) + 1 > test266151307():
            revert with 0, 65
        mem[64] = _11889 + ceil32(return_data.size) + ceil32(32 * mem[_11889 + mem[_11889]]) + 1
        mem[_11889 + ceil32(return_data.size)] = _11904
        require _11896 + (32 * _11904) + 32 <= return_data.size
        mem[_11889 + ceil32(return_data.size) + 32 len 32 * _11904] = mem[_11889 + _11896 + 32 len 32 * _11904]
        var94001 = _11904
        var94002 = _11889 + _11896 + (32 * _11904) + 32
        var94004 = _11889 + ceil32(return_data.size) + (32 * _11904) + 32
        mem[mem[64]] = 32
        mem[mem[64] + 32] = _11904
        mem[mem[64] + 64 len 32 * _11904] = mem[_11889 + ceil32(return_data.size) + 32 len 32 * _11904]
        return Array(len=_11904, data=mem[mem[64] + 64 len 32 * _11904])
    mem[mem[64] + 32 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
    if s > !t:
        revert with 0, 17
    if s + t > test266151307():
        revert with 0, 65
    mem[mem[64] + (32 * s + t) + 32] = s + t
    mem[64] = _9517 + (64 * s + t) + 64
    if not s + t:
        _10580 = mem[mem[ceil32(return_data.size) + 160]]
        idx = 0
        u = 0
        while idx < _10580:
            mem[0] = arg1
            mem[32] = 1
            mem[mem[64] + 32] = idx
            mem[mem[64] + 64] = stor1[arg1].field_512
            mem[mem[64] + 96] = stor8
            _10671 = mem[64]
            mem[mem[64]] = 96
            mem[64] = mem[64] + 128
            if idx >= mem[mem[ceil32(return_data.size) + 160]]:
                revert with 0, 50
            if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                revert with 0, 18
            if sha3(mem[_10671 + 32 len mem[_10671]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
                if idx == -1:
                    revert with 0, 17
                _10580 = mem[mem[ceil32(return_data.size) + 160]]
                idx = idx + 1
                u = u
                continue 
            if idx >= mem[mem[ceil32(return_data.size) + 96]]:
                revert with 0, 50
            if u >= mem[_9517]:
                revert with 0, 50
            mem[(32 * u) + _9517 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
            if idx >= mem[mem[ceil32(return_data.size) + 128]]:
                revert with 0, 50
            if u >= mem[_9517 + (32 * s + t) + 32]:
                revert with 0, 50
            mem[(32 * u) + _9517 + (32 * s + t) + 64] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
            if u == -1:
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            _10580 = mem[mem[ceil32(return_data.size) + 160]]
            idx = idx + 1
            u = u + 1
            continue 
        idx = 0
        while idx < stor5.length:
            mem[0] = 5
            _11393 = mem[64]
            mem[64] = mem[64] + 64
            mem[_11393] = address(stor5[idx].field_0)
            mem[_11393 + 32] = address(stor5[idx].field_256)
            mem[0] = address(stor5[idx].field_0)
            mem[32] = sha3(arg1, 1) + 3
            if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
                _11404 = mem[64]
                mem[mem[64]] = 0
                mem[mem[64] + 32] = 0
                mem[64] = mem[64] + 64
                _11741 = mem[_11404]
                v = 0
                w = u
                while v < _11741:
                    if v >= mem[_11404]:
                        revert with 0, 50
                    if w >= mem[_9517]:
                        revert with 0, 50
                    mem[(32 * w) + _9517 + 32] = mem[(32 * v) + _11404 + 32]
                    if v >= mem[_11404 + 32]:
                        revert with 0, 50
                    if w >= mem[_9517 + (32 * s + t) + 32]:
                        revert with 0, 50
                    mem[(32 * w) + _9517 + (32 * s + t) + 64] = mem[(32 * v) + _11404 + 64]
                    if w == -1:
                        revert with 0, 17
                    if v == -1:
                        revert with 0, 17
                    _11741 = mem[_11404]
                    v = v + 1
                    w = w + 1
                    continue 
            else:
                mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = arg1
                mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                require ext_code.size(address(stor5[idx].field_256))
                staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                        gas gas_remaining wei
                       args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _11584 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 64
                _11608 = mem[_11584]
                require mem[_11584] <= test266151307()
                require _11584 + mem[_11584] + 31 < _11584 + return_data.size
                _11628 = mem[_11584 + mem[_11584]]
                if mem[_11584 + mem[_11584]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_11584 + mem[_11584]]) + 1 < 0 or _11584 + ceil32(return_data.size) + ceil32(32 * mem[_11584 + mem[_11584]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _11584 + ceil32(return_data.size) + ceil32(32 * mem[_11584 + mem[_11584]]) + 1
                mem[_11584 + ceil32(return_data.size)] = _11628
                require _11608 + (32 * _11628) + 32 <= return_data.size
                v = 0
                w = _11584 + _11608 + 32
                x = _11584 + ceil32(return_data.size) + 32
                while v < _11628:
                    mem[x] = mem[w]
                    v = v + 1
                    w = w + 32
                    x = x + 32
                    continue 
                _11813 = mem[_11584 + 32]
                require mem[_11584 + 32] <= test266151307()
                require _11584 + mem[_11584 + 32] + 31 < _11584 + return_data.size
                _11892 = mem[_11584 + mem[_11584 + 32]]
                if mem[_11584 + mem[_11584 + 32]] > test266151307():
                    revert with 0, 65
                _11901 = mem[64]
                if mem[64] + ceil32(32 * mem[_11584 + mem[_11584 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_11584 + mem[_11584 + 32]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = mem[64] + ceil32(32 * mem[_11584 + mem[_11584 + 32]]) + 1
                mem[_11901] = _11892
                require _11813 + (32 * _11892) + 32 <= return_data.size
                v = 0
                w = _11584 + _11813 + 32
                x = _11901 + 32
                while v < _11892:
                    mem[x] = mem[w]
                    v = v + 1
                    w = w + 32
                    x = x + 32
                    continue 
                _12017 = mem[_11584 + ceil32(return_data.size)]
                v = 0
                w = u
                while v < _12017:
                    if v >= mem[_11584 + ceil32(return_data.size)]:
                        revert with 0, 50
                    if w >= mem[_9517]:
                        revert with 0, 50
                    mem[(32 * w) + _9517 + 32] = mem[(32 * v) + _11584 + ceil32(return_data.size) + 32]
                    if v >= mem[_11901]:
                        revert with 0, 50
                    if w >= mem[_9517 + (32 * s + t) + 32]:
                        revert with 0, 50
                    mem[(32 * w) + _9517 + (32 * s + t) + 64] = mem[(32 * v) + _11901 + 32]
                    if w == -1:
                        revert with 0, 17
                    if v == -1:
                        revert with 0, 17
                    _12017 = mem[_11584 + ceil32(return_data.size)]
                    v = v + 1
                    w = w + 1
                    continue 
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        if s > !t:
            revert with 0, 17
        if u != s + t:
            revert with 0, 1
        if arg2 >= stor5.length:
            revert with 0, 50
        mem[0] = 5
        _11454 = mem[64]
        mem[64] = mem[64] + 64
        mem[_11454] = address(stor5[arg2].field_0)
        mem[_11454 + 32] = address(stor5[arg2].field_256)
        mem[0] = address(stor5[arg2].field_0)
        mem[32] = sha3(arg1, 1) + 3
        if not stor1[arg1][3][address(stor5[arg2].field_0)].field_0:
            _11512 = mem[64]
            mem[64] = mem[64] + 32
            mem[_11512 + 32] = 32
            mem[_11512 + 64] = mem[_11512]
            mem[_11512 + 96 len 32 * mem[_11512]] = mem[_11512 + 32 len 32 * mem[_11512]]
            var74001 = mem[_11512]
            var74002 = _11512 + (32 * mem[_11512]) + 32
            return memory
              from mem[64]
               len _11512 + (32 * mem[_11512]) + -mem[64] + 96
        if stor1[arg1][3][address(stor5[arg2].field_0)].field_0 < 1:
            revert with 0, 17
        mem[mem[64]] = 0x26148aa500000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = 96
        _11617 = mem[_9517]
        mem[mem[64] + 100] = mem[_9517]
        mem[mem[64] + 132 len 32 * _11617] = mem[_9517 + 32 len 32 * _11617]
        var75001 = _11617
        var75002 = _9517 + (32 * _11617) + 32
        mem[mem[64] + 36] = arg1
        mem[mem[64] + 68] = stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1
        require ext_code.size(address(stor5[arg2].field_256))
        staticcall address(stor5[arg2].field_256).0x26148aa5 with:
                gas gas_remaining wei
               args 96, arg1, stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1, mem[mem[64] + 100 len (32 * _11617) + 32]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _11891 = mem[64]
        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _11897 = mem[_11891]
        require mem[_11891] <= test266151307()
        require _11891 + mem[_11891] + 31 < _11891 + return_data.size
        _11905 = mem[_11891 + mem[_11891]]
        if mem[_11891 + mem[_11891]] > test266151307():
            revert with 0, 65
        if ceil32(32 * mem[_11891 + mem[_11891]]) + 1 < 0 or _11891 + ceil32(return_data.size) + ceil32(32 * mem[_11891 + mem[_11891]]) + 1 > test266151307():
            revert with 0, 65
        mem[64] = _11891 + ceil32(return_data.size) + ceil32(32 * mem[_11891 + mem[_11891]]) + 1
        mem[_11891 + ceil32(return_data.size)] = _11905
        require _11897 + (32 * _11905) + 32 <= return_data.size
        mem[_11891 + ceil32(return_data.size) + 32 len 32 * _11905] = mem[_11891 + _11897 + 32 len 32 * _11905]
        var94001 = _11905
        var94002 = _11891 + _11897 + (32 * _11905) + 32
        var94004 = _11891 + ceil32(return_data.size) + (32 * _11905) + 32
        mem[mem[64]] = 32
        mem[mem[64] + 32] = _11905
        mem[mem[64] + 64 len 32 * _11905] = mem[_11891 + ceil32(return_data.size) + 32 len 32 * _11905]
        return Array(len=_11905, data=mem[mem[64] + 64 len 32 * _11905])
    mem[_9517 + (32 * s + t) + 64 len 32 * s + t] = call.data[calldata.size len 32 * s + t]
    _10582 = mem[mem[ceil32(return_data.size) + 160]]
    idx = 0
    u = 0
    while idx < _10582:
        mem[0] = arg1
        mem[32] = 1
        mem[mem[64] + 32] = idx
        mem[mem[64] + 64] = stor1[arg1].field_512
        mem[mem[64] + 96] = stor8
        _10678 = mem[64]
        mem[mem[64]] = 96
        mem[64] = mem[64] + 128
        if idx >= mem[mem[ceil32(return_data.size) + 160]]:
            revert with 0, 50
        if not mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
            revert with 0, 18
        if sha3(mem[_10678 + 32 len mem[_10678]]) % mem[(32 * idx) + mem[ceil32(return_data.size) + 160] + 32]:
            if idx == -1:
                revert with 0, 17
            _10582 = mem[mem[ceil32(return_data.size) + 160]]
            idx = idx + 1
            u = u
            continue 
        if idx >= mem[mem[ceil32(return_data.size) + 96]]:
            revert with 0, 50
        if u >= mem[_9517]:
            revert with 0, 50
        mem[(32 * u) + _9517 + 32] = mem[(32 * idx) + mem[ceil32(return_data.size) + 96] + 32]
        if idx >= mem[mem[ceil32(return_data.size) + 128]]:
            revert with 0, 50
        if u >= mem[_9517 + (32 * s + t) + 32]:
            revert with 0, 50
        mem[(32 * u) + _9517 + (32 * s + t) + 64] = mem[(32 * idx) + mem[ceil32(return_data.size) + 128] + 32]
        if u == -1:
            revert with 0, 17
        if idx == -1:
            revert with 0, 17
        _10582 = mem[mem[ceil32(return_data.size) + 160]]
        idx = idx + 1
        u = u + 1
        continue 
    idx = 0
    while idx < stor5.length:
        mem[0] = 5
        _11398 = mem[64]
        mem[64] = mem[64] + 64
        mem[_11398] = address(stor5[idx].field_0)
        mem[_11398 + 32] = address(stor5[idx].field_256)
        mem[0] = address(stor5[idx].field_0)
        mem[32] = sha3(arg1, 1) + 3
        if not stor1[arg1][3][address(stor5[idx].field_0)].field_0:
            _11405 = mem[64]
            mem[mem[64]] = 0
            mem[mem[64] + 32] = 0
            mem[64] = mem[64] + 64
            _11742 = mem[_11405]
            v = 0
            w = u
            while v < _11742:
                if v >= mem[_11405]:
                    revert with 0, 50
                if w >= mem[_9517]:
                    revert with 0, 50
                mem[(32 * w) + _9517 + 32] = mem[(32 * v) + _11405 + 32]
                if v >= mem[_11405 + 32]:
                    revert with 0, 50
                if w >= mem[_9517 + (32 * s + t) + 32]:
                    revert with 0, 50
                mem[(32 * w) + _9517 + (32 * s + t) + 64] = mem[(32 * v) + _11405 + 64]
                if w == -1:
                    revert with 0, 17
                if v == -1:
                    revert with 0, 17
                _11742 = mem[_11405]
                v = v + 1
                w = w + 1
                continue 
        else:
            mem[mem[64]] = 0x5f9e80d000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = arg1
            mem[mem[64] + 36] = stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
            require ext_code.size(address(stor5[idx].field_256))
            staticcall address(stor5[idx].field_256).0x5f9e80d0 with:
                    gas gas_remaining wei
                   args arg1, stor1[arg1][3][address(stor5[idx].field_0)].field_0 - 1
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _11588 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 64
            _11612 = mem[_11588]
            require mem[_11588] <= test266151307()
            require _11588 + mem[_11588] + 31 < _11588 + return_data.size
            _11630 = mem[_11588 + mem[_11588]]
            if mem[_11588 + mem[_11588]] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[_11588 + mem[_11588]]) + 1 < 0 or _11588 + ceil32(return_data.size) + ceil32(32 * mem[_11588 + mem[_11588]]) + 1 > test266151307():
                revert with 0, 65
            mem[64] = _11588 + ceil32(return_data.size) + ceil32(32 * mem[_11588 + mem[_11588]]) + 1
            mem[_11588 + ceil32(return_data.size)] = _11630
            require _11612 + (32 * _11630) + 32 <= return_data.size
            v = 0
            w = _11588 + _11612 + 32
            x = _11588 + ceil32(return_data.size) + 32
            while v < _11630:
                mem[x] = mem[w]
                v = v + 1
                w = w + 32
                x = x + 32
                continue 
            _11816 = mem[_11588 + 32]
            require mem[_11588 + 32] <= test266151307()
            require _11588 + mem[_11588 + 32] + 31 < _11588 + return_data.size
            _11894 = mem[_11588 + mem[_11588 + 32]]
            if mem[_11588 + mem[_11588 + 32]] > test266151307():
                revert with 0, 65
            _11902 = mem[64]
            if mem[64] + ceil32(32 * mem[_11588 + mem[_11588 + 32]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_11588 + mem[_11588 + 32]]) + 1 > test266151307():
                revert with 0, 65
            mem[64] = mem[64] + ceil32(32 * mem[_11588 + mem[_11588 + 32]]) + 1
            mem[_11902] = _11894
            require _11816 + (32 * _11894) + 32 <= return_data.size
            v = 0
            w = _11588 + _11816 + 32
            x = _11902 + 32
            while v < _11894:
                mem[x] = mem[w]
                v = v + 1
                w = w + 32
                x = x + 32
                continue 
            _12018 = mem[_11588 + ceil32(return_data.size)]
            v = 0
            w = u
            while v < _12018:
                if v >= mem[_11588 + ceil32(return_data.size)]:
                    revert with 0, 50
                if w >= mem[_9517]:
                    revert with 0, 50
                mem[(32 * w) + _9517 + 32] = mem[(32 * v) + _11588 + ceil32(return_data.size) + 32]
                if v >= mem[_11902]:
                    revert with 0, 50
                if w >= mem[_9517 + (32 * s + t) + 32]:
                    revert with 0, 50
                mem[(32 * w) + _9517 + (32 * s + t) + 64] = mem[(32 * v) + _11902 + 32]
                if w == -1:
                    revert with 0, 17
                if v == -1:
                    revert with 0, 17
                _12018 = mem[_11588 + ceil32(return_data.size)]
                v = v + 1
                w = w + 1
                continue 
        if idx == -1:
            revert with 0, 17
        idx = idx + 1
        continue 
    if s > !t:
        revert with 0, 17
    if u != s + t:
        revert with 0, 1
    if arg2 >= stor5.length:
        revert with 0, 50
    mem[0] = 5
    _11459 = mem[64]
    mem[64] = mem[64] + 64
    mem[_11459] = address(stor5[arg2].field_0)
    mem[_11459 + 32] = address(stor5[arg2].field_256)
    mem[0] = address(stor5[arg2].field_0)
    mem[32] = sha3(arg1, 1) + 3
    if not stor1[arg1][3][address(stor5[arg2].field_0)].field_0:
        _11518 = mem[64]
        mem[64] = mem[64] + 32
        mem[_11518 + 32] = 32
        mem[_11518 + 64] = mem[_11518]
        mem[_11518 + 96 len 32 * mem[_11518]] = mem[_11518 + 32 len 32 * mem[_11518]]
        var75001 = mem[_11518]
        var75002 = _11518 + (32 * mem[_11518]) + 32
        return memory
          from mem[64]
           len _11518 + (32 * mem[_11518]) + -mem[64] + 96
    if stor1[arg1][3][address(stor5[arg2].field_0)].field_0 < 1:
        revert with 0, 17
    mem[mem[64]] = 0x26148aa500000000000000000000000000000000000000000000000000000000
    mem[mem[64] + 4] = 96
    _11618 = mem[_9517]
    mem[mem[64] + 100] = mem[_9517]
    mem[mem[64] + 132 len 32 * _11618] = mem[_9517 + 32 len 32 * _11618]
    var76001 = _11618
    var76002 = _9517 + (32 * _11618) + 32
    mem[mem[64] + 36] = arg1
    mem[mem[64] + 68] = stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1
    require ext_code.size(address(stor5[arg2].field_256))
    staticcall address(stor5[arg2].field_256).0x26148aa5 with:
            gas gas_remaining wei
           args 96, arg1, stor1[arg1][3][address(stor5[arg2].field_0)].field_0 - 1, mem[mem[64] + 100 len (32 * _11618) + 32]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _11893 = mem[64]
    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 32
    _11898 = mem[_11893]
    require mem[_11893] <= test266151307()
    require _11893 + mem[_11893] + 31 < _11893 + return_data.size
    _11906 = mem[_11893 + mem[_11893]]
    if mem[_11893 + mem[_11893]] > test266151307():
        revert with 0, 65
    if ceil32(32 * mem[_11893 + mem[_11893]]) + 1 < 0 or _11893 + ceil32(return_data.size) + ceil32(32 * mem[_11893 + mem[_11893]]) + 1 > test266151307():
        revert with 0, 65
    mem[64] = _11893 + ceil32(return_data.size) + ceil32(32 * mem[_11893 + mem[_11893]]) + 1
    mem[_11893 + ceil32(return_data.size)] = _11906
    require _11898 + (32 * _11906) + 32 <= return_data.size
    mem[_11893 + ceil32(return_data.size) + 32 len 32 * _11906] = mem[_11893 + _11898 + 32 len 32 * _11906]
    var95001 = _11906
    var95002 = _11893 + _11898 + (32 * _11906) + 32
    var95004 = _11893 + ceil32(return_data.size) + (32 * _11906) + 32
    mem[mem[64]] = 32
    mem[mem[64] + 32] = _11906
    mem[mem[64] + 64 len 32 * _11906] = mem[_11893 + ceil32(return_data.size) + 32 len 32 * _11906]
    return Array(len=_11906, data=mem[mem[64] + 64 len 32 * _11906])
}



}
